// Code generated by smithy-go-codegen DO NOT EDIT.
package awsrestjson

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws/protocol/restjson"
	"github.com/aws/aws-sdk-go-v2/internal/protocoltest/awsrestjson/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithytime "github.com/awslabs/smithy-go/time"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	"io"
	"io/ioutil"
	"strconv"
	"strings"
	"time"
)

type awsRestjson1_deserializeOpInlineDocument struct {
}

func (*awsRestjson1_deserializeOpInlineDocument) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpInlineDocument) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &InlineDocumentOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentInlineDocumentOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentInlineDocumentOutput(v **InlineDocumentOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *InlineDocumentOutput
	if *v == nil {
		sv = &InlineDocumentOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "documentValue":
			if err := awsRestjson1_deserializeDocumentDocument(&sv.DocumentValue, decoder); err != nil {
				return err
			}

		case "stringValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.StringValue = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpInlineDocumentAsPayload struct {
}

func (*awsRestjson1_deserializeOpInlineDocumentAsPayload) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpInlineDocumentAsPayload) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &InlineDocumentAsPayloadOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentDocument(&output.DocumentValue, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentInlineDocumentAsPayloadOutput(v **InlineDocumentAsPayloadOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *InlineDocumentAsPayloadOutput
	if *v == nil {
		sv = &InlineDocumentAsPayloadOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "documentValue":
			if err := awsRestjson1_deserializeDocumentDocument(&sv.DocumentValue, decoder); err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpJsonLists struct {
}

func (*awsRestjson1_deserializeOpJsonLists) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpJsonLists) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonListsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentJsonListsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentJsonListsOutput(v **JsonListsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *JsonListsOutput
	if *v == nil {
		sv = &JsonListsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "booleanList":
			if err := awsRestjson1_deserializeDocumentBooleanList(&sv.BooleanList, decoder); err != nil {
				return err
			}

		case "enumList":
			if err := awsRestjson1_deserializeDocumentFooEnumList(&sv.EnumList, decoder); err != nil {
				return err
			}

		case "integerList":
			if err := awsRestjson1_deserializeDocumentIntegerList(&sv.IntegerList, decoder); err != nil {
				return err
			}

		case "nestedStringList":
			if err := awsRestjson1_deserializeDocumentNestedStringList(&sv.NestedStringList, decoder); err != nil {
				return err
			}

		case "stringList":
			if err := awsRestjson1_deserializeDocumentStringList(&sv.StringList, decoder); err != nil {
				return err
			}

		case "stringSet":
			if err := awsRestjson1_deserializeDocumentStringSet(&sv.StringSet, decoder); err != nil {
				return err
			}

		case "myStructureList":
			if err := awsRestjson1_deserializeDocumentStructureList(&sv.StructureList, decoder); err != nil {
				return err
			}

		case "timestampList":
			if err := awsRestjson1_deserializeDocumentTimestampList(&sv.TimestampList, decoder); err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpHttpPayloadWithStructure struct {
}

func (*awsRestjson1_deserializeOpHttpPayloadWithStructure) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpHttpPayloadWithStructure) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpPayloadWithStructureOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentNestedPayload(&output.Nested, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentHttpPayloadWithStructureOutput(v **HttpPayloadWithStructureOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *HttpPayloadWithStructureOutput
	if *v == nil {
		sv = &HttpPayloadWithStructureOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nested":
			if err := awsRestjson1_deserializeDocumentNestedPayload(&sv.Nested, decoder); err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpConstantAndVariableQueryString struct {
}

func (*awsRestjson1_deserializeOpConstantAndVariableQueryString) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpConstantAndVariableQueryString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &ConstantAndVariableQueryStringOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpNullAndEmptyHeadersServer struct {
}

func (*awsRestjson1_deserializeOpNullAndEmptyHeadersServer) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpNullAndEmptyHeadersServer) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &NullAndEmptyHeadersServerOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsNullAndEmptyHeadersServerOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsNullAndEmptyHeadersServerOutput(v *NullAndEmptyHeadersServerOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-A"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.A = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-B"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.B = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-C"); len(headerValues) != 0 {
		var list []*string
		for _, headerValuesVal := range headerValues {
			for _, headerValuesValPart := range strings.Split(headerValuesVal, ",") {
				headerValuesValPart = strings.TrimSpace(headerValuesValPart)
				list = append(list, ptr.String(headerValuesValPart))
			}
		}
		v.C = list
	}

	return nil
}

type awsRestjson1_deserializeOpRecursiveShapes struct {
}

func (*awsRestjson1_deserializeOpRecursiveShapes) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpRecursiveShapes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &RecursiveShapesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentRecursiveShapesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentRecursiveShapesOutput(v **RecursiveShapesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *RecursiveShapesOutput
	if *v == nil {
		sv = &RecursiveShapesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nested":
			if err := awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested1(&sv.Nested, decoder); err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpHttpPrefixHeaders struct {
}

func (*awsRestjson1_deserializeOpHttpPrefixHeaders) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpHttpPrefixHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpPrefixHeadersOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsHttpPrefixHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsHttpPrefixHeadersOutput(v *HttpPrefixHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Foo"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Foo = ptr.String(headerValues[0])
	}

	for headerKey, headerValues := range response.Header {
		if lenPrefix := len("X-Foo-"); len(headerKey) >= lenPrefix && strings.EqualFold(headerKey[:lenPrefix], "X-Foo-") {
			if v.FooMap == nil {
				v.FooMap = map[string]*string{}
			}
			headerValues[0] = strings.TrimSpace(headerValues[0])
			v.FooMap[headerKey[lenPrefix:]] = ptr.String(headerValues[0])
		}
	}

	return nil
}

type awsRestjson1_deserializeOpHttpPayloadTraits struct {
}

func (*awsRestjson1_deserializeOpHttpPayloadTraits) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpHttpPayloadTraits) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpPayloadTraitsOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsHttpPayloadTraitsOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestjson1_deserializeDocumentHttpPayloadTraitsOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsHttpPayloadTraitsOutput(v *HttpPayloadTraitsOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Foo"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Foo = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestjson1_deserializeDocumentHttpPayloadTraitsOutput(v *HttpPayloadTraitsOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	bs, err := ioutil.ReadAll(body)
	if err != nil {
		return err
	}
	if len(bs) > 0 {
		v.Blob = bs
	}
	return nil
}

type awsRestjson1_deserializeOpNoInputAndOutput struct {
}

func (*awsRestjson1_deserializeOpNoInputAndOutput) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpNoInputAndOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &NoInputAndOutputOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpHttpRequestWithLabelsAndTimestampFormat struct {
}

func (*awsRestjson1_deserializeOpHttpRequestWithLabelsAndTimestampFormat) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpHttpRequestWithLabelsAndTimestampFormat) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpRequestWithLabelsAndTimestampFormatOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpInputAndOutputWithHeaders struct {
}

func (*awsRestjson1_deserializeOpInputAndOutputWithHeaders) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpInputAndOutputWithHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &InputAndOutputWithHeadersOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsInputAndOutputWithHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsInputAndOutputWithHeadersOutput(v *InputAndOutputWithHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-BooleanList"); len(headerValues) != 0 {
		var list []*bool
		for _, headerValuesVal := range headerValues {
			for _, headerValuesValPart := range strings.Split(headerValuesVal, ",") {
				headerValuesValPart = strings.TrimSpace(headerValuesValPart)
				vv, err := strconv.ParseBool(headerValuesValPart)
				if err != nil {
					return err
				}
				list = append(list, ptr.Bool(vv))
			}
		}
		v.HeaderBooleanList = list
	}

	if headerValues := response.Header.Values("X-Byte"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseInt(headerValues[0], 0, 8)
		if err != nil {
			return err
		}
		v.HeaderByte = ptr.Int8(int8(vv))
	}

	if headerValues := response.Header.Values("X-Double"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseFloat(headerValues[0], 64)
		if err != nil {
			return err
		}
		v.HeaderDouble = ptr.Float64(vv)
	}

	if headerValues := response.Header.Values("X-Enum"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.HeaderEnum = types.FooEnum(headerValues[0])
	}

	if headerValues := response.Header.Values("X-EnumList"); len(headerValues) != 0 {
		var list []types.FooEnum
		for _, headerValuesVal := range headerValues {
			for _, headerValuesValPart := range strings.Split(headerValuesVal, ",") {
				headerValuesValPart = strings.TrimSpace(headerValuesValPart)
				list = append(list, types.FooEnum(headerValuesValPart))
			}
		}
		v.HeaderEnumList = list
	}

	if headerValues := response.Header.Values("X-Boolean2"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseBool(headerValues[0])
		if err != nil {
			return err
		}
		v.HeaderFalseBool = ptr.Bool(vv)
	}

	if headerValues := response.Header.Values("X-Float"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseFloat(headerValues[0], 32)
		if err != nil {
			return err
		}
		v.HeaderFloat = ptr.Float32(float32(vv))
	}

	if headerValues := response.Header.Values("X-Integer"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseInt(headerValues[0], 0, 32)
		if err != nil {
			return err
		}
		v.HeaderInteger = ptr.Int32(int32(vv))
	}

	if headerValues := response.Header.Values("X-IntegerList"); len(headerValues) != 0 {
		var list []*int32
		for _, headerValuesVal := range headerValues {
			for _, headerValuesValPart := range strings.Split(headerValuesVal, ",") {
				headerValuesValPart = strings.TrimSpace(headerValuesValPart)
				vv, err := strconv.ParseInt(headerValuesValPart, 0, 32)
				if err != nil {
					return err
				}
				list = append(list, ptr.Int32(int32(vv)))
			}
		}
		v.HeaderIntegerList = list
	}

	if headerValues := response.Header.Values("X-Long"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseInt(headerValues[0], 0, 64)
		if err != nil {
			return err
		}
		v.HeaderLong = ptr.Int64(vv)
	}

	if headerValues := response.Header.Values("X-Short"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseInt(headerValues[0], 0, 16)
		if err != nil {
			return err
		}
		v.HeaderShort = ptr.Int16(int16(vv))
	}

	if headerValues := response.Header.Values("X-String"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.HeaderString = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-StringList"); len(headerValues) != 0 {
		var list []*string
		for _, headerValuesVal := range headerValues {
			for _, headerValuesValPart := range strings.Split(headerValuesVal, ",") {
				headerValuesValPart = strings.TrimSpace(headerValuesValPart)
				list = append(list, ptr.String(headerValuesValPart))
			}
		}
		v.HeaderStringList = list
	}

	if headerValues := response.Header.Values("X-StringSet"); len(headerValues) != 0 {
		var list []*string
		for _, headerValuesVal := range headerValues {
			for _, headerValuesValPart := range strings.Split(headerValuesVal, ",") {
				headerValuesValPart = strings.TrimSpace(headerValuesValPart)
				list = append(list, ptr.String(headerValuesValPart))
			}
		}
		v.HeaderStringSet = list
	}

	if headerValues := response.Header.Values("X-TimestampList"); len(headerValues) != 0 {
		var list []*time.Time
		for _, headerValuesVal := range headerValues {
			for _, headerValuesValPart := range strings.Split(headerValuesVal, ",") {
				headerValuesValPart = strings.TrimSpace(headerValuesValPart)
				t, err := smithytime.ParseHTTPDate(headerValuesValPart)
				if err != nil {
					return err
				}
				list = append(list, ptr.Time(t))
			}
		}
		v.HeaderTimestampList = list
	}

	if headerValues := response.Header.Values("X-Boolean1"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseBool(headerValues[0])
		if err != nil {
			return err
		}
		v.HeaderTrueBool = ptr.Bool(vv)
	}

	return nil
}

type awsRestjson1_deserializeOpIgnoreQueryParamsInResponse struct {
}

func (*awsRestjson1_deserializeOpIgnoreQueryParamsInResponse) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpIgnoreQueryParamsInResponse) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &IgnoreQueryParamsInResponseOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentIgnoreQueryParamsInResponseOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentIgnoreQueryParamsInResponseOutput(v **IgnoreQueryParamsInResponseOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *IgnoreQueryParamsInResponseOutput
	if *v == nil {
		sv = &IgnoreQueryParamsInResponseOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "baz":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.Baz = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpHttpRequestWithLabels struct {
}

func (*awsRestjson1_deserializeOpHttpRequestWithLabels) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpHttpRequestWithLabels) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpRequestWithLabelsOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpAllQueryStringTypes struct {
}

func (*awsRestjson1_deserializeOpAllQueryStringTypes) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpAllQueryStringTypes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &AllQueryStringTypesOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpEmptyInputAndEmptyOutput struct {
}

func (*awsRestjson1_deserializeOpEmptyInputAndEmptyOutput) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpEmptyInputAndEmptyOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &EmptyInputAndEmptyOutputOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpGreetingWithErrors struct {
}

func (*awsRestjson1_deserializeOpGreetingWithErrors) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpGreetingWithErrors) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBuffer bytes.Buffer
		defer response.Body.Close()
		_, err := io.Copy(&errorBuffer, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		errorBody := bytes.NewReader(errorBuffer.Bytes())
		decoder := json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 500:
				errorType = "FooError"
			case 403:
				errorType = "ComplexError"
			case 400:
				errorType = "InvalidGreeting"
			}
		}

		// reset the ring buffer
		ringBuffer.Reset()
		// seek start of error body
		errorBody.Seek(0, io.SeekStart)

		decoder = json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		if errorType == "FooError" {
			errResult := &types.FooError{}
			output := errResult
			_ = output

			return out, metadata, errResult
		}

		if errorType == "ComplexError" {
			errResult := &types.ComplexError{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsComplexError(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentComplexError(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InvalidGreeting" {
			errResult := &types.InvalidGreeting{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInvalidGreeting(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &GreetingWithErrorsOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsGreetingWithErrorsOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsGreetingWithErrorsOutput(v *GreetingWithErrorsOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Greeting"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Greeting = ptr.String(headerValues[0])
	}

	return nil
}

type awsRestjson1_deserializeOpOmitsNullSerializesEmptyString struct {
}

func (*awsRestjson1_deserializeOpOmitsNullSerializesEmptyString) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpOmitsNullSerializesEmptyString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &OmitsNullSerializesEmptyStringOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpTimestampFormatHeaders struct {
}

func (*awsRestjson1_deserializeOpTimestampFormatHeaders) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpTimestampFormatHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &TimestampFormatHeadersOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsTimestampFormatHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsTimestampFormatHeadersOutput(v *TimestampFormatHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-defaultFormat"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseHTTPDate(headerValues[0])
		if err != nil {
			return err
		}
		v.DefaultFormat = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-memberDateTime"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseHTTPDate(headerValues[0])
		if err != nil {
			return err
		}
		v.MemberDateTime = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-memberEpochSeconds"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseHTTPDate(headerValues[0])
		if err != nil {
			return err
		}
		v.MemberEpochSeconds = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-memberHttpDate"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseHTTPDate(headerValues[0])
		if err != nil {
			return err
		}
		v.MemberHttpDate = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-targetDateTime"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseDateTime(headerValues[0])
		if err != nil {
			return err
		}
		v.TargetDateTime = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-targetEpochSeconds"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		f, err := strconv.ParseFloat(headerValues[0], 64)
		if err != nil {
			return err
		}
		t := smithytime.ParseEpochSeconds(f)
		v.TargetEpochSeconds = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-targetHttpDate"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseHTTPDate(headerValues[0])
		if err != nil {
			return err
		}
		v.TargetHttpDate = ptr.Time(t)
	}

	return nil
}

type awsRestjson1_deserializeOpJsonEnums struct {
}

func (*awsRestjson1_deserializeOpJsonEnums) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpJsonEnums) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonEnumsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentJsonEnumsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentJsonEnumsOutput(v **JsonEnumsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *JsonEnumsOutput
	if *v == nil {
		sv = &JsonEnumsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "fooEnum1":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FooEnum to be of type string, got %T instead", val)
				}
				sv.FooEnum1 = types.FooEnum(jtv)
			}

		case "fooEnum2":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FooEnum to be of type string, got %T instead", val)
				}
				sv.FooEnum2 = types.FooEnum(jtv)
			}

		case "fooEnum3":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FooEnum to be of type string, got %T instead", val)
				}
				sv.FooEnum3 = types.FooEnum(jtv)
			}

		case "fooEnumList":
			if err := awsRestjson1_deserializeDocumentFooEnumList(&sv.FooEnumList, decoder); err != nil {
				return err
			}

		case "fooEnumMap":
			if err := awsRestjson1_deserializeDocumentFooEnumMap(&sv.FooEnumMap, decoder); err != nil {
				return err
			}

		case "fooEnumSet":
			if err := awsRestjson1_deserializeDocumentFooEnumSet(&sv.FooEnumSet, decoder); err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpHttpRequestWithGreedyLabelInPath struct {
}

func (*awsRestjson1_deserializeOpHttpRequestWithGreedyLabelInPath) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpHttpRequestWithGreedyLabelInPath) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpRequestWithGreedyLabelInPathOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpNullAndEmptyHeadersClient struct {
}

func (*awsRestjson1_deserializeOpNullAndEmptyHeadersClient) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpNullAndEmptyHeadersClient) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &NullAndEmptyHeadersClientOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsNullAndEmptyHeadersClientOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsNullAndEmptyHeadersClientOutput(v *NullAndEmptyHeadersClientOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-A"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.A = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-B"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.B = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-C"); len(headerValues) != 0 {
		var list []*string
		for _, headerValuesVal := range headerValues {
			for _, headerValuesValPart := range strings.Split(headerValuesVal, ",") {
				headerValuesValPart = strings.TrimSpace(headerValuesValPart)
				list = append(list, ptr.String(headerValuesValPart))
			}
		}
		v.C = list
	}

	return nil
}

type awsRestjson1_deserializeOpQueryIdempotencyTokenAutoFill struct {
}

func (*awsRestjson1_deserializeOpQueryIdempotencyTokenAutoFill) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpQueryIdempotencyTokenAutoFill) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &QueryIdempotencyTokenAutoFillOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpJsonTimestamps struct {
}

func (*awsRestjson1_deserializeOpJsonTimestamps) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpJsonTimestamps) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonTimestampsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentJsonTimestampsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentJsonTimestampsOutput(v **JsonTimestampsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *JsonTimestampsOutput
	if *v == nil {
		sv = &JsonTimestampsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "dateTime":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Timestamp to be of type string, got %T instead", val)
				}
				t, err := smithytime.ParseDateTime(jtv)
				if err != nil {
					return err
				}
				sv.DateTime = &t
			}

		case "epochSeconds":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Timestamp to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.EpochSeconds = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "httpDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Timestamp to be of type string, got %T instead", val)
				}
				t, err := smithytime.ParseHTTPDate(jtv)
				if err != nil {
					return err
				}
				sv.HttpDate = &t
			}

		case "normal":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Timestamp to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.Normal = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpSimpleScalarProperties struct {
}

func (*awsRestjson1_deserializeOpSimpleScalarProperties) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpSimpleScalarProperties) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &SimpleScalarPropertiesOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsSimpleScalarPropertiesOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentSimpleScalarPropertiesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsSimpleScalarPropertiesOutput(v *SimpleScalarPropertiesOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Foo"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Foo = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestjson1_deserializeDocumentSimpleScalarPropertiesOutput(v **SimpleScalarPropertiesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *SimpleScalarPropertiesOutput
	if *v == nil {
		sv = &SimpleScalarPropertiesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "byteValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Byte to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.ByteValue = ptr.Int8(int8(i64))
			}

		case "DoubleDribble":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Double to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.DoubleValue = &f64
			}

		case "falseBooleanValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FalseBooleanValue = &jtv
			}

		case "floatValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Float to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.FloatValue = ptr.Float32(float32(f64))
			}

		case "integerValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Integer to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.IntegerValue = ptr.Int32(int32(i64))
			}

		case "longValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Long to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.LongValue = &i64
			}

		case "shortValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Short to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.ShortValue = ptr.Int16(int16(i64))
			}

		case "stringValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.StringValue = &jtv
			}

		case "trueBooleanValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.TrueBooleanValue = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpJsonBlobs struct {
}

func (*awsRestjson1_deserializeOpJsonBlobs) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpJsonBlobs) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonBlobsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentJsonBlobsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentJsonBlobsOutput(v **JsonBlobsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *JsonBlobsOutput
	if *v == nil {
		sv = &JsonBlobsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "data":
			err := decoder.Decode(&sv.Data)
			if err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpConstantQueryString struct {
}

func (*awsRestjson1_deserializeOpConstantQueryString) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpConstantQueryString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &ConstantQueryStringOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpHttpPayloadTraitsWithMediaType struct {
}

func (*awsRestjson1_deserializeOpHttpPayloadTraitsWithMediaType) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpHttpPayloadTraitsWithMediaType) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpPayloadTraitsWithMediaTypeOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsHttpPayloadTraitsWithMediaTypeOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestjson1_deserializeDocumentHttpPayloadTraitsWithMediaTypeOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsHttpPayloadTraitsWithMediaTypeOutput(v *HttpPayloadTraitsWithMediaTypeOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Foo"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Foo = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestjson1_deserializeDocumentHttpPayloadTraitsWithMediaTypeOutput(v *HttpPayloadTraitsWithMediaTypeOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	bs, err := ioutil.ReadAll(body)
	if err != nil {
		return err
	}
	if len(bs) > 0 {
		v.Blob = bs
	}
	return nil
}

type awsRestjson1_deserializeOpJsonMaps struct {
}

func (*awsRestjson1_deserializeOpJsonMaps) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpJsonMaps) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonMapsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeDocumentJsonMapsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeDocumentJsonMapsOutput(v **JsonMapsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *JsonMapsOutput
	if *v == nil {
		sv = &JsonMapsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "myMap":
			if err := awsRestjson1_deserializeDocumentJsonMapsInputOutputMap(&sv.MyMap, decoder); err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

type awsRestjson1_deserializeOpNoInputAndNoOutput struct {
}

func (*awsRestjson1_deserializeOpNoInputAndNoOutput) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestjson1_deserializeOpNoInputAndNoOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &NoInputAndNoOutputOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsComplexError(v *types.ComplexError, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Header"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Header = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestjson1_deserializeDocumentComplexError(v **types.ComplexError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ComplexError
	if *v == nil {
		sv = &types.ComplexError{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Nested":
			if err := awsRestjson1_deserializeDocumentComplexNestedErrorData(&sv.Nested, decoder); err != nil {
				return err
			}

		case "TopLevel":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.TopLevel = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsRestjson1_deserializeDocumentInvalidGreeting(v **types.InvalidGreeting, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidGreeting
	if *v == nil {
		sv = &types.InvalidGreeting{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsRestjson1_deserializeDocumentComplexNestedErrorData(v **types.ComplexNestedErrorData, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ComplexNestedErrorData
	if *v == nil {
		sv = &types.ComplexNestedErrorData{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Fooooo":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.Foo = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsRestjson1_deserializeDocumentDocument(v *smithy.Document, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	// TODO: implement document serialization.
	return nil
}

func awsRestjson1_deserializeDocumentJsonMapsInputOutputMap(v *map[string]*types.GreetingStruct, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var mv map[string]*types.GreetingStruct
	if *v == nil {
		mv = map[string]*types.GreetingStruct{}
	} else {
		mv = *v
	}

	for decoder.More() {
		token, err := decoder.Token()
		if err != nil {
			return err
		}

		key, ok := token.(string)
		if !ok {
			return fmt.Errorf("expected map-key of type string, found type %T", token)
		}

		var parsedVal *types.GreetingStruct
		if err := awsRestjson1_deserializeDocumentGreetingStruct(&parsedVal, decoder); err != nil {
			return err
		}
		mv[key] = parsedVal

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = mv
	return nil
}

func awsRestjson1_deserializeDocumentNestedPayload(v **types.NestedPayload, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.NestedPayload
	if *v == nil {
		sv = &types.NestedPayload{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "greeting":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.Greeting = &jtv
			}

		case "name":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.Name = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested1(v **types.RecursiveShapesInputOutputNested1, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RecursiveShapesInputOutputNested1
	if *v == nil {
		sv = &types.RecursiveShapesInputOutputNested1{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "foo":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.Foo = &jtv
			}

		case "nested":
			if err := awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested2(&sv.Nested, decoder); err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested2(v **types.RecursiveShapesInputOutputNested2, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RecursiveShapesInputOutputNested2
	if *v == nil {
		sv = &types.RecursiveShapesInputOutputNested2{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "bar":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.Bar = &jtv
			}

		case "recursiveMember":
			if err := awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested1(&sv.RecursiveMember, decoder); err != nil {
				return err
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsRestjson1_deserializeDocumentStructureList(v *[]*types.StructureListMember, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.StructureListMember
	if *v == nil {
		cv = []*types.StructureListMember{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.StructureListMember
		if err := awsRestjson1_deserializeDocumentStructureListMember(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsRestjson1_deserializeDocumentStructureListMember(v **types.StructureListMember, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.StructureListMember
	if *v == nil {
		sv = &types.StructureListMember{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "value":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.A = &jtv
			}

		case "other":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.B = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsRestjson1_deserializeDocumentBooleanList(v *[]*bool, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*bool
	if *v == nil {
		cv = []*bool{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *bool
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(bool)
			if !ok {
				return fmt.Errorf("expected PrimitiveBoolean to be of type *bool, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsRestjson1_deserializeDocumentFooEnumList(v *[]types.FooEnum, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []types.FooEnum
	if *v == nil {
		cv = []types.FooEnum{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col types.FooEnum
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected FooEnum to be of type string, got %T instead", val)
			}
			col = types.FooEnum(jtv)
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsRestjson1_deserializeDocumentFooEnumMap(v *map[string]types.FooEnum, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var mv map[string]types.FooEnum
	if *v == nil {
		mv = map[string]types.FooEnum{}
	} else {
		mv = *v
	}

	for decoder.More() {
		token, err := decoder.Token()
		if err != nil {
			return err
		}

		key, ok := token.(string)
		if !ok {
			return fmt.Errorf("expected map-key of type string, found type %T", token)
		}

		var parsedVal types.FooEnum
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected FooEnum to be of type string, got %T instead", val)
			}
			parsedVal = types.FooEnum(jtv)
		}
		mv[key] = parsedVal

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = mv
	return nil
}

func awsRestjson1_deserializeDocumentFooEnumSet(v *[]types.FooEnum, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []types.FooEnum
	if *v == nil {
		cv = []types.FooEnum{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col types.FooEnum
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected FooEnum to be of type string, got %T instead", val)
			}
			col = types.FooEnum(jtv)
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsRestjson1_deserializeDocumentGreetingStruct(v **types.GreetingStruct, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.GreetingStruct
	if *v == nil {
		sv = &types.GreetingStruct{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "hi":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected String to be of type string, got %T instead", val)
				}
				sv.Hi = &jtv
			}

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsRestjson1_deserializeDocumentIntegerList(v *[]*int32, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*int32
	if *v == nil {
		cv = []*int32{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *int32
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(json.Number)
			if !ok {
				return fmt.Errorf("expected Integer to be json.Number, got %T instead", val)
			}
			i64, err := jtv.Int64()
			if err != nil {
				return err
			}
			col = ptr.Int32(int32(i64))
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsRestjson1_deserializeDocumentNestedStringList(v *[][]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv [][]*string
	if *v == nil {
		cv = [][]*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col []*string
		if err := awsRestjson1_deserializeDocumentStringList(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsRestjson1_deserializeDocumentStringList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected String to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsRestjson1_deserializeDocumentStringSet(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected String to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsRestjson1_deserializeDocumentTimestampList(v *[]*time.Time, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*time.Time
	if *v == nil {
		cv = []*time.Time{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *time.Time
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(json.Number)
			if !ok {
				return fmt.Errorf("expected Timestamp to be json.Number, got %T instead", val)
			}
			f64, err := jtv.Float64()
			if err != nil {
				return err
			}
			col = ptr.Time(smithytime.ParseEpochSeconds(f64))
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}
