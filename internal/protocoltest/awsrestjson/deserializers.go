// Code generated by smithy-go-codegen DO NOT EDIT.
package awsrestjson

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws/protocol/restjson"
	"github.com/aws/aws-sdk-go-v2/internal/protocoltest/awsrestjson/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithytime "github.com/awslabs/smithy-go/time"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	"io"
	"io/ioutil"
	"strconv"
	"strings"
	"time"
)

type awsRestjson1_deserializeOpJsonLists struct {
}

func (*awsRestjson1_deserializeOpJsonLists) ID() string {
	return "awsRestjson1_deserializeOpJsonLists"
}

func (m *awsRestjson1_deserializeOpJsonLists) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonListsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentJsonListsOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentJsonListsOutput(v *JsonListsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "booleanList":
			col := []*bool{}
			if err := awsRestjson1_deserializeDocumentBooleanList(&col, decoder); err != nil {
				return err
			}
			v.BooleanList = col

		case "enumList":
			col := []types.FooEnum{}
			if err := awsRestjson1_deserializeDocumentFooEnumList(&col, decoder); err != nil {
				return err
			}
			v.EnumList = col

		case "integerList":
			col := []*int32{}
			if err := awsRestjson1_deserializeDocumentIntegerList(&col, decoder); err != nil {
				return err
			}
			v.IntegerList = col

		case "nestedStringList":
			col := [][]*string{}
			if err := awsRestjson1_deserializeDocumentNestedStringList(&col, decoder); err != nil {
				return err
			}
			v.NestedStringList = col

		case "stringList":
			col := []*string{}
			if err := awsRestjson1_deserializeDocumentStringList(&col, decoder); err != nil {
				return err
			}
			v.StringList = col

		case "stringSet":
			col := []*string{}
			if err := awsRestjson1_deserializeDocumentStringSet(&col, decoder); err != nil {
				return err
			}
			v.StringSet = col

		case "structureList":
			col := []*types.StructureListMember{}
			if err := awsRestjson1_deserializeDocumentStructureList(&col, decoder); err != nil {
				return err
			}
			v.StructureList = col

		case "timestampList":
			col := []*time.Time{}
			if err := awsRestjson1_deserializeDocumentTimestampList(&col, decoder); err != nil {
				return err
			}
			v.TimestampList = col

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpHttpPrefixHeaders struct {
}

func (*awsRestjson1_deserializeOpHttpPrefixHeaders) ID() string {
	return "awsRestjson1_deserializeOpHttpPrefixHeaders"
}

func (m *awsRestjson1_deserializeOpHttpPrefixHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpPrefixHeadersOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsHttpPrefixHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsHttpPrefixHeadersOutput(v *HttpPrefixHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-Foo"); val != "" {
		v.Foo = ptr.String(val)
	}

	if val := response.Header.Get("X-Foo-FooPrefixHeaders"); val != "" {
		v.FooMap["FooPrefixHeaders"] = ptr.String(val)
	}
	if val := response.Header.Get("X-Foo-FooPrefixHeaders"); val != "" {
		v.FooMap["FooPrefixHeaders"] = ptr.String(val)
	}

	return nil
}

type awsRestjson1_deserializeOpNullAndEmptyHeadersServer struct {
}

func (*awsRestjson1_deserializeOpNullAndEmptyHeadersServer) ID() string {
	return "awsRestjson1_deserializeOpNullAndEmptyHeadersServer"
}

func (m *awsRestjson1_deserializeOpNullAndEmptyHeadersServer) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &NullAndEmptyHeadersServerOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsNullAndEmptyHeadersServerOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsNullAndEmptyHeadersServerOutput(v *NullAndEmptyHeadersServerOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-A"); val != "" {
		v.A = ptr.String(val)
	}

	if val := response.Header.Get("X-B"); val != "" {
		v.B = ptr.String(val)
	}

	if val := response.Header.Get("X-C"); val != "" {
		list := make([]*string, 0, 0)
		for _, i := range strings.Split(val[1:len(val)-1], ",") {
			list = append(list, ptr.String(i))
		}
		v.C = list
	}

	return nil
}

type awsRestjson1_deserializeOpRecursiveShapes struct {
}

func (*awsRestjson1_deserializeOpRecursiveShapes) ID() string {
	return "awsRestjson1_deserializeOpRecursiveShapes"
}

func (m *awsRestjson1_deserializeOpRecursiveShapes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &RecursiveShapesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentRecursiveShapesOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentRecursiveShapesOutput(v *RecursiveShapesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nested":
			val := types.RecursiveShapesInputOutputNested1{}
			if err := awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested1(&val, decoder); err != nil {
				return err
			}
			v.Nested = &val

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpHttpRequestWithLabels struct {
}

func (*awsRestjson1_deserializeOpHttpRequestWithLabels) ID() string {
	return "awsRestjson1_deserializeOpHttpRequestWithLabels"
}

func (m *awsRestjson1_deserializeOpHttpRequestWithLabels) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpRequestWithLabelsOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpGreetingWithErrors struct {
}

func (*awsRestjson1_deserializeOpGreetingWithErrors) ID() string {
	return "awsRestjson1_deserializeOpGreetingWithErrors"
}

func (m *awsRestjson1_deserializeOpGreetingWithErrors) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBody bytes.Buffer
		_, err := io.Copy(&errorBody, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		body := io.TeeReader(response.Body, ringBuffer)
		defer response.Body.Close()

		decoder := json.NewDecoder(body)
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 500:
				errorType = "FooError"
			case 403:
				errorType = "ComplexError"
			case 400:
				errorType = "InvalidGreeting"
			}
		}

		body = io.TeeReader(&errorBody, ringBuffer)
		decoder = json.NewDecoder(&errorBody)
		decoder.UseNumber()

		if errorType == "FooError" {
			errResult := &types.FooError{}
			output := errResult
			_ = output

			return out, metadata, errResult
		}

		if errorType == "ComplexError" {
			errResult := &types.ComplexError{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsComplexError(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentComplexError(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InvalidGreeting" {
			errResult := &types.InvalidGreeting{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInvalidGreeting(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &GreetingWithErrorsOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsGreetingWithErrorsOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsGreetingWithErrorsOutput(v *GreetingWithErrorsOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-Greeting"); val != "" {
		v.Greeting = ptr.String(val)
	}

	return nil
}

type awsRestjson1_deserializeOpJsonMaps struct {
}

func (*awsRestjson1_deserializeOpJsonMaps) ID() string {
	return "awsRestjson1_deserializeOpJsonMaps"
}

func (m *awsRestjson1_deserializeOpJsonMaps) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonMapsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentJsonMapsOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentJsonMapsOutput(v *JsonMapsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "myMap":
			col := map[string]*types.GreetingStruct{}
			if err := awsRestjson1_deserializeDocumentJsonMapsInputOutputMap(&col, decoder); err != nil {
				return err
			}
			v.MyMap = col

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpJsonEnums struct {
}

func (*awsRestjson1_deserializeOpJsonEnums) ID() string {
	return "awsRestjson1_deserializeOpJsonEnums"
}

func (m *awsRestjson1_deserializeOpJsonEnums) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonEnumsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentJsonEnumsOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentJsonEnumsOutput(v *JsonEnumsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "fooEnum1":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected FooEnum1 to be of type types.FooEnum, got %T instead", val)
			}
			v.FooEnum1 = types.FooEnum(st)

		case "fooEnum2":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected FooEnum2 to be of type types.FooEnum, got %T instead", val)
			}
			v.FooEnum2 = types.FooEnum(st)

		case "fooEnum3":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected FooEnum3 to be of type types.FooEnum, got %T instead", val)
			}
			v.FooEnum3 = types.FooEnum(st)

		case "fooEnumList":
			col := []types.FooEnum{}
			if err := awsRestjson1_deserializeDocumentFooEnumList(&col, decoder); err != nil {
				return err
			}
			v.FooEnumList = col

		case "fooEnumMap":
			col := map[string]types.FooEnum{}
			if err := awsRestjson1_deserializeDocumentFooEnumMap(&col, decoder); err != nil {
				return err
			}
			v.FooEnumMap = col

		case "fooEnumSet":
			col := []types.FooEnum{}
			if err := awsRestjson1_deserializeDocumentFooEnumSet(&col, decoder); err != nil {
				return err
			}
			v.FooEnumSet = col

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpTimestampFormatHeaders struct {
}

func (*awsRestjson1_deserializeOpTimestampFormatHeaders) ID() string {
	return "awsRestjson1_deserializeOpTimestampFormatHeaders"
}

func (m *awsRestjson1_deserializeOpTimestampFormatHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &TimestampFormatHeadersOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsTimestampFormatHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsTimestampFormatHeadersOutput(v *TimestampFormatHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-defaultFormat"); val != "" {
		t, err := smithytime.ParseHTTPDate(val)
		if err != nil {
			return err
		}
		v.DefaultFormat = ptr.Time(t)
	}

	if val := response.Header.Get("X-memberDateTime"); val != "" {
		t, err := smithytime.ParseHTTPDate(val)
		if err != nil {
			return err
		}
		v.MemberDateTime = ptr.Time(t)
	}

	if val := response.Header.Get("X-memberEpochSeconds"); val != "" {
		t, err := smithytime.ParseHTTPDate(val)
		if err != nil {
			return err
		}
		v.MemberEpochSeconds = ptr.Time(t)
	}

	if val := response.Header.Get("X-memberHttpDate"); val != "" {
		t, err := smithytime.ParseHTTPDate(val)
		if err != nil {
			return err
		}
		v.MemberHttpDate = ptr.Time(t)
	}

	if val := response.Header.Get("X-targetDateTime"); val != "" {
		t, err := smithytime.ParseDateTime(val)
		if err != nil {
			return err
		}
		v.TargetDateTime = ptr.Time(t)
	}

	if val := response.Header.Get("X-targetEpochSeconds"); val != "" {
		f, err := strconv.ParseFloat(val, 64)
		if err != nil {
			return err
		}
		t := smithytime.ParseEpochSeconds(f)
		v.TargetEpochSeconds = ptr.Time(t)
	}

	if val := response.Header.Get("X-targetHttpDate"); val != "" {
		t, err := smithytime.ParseHTTPDate(val)
		if err != nil {
			return err
		}
		v.TargetHttpDate = ptr.Time(t)
	}

	return nil
}

type awsRestjson1_deserializeOpHttpPayloadTraitsWithMediaType struct {
}

func (*awsRestjson1_deserializeOpHttpPayloadTraitsWithMediaType) ID() string {
	return "awsRestjson1_deserializeOpHttpPayloadTraitsWithMediaType"
}

func (m *awsRestjson1_deserializeOpHttpPayloadTraitsWithMediaType) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpPayloadTraitsWithMediaTypeOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsHttpPayloadTraitsWithMediaTypeOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestjson1_deserializeOpDocumentHttpPayloadTraitsWithMediaTypeOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsHttpPayloadTraitsWithMediaTypeOutput(v *HttpPayloadTraitsWithMediaTypeOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-Foo"); val != "" {
		v.Foo = ptr.String(val)
	}

	return nil
}
func awsRestjson1_deserializeOpDocumentHttpPayloadTraitsWithMediaTypeOutput(v *HttpPayloadTraitsWithMediaTypeOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	bs, err := ioutil.ReadAll(body)
	if err != nil {
		return err
	}
	v.Blob = bs
	return nil
}

type awsRestjson1_deserializeOpNoInputAndNoOutput struct {
}

func (*awsRestjson1_deserializeOpNoInputAndNoOutput) ID() string {
	return "awsRestjson1_deserializeOpNoInputAndNoOutput"
}

func (m *awsRestjson1_deserializeOpNoInputAndNoOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &NoInputAndNoOutputOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpHttpPayloadWithStructure struct {
}

func (*awsRestjson1_deserializeOpHttpPayloadWithStructure) ID() string {
	return "awsRestjson1_deserializeOpHttpPayloadWithStructure"
}

func (m *awsRestjson1_deserializeOpHttpPayloadWithStructure) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpPayloadWithStructureOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentHttpPayloadWithStructureOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentHttpPayloadWithStructureOutput(v *HttpPayloadWithStructureOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nested":
			val := types.NestedPayload{}
			if err := awsRestjson1_deserializeDocumentNestedPayload(&val, decoder); err != nil {
				return err
			}
			v.Nested = &val

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpJsonBlobs struct {
}

func (*awsRestjson1_deserializeOpJsonBlobs) ID() string {
	return "awsRestjson1_deserializeOpJsonBlobs"
}

func (m *awsRestjson1_deserializeOpJsonBlobs) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonBlobsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentJsonBlobsOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentJsonBlobsOutput(v *JsonBlobsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "data":
			var bs []byte
			err := decoder.Decode(&bs)
			if err != nil {
				return err
			}
			v.Data = bs

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpSimpleScalarProperties struct {
}

func (*awsRestjson1_deserializeOpSimpleScalarProperties) ID() string {
	return "awsRestjson1_deserializeOpSimpleScalarProperties"
}

func (m *awsRestjson1_deserializeOpSimpleScalarProperties) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &SimpleScalarPropertiesOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsSimpleScalarPropertiesOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentSimpleScalarPropertiesOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsSimpleScalarPropertiesOutput(v *SimpleScalarPropertiesOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-Foo"); val != "" {
		v.Foo = ptr.String(val)
	}

	return nil
}
func awsRestjson1_deserializeOpDocumentSimpleScalarPropertiesOutput(v *SimpleScalarPropertiesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "byteValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			nt, err := val.(json.Number).Int64()
			if err != nil {
				return err
			}
			st := int8(nt)
			v.ByteValue = ptr.Int8(st)

		case "doubleValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			nt, err := val.(json.Number).Float64()
			if err != nil {
				return err
			}
			st := nt
			v.DoubleValue = ptr.Float64(st)

		case "falseBooleanValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			b, ok := val.(bool)
			if !ok {
				return fmt.Errorf("expected FalseBooleanValue to be of type bool, got %T instead", val)
			}
			v.FalseBooleanValue = ptr.Bool(b)

		case "floatValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			nt, err := val.(json.Number).Float64()
			if err != nil {
				return err
			}
			st := float32(nt)
			v.FloatValue = ptr.Float32(st)

		case "integerValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			nt, err := val.(json.Number).Int64()
			if err != nil {
				return err
			}
			st := int32(nt)
			v.IntegerValue = ptr.Int32(st)

		case "longValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			nt, err := val.(json.Number).Int64()
			if err != nil {
				return err
			}
			st := nt
			v.LongValue = ptr.Int64(st)

		case "shortValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			nt, err := val.(json.Number).Int64()
			if err != nil {
				return err
			}
			st := int16(nt)
			v.ShortValue = ptr.Int16(st)

		case "stringValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected StringValue to be of type *string, got %T instead", val)
			}
			v.StringValue = ptr.String(st)

		case "trueBooleanValue":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			b, ok := val.(bool)
			if !ok {
				return fmt.Errorf("expected TrueBooleanValue to be of type bool, got %T instead", val)
			}
			v.TrueBooleanValue = ptr.Bool(b)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpHttpRequestWithGreedyLabelInPath struct {
}

func (*awsRestjson1_deserializeOpHttpRequestWithGreedyLabelInPath) ID() string {
	return "awsRestjson1_deserializeOpHttpRequestWithGreedyLabelInPath"
}

func (m *awsRestjson1_deserializeOpHttpRequestWithGreedyLabelInPath) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpRequestWithGreedyLabelInPathOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpHttpPayloadTraits struct {
}

func (*awsRestjson1_deserializeOpHttpPayloadTraits) ID() string {
	return "awsRestjson1_deserializeOpHttpPayloadTraits"
}

func (m *awsRestjson1_deserializeOpHttpPayloadTraits) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpPayloadTraitsOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsHttpPayloadTraitsOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestjson1_deserializeOpDocumentHttpPayloadTraitsOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsHttpPayloadTraitsOutput(v *HttpPayloadTraitsOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-Foo"); val != "" {
		v.Foo = ptr.String(val)
	}

	return nil
}
func awsRestjson1_deserializeOpDocumentHttpPayloadTraitsOutput(v *HttpPayloadTraitsOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	bs, err := ioutil.ReadAll(body)
	if err != nil {
		return err
	}
	v.Blob = bs
	return nil
}

type awsRestjson1_deserializeOpQueryIdempotencyTokenAutoFill struct {
}

func (*awsRestjson1_deserializeOpQueryIdempotencyTokenAutoFill) ID() string {
	return "awsRestjson1_deserializeOpQueryIdempotencyTokenAutoFill"
}

func (m *awsRestjson1_deserializeOpQueryIdempotencyTokenAutoFill) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &QueryIdempotencyTokenAutoFillOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpAllQueryStringTypes struct {
}

func (*awsRestjson1_deserializeOpAllQueryStringTypes) ID() string {
	return "awsRestjson1_deserializeOpAllQueryStringTypes"
}

func (m *awsRestjson1_deserializeOpAllQueryStringTypes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &AllQueryStringTypesOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpConstantQueryString struct {
}

func (*awsRestjson1_deserializeOpConstantQueryString) ID() string {
	return "awsRestjson1_deserializeOpConstantQueryString"
}

func (m *awsRestjson1_deserializeOpConstantQueryString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &ConstantQueryStringOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpEmptyInputAndEmptyOutput struct {
}

func (*awsRestjson1_deserializeOpEmptyInputAndEmptyOutput) ID() string {
	return "awsRestjson1_deserializeOpEmptyInputAndEmptyOutput"
}

func (m *awsRestjson1_deserializeOpEmptyInputAndEmptyOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &EmptyInputAndEmptyOutputOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpJsonTimestamps struct {
}

func (*awsRestjson1_deserializeOpJsonTimestamps) ID() string {
	return "awsRestjson1_deserializeOpJsonTimestamps"
}

func (m *awsRestjson1_deserializeOpJsonTimestamps) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &JsonTimestampsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentJsonTimestampsOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentJsonTimestampsOutput(v *JsonTimestampsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "dateTime":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			ts, err := smithytime.ParseDateTime(val.(string))
			if err != nil {
				return err
			}
			v.DateTime = ptr.Time(ts)

		case "epochSeconds":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			ft, err := val.(json.Number).Float64()
			if err != nil {
				return err
			}
			ts := smithytime.ParseEpochSeconds(ft)
			v.EpochSeconds = ptr.Time(ts)

		case "httpDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			ts, err := smithytime.ParseHTTPDate(val.(string))
			if err != nil {
				return err
			}
			v.HttpDate = ptr.Time(ts)

		case "normal":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			ft, err := val.(json.Number).Float64()
			if err != nil {
				return err
			}
			ts := smithytime.ParseEpochSeconds(ft)
			v.Normal = ptr.Time(ts)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpConstantAndVariableQueryString struct {
}

func (*awsRestjson1_deserializeOpConstantAndVariableQueryString) ID() string {
	return "awsRestjson1_deserializeOpConstantAndVariableQueryString"
}

func (m *awsRestjson1_deserializeOpConstantAndVariableQueryString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &ConstantAndVariableQueryStringOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpNullAndEmptyHeadersClient struct {
}

func (*awsRestjson1_deserializeOpNullAndEmptyHeadersClient) ID() string {
	return "awsRestjson1_deserializeOpNullAndEmptyHeadersClient"
}

func (m *awsRestjson1_deserializeOpNullAndEmptyHeadersClient) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &NullAndEmptyHeadersClientOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsNullAndEmptyHeadersClientOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsNullAndEmptyHeadersClientOutput(v *NullAndEmptyHeadersClientOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-A"); val != "" {
		v.A = ptr.String(val)
	}

	if val := response.Header.Get("X-B"); val != "" {
		v.B = ptr.String(val)
	}

	if val := response.Header.Get("X-C"); val != "" {
		list := make([]*string, 0, 0)
		for _, i := range strings.Split(val[1:len(val)-1], ",") {
			list = append(list, ptr.String(i))
		}
		v.C = list
	}

	return nil
}

type awsRestjson1_deserializeOpNoInputAndOutput struct {
}

func (*awsRestjson1_deserializeOpNoInputAndOutput) ID() string {
	return "awsRestjson1_deserializeOpNoInputAndOutput"
}

func (m *awsRestjson1_deserializeOpNoInputAndOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &NoInputAndOutputOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpOmitsNullSerializesEmptyString struct {
}

func (*awsRestjson1_deserializeOpOmitsNullSerializesEmptyString) ID() string {
	return "awsRestjson1_deserializeOpOmitsNullSerializesEmptyString"
}

func (m *awsRestjson1_deserializeOpOmitsNullSerializesEmptyString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &OmitsNullSerializesEmptyStringOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpIgnoreQueryParamsInResponse struct {
}

func (*awsRestjson1_deserializeOpIgnoreQueryParamsInResponse) ID() string {
	return "awsRestjson1_deserializeOpIgnoreQueryParamsInResponse"
}

func (m *awsRestjson1_deserializeOpIgnoreQueryParamsInResponse) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &IgnoreQueryParamsInResponseOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentIgnoreQueryParamsInResponseOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentIgnoreQueryParamsInResponseOutput(v *IgnoreQueryParamsInResponseOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "baz":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Baz to be of type *string, got %T instead", val)
			}
			v.Baz = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpHttpRequestWithLabelsAndTimestampFormat struct {
}

func (*awsRestjson1_deserializeOpHttpRequestWithLabelsAndTimestampFormat) ID() string {
	return "awsRestjson1_deserializeOpHttpRequestWithLabelsAndTimestampFormat"
}

func (m *awsRestjson1_deserializeOpHttpRequestWithLabelsAndTimestampFormat) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &HttpRequestWithLabelsAndTimestampFormatOutput{}
	out.Result = output

	return out, metadata, err
}

type awsRestjson1_deserializeOpInputAndOutputWithHeaders struct {
}

func (*awsRestjson1_deserializeOpInputAndOutputWithHeaders) ID() string {
	return "awsRestjson1_deserializeOpInputAndOutputWithHeaders"
}

func (m *awsRestjson1_deserializeOpInputAndOutputWithHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		decoder := json.NewDecoder(response.Body)
		decoder.UseNumber()
		defer response.Body.Close()

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}
		return out, metadata, genericError
	}

	output := &InputAndOutputWithHeadersOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsInputAndOutputWithHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsInputAndOutputWithHeadersOutput(v *InputAndOutputWithHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-BooleanList"); val != "" {
		list := make([]*bool, 0, 0)
		for _, i := range strings.Split(val[1:len(val)-1], ",") {
			vv, err := strconv.ParseBool(i)
			if err != nil {
				return err
			}
			list = append(list, ptr.Bool(vv))
		}
		v.HeaderBooleanList = list
	}

	if val := response.Header.Get("X-Byte"); val != "" {
		vv, err := strconv.ParseInt(val, 0, 8)
		if err != nil {
			return err
		}
		v.HeaderByte = ptr.Int8(int8(vv))
	}

	if val := response.Header.Get("X-Double"); val != "" {
		vv, err := strconv.ParseFloat(val, 64)
		if err != nil {
			return err
		}
		v.HeaderDouble = ptr.Float64(vv)
	}

	if val := response.Header.Get("X-Enum"); val != "" {
		v.HeaderEnum = types.FooEnum(val)
	}

	if val := response.Header.Get("X-EnumList"); val != "" {
		list := make([]types.FooEnum, 0, 0)
		for _, i := range strings.Split(val[1:len(val)-1], ",") {
			list = append(list, types.FooEnum(i))
		}
		v.HeaderEnumList = list
	}

	if val := response.Header.Get("X-Boolean2"); val != "" {
		vv, err := strconv.ParseBool(val)
		if err != nil {
			return err
		}
		v.HeaderFalseBool = ptr.Bool(vv)
	}

	if val := response.Header.Get("X-Float"); val != "" {
		vv, err := strconv.ParseFloat(val, 32)
		if err != nil {
			return err
		}
		v.HeaderFloat = ptr.Float32(float32(vv))
	}

	if val := response.Header.Get("X-Integer"); val != "" {
		vv, err := strconv.ParseInt(val, 0, 32)
		if err != nil {
			return err
		}
		v.HeaderInteger = ptr.Int32(int32(vv))
	}

	if val := response.Header.Get("X-IntegerList"); val != "" {
		list := make([]*int32, 0, 0)
		for _, i := range strings.Split(val[1:len(val)-1], ",") {
			vv, err := strconv.ParseInt(i, 0, 32)
			if err != nil {
				return err
			}
			list = append(list, ptr.Int32(int32(vv)))
		}
		v.HeaderIntegerList = list
	}

	if val := response.Header.Get("X-Long"); val != "" {
		vv, err := strconv.ParseInt(val, 0, 64)
		if err != nil {
			return err
		}
		v.HeaderLong = ptr.Int64(vv)
	}

	if val := response.Header.Get("X-Short"); val != "" {
		vv, err := strconv.ParseInt(val, 0, 16)
		if err != nil {
			return err
		}
		v.HeaderShort = ptr.Int16(int16(vv))
	}

	if val := response.Header.Get("X-String"); val != "" {
		v.HeaderString = ptr.String(val)
	}

	if val := response.Header.Get("X-StringList"); val != "" {
		list := make([]*string, 0, 0)
		for _, i := range strings.Split(val[1:len(val)-1], ",") {
			list = append(list, ptr.String(i))
		}
		v.HeaderStringList = list
	}

	if val := response.Header.Get("X-StringSet"); val != "" {
		list := make([]*string, 0, 0)
		for _, i := range strings.Split(val[1:len(val)-1], ",") {
			list = append(list, ptr.String(i))
		}
		v.HeaderStringSet = list
	}

	if val := response.Header.Get("X-TimestampList"); val != "" {
		list := make([]*time.Time, 0, 0)
		for _, i := range strings.Split(val[1:len(val)-1], ",") {
			t, err := smithytime.ParseHTTPDate(i)
			if err != nil {
				return err
			}
			list = append(list, ptr.Time(t))
		}
		v.HeaderTimestampList = list
	}

	if val := response.Header.Get("X-Boolean1"); val != "" {
		vv, err := strconv.ParseBool(val)
		if err != nil {
			return err
		}
		v.HeaderTrueBool = ptr.Bool(vv)
	}

	return nil
}
func awsRestjson1_deserializeHttpBindingsComplexError(v *types.ComplexError, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("X-Header"); val != "" {
		v.Header = ptr.String(val)
	}

	return nil
}
func awsRestjson1_deserializeDocumentComplexError(v *types.ComplexError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Nested":
			val := types.ComplexNestedErrorData{}
			if err := awsRestjson1_deserializeDocumentComplexNestedErrorData(&val, decoder); err != nil {
				return err
			}
			v.Nested = &val

		case "TopLevel":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected TopLevel to be of type *string, got %T instead", val)
			}
			v.TopLevel = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentInvalidGreeting(v *types.InvalidGreeting, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentComplexNestedErrorData(v *types.ComplexNestedErrorData, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Foo":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Foo to be of type *string, got %T instead", val)
			}
			v.Foo = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentJsonMapsInputOutputMap(vp *map[string]*types.GreetingStruct, decoder *json.Decoder) error {
	v := map[string]*types.GreetingStruct{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		token, err := decoder.Token()
		if err != nil {
			return err
		}

		key, ok := token.(string)
		if !ok {
			return fmt.Errorf("expected map-key of type string, found type %T", token)
		}

		val := types.GreetingStruct{}
		if err := awsRestjson1_deserializeDocumentGreetingStruct(&val, decoder); err != nil {
			return err
		}
		v[key] = &val

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentNestedPayload(v *types.NestedPayload, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "greeting":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Greeting to be of type *string, got %T instead", val)
			}
			v.Greeting = ptr.String(st)

		case "name":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Name to be of type *string, got %T instead", val)
			}
			v.Name = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested1(v *types.RecursiveShapesInputOutputNested1, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "foo":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Foo to be of type *string, got %T instead", val)
			}
			v.Foo = ptr.String(st)

		case "nested":
			val := types.RecursiveShapesInputOutputNested2{}
			if err := awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested2(&val, decoder); err != nil {
				return err
			}
			v.Nested = &val

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested2(v *types.RecursiveShapesInputOutputNested2, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "bar":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Bar to be of type *string, got %T instead", val)
			}
			v.Bar = ptr.String(st)

		case "recursiveMember":
			val := types.RecursiveShapesInputOutputNested1{}
			if err := awsRestjson1_deserializeDocumentRecursiveShapesInputOutputNested1(&val, decoder); err != nil {
				return err
			}
			v.RecursiveMember = &val

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentStructureList(vp *[]*types.StructureListMember, decoder *json.Decoder) error {
	v := []*types.StructureListMember{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val := types.StructureListMember{}
		if err := awsRestjson1_deserializeDocumentStructureListMember(&val, decoder); err != nil {
			return err
		}
		v = append(v, &val)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentStructureListMember(v *types.StructureListMember, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "a":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected A to be of type *string, got %T instead", val)
			}
			v.A = ptr.String(st)

		case "b":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected B to be of type *string, got %T instead", val)
			}
			v.B = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentBooleanList(vp *[]*bool, decoder *json.Decoder) error {
	v := []*bool{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		b, ok := val.(bool)
		if !ok {
			return fmt.Errorf("expected Member to be of type bool, got %T instead", val)
		}
		v = append(v, ptr.Bool(b))

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentFooEnumList(vp *[]types.FooEnum, decoder *json.Decoder) error {
	v := []types.FooEnum{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		st, ok := val.(string)
		if !ok {
			return fmt.Errorf("expected Member to be of type types.FooEnum, got %T instead", val)
		}
		v = append(v, types.FooEnum(st))

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentFooEnumMap(vp *map[string]types.FooEnum, decoder *json.Decoder) error {
	v := map[string]types.FooEnum{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		token, err := decoder.Token()
		if err != nil {
			return err
		}

		key, ok := token.(string)
		if !ok {
			return fmt.Errorf("expected map-key of type string, found type %T", token)
		}

		val, err := decoder.Token()
		if err != nil {
			return err
		}
		st, ok := val.(string)
		if !ok {
			return fmt.Errorf("expected Value to be of type types.FooEnum, got %T instead", val)
		}
		v[key] = types.FooEnum(st)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentFooEnumSet(vp *[]types.FooEnum, decoder *json.Decoder) error {
	v := []types.FooEnum{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		st, ok := val.(string)
		if !ok {
			return fmt.Errorf("expected Member to be of type types.FooEnum, got %T instead", val)
		}
		v = append(v, types.FooEnum(st))

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentGreetingStruct(v *types.GreetingStruct, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "hi":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Hi to be of type *string, got %T instead", val)
			}
			v.Hi = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentIntegerList(vp *[]*int32, decoder *json.Decoder) error {
	v := []*int32{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		nt, err := val.(json.Number).Int64()
		if err != nil {
			return err
		}
		st := int32(nt)
		v = append(v, ptr.Int32(st))

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentNestedStringList(vp *[][]*string, decoder *json.Decoder) error {
	v := [][]*string{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		col := []*string{}
		if err := awsRestjson1_deserializeDocumentStringList(&col, decoder); err != nil {
			return err
		}
		v = append(v, col)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentStringList(vp *[]*string, decoder *json.Decoder) error {
	v := []*string{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		st, ok := val.(string)
		if !ok {
			return fmt.Errorf("expected Member to be of type *string, got %T instead", val)
		}
		v = append(v, ptr.String(st))

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentStringSet(vp *[]*string, decoder *json.Decoder) error {
	v := []*string{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		st, ok := val.(string)
		if !ok {
			return fmt.Errorf("expected Member to be of type *string, got %T instead", val)
		}
		v = append(v, ptr.String(st))

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentTimestampList(vp *[]*time.Time, decoder *json.Decoder) error {
	v := []*time.Time{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		ft, err := val.(json.Number).Float64()
		if err != nil {
			return err
		}
		ts := smithytime.ParseEpochSeconds(ft)
		v = append(v, ptr.Time(ts))

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}
