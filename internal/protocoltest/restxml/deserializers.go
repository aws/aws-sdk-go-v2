// Code generated by smithy-go-codegen DO NOT EDIT.

package restxml

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/xml"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/internal/protocoltest/restxml/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithytime "github.com/awslabs/smithy-go/time"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	smithyxml "github.com/awslabs/smithy-go/xml"
	"io"
	"io/ioutil"
	"strconv"
	"strings"
	"time"
)

type awsRestxml_deserializeOpAllQueryStringTypes struct {
}

func (*awsRestxml_deserializeOpAllQueryStringTypes) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpAllQueryStringTypes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorAllQueryStringTypes(response)
	}
	output := &AllQueryStringTypesOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorAllQueryStringTypes(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpConstantAndVariableQueryString struct {
}

func (*awsRestxml_deserializeOpConstantAndVariableQueryString) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpConstantAndVariableQueryString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorConstantAndVariableQueryString(response)
	}
	output := &ConstantAndVariableQueryStringOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorConstantAndVariableQueryString(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpConstantQueryString struct {
}

func (*awsRestxml_deserializeOpConstantQueryString) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpConstantQueryString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorConstantQueryString(response)
	}
	output := &ConstantQueryStringOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorConstantQueryString(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpEmptyInputAndEmptyOutput struct {
}

func (*awsRestxml_deserializeOpEmptyInputAndEmptyOutput) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpEmptyInputAndEmptyOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorEmptyInputAndEmptyOutput(response)
	}
	output := &EmptyInputAndEmptyOutputOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorEmptyInputAndEmptyOutput(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpFlattenedXmlMap struct {
}

func (*awsRestxml_deserializeOpFlattenedXmlMap) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpFlattenedXmlMap) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorFlattenedXmlMap(response)
	}
	output := &FlattenedXmlMapOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentFlattenedXmlMapOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorFlattenedXmlMap(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentFlattenedXmlMapOutput(v **FlattenedXmlMapOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *FlattenedXmlMapOutput
	if *v == nil {
		sv = &FlattenedXmlMapOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("myMap", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentFooEnumMapUnwrapped(&sv.MyMap, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpFlattenedXmlMapWithXmlName struct {
}

func (*awsRestxml_deserializeOpFlattenedXmlMapWithXmlName) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpFlattenedXmlMapWithXmlName) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorFlattenedXmlMapWithXmlName(response)
	}
	output := &FlattenedXmlMapWithXmlNameOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentFlattenedXmlMapWithXmlNameOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorFlattenedXmlMapWithXmlName(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentFlattenedXmlMapWithXmlNameOutput(v **FlattenedXmlMapWithXmlNameOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *FlattenedXmlMapWithXmlNameOutput
	if *v == nil {
		sv = &FlattenedXmlMapWithXmlNameOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("KVP", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentFlattenedXmlMapWithXmlNameInputOutputMapUnwrapped(&sv.MyMap, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGreetingWithErrors struct {
}

func (*awsRestxml_deserializeOpGreetingWithErrors) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGreetingWithErrors) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGreetingWithErrors(response)
	}
	output := &GreetingWithErrorsOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsGreetingWithErrorsOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGreetingWithErrors(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ComplexError", errorCode):
		return awsRestxml_deserializeErrorComplexError(response, errorBody)

	case strings.EqualFold("InvalidGreeting", errorCode):
		return awsRestxml_deserializeErrorInvalidGreeting(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsGreetingWithErrorsOutput(v *GreetingWithErrorsOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Greeting"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Greeting = ptr.String(headerValues[0])
	}

	return nil
}

type awsRestxml_deserializeOpHttpPayloadTraits struct {
}

func (*awsRestxml_deserializeOpHttpPayloadTraits) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpPayloadTraits) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpPayloadTraits(response)
	}
	output := &HttpPayloadTraitsOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsHttpPayloadTraitsOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestxml_deserializeDocumentHttpPayloadTraitsOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpPayloadTraits(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsHttpPayloadTraitsOutput(v *HttpPayloadTraitsOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Foo"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Foo = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeDocumentHttpPayloadTraitsOutput(v *HttpPayloadTraitsOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}
	bs, err := ioutil.ReadAll(body)
	if err != nil {
		return err
	}
	if len(bs) > 0 {
		v.Blob = bs
	}
	return nil
}

type awsRestxml_deserializeOpHttpPayloadTraitsWithMediaType struct {
}

func (*awsRestxml_deserializeOpHttpPayloadTraitsWithMediaType) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpPayloadTraitsWithMediaType) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpPayloadTraitsWithMediaType(response)
	}
	output := &HttpPayloadTraitsWithMediaTypeOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsHttpPayloadTraitsWithMediaTypeOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestxml_deserializeDocumentHttpPayloadTraitsWithMediaTypeOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpPayloadTraitsWithMediaType(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsHttpPayloadTraitsWithMediaTypeOutput(v *HttpPayloadTraitsWithMediaTypeOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Foo"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Foo = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeDocumentHttpPayloadTraitsWithMediaTypeOutput(v *HttpPayloadTraitsWithMediaTypeOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}
	bs, err := ioutil.ReadAll(body)
	if err != nil {
		return err
	}
	if len(bs) > 0 {
		v.Blob = bs
	}
	return nil
}

type awsRestxml_deserializeOpHttpPayloadWithStructure struct {
}

func (*awsRestxml_deserializeOpHttpPayloadWithStructure) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpPayloadWithStructure) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpPayloadWithStructure(response)
	}
	output := &HttpPayloadWithStructureOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNestedPayload(&output.Nested, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpPayloadWithStructure(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentHttpPayloadWithStructureOutput(v **HttpPayloadWithStructureOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *HttpPayloadWithStructureOutput
	if *v == nil {
		sv = &HttpPayloadWithStructureOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("nested", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentNestedPayload(&sv.Nested, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpHttpPayloadWithXmlName struct {
}

func (*awsRestxml_deserializeOpHttpPayloadWithXmlName) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpPayloadWithXmlName) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpPayloadWithXmlName(response)
	}
	output := &HttpPayloadWithXmlNameOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentPayloadWithXmlName(&output.Nested, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpPayloadWithXmlName(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentHttpPayloadWithXmlNameOutput(v **HttpPayloadWithXmlNameOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *HttpPayloadWithXmlNameOutput
	if *v == nil {
		sv = &HttpPayloadWithXmlNameOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("nested", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentPayloadWithXmlName(&sv.Nested, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpHttpPayloadWithXmlNamespace struct {
}

func (*awsRestxml_deserializeOpHttpPayloadWithXmlNamespace) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpPayloadWithXmlNamespace) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpPayloadWithXmlNamespace(response)
	}
	output := &HttpPayloadWithXmlNamespaceOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentPayloadWithXmlNamespace(&output.Nested, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpPayloadWithXmlNamespace(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentHttpPayloadWithXmlNamespaceOutput(v **HttpPayloadWithXmlNamespaceOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *HttpPayloadWithXmlNamespaceOutput
	if *v == nil {
		sv = &HttpPayloadWithXmlNamespaceOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("nested", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentPayloadWithXmlNamespace(&sv.Nested, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpHttpPayloadWithXmlNamespaceAndPrefix struct {
}

func (*awsRestxml_deserializeOpHttpPayloadWithXmlNamespaceAndPrefix) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpPayloadWithXmlNamespaceAndPrefix) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpPayloadWithXmlNamespaceAndPrefix(response)
	}
	output := &HttpPayloadWithXmlNamespaceAndPrefixOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentPayloadWithXmlNamespaceAndPrefix(&output.Nested, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpPayloadWithXmlNamespaceAndPrefix(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentHttpPayloadWithXmlNamespaceAndPrefixOutput(v **HttpPayloadWithXmlNamespaceAndPrefixOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *HttpPayloadWithXmlNamespaceAndPrefixOutput
	if *v == nil {
		sv = &HttpPayloadWithXmlNamespaceAndPrefixOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("nested", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentPayloadWithXmlNamespaceAndPrefix(&sv.Nested, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpHttpPrefixHeaders struct {
}

func (*awsRestxml_deserializeOpHttpPrefixHeaders) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpPrefixHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpPrefixHeaders(response)
	}
	output := &HttpPrefixHeadersOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsHttpPrefixHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpPrefixHeaders(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsHttpPrefixHeadersOutput(v *HttpPrefixHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Foo"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Foo = ptr.String(headerValues[0])
	}

	for headerKey, headerValues := range response.Header {
		if lenPrefix := len("X-Foo-"); len(headerKey) >= lenPrefix && strings.EqualFold(headerKey[:lenPrefix], "X-Foo-") {
			if v.FooMap == nil {
				v.FooMap = map[string]*string{}
			}
			headerValues[0] = strings.TrimSpace(headerValues[0])
			v.FooMap[headerKey[lenPrefix:]] = ptr.String(headerValues[0])
		}
	}

	return nil
}

type awsRestxml_deserializeOpHttpRequestWithGreedyLabelInPath struct {
}

func (*awsRestxml_deserializeOpHttpRequestWithGreedyLabelInPath) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpRequestWithGreedyLabelInPath) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpRequestWithGreedyLabelInPath(response)
	}
	output := &HttpRequestWithGreedyLabelInPathOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpRequestWithGreedyLabelInPath(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpHttpRequestWithLabels struct {
}

func (*awsRestxml_deserializeOpHttpRequestWithLabels) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpRequestWithLabels) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpRequestWithLabels(response)
	}
	output := &HttpRequestWithLabelsOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpRequestWithLabels(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpHttpRequestWithLabelsAndTimestampFormat struct {
}

func (*awsRestxml_deserializeOpHttpRequestWithLabelsAndTimestampFormat) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpHttpRequestWithLabelsAndTimestampFormat) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorHttpRequestWithLabelsAndTimestampFormat(response)
	}
	output := &HttpRequestWithLabelsAndTimestampFormatOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorHttpRequestWithLabelsAndTimestampFormat(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpIgnoreQueryParamsInResponse struct {
}

func (*awsRestxml_deserializeOpIgnoreQueryParamsInResponse) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpIgnoreQueryParamsInResponse) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorIgnoreQueryParamsInResponse(response)
	}
	output := &IgnoreQueryParamsInResponseOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentIgnoreQueryParamsInResponseOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorIgnoreQueryParamsInResponse(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentIgnoreQueryParamsInResponseOutput(v **IgnoreQueryParamsInResponseOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *IgnoreQueryParamsInResponseOutput
	if *v == nil {
		sv = &IgnoreQueryParamsInResponseOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("baz", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Baz = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpInputAndOutputWithHeaders struct {
}

func (*awsRestxml_deserializeOpInputAndOutputWithHeaders) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpInputAndOutputWithHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorInputAndOutputWithHeaders(response)
	}
	output := &InputAndOutputWithHeadersOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsInputAndOutputWithHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorInputAndOutputWithHeaders(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsInputAndOutputWithHeadersOutput(v *InputAndOutputWithHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-BooleanList"); len(headerValues) != 0 {
		{
			var err error
			headerValues, err = smithyhttp.SplitHeaderListValues(headerValues)
			if err != nil {
				return err
			}
		}
		var list []*bool
		for _, headerValuesVal := range headerValues {
			headerValuesVal = strings.TrimSpace(headerValuesVal)
			vv, err := strconv.ParseBool(headerValuesVal)
			if err != nil {
				return err
			}
			list = append(list, ptr.Bool(vv))
		}
		v.HeaderBooleanList = list
	}

	if headerValues := response.Header.Values("X-Byte"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseInt(headerValues[0], 0, 8)
		if err != nil {
			return err
		}
		v.HeaderByte = ptr.Int8(int8(vv))
	}

	if headerValues := response.Header.Values("X-Double"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseFloat(headerValues[0], 64)
		if err != nil {
			return err
		}
		v.HeaderDouble = ptr.Float64(vv)
	}

	if headerValues := response.Header.Values("X-Enum"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.HeaderEnum = types.FooEnum(headerValues[0])
	}

	if headerValues := response.Header.Values("X-EnumList"); len(headerValues) != 0 {
		{
			var err error
			headerValues, err = smithyhttp.SplitHeaderListValues(headerValues)
			if err != nil {
				return err
			}
		}
		var list []types.FooEnum
		for _, headerValuesVal := range headerValues {
			headerValuesVal = strings.TrimSpace(headerValuesVal)
			list = append(list, types.FooEnum(headerValuesVal))
		}
		v.HeaderEnumList = list
	}

	if headerValues := response.Header.Values("X-Boolean2"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseBool(headerValues[0])
		if err != nil {
			return err
		}
		v.HeaderFalseBool = ptr.Bool(vv)
	}

	if headerValues := response.Header.Values("X-Float"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseFloat(headerValues[0], 32)
		if err != nil {
			return err
		}
		v.HeaderFloat = ptr.Float32(float32(vv))
	}

	if headerValues := response.Header.Values("X-Integer"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseInt(headerValues[0], 0, 32)
		if err != nil {
			return err
		}
		v.HeaderInteger = ptr.Int32(int32(vv))
	}

	if headerValues := response.Header.Values("X-IntegerList"); len(headerValues) != 0 {
		{
			var err error
			headerValues, err = smithyhttp.SplitHeaderListValues(headerValues)
			if err != nil {
				return err
			}
		}
		var list []*int32
		for _, headerValuesVal := range headerValues {
			headerValuesVal = strings.TrimSpace(headerValuesVal)
			vv, err := strconv.ParseInt(headerValuesVal, 0, 32)
			if err != nil {
				return err
			}
			list = append(list, ptr.Int32(int32(vv)))
		}
		v.HeaderIntegerList = list
	}

	if headerValues := response.Header.Values("X-Long"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseInt(headerValues[0], 0, 64)
		if err != nil {
			return err
		}
		v.HeaderLong = ptr.Int64(vv)
	}

	if headerValues := response.Header.Values("X-Short"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseInt(headerValues[0], 0, 16)
		if err != nil {
			return err
		}
		v.HeaderShort = ptr.Int16(int16(vv))
	}

	if headerValues := response.Header.Values("X-String"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.HeaderString = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-StringList"); len(headerValues) != 0 {
		{
			var err error
			headerValues, err = smithyhttp.SplitHeaderListValues(headerValues)
			if err != nil {
				return err
			}
		}
		var list []*string
		for _, headerValuesVal := range headerValues {
			headerValuesVal = strings.TrimSpace(headerValuesVal)
			list = append(list, ptr.String(headerValuesVal))
		}
		v.HeaderStringList = list
	}

	if headerValues := response.Header.Values("X-StringSet"); len(headerValues) != 0 {
		{
			var err error
			headerValues, err = smithyhttp.SplitHeaderListValues(headerValues)
			if err != nil {
				return err
			}
		}
		var list []*string
		for _, headerValuesVal := range headerValues {
			headerValuesVal = strings.TrimSpace(headerValuesVal)
			list = append(list, ptr.String(headerValuesVal))
		}
		v.HeaderStringSet = list
	}

	if headerValues := response.Header.Values("X-TimestampList"); len(headerValues) != 0 {
		{
			var err error
			headerValues, err = smithyhttp.SplitHTTPDateTimestampHeaderListValues(headerValues)
			if err != nil {
				return err
			}
		}
		var list []*time.Time
		for _, headerValuesVal := range headerValues {
			headerValuesVal = strings.TrimSpace(headerValuesVal)
			t, err := smithytime.ParseHTTPDate(headerValuesVal)
			if err != nil {
				return err
			}
			list = append(list, ptr.Time(t))
		}
		v.HeaderTimestampList = list
	}

	if headerValues := response.Header.Values("X-Boolean1"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		vv, err := strconv.ParseBool(headerValues[0])
		if err != nil {
			return err
		}
		v.HeaderTrueBool = ptr.Bool(vv)
	}

	return nil
}

type awsRestxml_deserializeOpNoInputAndNoOutput struct {
}

func (*awsRestxml_deserializeOpNoInputAndNoOutput) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpNoInputAndNoOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorNoInputAndNoOutput(response)
	}
	output := &NoInputAndNoOutputOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorNoInputAndNoOutput(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpNoInputAndOutput struct {
}

func (*awsRestxml_deserializeOpNoInputAndOutput) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpNoInputAndOutput) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorNoInputAndOutput(response)
	}
	output := &NoInputAndOutputOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorNoInputAndOutput(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpNullAndEmptyHeadersClient struct {
}

func (*awsRestxml_deserializeOpNullAndEmptyHeadersClient) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpNullAndEmptyHeadersClient) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorNullAndEmptyHeadersClient(response)
	}
	output := &NullAndEmptyHeadersClientOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsNullAndEmptyHeadersClientOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorNullAndEmptyHeadersClient(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsNullAndEmptyHeadersClientOutput(v *NullAndEmptyHeadersClientOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-A"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.A = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-B"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.B = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-C"); len(headerValues) != 0 {
		{
			var err error
			headerValues, err = smithyhttp.SplitHeaderListValues(headerValues)
			if err != nil {
				return err
			}
		}
		var list []*string
		for _, headerValuesVal := range headerValues {
			headerValuesVal = strings.TrimSpace(headerValuesVal)
			list = append(list, ptr.String(headerValuesVal))
		}
		v.C = list
	}

	return nil
}

type awsRestxml_deserializeOpNullAndEmptyHeadersServer struct {
}

func (*awsRestxml_deserializeOpNullAndEmptyHeadersServer) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpNullAndEmptyHeadersServer) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorNullAndEmptyHeadersServer(response)
	}
	output := &NullAndEmptyHeadersServerOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsNullAndEmptyHeadersServerOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorNullAndEmptyHeadersServer(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsNullAndEmptyHeadersServerOutput(v *NullAndEmptyHeadersServerOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-A"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.A = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-B"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.B = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("X-C"); len(headerValues) != 0 {
		{
			var err error
			headerValues, err = smithyhttp.SplitHeaderListValues(headerValues)
			if err != nil {
				return err
			}
		}
		var list []*string
		for _, headerValuesVal := range headerValues {
			headerValuesVal = strings.TrimSpace(headerValuesVal)
			list = append(list, ptr.String(headerValuesVal))
		}
		v.C = list
	}

	return nil
}

type awsRestxml_deserializeOpOmitsNullSerializesEmptyString struct {
}

func (*awsRestxml_deserializeOpOmitsNullSerializesEmptyString) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpOmitsNullSerializesEmptyString) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorOmitsNullSerializesEmptyString(response)
	}
	output := &OmitsNullSerializesEmptyStringOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorOmitsNullSerializesEmptyString(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpQueryIdempotencyTokenAutoFill struct {
}

func (*awsRestxml_deserializeOpQueryIdempotencyTokenAutoFill) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpQueryIdempotencyTokenAutoFill) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorQueryIdempotencyTokenAutoFill(response)
	}
	output := &QueryIdempotencyTokenAutoFillOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorQueryIdempotencyTokenAutoFill(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpRecursiveShapes struct {
}

func (*awsRestxml_deserializeOpRecursiveShapes) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpRecursiveShapes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorRecursiveShapes(response)
	}
	output := &RecursiveShapesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentRecursiveShapesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorRecursiveShapes(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentRecursiveShapesOutput(v **RecursiveShapesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *RecursiveShapesOutput
	if *v == nil {
		sv = &RecursiveShapesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("nested", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentRecursiveShapesInputOutputNested1(&sv.Nested, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpSimpleScalarProperties struct {
}

func (*awsRestxml_deserializeOpSimpleScalarProperties) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpSimpleScalarProperties) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorSimpleScalarProperties(response)
	}
	output := &SimpleScalarPropertiesOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsSimpleScalarPropertiesOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentSimpleScalarPropertiesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorSimpleScalarProperties(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsSimpleScalarPropertiesOutput(v *SimpleScalarPropertiesOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Foo"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Foo = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeDocumentSimpleScalarPropertiesOutput(v **SimpleScalarPropertiesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *SimpleScalarPropertiesOutput
	if *v == nil {
		sv = &SimpleScalarPropertiesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("byteValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.ByteValue = ptr.Int8(int8(i64))
			}

		case strings.EqualFold("DoubleDribble", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				f64, err := strconv.ParseFloat(xtv, 64)
				if err != nil {
					return err
				}
				sv.DoubleValue = &f64
			}

		case strings.EqualFold("falseBooleanValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FalseBooleanValue = &xtv
			}

		case strings.EqualFold("floatValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				f64, err := strconv.ParseFloat(xtv, 64)
				if err != nil {
					return err
				}
				sv.FloatValue = ptr.Float32(float32(f64))
			}

		case strings.EqualFold("integerValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.IntegerValue = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("longValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.LongValue = &i64
			}

		case strings.EqualFold("shortValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.ShortValue = ptr.Int16(int16(i64))
			}

		case strings.EqualFold("stringValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.StringValue = &xtv
			}

		case strings.EqualFold("trueBooleanValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.TrueBooleanValue = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpTimestampFormatHeaders struct {
}

func (*awsRestxml_deserializeOpTimestampFormatHeaders) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpTimestampFormatHeaders) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorTimestampFormatHeaders(response)
	}
	output := &TimestampFormatHeadersOutput{}
	out.Result = output

	err = awsRestxml_deserializeHttpBindingsTimestampFormatHeadersOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorTimestampFormatHeaders(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeHttpBindingsTimestampFormatHeadersOutput(v *TimestampFormatHeadersOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-defaultFormat"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseHTTPDate(headerValues[0])
		if err != nil {
			return err
		}
		v.DefaultFormat = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-memberDateTime"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseDateTime(headerValues[0])
		if err != nil {
			return err
		}
		v.MemberDateTime = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-memberEpochSeconds"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		f, err := strconv.ParseFloat(headerValues[0], 64)
		if err != nil {
			return err
		}
		t := smithytime.ParseEpochSeconds(f)
		v.MemberEpochSeconds = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-memberHttpDate"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseHTTPDate(headerValues[0])
		if err != nil {
			return err
		}
		v.MemberHttpDate = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-targetDateTime"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseDateTime(headerValues[0])
		if err != nil {
			return err
		}
		v.TargetDateTime = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-targetEpochSeconds"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		f, err := strconv.ParseFloat(headerValues[0], 64)
		if err != nil {
			return err
		}
		t := smithytime.ParseEpochSeconds(f)
		v.TargetEpochSeconds = ptr.Time(t)
	}

	if headerValues := response.Header.Values("X-targetHttpDate"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		t, err := smithytime.ParseHTTPDate(headerValues[0])
		if err != nil {
			return err
		}
		v.TargetHttpDate = ptr.Time(t)
	}

	return nil
}

type awsRestxml_deserializeOpXmlAttributes struct {
}

func (*awsRestxml_deserializeOpXmlAttributes) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlAttributes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlAttributes(response)
	}
	output := &XmlAttributesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlAttributesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlAttributes(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlAttributesOutput(v **XmlAttributesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlAttributesOutput
	if *v == nil {
		sv = &XmlAttributesOutput{}
	} else {
		sv = *v
	}

	for _, attr := range decoder.StartEl.Attr {
		switch {
		case strings.EqualFold("test", attr.Name.Local):
			val := []byte(attr.Value)
			if val != nil {
				xtv := string(val)
				sv.Attr = &xtv
			}

		}
	}
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("foo", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Foo = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpXmlAttributesOnPayload struct {
}

func (*awsRestxml_deserializeOpXmlAttributesOnPayload) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlAttributesOnPayload) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlAttributesOnPayload(response)
	}
	output := &XmlAttributesOnPayloadOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlAttributesInputOutput(&output.Payload, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlAttributesOnPayload(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlAttributesOnPayloadOutput(v **XmlAttributesOnPayloadOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlAttributesOnPayloadOutput
	if *v == nil {
		sv = &XmlAttributesOnPayloadOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("payload", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentXmlAttributesInputOutput(&sv.Payload, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpXmlBlobs struct {
}

func (*awsRestxml_deserializeOpXmlBlobs) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlBlobs) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlBlobs(response)
	}
	output := &XmlBlobsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlBlobsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlBlobs(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlBlobsOutput(v **XmlBlobsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlBlobsOutput
	if *v == nil {
		sv = &XmlBlobsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("data", t.Name.Local):
			var data string
			err := decoder.Decoder.DecodeElement(&data, &t)
			if err != nil {
				return err
			}
			sv.Data, err = base64.StdEncoding.DecodeString(data)
			if err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpXmlEnums struct {
}

func (*awsRestxml_deserializeOpXmlEnums) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlEnums) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlEnums(response)
	}
	output := &XmlEnumsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlEnumsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlEnums(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlEnumsOutput(v **XmlEnumsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlEnumsOutput
	if *v == nil {
		sv = &XmlEnumsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("fooEnum1", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.FooEnum1 = types.FooEnum(xtv)
			}

		case strings.EqualFold("fooEnum2", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.FooEnum2 = types.FooEnum(xtv)
			}

		case strings.EqualFold("fooEnum3", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.FooEnum3 = types.FooEnum(xtv)
			}

		case strings.EqualFold("fooEnumList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentFooEnumList(&sv.FooEnumList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("fooEnumMap", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentFooEnumMap(&sv.FooEnumMap, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("fooEnumSet", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentFooEnumSet(&sv.FooEnumSet, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpXmlLists struct {
}

func (*awsRestxml_deserializeOpXmlLists) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlLists) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlLists(response)
	}
	output := &XmlListsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlListsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlLists(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlListsOutput(v **XmlListsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlListsOutput
	if *v == nil {
		sv = &XmlListsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("booleanList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentBooleanList(&sv.BooleanList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("enumList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentFooEnumList(&sv.EnumList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("flattenedList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentRenamedListMembersUnwrapped(&sv.FlattenedList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("customName", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentRenamedListMembersUnwrapped(&sv.FlattenedList2, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("integerList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentIntegerList(&sv.IntegerList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("nestedStringList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentNestedStringList(&sv.NestedStringList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("renamed", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentRenamedListMembers(&sv.RenamedListMembers, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("stringList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentStringList(&sv.StringList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("stringSet", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentStringSet(&sv.StringSet, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("myStructureList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentStructureList(&sv.StructureList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("timestampList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTimestampList(&sv.TimestampList, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpXmlMaps struct {
}

func (*awsRestxml_deserializeOpXmlMaps) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlMaps) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlMaps(response)
	}
	output := &XmlMapsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlMapsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlMaps(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlMapsOutput(v **XmlMapsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlMapsOutput
	if *v == nil {
		sv = &XmlMapsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("myMap", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentXmlMapsInputOutputMap(&sv.MyMap, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpXmlMapsXmlName struct {
}

func (*awsRestxml_deserializeOpXmlMapsXmlName) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlMapsXmlName) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlMapsXmlName(response)
	}
	output := &XmlMapsXmlNameOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlMapsXmlNameOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlMapsXmlName(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlMapsXmlNameOutput(v **XmlMapsXmlNameOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlMapsXmlNameOutput
	if *v == nil {
		sv = &XmlMapsXmlNameOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("myMap", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentXmlMapsXmlNameInputOutputMap(&sv.MyMap, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpXmlNamespaces struct {
}

func (*awsRestxml_deserializeOpXmlNamespaces) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlNamespaces) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlNamespaces(response)
	}
	output := &XmlNamespacesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlNamespacesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlNamespaces(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlNamespacesOutput(v **XmlNamespacesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlNamespacesOutput
	if *v == nil {
		sv = &XmlNamespacesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("nested", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentXmlNamespaceNested(&sv.Nested, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpXmlTimestamps struct {
}

func (*awsRestxml_deserializeOpXmlTimestamps) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpXmlTimestamps) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorXmlTimestamps(response)
	}
	output := &XmlTimestampsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentXmlTimestampsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorXmlTimestamps(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeDocumentXmlTimestampsOutput(v **XmlTimestampsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *XmlTimestampsOutput
	if *v == nil {
		sv = &XmlTimestampsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("dateTime", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				t, err := smithytime.ParseDateTime(xtv)
				if err != nil {
					return err
				}
				sv.DateTime = &t
			}

		case strings.EqualFold("epochSeconds", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				f64, err := strconv.ParseFloat(xtv, 64)
				if err != nil {
					return err
				}
				sv.EpochSeconds = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case strings.EqualFold("httpDate", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				t, err := smithytime.ParseHTTPDate(xtv)
				if err != nil {
					return err
				}
				sv.HttpDate = &t
			}

		case strings.EqualFold("normal", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				t, err := smithytime.ParseDateTime(xtv)
				if err != nil {
					return err
				}
				sv.Normal = &t
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeHttpBindingsComplexError(v *types.ComplexError, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("X-Header"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Header = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeErrorComplexError(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ComplexError{}
	if err := awsRestxml_deserializeHttpBindingsComplexError(output, response); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid HTTP bindings, %w", err)}
	}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentComplexError(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInvalidGreeting(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidGreeting{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInvalidGreeting(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeDocumentComplexError(v **types.ComplexError, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ComplexError
	if *v == nil {
		sv = &types.ComplexError{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Header", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Header = &xtv
			}

		case strings.EqualFold("Nested", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentComplexNestedErrorData(&sv.Nested, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TopLevel", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TopLevel = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentComplexNestedErrorData(v **types.ComplexNestedErrorData, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ComplexNestedErrorData
	if *v == nil {
		sv = &types.ComplexNestedErrorData{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Foo", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Foo = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentFlattenedXmlMapWithXmlNameInputOutputMap(v *map[string]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv map[string]*string
	if *v == nil {
		sv = make(map[string]*string, 0)
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if strings.EqualFold("entry", t.Name.Local) {
			entryDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentFlattenedXmlMapWithXmlNameInputOutputMapUnwrapped(&sv, entryDecoder); err != nil {
				return err
			}
		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentFlattenedXmlMapWithXmlNameInputOutputMapUnwrapped(v *map[string]*string, decoder smithyxml.NodeDecoder) error {
	var sv map[string]*string
	if *v == nil {
		sv = make(map[string]*string, 0)
	} else {
		sv = *v
	}

	var ek *string
	var ev *string
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			sv[*ek] = ev
			break
		}
		switch {
		case strings.EqualFold("K", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				ek = &xtv
			}

		case strings.EqualFold("V", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				ev = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentInvalidGreeting(v **types.InvalidGreeting, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidGreeting
	if *v == nil {
		sv = &types.InvalidGreeting{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNestedPayload(v **types.NestedPayload, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NestedPayload
	if *v == nil {
		sv = &types.NestedPayload{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("greeting", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Greeting = &xtv
			}

		case strings.EqualFold("name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentPayloadWithXmlName(v **types.PayloadWithXmlName, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.PayloadWithXmlName
	if *v == nil {
		sv = &types.PayloadWithXmlName{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentPayloadWithXmlNamespace(v **types.PayloadWithXmlNamespace, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.PayloadWithXmlNamespace
	if *v == nil {
		sv = &types.PayloadWithXmlNamespace{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentPayloadWithXmlNamespaceAndPrefix(v **types.PayloadWithXmlNamespaceAndPrefix, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.PayloadWithXmlNamespaceAndPrefix
	if *v == nil {
		sv = &types.PayloadWithXmlNamespaceAndPrefix{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentRecursiveShapesInputOutputNested1(v **types.RecursiveShapesInputOutputNested1, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.RecursiveShapesInputOutputNested1
	if *v == nil {
		sv = &types.RecursiveShapesInputOutputNested1{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("foo", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Foo = &xtv
			}

		case strings.EqualFold("nested", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentRecursiveShapesInputOutputNested2(&sv.Nested, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentRecursiveShapesInputOutputNested2(v **types.RecursiveShapesInputOutputNested2, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.RecursiveShapesInputOutputNested2
	if *v == nil {
		sv = &types.RecursiveShapesInputOutputNested2{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("bar", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Bar = &xtv
			}

		case strings.EqualFold("recursiveMember", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentRecursiveShapesInputOutputNested1(&sv.RecursiveMember, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentRenamedListMembers(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("item", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentRenamedListMembersUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	for {
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentStructureList(v *[]*types.StructureListMember, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.StructureListMember
	if *v == nil {
		sv = make([]*types.StructureListMember, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("item", t.Name.Local) {
				var col *types.StructureListMember
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentStructureListMember(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentStructureListUnwrapped(v *[]*types.StructureListMember, decoder smithyxml.NodeDecoder) error {
	var sv []*types.StructureListMember
	if *v == nil {
		sv = make([]*types.StructureListMember, 0)
	} else {
		sv = *v
	}

	for {
		var mv *types.StructureListMember
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentStructureListMember(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentStructureListMember(v **types.StructureListMember, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.StructureListMember
	if *v == nil {
		sv = &types.StructureListMember{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.A = &xtv
			}

		case strings.EqualFold("other", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.B = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentXmlAttributesInputOutput(v **types.XmlAttributesInputOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.XmlAttributesInputOutput
	if *v == nil {
		sv = &types.XmlAttributesInputOutput{}
	} else {
		sv = *v
	}

	for _, attr := range decoder.StartEl.Attr {
		switch {
		case strings.EqualFold("test", attr.Name.Local):
			val := []byte(attr.Value)
			if val != nil {
				xtv := string(val)
				sv.Attr = &xtv
			}

		}
	}
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("foo", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Foo = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentXmlMapsInputOutputMap(v *map[string]*types.GreetingStruct, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv map[string]*types.GreetingStruct
	if *v == nil {
		sv = make(map[string]*types.GreetingStruct, 0)
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if strings.EqualFold("entry", t.Name.Local) {
			entryDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentXmlMapsInputOutputMapUnwrapped(&sv, entryDecoder); err != nil {
				return err
			}
		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentXmlMapsInputOutputMapUnwrapped(v *map[string]*types.GreetingStruct, decoder smithyxml.NodeDecoder) error {
	var sv map[string]*types.GreetingStruct
	if *v == nil {
		sv = make(map[string]*types.GreetingStruct, 0)
	} else {
		sv = *v
	}

	var ek *string
	var ev *types.GreetingStruct
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			sv[*ek] = ev
			break
		}
		switch {
		case strings.EqualFold("key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				ek = &xtv
			}

		case strings.EqualFold("value", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentGreetingStruct(&ev, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentXmlMapsXmlNameInputOutputMap(v *map[string]*types.GreetingStruct, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv map[string]*types.GreetingStruct
	if *v == nil {
		sv = make(map[string]*types.GreetingStruct, 0)
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if strings.EqualFold("entry", t.Name.Local) {
			entryDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentXmlMapsXmlNameInputOutputMapUnwrapped(&sv, entryDecoder); err != nil {
				return err
			}
		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentXmlMapsXmlNameInputOutputMapUnwrapped(v *map[string]*types.GreetingStruct, decoder smithyxml.NodeDecoder) error {
	var sv map[string]*types.GreetingStruct
	if *v == nil {
		sv = make(map[string]*types.GreetingStruct, 0)
	} else {
		sv = *v
	}

	var ek *string
	var ev *types.GreetingStruct
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			sv[*ek] = ev
			break
		}
		switch {
		case strings.EqualFold("Attribute", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				ek = &xtv
			}

		case strings.EqualFold("Setting", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentGreetingStruct(&ev, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentXmlNamespacedList(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentXmlNamespacedListUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	for {
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentXmlNamespaceNested(v **types.XmlNamespaceNested, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.XmlNamespaceNested
	if *v == nil {
		sv = &types.XmlNamespaceNested{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("foo", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Foo = &xtv
			}

		case strings.EqualFold("values", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentXmlNamespacedList(&sv.Values, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentBooleanList(v *[]*bool, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*bool
	if *v == nil {
		sv = make([]*bool, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *bool
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv, err := strconv.ParseBool(string(val))
					if err != nil {
						return fmt.Errorf("expected PrimitiveBoolean to be of type *bool, got %T instead", val)
					}
					col = &xtv
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentBooleanListUnwrapped(v *[]*bool, decoder smithyxml.NodeDecoder) error {
	var sv []*bool
	if *v == nil {
		sv = make([]*bool, 0)
	} else {
		sv = *v
	}

	for {
		var mv *bool
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv, err := strconv.ParseBool(string(val))
			if err != nil {
				return fmt.Errorf("expected PrimitiveBoolean to be of type *bool, got %T instead", val)
			}
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentFooEnumList(v *[]types.FooEnum, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []types.FooEnum
	if *v == nil {
		sv = make([]types.FooEnum, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col types.FooEnum
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					col = types.FooEnum(xtv)
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentFooEnumListUnwrapped(v *[]types.FooEnum, decoder smithyxml.NodeDecoder) error {
	var sv []types.FooEnum
	if *v == nil {
		sv = make([]types.FooEnum, 0)
	} else {
		sv = *v
	}

	for {
		var mv types.FooEnum
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			mv = types.FooEnum(xtv)
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentFooEnumMap(v *map[string]types.FooEnum, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv map[string]types.FooEnum
	if *v == nil {
		sv = make(map[string]types.FooEnum, 0)
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if strings.EqualFold("entry", t.Name.Local) {
			entryDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentFooEnumMapUnwrapped(&sv, entryDecoder); err != nil {
				return err
			}
		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentFooEnumMapUnwrapped(v *map[string]types.FooEnum, decoder smithyxml.NodeDecoder) error {
	var sv map[string]types.FooEnum
	if *v == nil {
		sv = make(map[string]types.FooEnum, 0)
	} else {
		sv = *v
	}

	var ek *string
	var ev types.FooEnum
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			sv[*ek] = ev
			break
		}
		switch {
		case strings.EqualFold("key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				ek = &xtv
			}

		case strings.EqualFold("value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				ev = types.FooEnum(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentFooEnumSet(v *[]types.FooEnum, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []types.FooEnum
	if *v == nil {
		sv = make([]types.FooEnum, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col types.FooEnum
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					col = types.FooEnum(xtv)
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentFooEnumSetUnwrapped(v *[]types.FooEnum, decoder smithyxml.NodeDecoder) error {
	var sv []types.FooEnum
	if *v == nil {
		sv = make([]types.FooEnum, 0)
	} else {
		sv = *v
	}

	for {
		var mv types.FooEnum
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			mv = types.FooEnum(xtv)
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentGreetingStruct(v **types.GreetingStruct, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.GreetingStruct
	if *v == nil {
		sv = &types.GreetingStruct{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("hi", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Hi = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentIntegerList(v *[]*int32, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*int32
	if *v == nil {
		sv = make([]*int32, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *int32
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					i64, err := strconv.ParseInt(xtv, 10, 64)
					if err != nil {
						return err
					}
					col = ptr.Int32(int32(i64))
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentIntegerListUnwrapped(v *[]*int32, decoder smithyxml.NodeDecoder) error {
	var sv []*int32
	if *v == nil {
		sv = make([]*int32, 0)
	} else {
		sv = *v
	}

	for {
		var mv *int32
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			i64, err := strconv.ParseInt(xtv, 10, 64)
			if err != nil {
				return err
			}
			mv = ptr.Int32(int32(i64))
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentNestedStringList(v *[][]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv [][]*string
	if *v == nil {
		sv = make([][]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col []*string
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentStringList(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNestedStringListUnwrapped(v *[][]*string, decoder smithyxml.NodeDecoder) error {
	var sv [][]*string
	if *v == nil {
		sv = make([][]*string, 0)
	} else {
		sv = *v
	}

	for {
		var mv []*string
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentStringList(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentStringList(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentStringListUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	for {
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentStringSet(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentStringSetUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	for {
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentTimestampList(v *[]*time.Time, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*time.Time
	if *v == nil {
		sv = make([]*time.Time, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *time.Time
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					t, err := smithytime.ParseDateTime(xtv)
					if err != nil {
						return err
					}
					col = &t
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTimestampListUnwrapped(v *[]*time.Time, decoder smithyxml.NodeDecoder) error {
	var sv []*time.Time
	if *v == nil {
		sv = make([]*time.Time, 0)
	} else {
		sv = *v
	}

	for {
		var mv *time.Time
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			t, err := smithytime.ParseDateTime(xtv)
			if err != nil {
				return err
			}
			mv = &t
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
