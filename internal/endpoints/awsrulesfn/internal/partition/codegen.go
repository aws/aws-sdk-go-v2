//go:build ignore
// +build ignore

package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"
)

var tmpl = template.Must(template.New("generate").
	Funcs(map[string]interface{}{
		"privateSymbol": func(v string) string {
			return strings.TrimSpace(strings.ToLower(v[0:1]) + v[1:])
		},
		"publicSymbol": func(v string) string {
			return strings.TrimSpace(strings.ToUpper(v[0:1]) + v[1:])
		},
		"join": func(v ...string) string {
			return strings.Join(v, "")
		},
		"quote": func(v string) string {
			return strconv.Quote(v)
		},
		"strOrNil": func(v *string) string {
			if v == nil {
				return "nil"
			}
			return fmt.Sprintf("ptr.String(%q)", *v)
		},
		"boolOrNil": func(v *bool) string {
			if v == nil {
				return "nil"
			}
			return fmt.Sprintf("ptr.Bool(%t)", *v)
		},
	}).
	Parse(`
{{- block "root" $ -}}
// Code generated by endpoint/awsrulesfn/internal/partition. DO NOT EDIT.

package awsrulesfn

import (
	"fmt"
	"regexp"

	"github.com/aws/smithy-go/ptr"
)

// Partition provides the metadata describing an AWS partition.
type Partition struct {
	Name               string
	DnsSuffix          string
	DualStackDnsSuffix string
	SupportsFIPS       bool
	SupportsDualStack  bool
}

// GetPartition returns an AWS [Partition] for the region provided. If the
// partition cannot be determined nil will be returned.
func GetPartition(region string) *Partition {
	if v, ok := regionPartition[region]; ok {
		p, ok := partitions[v.PartitionID]
		if !ok {
			panic(fmt.Sprintf(
				"bad codegen, unable to get region looked up partition %v from partitions map",
				v.PartitionID))
		}
		p.mergeWith(v.Metadata)
		return &p
	}

	for _, r := range regionRegexps {
		if r.RegionRegex.MatchString(region) {
			p, ok := partitions[r.PartitionID]
			if !ok {
				panic(fmt.Sprintf(
					"bad codegen, unable to get region regexp looked up partition %v from partitions map",
					r.PartitionID))
			}
			return &p
		}
	}

	p, ok := partitions[defaultPartition]
	if !ok {
		panic(fmt.Sprintf(
			"bad codegen, unable to get default partition %v from partitions map",
			defaultPartition))
	}

	return &p
}

func (p *Partition) mergeWith(other partitionMetadata) {
	if vv := other.Name; vv != nil {
		p.Name = *vv
	}
	if vv := other.DnsSuffix; vv != nil {
		p.DnsSuffix = *vv
	}
	if vv := other.DualStackDnsSuffix; vv != nil {
		p.DualStackDnsSuffix = *vv
	}
	if vv := other.SupportsFIPS; vv != nil {
		p.SupportsFIPS = *vv
	}
	if vv := other.SupportsDualStack; vv != nil {
		p.SupportsDualStack = *vv
	}
}

const defaultPartition = "aws"

var partitions = map[string]Partition{
	{{- range $_, $partition := $.Partitions }}
		{{ quote $partition.ID }}: Partition{
			Name:				{{ quote $partition.Metadata.Name }},
			DnsSuffix:			{{ quote $partition.Metadata.DnsSuffix }},
			DualStackDnsSuffix: {{ quote $partition.Metadata.DualStackDnsSuffix }},
			SupportsFIPS:		{{ $partition.Metadata.SupportsFIPS }},
			SupportsDualStack:	{{ $partition.Metadata.SupportsDualStack }},
		},
	{{- end }}
}

type partitionMetadata struct {
	Name               *string
	DnsSuffix          *string
	DualStackDnsSuffix *string
	SupportsFIPS       *bool
	SupportsDualStack  *bool
}

var regionPartition = map[string]struct{
	PartitionID string
	Metadata partitionMetadata
}{
	{{- range $_, $partition := $.Partitions }}
		{{- range $region, $metadata := $partition.Regions }}
			{{ quote $region }}: {
				PartitionID: {{ quote $partition.ID }},
				Metadata: partitionMetadata{
					Name:               {{ strOrNil $metadata.Name }},
					DnsSuffix:          {{ strOrNil $metadata.DnsSuffix }},
					DualStackDnsSuffix: {{ strOrNil $metadata.DualStackDnsSuffix }},
					SupportsFIPS:       {{ boolOrNil $metadata.SupportsFIPS }},
					SupportsDualStack:  {{ boolOrNil $metadata.SupportsDualStack }},
				},
			},
		{{- end }}
	{{- end }}
}

var regionRegexps = []struct{
	PartitionID  string
	RegionRegex *regexp.Regexp
}{
	{{- range $_, $partition := $.Partitions }}
	{
		PartitionID:  {{ quote $partition.ID }},
		RegionRegex: regexp.MustCompile({{ quote $partition.RegionRegex }}),
	},
	{{- end }}
}

{{- end }}
`))

func main() {
	var modelFilename, outputFilename string
	flag.StringVar(&modelFilename, "model", "partitions.json", "The `file` providing the partition model metadata.")
	flag.StringVar(&outputFilename, "output", "partitions.go", "The `file` to write the source to.")
	flag.Parse()

	modelFile, err := os.Open(modelFilename)
	if err != nil {
		log.Fatalf("failed to open model file, %v", err)
	}

	var model PartitionModel
	if err = json.NewDecoder(modelFile).Decode(&model); err != nil {
		log.Fatalf("failed to unmarshal model file, %v", err)
	}
	modelFile.Close()

	file, err := os.Create(outputFilename)
	if err != nil {
		log.Fatalf("failed to create output file, %v", err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Fatalf("failed to close output file, %v", err)
		}
	}()

	err = tmpl.Execute(file, struct {
		Partitions []Partition
	}{
		Partitions: model.Partitions,
	})
	if err != nil {
		log.Fatalf("failed to render partition Go file, %v", err)
	}
}

type PartitionModel struct {
	Partitions []Partition `json:"partitions"`
}

type Partition struct {
	ID          string                       `json:"id"`
	RegionRegex string                       `json:"regionRegex"`
	Regions     map[string]PartitionMetadata `json:"regions"`
	Metadata    PartitionMetadata            `json:"outputs"`
}

type PartitionMetadata struct {
	Name               *string `json:"name"`
	DnsSuffix          *string `json:"dnsSuffix"`
	DualStackDnsSuffix *string `json:"dualStackDnsSuffix"`
	SupportsFIPS       *bool   `json:"supportsFIPS"`
	SupportsDualStack  *bool   `json:"supportsDualStack"`
}
