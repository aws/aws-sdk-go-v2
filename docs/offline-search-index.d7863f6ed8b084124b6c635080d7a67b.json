[{"body":"Welcome to the AWS SDK for Go. The AWS SDK for Go V2 provides APIs and utilities that developers can use to build Go applications that use AWS services, such as Amazon Elastic Compute Cloud (Amazon EC2) and Amazon Simple Storage Service (Amazon S3).\nThe SDK removes the complexity of coding directly against a web service interface. It hides a lot of the lower-level plumbing, such as authentication, request retries, and error handling.\nThe SDK also includes helpful utilities. For example, the Amazon S3 download and upload manager can automatically break up large objects into multiple parts and transfer them in parallel.\nUse the AWS SDK for Go Developer Guide to help you install, configure, and use the SDK. The guide provides configuration information, sample code, and an introduction to the SDK utilities.\nMaintenance and support for SDK major versions For information about maintenance and support for SDK major versions and their underlying dependencies, see the following in the AWS SDKs and Tools Shared Configuration and Credentials Reference Guide:\n AWS SDKs and Tools Maintenance Policy AWS SDKs and Tools Version Support Matrix  ","categories":"","description":"","excerpt":"Welcome to the AWS SDK for Go. The AWS SDK for Go V2 provides APIs and …","ref":"/aws-sdk-go-v2/docs/","tags":"","title":"Developer Guide"},{"body":"The AWS SDK for Go requires Go 1.15 or later. You can view your current version of Go by running the following command.\ngo version For information about installing or upgrading your version of Go, see https://golang.org/doc/install.\nGet an Amazon Account Before you can use the AWS SDK for Go V2, you must have an Amazon account. See How do I create and activate a new AWS account? for details.\nInstall the AWS SDK for Go V2 The AWS SDK for Go V2 uses Go Modules, which was a feature introduced in Go 1.11. To get started initialize your local project by running the following Go command.\ngo mod init example After initializing your Go Module project you will be able to retrieve the SDK, and its required dependencies using the go get command. These dependencies will be recorded in the go.mod file which was created by the previous command.\nThe following commands show how to retrieve the standard set of SDK modules to use in your application.\ngo get github.com/aws/aws-sdk-go-v2 go get github.com/aws/aws-sdk-go-v2/config This will retrieve the core SDK module, and the config module which is used for loading the AWS shared configuration.\nNext you can install one or more AWS service API clients required by your application. All API clients are located under github.com/aws/aws-sdk-go-v2/service import hierarchy. A complete set of currently supported API clients can be found here. To install a service client, execute the following command to retrieve the module and record the dependency in your go.mod file. In this example we retrieve the Amazon S3 API client.\ngo get github.com/aws/aws-sdk-go-v2/service/s3 Get your AWS access keys Access keys consist of an access key ID and secret access key, which are used to sign programmatic requests that you make to AWS. If you don’t have access keys, you can create them by using the AWS Management Console. We recommend that you use IAM access keys instead of AWS root account access keys. IAM lets you securely control access to AWS services and resources in your AWS account. Note\nTo create access keys, you must have permissions to perform the required IAM actions. For more information, see Granting IAM User Permission to Manage Password Policy and Credentials in the IAM User Guide.\n To get your access key ID and secret access key.  Open the IAM console On the navigation menu, choose Users. Choose your IAM user name (not the check box). Open the Security credentials tab, and then choose Create access key. To see the new access key, choose Show. Your credentials resemble the following:  Access key ID: AKIAIOSFODNN7EXAMPLE Secret access key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY   To download the key pair, choose Download .csv file. Store the keys in a secure location.  Keep the keys confidential to protect your AWS account, and never email them. Do not share them outside your organization, even if an inquiry appears to come from AWS or Amazon.com. No one who legitimately represents Amazon will ever ask you for your secret key.\n Related topics  What Is IAM? in IAM User Guide. AWS Security Credentials in Amazon Web Services General Reference.  Invoke an Operation After you have installed the SDK, you import AWS packages into your Go applications to use the SDK, as shown in the following example, which imports the AWS, Config, and Amazon S3 libraries. After importing the SDK packages, the AWS SDK Shared Configuration is loaded, a client is constructed, and an API operation is invoked.\npackage main import ( \"context\" \"log\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) func main() { // Load the Shared AWS Configuration (~/.aws/config) \tcfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Fatal(err) } // Create an Amazon S3 service client \tclient := s3.NewFromConfig(cfg) // Get the first page of results for ListObjectsV2 for a bucket \toutput, err := client.ListObjectsV2(context.TODO(), \u0026s3.ListObjectsV2Input{ Bucket: aws.String(\"my-bucket\"), }) if err != nil { log.Fatal(err) } log.Println(\"first page results:\") for _, object := range output.Contents { log.Printf(\"key=%s size=%d\", aws.ToString(object.Key), object.Size) } } ","categories":"","description":"","excerpt":"The AWS SDK for Go requires Go 1.15 or later. You can view your …","ref":"/aws-sdk-go-v2/docs/getting-started/","tags":"","title":"Getting Started with the AWS SDK for Go V2"},{"body":"This section contains code examples for Amazon CloudWatch using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for Amazon CloudWatch using …","ref":"/aws-sdk-go-v2/docs/code-examples/cloudwatch/","tags":"","title":"Amazon CloudWatch Examples"},{"body":"This section contains code examples for Amazon DynamoDB using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for Amazon DynamoDB using version …","ref":"/aws-sdk-go-v2/docs/code-examples/dynamodb/","tags":"","title":"Amazon DynamoDB Examples"},{"body":"This section contains code examples for Amazon EC2 using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for Amazon EC2 using version 2 of …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/","tags":"","title":"Amazon EC2 Examples"},{"body":"This section contains code examples for Amazon S3 using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for Amazon S3 using version 2 of …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/","tags":"","title":"Amazon S3 Examples"},{"body":"This section contains code examples for Amazon SNS using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for Amazon SNS using version 2 of …","ref":"/aws-sdk-go-v2/docs/code-examples/sns/","tags":"","title":"Amazon SNS Examples"},{"body":"This section contains code examples for Amazon SQS using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for Amazon SQS using version 2 of …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/","tags":"","title":"Amazon SQS Examples"},{"body":"This section contains code examples for AWS KMS using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for AWS KMS using version 2 of the …","ref":"/aws-sdk-go-v2/docs/code-examples/kms/","tags":"","title":"AWS KMS Examples"},{"body":"This section contains code examples for AWS STS using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for AWS STS using version 2 of the …","ref":"/aws-sdk-go-v2/docs/code-examples/sts/","tags":"","title":"AWS STS Examples"},{"body":"This section contains code examples for AWS Systems Manager using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for AWS Systems Manager using …","ref":"/aws-sdk-go-v2/docs/code-examples/ssm/","tags":"","title":"AWS Systems Manager Examples"},{"body":"In the AWS SDK for Go V2, you can configure common settings for service clients, such as the logger, log level, and retry configuration. Most settings are optional. However, for each service client, you must specify an AWS Region and your credentials. The SDK uses these values to send requests to the correct Region and sign requests with the correct credentials. You can specify these values as programmatically in code, or via the execution environment.\nLoading AWS Shared Configuration There are a number of ways to initialize a service API client, but the following is the most common pattern recommended to users.\nTo configure the SDK to use the AWS shared configuration use the following code:\nimport ( \"context\" \"log\" \"github.com/aws/aws-sdk-go-v2/config\" ) // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Fatalf(\"failed to load configuration, %v\", err) } config.LoadDefaultConfig(context.TODO()) will construct an aws.Config using the AWS shared configuration sources. This includes configuring a credential provider, configuring the AWS Region, and loading service specific configuration. Service clients can be constructed using the loaded aws.Config, providing a consistent pattern for constructing clients.\nFor more information about AWS Shared Configuration see the AWS Tools and SDKs Shared Configuration and Credentials Reference Guide \nSpecifying the AWS Region When you specify the Region, you specify where to send requests, such as us-west-2 or us-east-2. For a list of Regions for each service, see Regions and Endpoints in the Amazon Web Services General Reference.\nThe SDK does not have a default Region. To specify a Region:\n  Set the AWS_REGION environment variable to the default Region\n  Set the region explicitly using config.WithRegion as an argument to config.LoadDefaultConfig when loading configuration.\n  If you set a Region using all of these techniques, the SDK uses the Region you explicitly specified.\nConfigure Region with Environment Variable Linux, macOS, or Unix export AWS_REGION=us-west-2 Windows set AWS_REGION=us-west-2 Specify Region Programmatically cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion(\"us-west-2\")) Specifying Credentials The AWS SDK for Go V2 requires credentials (an access key and secret access key) to sign requests to AWS. You can specify your credentials in several locations, depending on your particular use case. For information about obtaining credentials, see Getting Started.\nWhen you initialize an aws.Config instance using config.LoadDefaultConfig, the SDK uses its default credential chain to find AWS credentials. This default credential chain looks for credentials in the following order:\n Environment variables.  Static Credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN) Web Identity Token (AWS_WEB_IDENTITY_TOKEN_FILE)   Shared configuration files.  SDK defaults to credentials file under .aws folder that is placed in the home folder on your computer. SDK defaults to config file under .aws folder that is placed in the home folder on your computer.   If your application uses an ECS task definition or RunTask API operation, IAM role for tasks. If your application is running on an Amazon EC2 instance, IAM role for Amazon EC2.  The SDK detects and uses the built-in providers automatically, without requiring manual configurations. For example, if you use IAM roles for Amazon EC2 instances, your applications automatically use the instance’s credentials. You don’t need to manually configure credentials in your application.\nAs a best practice, AWS recommends that you specify credentials in the following order:\n  Use IAM roles for tasks if your application uses an ECS task definition or RunTask API operation.\n  Use IAM roles for Amazon EC2 (if your application is running on an Amazon EC2 instance).\nIAM roles provide applications on the instance temporary security credentials to make AWS calls. IAM roles provide an easy way to distribute and manage credentials on multiple Amazon EC2 instances.\n  Use shared credentials or config files.\nThe credentials and config files are shared across other AWS SDKs and AWS CLI. As a security best practice, we recommend using credentials file for setting sensitive values such as access key IDs and secret keys. Here are the formatting requirements for each of these files.\n  Use environment variables.\nSetting environment variables is useful if you’re doing development work on a machine other than an Amazon EC2 instance.\n  IAM Roles for Tasks If your application uses an Amazon ECS task definition or RunTask operation, use IAM Roles for Tasks to specify an IAM role that can be used by the containers in a task.\nIAM Roles for Amazon EC2 Instances If you are running your application on an Amazon EC2 instance, use the instance’s IAM role to get temporary security credentials to make calls to AWS.\nIf you have configured your instance to use IAM roles, the SDK uses these credentials for your application automatically. You don’t need to manually specify these credentials.\nShared Credentials and Configuration The shared credentials and config files can be used to share common configuration amongst AWS SDKs and other tools. If you use different credentials for different tools or applications, you can use profiles to configure multiple access keys in the same configuration file.\nYou can provide multiple credential or config files locations using config.LoadOptions, by default the SDK loads files stored at default locations mentioned in the specifying credentials section.\nimport ( \"context\" \"github.com/aws/aws-sdk-go-v2/config\" ) // ...  cfg , err := config.LoadDefaultConfig(context.TODO(), config.WithSharedCredentialsFiles( []string{\"test/credentials\", \"data/credentials\"}, ), config.WithSharedConfigFiles( []string{\"test/config\", \"data/config\"}, )\t) When working with shared credentials and config files, if duplicate profiles are specified they are merged to resolve a profile. In case of merge conflict,\n  If duplicate profiles are specified within a same credentials/config file, the profile properties specified in the latter profile takes precedence.\n  If duplicate profiles are specified across either multiple credentials files or across multiple config files, the profile properties are resolved as per the order of file input to the config.LoadOptions. The profile properties in the latter files take precedence.\n  If a profile exists in both credentials file and config file, the credentials file properties take precedence.\n  If need be, you can enable LogConfigurationWarnings on config.LoadOptions, and log the profile resolution steps.\nCreating the Credentials File If you don’t have a shared credentials file (.aws/credentials), you can use any text editor to create one in your home directory. Add the following content to your credentials file, replacing \u003cYOUR_ACCESS_KEY_ID\u003e and \u003cYOUR_SECRET_ACCESS_KEY\u003e with your credentials.\n[default] aws_access_key_id = \u003cYOUR_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_SECRET_ACCESS_KEY\u003e The [default] heading defines credentials for the default profile, which the SDK will use unless you configure it to use another profile.\nYou can also use temporary security credentials by adding the session tokens to your profile, as shown in the following example:\n[temp] aws_access_key_id = \u003cYOUR_TEMP_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_TEMP_SECRET_ACCESS_KEY\u003e aws_session_token = \u003cYOUR_SESSION_TOKEN\u003e The section name for a non-default profile within a credentials file must not begin with the word profile. You can read more at AWS Tools and SDKs Shared Configuration and Credentials Reference Guide.\nCreating the Config File If you don’t have a shared credentials file (.aws/config), you can use any text editor to create one in your home directory. Add the following content to your config file, replacing \u003cREGION\u003e with the desired region.\n[default] region = \u003cREGION\u003e The [default] heading defines config for the default profile, which the SDK will use unless you configure it to use another profile.\nYou use named profiles, as shown in the following example:\n[profile named-profile] region = \u003cREGION\u003e The section name for a non-default profile within a config file must always begin with the word profile , followed by the intended profile name. You can read more at AWS Tools and SDKs Shared Configuration and Credentials Reference Guide.\nSpecifying Profiles You can include multiple access keys in the same configuration file by associating each set of access keys with a profile. For example, in your credentials file, you can declare multiple profiles, as follows.\n[default] aws_access_key_id = \u003cYOUR_DEFAULT_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_DEFAULT_SECRET_ACCESS_KEY\u003e [test-account] aws_access_key_id = \u003cYOUR_TEST_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_TEST_SECRET_ACCESS_KEY\u003e [prod-account] ; work profile aws_access_key_id = \u003cYOUR_PROD_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_PROD_SECRET_ACCESS_KEY\u003e By default, the SDK checks the AWS_PROFILE environment variable to determine which profile to use. If no AWS_PROFILE variable is set, the SDK uses the default profile.\nSometimes, you may to want to use a different profile with your application. For example let’s say you want to use the test-account credentials with your myapp application. You can your application and use this profile by using the following command:\n$ AWS_PROFILE=test-account myapp You can also use instruct the SDK to select a profile by either os.Setenv(\"AWS_PROFILE\", \"test-account\") before calling config.LoadDefaultConfig, or by passing an explicit profile as an argument as shown in the following example:\ncfg, err := config.LoadDefaultConfig(context.TODO(), config.WithSharedConfigProfile(\"test-account\"))  If you specify credentials in environment variables, the SDK always uses those credentials, no matter which profile you specify.\n Environment Variables By default, the SDK detects AWS credentials set in your environment and uses them to sign requests to AWS. That way you don’t need to manage credentials in your applications.\nThe SDK looks for credentials in the following environment variables:\n AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN (optional)  The following examples show how you configure the environment variables.\nLinux, OS X, or Unix $ export AWS_ACCESS_KEY_ID=YOUR_AKID $ export AWS_SECRET_ACCESS_KEY=YOUR_SECRET_KEY $ export AWS_SESSION_TOKEN=TOKEN Windows \u003e set AWS_ACCESS_KEY_ID=YOUR_AKID \u003e set AWS_SECRET_ACCESS_KEY=YOUR_SECRET_KEY \u003e set AWS_SESSION_TOKEN=TOKEN Specify Credentials Programmatically config.LoadDefaultConfig allows you to provide an explicit aws.CredentialProvider when loading the shared configuration sources. To pass an explicity credential provider when loading shared configuration use config.WithCredentialsProvider. For example, if customProvider references an instance of aws.CredentialProvider implementation, it can be passed during configuration loading like so:\ncfg, err := config.LoadDefaultConfig(context.TODO(), config.WithCredentialsProvider(customProvider)) If you explicitly provide credentials, as in this example, the SDK uses only those credentials.\nAll credential providers passed to or returned by LoadDefaultConfig are wrapped in a CredentialsCache automatically. This enables caching and concurrency safe credential access. If you explicitly configure a provider on aws.Config directly you must explicitly wrap the provider with this type using NewCredentialsCache.\n Static Credentials You can hard-code credentials in your application by using the credentials.NewStaticCredentialsProvider credential provider to explicitly set the access keys to be used. For example:\ncfg, err := config.LoadDefaultConfig(context.TODO(), config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(\"AKID\", \"SECRET_KEY\", \"TOKEN\")), )  Do not embed credentials inside an application. Use this method only for testing purposes.\n AWS Single Sign-On Credentials The SDK provides a credential provider for retrieving temporary AWS credentials using AWS Single Sign-On. Using the AWS CLI you authenticate with the AWS SSO user portal and authorize access to temporary AWS credentials. You then configure your application to load the AWS SSO profile, and the SDK uses your AWS SSO credentials to retrieve temporary AWS credentials that will be automatically renewed if expired. If your AWS SSO credentials expire, you must explicitly renew them by logging in to your AWS SSO account again using the \u003cnil\u003e.\nFor example, you can create a profile dev-profile, authenticate and authorize that profile using the AWS CLI, and configure your application as shown below.\n First create the dev-profile  [profile dev-profile] sso_start_url = https://company-sso-portal.awsapps.com/start sso_region = us-west-2 sso_account_id = 012345678901 sso_role_name = Developer region = us-east-1 Login using the AWS CLI to authenticate and authorize the AWS SSO profile.  $ aws sso login --profile dev-profile Attempting to automatically open the SSO authorization page in your default browser. If the browser does not open or you wish to use a different device to authorize this request, open the following URL: https://device.sso.us-west-2.amazonaws.com/ Then enter the code: ABCD-EFGH Successully logged into Start URL: https://company-sso-portal.awsapps.com/start Next configure your application to use the AWS SSO profile.  import \"github.com/aws/aws-sdk-go-v2/config\" // ...  cfg, err := config.LoadDefaultConfig( context.Background(), config.WithSharedConfigProfile(\"dev-profile\"), ) if err != nil { return err } For more information on configuring AWS SSO profiles and authenticating using the AWS CLI see Configuring the AWS CLI use AWS Single Sign-On in the AWS CLI User Guide. For more information on programmatically constructing the AWS SSO credential provider see the ssocreds API reference documentation.\nOther Credentials Providers The SDK provides other methods for retrieving credentials in the credentials module. For example, you can retrieve temporary security credentials from AWS Security Token Service or credentials from encrypted storage.\nAvailable Credential Providers:\n  ec2rolecreds – Retrieve Credentials from Amazon EC2 Instances Roles via Amazon EC2 IMDS.\n  endpointcreds – Retrieve Credentials from an arbitrary HTTP endpoint.\n  processcreds – Retrieve Credentials from an external process that will be invoked by the host environment’s shell.\n  stscreds – Retrieve Credentials from AWS STS\n  ","categories":"","description":"","excerpt":"In the AWS SDK for Go V2, you can configure common settings for …","ref":"/aws-sdk-go-v2/docs/configuring-sdk/","tags":"","title":"Configuring the AWS SDK for Go V2"},{"body":"This section contains code examples for IAM using version 2 of the AWS SDK for Go.\n","categories":"","description":"","excerpt":"This section contains code examples for IAM using version 2 of the AWS …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/","tags":"","title":"IAM Examples"},{"body":"Minimum Go Version The AWS SDK for Go V2 requires a minimum version of Go 1.15. Migration from AWS SDK for Go to AWS SDK for Go V2 might require you to upgrade your application by one or more Go versions. The latest version of Go can be downloaded on the Downloads page. See the Release History for more information about each Go version release, and relevant information required for upgrading.\nModularization The AWS SDK for Go V2 has been updated to take advantage of the Go modules which became the default development mode in Go 1.13. A number of packages provided by the SDK have been modularized and are independently versioned and released respectively. This change enables improved application dependency modeling, and enables the SDK to provide new features and functionality that follows the Go module versioning strategy.\nThe following list are some Go modules provided by the SDK:\n   Module Description     github.com/aws/aws-sdk-go-v2 The SDK core   github.com/aws/aws-sdk-go-v2/config Shared Configuration Loading   github.com/aws/aws-sdk-go-v2/credentials AWS Credential Providers   github.com/aws/aws-sdk-go-v2/feature/ec2/imds Amazon EC2 Instance Metadata Service Client    The SDK’s service clients and higher level utilities modules are nested under the following import paths:\n   Import Root Description     github.com/aws/aws-sdk-go-v2/service/ Service Client Modules   github.com/aws/aws-sdk-go-v2/feature/ High-Level utilities for services, for example the Amazon S3 Transfer Manager    Configuration Loading The session package and associated functionality are replaced with a simplified configuration system provided by the config package. The config package is a separate Go module, and can be included in your applications dependencies by with go get.\ngo get github.com/aws/aws-sdk-go-v2/config The session.New, session.NewSession, NewSessionWithOptions, and session.Must must be migrated to config.LoadDefaultConfig.\nThe config package provides several helper functions that aid in overriding the shared configuration loading programmatically. These function names are prefixed with With followed by option that they override. Let’s look at some examples of how to migrate usage of the session package.\nFor more information on loading shared configuration see Configuring the AWS SDK for Go V2.\nExamples Migrating from NewSession to LoadDefaultConfig The following example shows how usage of session.NewSession without additional argument parameters is migrated to config.LoadDefaultConfig.\n// V1 using NewSession  import \"github.com/aws/aws-sdk-go/aws/session\" // ...  sess, err := session.NewSession() if err != nil { // handle error } // V2 using LoadDefaultConfig  import \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { // handle error } Migrating from NewSession with aws.Config options The example shows how to migrate overriding of aws.Config values during configuration loading. One or more config.With* helper functions can be provided to config.LoadDefaultConfig to override the loaded configuration values. In this example the AWS Region is overridden to us-west-2 using the config.WithRegion helper function.\n// V1  import \"github.com/aws/aws-sdk-go/aws\" import \"github.com/aws/aws-sdk-go/aws/session\" // ...  sess, err := session.NewSession(aws.Config{ Region: aws.String(\"us-west-2\") }) if err != nil { // handle error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion(\"us-west-2\"), ) if err != nil { // handle error } Migrating from NewSessionWithOptions This example shows how to migrate overriding values during configuration loading. Zero or more config.With* helper functions can be provided to config.LoadDefaultConfig to override the loaded configuration values. In this example we show how to override the target profile that is used when loading the AWS SDK shared configuration.\n// V1  import \"github.com/aws/aws-sdk-go/aws\" import \"github.com/aws/aws-sdk-go/aws/session\" // ...  sess, err := session.NewSessionWithOptions(aws.Config{ Profile: \"my-application-profile\" }) if err != nil { // handle error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithSharedConfigProfile(\"my-application-profile\"), ) if err != nil { // handle error } Credentials \u0026 Credential Providers The aws/credentials package and associated credential providers have been relocated to the credentials package location. The credentials package is a Go module that you retrieve by using go get.\ngo get github.com/aws/aws-sdk-go-v2/credentials The AWS SDK for Go V2 release updates the AWS Credential Providers to provide a consistent interface for retrieving AWS Credentials. Each provider implements the aws.CredentialsProvider interface, which defines a Retrieve method that returns a (aws.Credentials, error). aws.Credentials that is analogous to the AWS SDK for Go credentials.Value type.\nYou must wrap aws.CredentialsProvider objects with aws.CredentialsCache to allow credential caching to occur. You use NewCredentialsCache to construct a aws.CredentialsCache object. By default, credentials configured by config.LoadDefaultConfig are wrapped with aws.CredentialsCache.\nThe following table list the location changes of the AWS credential providers from AWS SDK for Go V1 to AWS SDK for Go V2.\n   Name V1 Import V2 Import     Amazon EC2 IAM Role Credentials github.com/aws/aws-sdk-go/aws/credentials/ec2rolecreds github.com/aws/aws-sdk-go-v2/credentials/ec2rolecreds   Endpoint Credentials github.com/aws/aws-sdk-go/aws/credentials/endpointcreds github.com/aws/aws-sdk-go-v2/credentials/endpointcreds   Process Credentials github.com/aws/aws-sdk-go/aws/credentials/processcreds github.com/aws/aws-sdk-go-v2/credentials/processcreds   AWS Security Token Service github.com/aws/aws-sdk-go/aws/credentials/stscreds github.com/aws/aws-sdk-go-v2/credentials/stscreds    Static Credentials Applications that use credentials.NewStaticCredentials to construct static credential programmatically must use credentials.NewStaticCredentialsProvider.\nExample // V1  import \"github.com/aws/aws-sdk-go/aws/credentials\" // ...  appCreds := credentials.NewStaticCredentials(accessKey, secretKey, sessionToken) value, err := appCreds.Get() if err != nil { // handle error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/credentials\" // ...  appCreds := aws.NewCredentialsCache(credentials.NewStaticCredentialsProvider(accessKey, secretKey, sessionToken)) value, err := appCreds.Retrieve(context.TODO()) if err != nil { // handle error } Amazon EC2 IAM Role Credentials You must migrate usage of NewCredentials and NewCredentialsWithClient to use New.\nThe ec2rolecreds package’s ec2rolecreds.New takes functional options of ec2rolecreds.Options as input, allowing you override the specific Amazon EC2 Instance Metadata Service client to use, or to override the credential expiry window.\nExample // V1  import \"github.com/aws/aws-sdk-go/aws/credentials/ec2rolecreds\" // ...  appCreds := ec2rolecreds.NewCredentials(sess) value, err := appCreds.Get() if err != nil { // handle error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/credentials/ec2rolecreds\" // ...  // New returns an object of a type that satisfies the aws.CredentialProvider interface appCreds := aws.NewCredentialsCache(ec2rolecreds.New()) value, err := appCreds.Retrieve(context.TODO()) if err != nil { // handle error } Endpoint Credentials You must migrate usage of NewCredentialsClient and NewProviderClient to use New.\nThe endpointcreds package’s New function takes a string argument containing the URL of an HTTP or HTTPS endpoint to retrieve credentials from, and functional options of endpointcreds.Options to mutate the credentials provider and override specific configuration settings.\nProcess Credentials You must migrate usage of NewCredentials, NewCredentialsCommand, and NewCredentialsTimeout to use NewProvider or NewProviderCommand.\nThe processcreds package’s NewProvider function takes a string argument that is the command to be executed in the host environment’s shell, and functional options of Options to mutate the credentials provider and override specific configuration settings.\nNewProviderCommand takes an implementation of the NewCommandBuilder interface that defines more complex process commands that might take one or more command-line arguments, or have certain execution environment requirements. DefaultNewCommandBuilder implements this interface, and defines a command builder for a process that requires multiple command-line arguments.\nExample // V1  import \"github.com/aws/aws-sdk-go/aws/credentials/processcreds\" // ...  appCreds := processcreds.NewCredentials(\"/path/to/command\") value, err := appCreds.Get() if err != nil { // handle error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/credentials/processcreds\" // ...  appCreds := aws.NewCredentialsCache(processcreds.NewProvider(\"/path/to/command\")) value, err := appCreds.Retrieve(context.TODO()) if err != nil { // handle error } AWS Security Token Service Credentials AssumeRole You must migrate usage of NewCredentials, and NewCredentialsWithClient to use NewAssumeRoleProvider.\nThe stscreds package’s NewAssumeRoleProvider function must be called with a sts.Client, and the AWS Identity and Access Management Role ARN to be assumed from the provided sts.Client’s configured credentials. You can also provide a set of functional options of AssumeRoleOptions to modify other optional settings of the provider.\nExample // V1  import \"github.com/aws/aws-sdk-go/aws/credentials/stscreds\" // ...  appCreds := stscreds.NewCredentials(sess, \"arn:aws:iam::123456789012:role/demo\") value, err := appCreds.Get() if err != nil { // handle error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/credentials/stscreds\" // ...  client := sts.NewFromConfig(cfg) appCreds := stscreds.NewAssumeRoleProvider(client, \"arn:aws:iam::123456789012:role/demo\") value, err := appCreds.Retrieve(context.TODO()) if err != nil { // handle error } AssumeRoleWithWebIdentity You must migrate usage of NewWebIdentityCredentials, NewWebIdentityRoleProvider, and NewWebIdentityRoleProviderWithToken to use NewWebIdentityRoleProvider.\nThe stscreds package’s NewWebIdentityRoleProvider function must be called with a sts.Client, and the AWS Identity and Access Management Role ARN to be assumed using the provided sts.Client’s configured credentials, and an implementation of a IdentityTokenRetriever for providing the OAuth 2.0 or OpenID Connect ID token. IdentityTokenFile is an IdentityTokenRetriever that can be used to provide the web identity token from a file located on the application’s host file-system. You can also provide a set of functional options of WebIdentityRoleOptions to modify other optional settings for the provider.\nExample // V1  import \"github.com/aws/aws-sdk-go/aws/credentials/stscreds\" // ...  appCreds := stscreds.NewWebIdentityRoleProvider(sess, \"arn:aws:iam::123456789012:role/demo\", \"sessionName\", \"/path/to/token\") value, err := appCreds.Get() if err != nil { // handle error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/credentials/stscreds\" // ...  client := sts.NewFromConfig(cfg) appCreds := aws.NewCredentialsCache(stscreds.NewWebIdentityRoleProvider( client, \"arn:aws:iam::123456789012:role/demo\", stscreds.IdentityTokenFile(\"/path/to/file\"), func(o *stscreds.WebIdentityRoleOptions) { o.RoleSessionName = \"sessionName\" })) value, err := appCreds.Retrieve(context.TODO()) if err != nil { // handle error } Service Clients AWS SDK for Go V2 provides service client modules nested under the github.com/aws/aws-sdk-go-v2/service import path. Each service client is contained in a Go package using each service’s unique identifier. The following table provides some examples of service import paths in the AWS SDK for Go V2.\n   Service Name V1 Import Path V2 Import Path     Amazon S3 github.com/aws/aws-sdk-go/service/s3 github.com/aws/aws-sdk-go-v2/service/s3   Amazon DynamoDB github.com/aws/aws-sdk-go/service/dynamodb github.com/aws/aws-sdk-go-v2/service/dynamodb   Amazon CloudWatch Logs github.com/aws/aws-sdk-go/service/cloudwatchlogs github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs    Each service client package is an independently versioned Go module. To add the service client as a dependency of your application, use the go get command with the service’s import path. For example, to add the Amazon S3 client to your dependencies use\ngo get github.com/aws/aws-sdk-go-v2/service/s3 Client Construction You can construct clients in the AWS SDK for Go V2 using either the New or NewFromConfig constructor functions in the client’s package. When migrating from the AWS SDK for Go we recommend that you use the NewFromConfig variant, which will return a new service client using values from an aws.Config. The aws.Config value will have been created while loading the SDK shared configuration using config.LoadDefaultConfig. For details on creating service clients see Using AWS Services.\nExample 1 // V1  import \"github.com/aws/aws-sdk-go/aws/session\" import \"github.com/aws/aws-sdk-go/service/s3\" // ...  sess, err := session.NewSession() if err != nil { // handle error } client := s3.New(sess) // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { // handle error } client := s3.NewFromConfig(cfg) Example 2: Overriding Client Settings // V1  import \"github.com/aws/aws-sdk-go/aws\" import \"github.com/aws/aws-sdk-go/aws/session\" import \"github.com/aws/aws-sdk-go/service/s3\" // ...  sess, err := session.NewSession() if err != nil { // handle error } client := s3.New(sess, \u0026aws.Config{ Region: aws.String(\"us-west-2\"), }) // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { // handle error } client := s3.NewFromConfig(cfg, func(o *s3.Options) { o.Region = \"us-west-2\" }) Endpoints The endpoints package no longer exists in the AWS SDK for Go V2. Each service client now embeds its required AWS endpoint metadata within the client package. This reduces the overall binary size of compiled applications by no longer including endpoint metadata for services not used by your application.\nBy default, service clients use their configured AWS Region to resolve the service endpoint for the target Region. If your application requires a custom endpoint to be specified for a particular service and region, you can specify a custom aws.EndpointResolver using the EndpointResolver field on the aws.Config structure. If your application implements a custom endpoints.Resolver you must migrate it to conform to the aws.EndpointResolver interface. aws.EndpointResolverFunc is provided as a convenient way to wrap a resolver function to satisfy the aws.EndpointResolver interface.\nFor more information on endpoints and implementing a custom resolver, see Configuring Client Endpoints.\nInvoking API Operations The number of service client operation methods have been reduced significantly. The \u003cOperationName\u003eRequest, \u003cOperationName\u003eWithContext, and \u003cOperationName\u003e methods have all been consolidated into single operation method, \u003cOperationName\u003e.\nExample The following example shows how calls to the \u003cnil\u003e PutObject operation would be migrated from AWS SDK for Go to AWS SDK for Go V2.\n// V1  import \"context\" import \"github.com/aws/aws-sdk-go/service/s3\" // ...  client := s3.New(sess) // Pattern 1 output, err := client.PutObject(\u0026s3.PutObjectInput{ // input parameters }) // Pattern 2 output, err := client.PutObjectWithContext(context.TODO(), \u0026s3.PutObjectInput{ // input parameters }) // Pattern 3 req, output := client.PutObjectRequest(context.TODO(), \u0026s3.PutObjectInput{ // input parameters }) err := req.Send() // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  client : s3.NewFromConfig(cfg) output, err := client.PutObject(context.TODO(), \u0026s3.PutObjectInput{ // input parameters }) Service Data Types The top-level input and output types of an operation are found in the service client package. The input and output type for a given operation follow the pattern of \u003cOperationName\u003eInput and \u003cOperationName\u003eOutput, where OperationName is the name of the operation you are invoking. For example the input and output shape for the Amazon S3 PutObject operation are PutObjectInput and PutObjectOutput respectively.\nAll other service data types, other than input and output types, have been migrated to the types package located under the service client package import path hierarchy. For example, the s3.AccessControlPolicy type is now located at types.AccessControlPolicy.\nEnumeration Values The SDK now provides a typed experience for all API enumeration fields. Rather than using a string literal value copied from the service API reference documentation, you can now use one of the concrete types found in the service client’s types package. For example, you can provide the Amazon S3 PutObjectInput operation with an ACL to be applied on an object. In the AWS SDK for Go V1, this parameter was a *string type. In the {{\u0026 alias sdk-go %}} this parameter is now a types.ObjectCannedACL. The types package provides generated constants for the valid enumeration values that can be assigned to this field. For example types.ObjectCannedACLPrivate is the constant for the “private” canned ACL value. This value can be used in place of managing string constants within your application.\nPointer Parameters The AWS SDK for Go v1 required pointer references to be passed for all input parameters to service operations. The AWS SDK for Go V2 has simplified the experience with most services by removing the need to pass input values as pointers where possible. This change means that many service clients operations no longer require your application to pass pointer references for the following types: uint8, uint16, uint32, int8, int16, int32, float32, float64, bool. Similarly, slice and map element types have been updated accordingly to reflect whether their elements must be passed as pointer references.\nThe aws package contains helper functions for creating pointers for the Go built-in types, these helpers should be used to more easily handle creating pointer types for these Go types. Similarly, helper methods are provided for safely de-referencing pointer values for these types. For example, the aws.String function converts from string ⇒ *string. Inversely, the aws.ToString converts from *string ⇒ string. When upgrading your application from AWS SDK for Go V1 to AWS SDK for Go V2, you must migrate usage of the helpers for converting from the pointer types to the non-pointer variants. For example, aws.StringValue must be updated to aws.ToString.\nErrors Types The AWS SDK for Go V2 takes full advantage of the error wrapping functionality introduced in Go 1.13. Services that model error responses have generated types available in their client’s types package that can be used to test whether a client operation error was caused by one of these types. For example Amazon S3 GetObject operation can return a NoSuchKey error if attempting to retrieve an object key that doesn’t exist. You can use errors.As to test whether the returned operation error is a types.NoSuchKey error. In the event a service does not model a specific type for an error, you can utilize the smithy.APIError interface type for inspecting the returned error code and message from the service. This functionality replaces awserr.Error and the other awserr functionality from the AWS SDK for Go V1. For more details information on handling errors see Handling Errors.\nExample // V1  import \"github.com/aws/aws-sdk-go/aws/awserr\" import \"github.com/aws/aws-sdk-go/service/s3\" // ...  client := s3.New(sess) output, err := s3.GetObject(\u0026s3.GetObjectInput{ // input parameters }) if err != nil { if awsErr, ok := err.(awserr.Error); ok { if awsErr.Code() == \"NoSuchKey\" { // handle NoSuchKey \t} else { // handle other codes \t} return } // handle a error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/aws-sdk-go-v2/service/s3/types\" import \"github.com/aws/smithy-go\" // ...  client := s3.NewFromConfig(cfg) output, err := s3.GetObject(context.TODO(), \u0026s3.GetObjectInput{ // input parameters }) if err != nil { var nsk *types.NoSuchKey if errors.As(err, \u0026nsk) { // handle NoSuchKey error \treturn } var apiErr smithy.APIError if errors.As(err, \u0026apiErr) { code := apiErr.ErrorCode() message := apiErr.ErrorMessage() // handle error code \treturn } // handle error \treturn } Paginators Service operation paginators are no longer invoked as methods on the service client. To use a paginator for an operation you must construct a paginator for an operation using one of the paginator constructor methods. For example, to use paginate over the Amazon S3 ListObjectsV2 operation you must construct its paginator using the s3.NewListObjectsV2Paginator. This constructor returns a ListObjectsV2Paginator which provides the methods HasMorePages, and NextPage for determining whether there are more pages to retrieve and invoking the operation to retrieve the next page respectively. More details on using the SDK paginators can be found at .\nLet’s look at an example of how to migrate from a AWS SDK for Go paginator to the AWS SDK for Go V2 equivalent.\nExample // V1  import \"fmt\" import \"github.com/aws/aws-sdk-go/service/s3\" // ...  client := s3.New(sess) params := \u0026s3.ListObjectsV2Input{ // input parameters } totalObjects := 0 err := client.ListObjectsV2Pages(params, func(output *s3.ListObjectsV2Output, lastPage bool) bool { totalObjects += len(output.Contents) return !lastPage }) if err != nil { // handle error } fmt.Println(\"total objects:\", totalObjects) // V2  import \"context\" import \"fmt\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  client := s3.NewFromConfig(cfg) params := \u0026s3.ListObjectsV2Input{ // input parameters } totalObjects := 0 paginator := s3.NewListObjectsV2Paginator(client, params) for paginator.HasMorePages() { output, err := paginator.NextPage(context.TODO()) if err != nil { // handle error \t} totalObjects += len(output.Contents) } fmt.Println(\"total objects:\", totalObjects) Waiters Service operation waiters are no longer invoked as methods on the service client. To use a waiter you first construct the desired waiter type, and then invoke the wait method. For example, to wait for a Amazon S3 Bucket to exist, you must construct a BucketExists waiter. Use the s3.NewBucketExistsWaiter constructor to create a s3.BucketExistsWaiter. The s3.BucketExistsWaiter provides a Wait method which can be used to wait for a bucket to become available.\nFeatures Amazon EC2 Instance Metadata Service The AWS SDK for Go V2 provides an Amazon EC2 Instance Metadata Service (IMDS) client that you can use to query the local IMDS when executing your application on an Amazon EC2 instance. The IMDS client is a separate Go module that can be added to your application by using\ngo get github.com/aws/aws-sdk-go-v2/feature/ec2/imds The client constructor and method operations have been updated to match the design of the other SDK service clients.\nExample // V1  import \"github.com/aws/aws-sdk-go/aws/ec2metadata\" // ...  client := ec2metadata.New(sess) region, err := client.Region() if err != nil { // handle error } // V2  import \"context\" import \"github.com/aws/aws-sdk-go-v2/feature/ec2/imds\" // ...  client := imds.NewFromConfig(cfg) region, err := client.GetRegion(context.TODO()) if err != nil { // handle error } Amazon S3 Transfer Manager The Amazon S3 transfer manager is available for managing uploads and downloads of objects concurrently. This package is located in a Go module outside the service client import path. This module can be retrieved by using go get github.com/aws/aws-sdk-go-v2/feature/s3/manager.\ns3.NewUploader and s3.NewUploaderWithClient have been replaced with the constructor method manager.NewUploader for creating an Upload manager client.\ns3.NewDownloader and s3.NewDownloaderWithClient have been replaced with a single constructor method manager.NewDownloader for creating a Download manager client.\nAmazon CloudFront Signing Utilities The AWS SDK for Go V2 provides Amazon CloudFront signing utilities in a Go module outside the service client import path. This module can be retrieved by using go get.\ngo get github.com/aws/aws-sdk-go-v2/feature/cloudfront/sign ","categories":"","description":"How to migrate to the AWS SDK for Go V2 from AWS SDK for Go V1.","excerpt":"How to migrate to the AWS SDK for Go V2 from AWS SDK for Go V1.","ref":"/aws-sdk-go-v2/docs/migrating/","tags":"","title":"Migrating to the AWS SDK for Go V2"},{"body":"To make calls to an AWS service, you must first construct a service client instance. A service client provides low-level access to every API action for that service. For example, you create an Amazon S3 service client to make calls to Amazon S3 APIs.\nWhen you call service operations, you pass in input parameters as a struct. A successful call will result in an output struct containing the service API response. For example, after you successfully call an Amazon S3 create bucket action, the action returns an output struct with the bucket’s location.\nFor the list of service clients, including their methods and parameters, see the AWS SDK for Go V2 API Reference\nConstructing a Service Client Service clients can be constructed using either the New or NewFromConfig functions available in service client’s Go package. Each function will return a Client struct type containing the methods for invoking the service APIs. The New and NewFromConfig each provide the same set of configurable options for constructing a service client, but provide slightly different construction patterns that we will look at in the following sections.\nNewFromConfig NewFromConfig function provides a consistent interface for constructing service clients using the aws.Config. An aws.Config can be loaded using the config.LoadDefaultConfig. For more information on constructing an aws.Config see Configure the SDK. The following example shows how to construct an Amazon S3 service client using the aws.Configand the NewFromConfig function:\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } client := s3.NewFromConfig(cfg) Overriding Configuration NewFromConfig can take one or more functional arguments that can mutate a client’s configuration Options struct. This allows you to make specific overrides such as changing the Region, or modifying service specific options such as Amazon S3 UseAccelerate option. For example:\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } client := s3.NewFromConfig(cfg, func(o *s3.Options) { o.Region = \"us-west-2\" o.UseAccelerate = true }) Overrides to the client Options value is determined by the order that the functional arguments are given to NewFromConfig.\nNew New is considered a more advanced form of client construction. We recommend you use NewFromConfig for client construction, as it allows construction using the aws.Config struct. This removes the need to construct an Options struct instance for each service client your application requires.\n New function is a client constructor provides an interface for constructing clients using only the client packages Options struct for defining the client’s configuration options. For example to construct Amazon S3 client using New:\nimport \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/credentials\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  client := s3.New(s3.Options{ Region: \"us-west-2\", Credentials: aws.NewCredentialsCache(credentials.NewStaticCredentials(accessKey, secretKey)), }) Overriding Configuration New can take one or more functional arguments that can mutate a client’s configuration Options struct. This allows you to make specific overrides such as changing the Region or modifying service specific options such as Amazon S3 UseAccelerate option. For example:\nimport \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/credentials\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  options := s3.Options{ Region: \"us-west-2\", Credentials: aws.NewCredentialsCache(credentials.NewStaticCredentials(accessKey, secretKey)), } client := s3.New(options, func(o *s3.Options) { o.Region = \"us-east-1\" o.UseAccelerate = true }) Overrides to the client Options value is determined by the order that the functional arguments are given to New.\nCalling Service Operations After you have a service client instance, you can use it to call a service’s operations. For example to call the Amazon S3 GetObject operation:\nresponse, err := client.GetObject(context.TODO(), \u0026s3.GetObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"obj-key\"), }) When you call a service operation, the SDK synchronously validates the input, serializes the request, signs it with your credentials, sends it to AWS, and then deserializes a response or an error. In most cases, you can call service operations directly. Each service operation client method will return an operation response struct, and an error interface type. You should always check error type to determine if an error occurred before attempting to access the service operation’s response struct.\nPassing Parameters to a Service Operation Each service operation method takes a context.Context value that can be used for setting request deadlines that will be honored by the SDK. In addition, each service operation will take a \u003cOperationName\u003eInput struct found in the service’s respective Go package. You pass in API input parameters using the operation input struct.\nOperation input structures can have input parameters such as the standard Go numerics, boolean, string, map, and list types. In more complex API operations a service might have more complex modeling of input parameters. These other types such as service specific structures and enum values are found in the service’s types Go package.\nIn addition, services might distinguish between the default value of a Go type and whether the value was set or not by the user. In these cases, input parameters might require you to pass a pointer reference to the type in question. For standard Go types like numerics, boolean, and string there are \u003cType\u003e and From\u003cType\u003e convenience functions available in the aws to ease this conversion. For example aws.String can be used to convert a string to a *string type for input parameters that require a pointer to a string. Inversely aws.ToString can be used to transform a *string to a string while providing protection from dereferencing a nil pointer. The To\u003cType\u003e functions are helpful when handling service responses.\nLet’s look at an example of how we can use a Amazon S3 client to call the GetObject API, and construct our input using the types package, and aws.\u003cType\u003e helpers.\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/aws-sdk-go-v2/service/s3/types\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } client := s3.NewFromConfig(cfg) resp, err := client.GetObject(context.TODO(), \u0026s3.GetObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"keyName\"), RequestPayer: types.RequestPayerRequester, }) Overriding Client Options For Operation Call Similar to how client operation options can be modified during construction of a client using functional arguments, the client options can be modified at the time the operation method is called by providing one or more functional arguments to the service operation method. This action is concurrency safe and will not affect other concurrent operations on the client.\nFor example to override the client region from “us-west-2” to “us-east-1”:\ncfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion(\"us-west-2\")) if err != nil { log.Printf(\"error: %v\", err) return } client := s3.NewFromConfig(cfg) params := \u0026s3.GetObjectInput{ // ... } resp, err := client.GetObject(context.TODO(), params, func(o *Options) { o.Region = \"us-east-1\" }) Handling Operation Responses Each service operation has an associated output struct that contains the service’s operation response members. The output struct follows the following naming pattern \u003cOperationName\u003eOutput. Some operations might have no members defined for their operation output. After calling a service operation, the return error argument type should always be checked to determine if an error occurred while invoking the service operation. Errors returned can range from client-side input validation errors to service-side error responses returned to the client. The operation’s output struct should not be accessed in the event that a non-nil error is returned by the client.\nFor example to log an operation error and prematurely return from the calling function:\nresponse, err := client.GetObject(context.TODO()) if err != nil { log.Printf(\"GetObject error: %v\", err) return } For more information on error handling, including how to inspect for specific error types, see the Handling Errors documentation.\nResponses with io.ReadCloser Some API operations return a response struct that contain an output member that is an io.ReadCloser. If you’re making requests with these operations, always be sure to call io.ReadCloser member’s Close method after you’ve completed reading the content.\nFor example Amazon S3 GetObject operation returns a response whose Body member is an io.ReadCloser:\nresp, err := s3svc.GetObject(context.TODO(), \u0026s3.GetObjectInput{...}) if err != nil { // handle error  return } // Make sure to always close the response Body when finished defer resp.Body.Close() decoder := json.NewDecoder(resp.Body) if err := decoder.Decode(\u0026myStruct); err != nil { // handle error  return } Response Metadata All service operation output structs include a ResultMetadata member of type middleware.Metadata. middleware.Metadata is used by the SDK middleware to provide additional information from a service response that is not modeled by the service. This includes metadata like the RequestID. For example to retrieve the RequestID associated with a service response to assit AWS Support in troubleshooting a request:\nimport \"fmt\" import \"log\" import \"github.com/aws/aws-sdk-go-v2/aws/middleware\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ..  resp, err := client.GetObject(context.TODO(), \u0026s3.GetObjectInput{ // ... }) if err != nil { log.Printf(\"error: %v\", err) return } requestID, ok := middleware.GetRequestIDMetadata(resp.ResultMetadata) if !ok { fmt.Println(\"RequestID not included with request\") } fmt.Printf(\"RequestID: %s\\n\", requestID) Concurrently Using Service Clients You can create goroutines that concurrently use the same service client to send multiple requests. You can use a service client with as many goroutines as you want.\nIn the following example, an service client is used in multiple goroutines. This example concurrently uploads two objects to an Amazon S3 bucket.\nimport \"context\" import \"log\" import \"strings\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } client := s3.NewFromConfig(cfg) type result struct { Output *s3.PutObjectOutput Err error } results := make(chan result, 2) var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() output, err := client.PutObject(context.TODO(), \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"foo\"), Body: strings.NewReader(\"foo body content\"), }) results \u003c- result{Output: output, Err: err} }() go func() { defer wg.Done() output, err := client.PutObject(context.TODO(), \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"bar\"), Body: strings.NewReader(\"bar body content\"), }) results \u003c- result{Output: output, Err: err} }() wg.Wait() close(results) for result := range results { if result.Err != nil { log.Printf(\"error: %v\", result.Err) continue } fmt.Printf(\"etag: %v\", aws.ToString(result.Output.ETag)) } Using Operation Paginators Typically, when you retrieve a list of items, you might need to check the output struct for a token or marker to confirm whether the AWS service returned all results from your request. If the token or marker is present, you use it to request the next page of results. Instead of managing these tokens or markers, you can use the service package’s available paginator types.\nPaginator helpers are available for supported service operations, and can be found in the service client’s Go package. To construct a paginator for a supported operation, use the New\u003cOperationName\u003ePaginator function. Paginator construct functions take the service Client, the operation’s \u003cOperationName\u003eInput input parameters, and an optional set of functional arguments allowing you to configure other optional paginator settings.\nThe returned operation paginator type provides a convenient way to iterate over a paginated operation until you have reached the last page, or you have found the item(s) that your application was searching for. A paginator type has two methods: HasMorePages and NextPage. HasMorePages returns a boolean value of true if the first page has not been retrieved, or if additional pages available to retrieve using the operation. To retrieve the first or subsequent pages of the operation, the NextPage operation must be called. NextPage takes context.Context and returns the operation output and any corresponding error. Like the client operation method return parameters, the return error should always be checked before attempting to use the returned response structure. See Handling Operation Responses\nThe following example uses the ListObjectsV2 paginator to list up to three pages of object keys from the ListObjectV2operation. Each page consists of up to 10 keys, which is defined by the Limit paginator option.\nimport \"context\" import \"log\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } client := s3.NewFromConfig(cfg) params := \u0026s3.ListObjectsV2Input{ Bucket: aws.String(\"my-bucket\"), } paginator := s3.NewListObjectsV2Paginator(client, params, func(o *s3.ListObjectsV2PaginatorOptions) { o.Limit = 10 }) pageNum := 0 for paginator.HasMorePages() \u0026\u0026 pageNum \u003c 3 { output, err := paginator.NextPage(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } for _, value := range output.Contents { fmt.Println(*value.Key) } pageNum++ } Similar to client operation method, the client options like the request Region can be modified by providing one or more functional arguments to NextPage. For more information about overriding client options when calling an operation see Overriding Clients For Operation\nUsing Waiters When interacting with AWS APIs that are asynchronous, you often need to wait for a particular resource to become available in order to perform further actions on it.\nFor example, the Amazon DynamoDB CreateTable API returns immediately with a TableStatus of CREATING, and you can’t invoke read or write operations until the table status has been transitioned to ACTIVE.\nWriting logic to continuously poll the table status can be cumbersome and error-prone. The waiters help take the complexity out of it and are simple APIs that handle the polling task for you.\nFor example, you can use waiters to poll if a DynamoDB table is created and ready for a write operation.\nimport \"context\" import \"fmt\" import \"log\" import \"time\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/dynamodb\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } client := dynamodb.NewFromConfig(cfg) // we create a waiter instance by directly passing in a client // that satisfies the waiters client Interface. waiter := dynamodb.NewTableExistsWaiter(client) // params is the input to api operation used by the waiter params := \u0026dynamodb.DescribeTableInput { TableName: aws.String(\"test-table\") } // maxWaitTime is the maximum wait time, the waiter will wait for // the resource status. maxWaitTime := 5 * time.Minutes // Wait will poll until it gets the resource status, or max wait time // expires. err := waiter.Wait(context.TODO(), params, maxWaitTime) if err != nil { log.Printf(\"error: %v\", err) return } fmt.Println(\"Dynamodb table is now ready for write operations\") Overriding waiter configuration By default, the SDK uses the minimum delay and maximum delay value configured with optimal values defined by AWS services for different APIs. You can override waiter configuration by providing functional options during waiter construction, or when invoking a waiter operation.\nFor example, to override waiter configuration during waiter construction\nimport \"context\" import \"fmt\" import \"log\" import \"time\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/dynamodb\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } client := dynamodb.NewFromConfig(cfg) // we create a waiter instance by directly passing in a client // that satisfies the waiters client Interface. waiter := dynamodb.NewTableExistsWaiter(client, func (o *dynamodb.TableExistsWaiterOptions) { // override minimum delay to 10 seconds \to.MinDelay = 10 * time.Second // override maximum default delay to 300 seconds \to.MaxDelay = 300 * time.Second }) The Wait function on each waiter also takes in functional options.\nSimilar to the above example, you can override waiter configuration per Wait request.\n// params is the input to api operation used by the waiter params := \u0026dynamodb.DescribeTableInput { TableName: aws.String(\"test-table\") } // maxWaitTime is the maximum wait time, the waiter will wait for // the resource status. maxWaitTime := 5 * time.Minutes // Wait will poll until it gets the resource status, or max wait time // expires. err := waiter.Wait(context.TODO(), params, maxWaitTime, func (o *dynamodb.TableExistsWaiterOptions) { // override minimum delay to 5 seconds  o.MinDelay = 5 * time.Second // override maximum default delay to 120 seconds  o.MaxDelay = 120 * time.Second }) if err != nil { log.Printf(\"error: %v\", err) return } fmt.Println(\"Dynamodb table is now ready for write operations\") Advanced waiter configuration overrides You can additionally customize the waiter default behavior by providing a custom retryable function. The waiter-specific options also provides APIOptions to customize operation middlewares.\nFor example, to configure advanced waiter overrides.\nimport \"context\" import \"fmt\" import \"log\" import \"time\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/dynamodb\" import \"github.com/aws/aws-sdk-go-v2/service/dynamodb/types\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } client := dynamodb.NewFromConfig(cfg) // custom retryable defines if a waiter state is retryable or a terminal state. // For example purposes, we will configure the waiter to not wait // if table status is returned as `UPDATING` customRetryable := func(ctx context.Context, params *dynamodb.DescribeTableInput, output *dynamodb.DescribeTableOutput, err error) (bool, error) { if output.Table != nil { if output.Table.TableStatus == types.TableStatusUpdating { // if table status is `UPDATING`, no need to wait \treturn false, nil\t} } } // we create a waiter instance by directly passing in a client // that satisfies the waiters client Interface. waiter := dynamodb.NewTableExistsWaiter(client, func (o *dynamodb.TableExistsWaiterOptions) { // override the service defined waiter-behavior \to.Retryable = customRetryable }) ","categories":"","description":"Construct service clients and make operation calls to send requests to AWS services.","excerpt":"Construct service clients and make operation calls to send requests to …","ref":"/aws-sdk-go-v2/docs/making-requests/","tags":"","title":"Using the AWS SDK for Go V2 with AWS Services"},{"body":"The AWS SDK for Go V2 returns errors that satisfy the Go error interface type. You can use the Error() method to get a formatted string of the SDK error message without any special handling. Errors returned by the SDK may implement an Unwrap method. The Unwrap method is used by the SDK to provide additional contextual information to errors, while providing access to the underlying error or chain of errors. The Unwrap method should be used with the errors.As to handle unwrapping error chains.\nIt is important that your application check whether an error occurred after invoking a function or method that can return an error interface type. The most basic form of error handling looks similar to the following example:\nif err != nil { // Handle error \treturn } Logging Errors The simplest form of error handling is traditionally to log or print the error message before returning or exiting from the application. For example:\nimport \"log\" // ...  if err != nil { log.Printf(\"error: %s\", err.Error()) return } Service Client Errors The SDK wraps all errors returned by service clients with the smithy.OperationError error type. OperationError provides contextual information about the service name and operation that is associated with an underlying error. This information can be useful for applications that perform batches of operations to one or more services, with a centralized error handling mechanism. Your application can use errors.As to access this OperationError metadata.\nFor example:\nimport \"log\" import \"github.com/aws/smithy-go\" // ...  if err != nil { var oe *smithy.OperationError if errors.As(err, \u0026oe) { log.Printf(\"failed to call service: %s, operation: %s, error: %v\", oe.Service(), oe.Operation(), oe.Unwrap()) } return } API Error Responses Service operations can return modeled error types to indicate specific errors. These modeled types can be used with errors.As to unwrap and determine if the operation failure was due to a specific error. For example Amazon S3 CreateBucket can return a BucketAlreadyExists error if a bucket of the same name already exists.\nFor example, to check if an error was a BucketAlreadyExists error:\nimport \"log\" import \"github.com/aws/aws-sdk-go-v2/service/s3/types\" // ...  if err != nil { var bne *types.BucketAlreadyExists if errors.As(err, \u0026bne) { log.Println(\"error:\", bne) } return } All service API response errors implement the smithy.APIError interface type. This interface can be used to handle both modeled or un-modeled service error responses. This type provides access to the error code and message returned by the service. Additionally, this type provides indication of whether the fault of the error was due to the client or server if known. For example:\nimport \"log\" import \"github.com/aws/smithy-go\" // ...  if err != nil { var ae smithy.APIError if errors.As(err, \u0026ae) { log.Printf(\"code: %s, message: %s, fault: %s\", ae.ErrorCode(), ae.ErrorMessage(), ae.ErrorFault().String()) } return } Retrieving Request Identifiers When working with AWS Support, you may be asked to provide the request identifier that identifies the request you are attempting to troubleshoot. You can use http.ResponseError and use the ServiceRequestID() method to retrieve the request identifier associated with error response.\nFor example:\nimport \"log\" import awshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" // ...  if err != nil { var re *awshttp.ResponseError if errors.As(err, \u0026re) { log.Printf(\"requestID: %s, error: %v\", re.ServiceRequestID(), re.Unwrap()); } return } Amazon S3 Request Identifiers Amazon S3 requests contain additional identifiers that can be used to assist AWS Support with troubleshooting your request. You can use s3.ResponseError and call ServiceRequestID() and ServiceHostID() to retrieve the request ID and host ID.\nFor example:\nimport \"log\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  if err != nil { var re s3.ResponseError if errors.As(err, \u0026re) { log.Printf(\"requestID: %s, hostID: %s request failure\", re.ServiceRequestID(), re.ServiceHostID()); } return } ","categories":"","description":"Use the Error interface to handle errors from the AWS SDK for Go V2 or AWS service.","excerpt":"Use the Error interface to handle errors from the AWS SDK for Go V2 or …","ref":"/aws-sdk-go-v2/docs/handling-errors/","tags":"","title":"Handling Errors in the AWS SDK for Go V2"},{"body":"The AWS SDK for Go V2 includes the following utilities to help you more easily use AWS services. Find the SDK utilities in their related AWS service package.\n","categories":"","description":"Use the AWS SDK for Go V2 utilities to help use AWS services.","excerpt":"Use the AWS SDK for Go V2 utilities to help use AWS services.","ref":"/aws-sdk-go-v2/docs/sdk-utilities/","tags":"","title":"Using the AWS SDK for Go V2 Utilities"},{"body":" Modifying the client request pipeline can result in malformed/invalid requests, or can result in unexpected application errors. This functionality is meant for advanced uses cases not provided by the SDK interface by default.\n You can customize AWS SDK for Go V2 client requests by registering one or more middleware to a service operation’s stack. The stack is composed of a series of steps: Initialize, Serialize, Build, Finalize, and Deserialize. Each step contains zero or more middleware that operate on that step’s input and output types. The following diagram and table provide an overview of how an operation’s request and response traverses the stack.\n   Stack Step Description     Initialize Prepares the input, and sets any default parameters as needed.   Serialize Serializes the input to a protocol format suitable for the target transport layer.   Build Attach additional metadata to the serialized input, such as HTTP Content-Length.   Finalize Final message preparation, including retries and authentication (SigV4 signing).   Deserialize Deserialize responses from the protocol format into a structured type or error.    Each middleware within a given step must have a unique identifier, which is determined by the middleware’s ID method. Middleware identifiers ensure that only one instance of a given middleware is registered to a step, and allows other step middleware to be inserted relative to it.\nYou attach step middleware by using a step’s Insert or Add methods. You use Add to attach a middleware to the beginning of a step by specifying middleware.Before as the RelativePosition, and middleware.After to attach to the end of the step. You use Insert to attach a middleware to a step by inserting the middleware relative to another step middleware.\nYou must use the Add method to safely insert custom step middleware. Using Insert creates a dependency between your custom middleware, and the middleware that you are inserting relative to. The middleware within a stack step must be considered opaque to avoid breaking changes occurring to your application.\n Writing a Custom Middleware Each stack step has an interface that you must satisfy in order attach a middleware to a given step. You can use one of the provided \u003cStep\u003eMiddlewareFunc functions to quickly satisfy this interface. The following table outlines the steps, their interface, and the helper function that can be used to satisfy the interface.\n   Step Interface Helper Function     Initialize InitializeMiddleware InitializeMiddlewareFunc   Build BuildMiddleware BuildMiddlewareFunc   Serialize SerializeMiddleware SerializeMiddlewareFunc   Finalize FinalizeMiddleware FinalizeMiddlewareFunc   Deserialize DeserializeMiddleware DeserializeMiddlewareFunc    The following examples show how you can write a custom middleware to populate the Bucket member of the Amazon S3 GetObject API calls if one is not provided. This middleware will be referenced in proceeding examples to show how to attach step middleware to the stack.\nimport \"github.com/aws/smithy-go/aws\" import \"github.com/aws/smithy-go/middleware\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  var defaultBucket = middleware.InitializeMiddlewareFunc(\"DefaultBucket\", func( ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler, ) ( out middleware.InitializeOutput, metadata middleware.Metadata, err error, ) { // Type switch to check if the input is s3.GetObjectInput, if so and the bucket is not set, populate it with \t// our default. \tswitch v := in.Parameters.(type) { case *s3.GetObjectInput: if v.Bucket == nil { v.Bucket = aws.String(\"my-default-bucket\") } } // Middleware must call the next middleware to be executed in order to continue execution of the stack. \t// If an error occurs, you can return to prevent further execution. \treturn next.HandleInitialize(ctx, in) }) Attaching Middleware to All Clients You can attach your custom step middleware to every client by adding the middleware using the APIOptions member of the aws.Config type. The following examples attaches the defaultBucket middleware to every client constructed using your applications aws.Config object:\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/smithy-go/middleware\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { // handle error } cfg.APIOptions = append(cfg.APIOptions, func(stack *middleware.Stack) error { // Attach the custom middleware to the beginning of the Initialize step \treturn stack.Initialize.Add(defaultBucket, middleware.Before) }) client := s3.NewFromConfig(cfg) Attaching Middleware to a Specific Operation You can attach your custom step middleware to a specific client operation by modifying the client’s APIOptions member using the variadic argument list for an operation. The following examples attaches the defaultBucket middleware to a specific Amazon S3 GetObject operation invocation:\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/smithy-go/middleware\" // ...  // registerDefaultBucketMiddleware registers the defaultBucket middleware with the provided stack. func registerDefaultBucketMiddleware(stack *middleware.Stack) error { // Attach the custom middleware to the beginning of the Initialize step \treturn stack.Initialize.Add(defaultBucket, middleware.Before) } // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { // handle error } client := s3.NewFromConfig(cfg) object, err := client.GetObject(context.TODO(), \u0026s3.GetObjectInput{ Key: aws.String(\"my-key\"), }, func(options *s3.Options) { // Register the defaultBucketMiddleware for this operation only \toptions.APIOptions = append(options.APIOptions, registerDefaultBucketMiddleware) }) Passing Metadata Down the Stack In certain situations, you may find that you require two or more middleware to function in tandem by sharing information or state. You can use context.Context to pass this metadata by using middleware.WithStackValue. middleware.WithStackValue attaches the given key-value pair to the provided context, and safely limits the scope to the currently executing stack. These stack-scoped values can be retrieved from a context using middleware.GetStackValue and providing the key used to stored the corresponding value. Keys must be comparable, and you must define your own types as context keys to avoid collisions. The following examples shows how two middleware can use context.Context to pass information down the stack.\nimport \"context\" import \"github.com/aws/smithy-go/middleware\" // ...  type customKey struct {} func GetCustomKey(ctx context.Context) (v string) { v, _ = middleware.GetStackValue(ctx, customKey{}).(string) return v } func SetCustomKey(ctx context.Context, value string) context.Context { return middleware.WithStackValue(ctx, customkey{}, value) } // ...  var customInitalize = middleware.InitializeMiddlewareFunc(\"customInitialize\", func( ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler, ) ( out middleware.InitializeOutput, metadata middleware.Metadata, err error, ) { ctx = SetCustomKey(ctx, \"my-custom-value\") return next.HandleInitialize(ctx, in) }) var customBuild = middleware.BuildMiddlewareFunc(\"customBuild\", func( ctx context.Context, in middleware.BuildInput, next middleware.BuildHandler, ) ( out middleware.BuildOutput, metadata Metadata, err error, ) { customValue := GetCustomKey(ctx) // use customValue  return next.HandleBuild(ctx, in) }) Metadata Provided by the SDK The AWS SDK for Go V2 provides several metadata values that can be retrieved from the provided context. These values can be used to enable more dynamic middleware that modifies its behavior based on the executing service, operation, or target region. A few of the available keys are provided in the table below:\n   Key Retriever Description     ServiceID GetServiceID Retrieve the service identifier for the executing stack. This can be compared to the service client package’s ServiceID constant.   OperationName GetOperationName Retrieve the operation name for the executing stack.   Logger GetLogger Retrieve the logger that can be used for logging message from the middleware.    Passing Metadata Up the Stack You can pass metadata up through the stack by adding metadata key and value pairs using the middleware.Metadata. Each middleware step returns an output structure, metadata, and an error. Your custom middleware must return the metadata received from calling the next handler in the step. This ensures that metadata added by downstream middleware propagates to the application invoking the service operation. The resulting metadata is accessible to the invoking application by either the operation’s output shape via the ResultMetadata structure member.\nThe following examples shows how a custom middleware can add metadata that is returned as part of the operation output.\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/smithy-go/middleware\" // ...  type customKey struct{} func GetCustomKey(metadata middleware.Metadata) (v string) { v, _ = metadata.Get(customKey{}).(string) return v } func SetCustomKey(metadata *middleware.Metadata, value string) { metadata.Set(customKey{}, value) } // ...  var customInitalize = middleware.InitializeMiddlewareFunc(\"customInitialize\", func ( ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler, ) ( out middleware.InitializeOutput, metadata middleware.Metadata, err error, ) { out, metadata, err = next.HandleInitialize(ctx, in) if err != nil { return out, metadata, err } SetCustomKey(\u0026metadata, \"my-custom-value\") return out, metadata, nil }) // ...  client := s3.NewFromConfig(cfg, func (options *s3.Options) { options.APIOptions = append(options.APIOptions, func(stack *middleware.Stack) error { return stack.Initialize.Add(customInitalize, middleware.After) }) }) out, err := client.GetObject(context.TODO(), \u0026s3.GetObjectInput{ // input parameters }) if err != nil { // handle error } customValue := GetCustomKey(out.ResponseMetadata) ","categories":"","description":"How to use stack step middleware to customize AWS SDK for Go V2 client requests.","excerpt":"How to use stack step middleware to customize AWS SDK for Go V2 client …","ref":"/aws-sdk-go-v2/docs/middleware/","tags":"","title":"Customizing the AWS SDK for Go V2 Client Requests"},{"body":"When using the SDK in your application, you’ll want to mock out the SDK for your application’s unit test. Mocking out the SDK allows your test to be focused on what you want to test, not the internals of the SDK.\nTo support mocking use Go interfaces instead of concrete service client, paginators, and waiter types, (e.g. s3.Client). This allows your application to use patterns like dependency injection to test your application logic.\nMocking Client Operations In this example, S3GetObjectAPI is an interface that defines the set of Amazon S3 API operations required by the GetObjectFromS3 function. S3GetObjectAPI is satisfied by the Amazon S3 client’s GetObject method.\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  type S3GetObjectAPI interface { GetObject(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error) } func GetObjectFromS3(ctx context.Context, api S3GetObjectAPI, bucket, key string) ([]byte, error) { object, err := api.GetObject(ctx, \u0026s3.GetObjectInput{ Bucket: \u0026bucket, Key: \u0026key, }) if err != nil { return nil, err } defer object.Body.Close() return ioutil.ReadAll(object.Body) } To test the GetObjectFromS3 function, use the mockGetObjectAPI to satisfy the S3GetObjectAPI interface definition. Then use the mockGetObjectAPI type to mock output and error responses returned from the service client.\nimport \"testing\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  type mockGetObjectAPI func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error) func (m mockGetObjectAPI) GetObject(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error) { return m(ctx, params, optFns...) } func TestGetObjectFromS3(t *testing.T) { cases := []struct { client func(t *testing.T) S3GetObjectAPI bucket string key\tstring expect []byte }{ { client: func(t *testing.T) S3GetObjectAPI { return mockGetObjectAPI(func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error) { t.Helper() if params.Bucket == nil { t.Fatal(\"expect bucket to not be nil\") } if e, a := \"fooBucket\", *params.Bucket; e != a { t.Errorf(\"expect %v, got %v\", e, a) } if params.Key == nil { t.Fatal(\"expect key to not be nil\") } if e, a := \"barKey\", *params.Key; e != a { t.Errorf(\"expect %v, got %v\", e, a) } return \u0026s3.GetObjectOutput{ Body: ioutil.NopCloser(bytes.NewReader([]byte(\"this is the body foo bar baz\"))), }, nil }) }, bucket: \"fooBucket\", key:\t\"barKey\", expect: []byte(\"this is the body foo bar baz\"), }, } for i, tt := range cases { t.Run(strconv.Itoa(i), func(t *testing.T) { ctx := context.TODO() content, err := GetObjectFromS3(ctx, tt.client(t), tt.bucket, tt.key) if err != nil { t.Fatalf(\"expect no error, got %v\", err) } if e, a := tt.expect, content; bytes.Compare(e, a) != 0 { t.Errorf(\"expect %v, got %v\", e, a) } }) } } Mocking Paginators Similar to service clients, paginators can be mocked by defining a Go interface for the paginator. That interface would be used by your application’s code. This allows the SDK’s implementation to be used when your application is running, and a mocked implementation for testing.\nIn the following example, ListObjectsV2Pager is an interface that defines the behaviors for the Amazon S3 ListObjectsV2Paginator. required by CountObjects function.\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  type ListObjectsV2Pager interface { HasMorePages() bool NextPage(context.Context, ...func(*s3.Options)) (*s3.ListObjectsV2Output, error) } func CountObjects(ctx context.Context, pager ListObjectsV2Pager) (count int, err error) { for pager.HasMorePages() { var output *s3.ListObjectsV2Output output, err = pager.NextPage(ctx) if err != nil { return count, err } count += int(output.KeyCount) } return count, nil } To test CountObjects, create the mockListObjectsV2Pager type to satisfy the ListObjectsV2Pager interface definition. Then use mockListObjectsV2Pager to replicate the paging behavior of output and error responses from the service operation paginator.\nimport \"context\" import\t\"fmt\" import \"testing\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  type mockListObjectsV2Pager struct { PageNum int Pages []*s3.ListObjectsV2Output } func (m *mockListObjectsV2Pager) HasMorePages() bool { return m.PageNum \u003c len(m.Pages) } func (m *mockListObjectsV2Pager) NextPage(ctx context.Context, f ...func(*s3.Options)) (output *s3.ListObjectsV2Output, err error) { if m.PageNum \u003e= len(m.Pages) { return nil, fmt.Errorf(\"no more pages\") } output = m.Pages[m.PageNum] m.PageNum++ return output, nil } func TestCountObjects(t *testing.T) { pager := \u0026mockListObjectsV2Pager{ Pages: []*s3.ListObjectsV2Output{ { KeyCount: 5, }, { KeyCount: 10, }, { KeyCount: 15, }, }, } objects, err := CountObjects(context.TODO(), pager) if err != nil { t.Fatalf(\"expect no error, got %v\", err) } if expect, actual := 30, objects; expect != actual { t.Errorf(\"expect %v, got %v\", expect, actual) } } ","categories":"","description":"How to mock the AWS SDK for Go V2 when unit testing your application.","excerpt":"How to mock the AWS SDK for Go V2 when unit testing your application.","ref":"/aws-sdk-go-v2/docs/unit-testing/","tags":"","title":"Unit Testing with the AWS SDK for Go V2"},{"body":"You can use AWS Cloud9 with the AWS SDK for Go V2 to write and run your Go code using just a browser. AWS Cloud9 includes tools such as a code editor and terminal. The AWS Cloud9 IDE is cloud based, so you can work on your projects from your office, home, or anywhere using an internet-connected machine. For general information about AWS Cloud9, see the AWS Cloud9 User Guide.\nFollow the instructions below to set up AWS Cloud9 with the AWS SDK for Go V2:\nSet up Your AWS Account to Use AWS Cloud9 To start using AWS Cloud9, sign in to the AWS Cloud9 console as an AWS Identity and Access Management (IAM) entity (for example, an IAM user) in your AWS account which has access permissions for AWS Cloud9.\nReview Team Setup for AWS Cloud9 in the AWS Cloud9 User Guide, for help with setting up an IAM entity in your AWS account to access AWS Cloud9, and to sign in to the AWS Cloud9 console.\nSet up Your AWS Cloud9 Development Environment After you sign in to the AWS Cloud9 console, use the console to create an AWS Cloud9 development environment. After you create the environment, AWS Cloud9 opens the IDE for that environment.\nSee Creating an Environment in AWS Cloud9 in the AWS Cloud9 User Guide for details.\nAs you create your environment in the console for the first time, we recommend that you choose the option to Create a new instance for environment (EC2). This option tells AWS Cloud9 to create an environment, launch an Amazon EC2 instance, and then connect the new instance to the new environment. This is the fastest way to begin using AWS Cloud9.\n Set up the AWS SDK for Go V2 After AWS Cloud9 opens the IDE for your development environment, use the IDE to set up the AWS SDK for Go V2 in your environment, as follows.\n  If the terminal isn’t already open in the IDE, open it. On the menu bar in the IDE, choose Window, New Terminal.\n  Validate the AWS Cloud9 available Go version.\ngo version If the Go version reports a version less than 1.15, or the IDE can’t find the Go binary follow the guide to Install/Upgrade Go.\n  Follow the Getting Started guide to set up a Go project under ~/environment, or follow the steps to Download Example Code\n  Download Example Code Use the terminal you opened in the previous step to download example code for the AWS SDK for Go V2 into the AWS Cloud9 development environment.\nTo do this, run the following command. This command downloads a copy of all the code examples used in the official AWS SDK documentation into your environment’s root directory.\ngit clone https://github.com/awsdocs/aws-doc-sdk-examples.git To find code examples for the AWS SDK for Go V2, use the Environment window to open the ENVIRONMENT_NAME/aws-doc-sdk-examples/gov2 directory, where ENVIRONMENT_NAME is the name of your development environment.\nRun Example Code To run code in your AWS Cloud9 development environment, see Run Your Code in the AWS Cloud9 User Guide.\nInstalling/Upgrading AWS Cloud9 Go Version If the IDE can’t find Go or version of Go doesn’t meet the minimum require version, run the following commands, one at a time in this order, to install it. (These commands assume you chose the option to Create a new instance for environment (EC2), earlier in this topic. Also, these commands assume the latest stable version of Go at the time this topic was written; for more information, see Downloads on The Go Programming Language website.)\nwget https://golang.org/dl/go1.15.5.linux-amd64.tar.gz # Download the Go installer. sudo tar -C /usr/local -xzf ./go1.15.5.linux-amd64.tar.gz # Install Go. rm ./go1.15.5.linux-amd64.tar.gz # Delete the Go installer, as you no longer need it. After you install Go, add the path to the Go binary to your PATH environment variable. To do this, add the following code to the end of your shell profile file (for example, ~/.bashrc in Amazon Linux, assuming you chose the option to Create a new instance for environment (EC2), earlier in this topic), and then save the file.\n PATH=$PATH:/usr/local/go/bin After you save the file, source the ~/.bashrc file so that the terminal can now find the Go binary you just referenced. To do this, run the following command. (This command assumes you chose the option to Create a new instance for environment (EC2), earlier in this topic.)\n. ~/.bashrc ","categories":"","description":"","excerpt":"You can use AWS Cloud9 with the AWS SDK for Go V2 to write and run …","ref":"/aws-sdk-go-v2/docs/cloud9-go/","tags":"","title":"Using AWS Cloud9 with the AWS SDK for Go V2"},{"body":"Cloud security at Amazon Web Services (AWS) is the highest priority. As an AWS customer, you benefit from a data center and network architecture that is built to meet the requirements of the most security-sensitive organizations. Security is a shared responsibility between AWS and you. The Shared Responsibility Model describes this as Security of the Cloud and Security in the Cloud.\nSecurity of the Cloud– AWS is responsible for protecting the infrastructure that runs all of the services offered in the AWS Cloud and providing you with services that you can use securely. Our security responsibility is the highest priority at AWS, and the effectiveness of our security is regularly tested and verified by third-party auditors as part of the AWS Compliance Programs.\nSecurity in the Cloud– Your responsibility is determined by the AWS service you are using, and other factors including the sensitivity of your data, your organization’s requirements, and applicable laws and regulations.\n","categories":"","description":"","excerpt":"Cloud security at Amazon Web Services (AWS) is the highest priority. …","ref":"/aws-sdk-go-v2/docs/security/","tags":"","title":"Security for this AWS Product or Service"},{"body":"The AWS SDK for Go V2 examples can help you write your own Go applications that use Amazon Web Services. The examples assume you have already set up and configured the SDK (that is, you have imported all required packages and set your credentials and region). For more information, see Getting Started and Configuring the SDK.\nFind the source code for these examples and others in the AWS documentation code examples repository on GitHub. To propose a new code example for the AWS documentation team to consider producing, create a new request. The team is looking to produce code examples that cover broader scenarios and use cases, versus simple code snippets that cover only individual API calls. For instructions, see the Proposing new code examples section in the Readme on GitHub.\n","categories":"","description":"","excerpt":"The AWS SDK for Go V2 examples can help you write your own Go …","ref":"/aws-sdk-go-v2/docs/code-examples/","tags":"","title":"Code Examples"},{"body":"IAM Authentication The auth package provides utilities for generating authentication tokens for connecting to Amazon RDS MySQL and PostgreSQL database instances. Using the BuildAuthToken method, you generate a database authorization token by providing the database endpoint, AWS Region, username, and a aws.CredentialProvider implantation that returns IAM credentials with permission connect to the database using IAM database authentication. To learn more about configuring Amazon RDS with IAM authentication see the following Amazon RDS Developer Guide resources:\n Enabling and disabling IAM database authentication Creating and using an IAM policy for IAM database access Creating a database account using IAM authentication  The following examples shows how to generate an authentication token to connect to an Amazon RDS database:\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/feature/rds/auth\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error: \" + err.Error()) } authenticationToken, err := auth.BuildAuthToken( context.TODO(), \"mydb.123456789012.us-east-1.rds.amazonaws.com:3306\", // Database Endpoint (With Port) \t\"us-east-1\", // AWS Region \t\"jane_doe\", // Database Account \tcfg.Credentials, ) if err != nil { panic(\"failed to create authentication token: \" + err.Error()) } ","categories":"","description":"Using the AWS SDK for Go V2 Amazon RDS Utilities","excerpt":"Using the AWS SDK for Go V2 Amazon RDS Utilities","ref":"/aws-sdk-go-v2/docs/sdk-utilities/rds/","tags":"","title":"Amazon RDS Utilities"},{"body":"Amazon CloudFront URL Signer The Amazon CloudFront URL signer simplifies the process of creating signed URLs. A signed URL includes information, such as an expiration date and time, that enables you to control access to your content. Signed URLs are useful when you want to distribute content through the internet, but want to restrict access to certain users (for example, to users who have paid a fee).\nTo sign a URL, create a URLSigner instance with your CloudFront key pair ID and the associated private key. Then call the Sign or SignWithPolicy method and include the URL to sign. For more information about Amazon CloudFront key pairs, see Creating CloudFront Key Pairs for Your Trusted Signers in the CloudFront Developer Guide.\nThe following example creates a signed URL that’s valid for one hour after it is created.\nimport \"github.com/aws/aws-sdk-go-v2/feature/cloudfront/sign\" // ...  signer := sign.NewURLSigner(keyID, privKey) signedURL, err := signer.Sign(rawURL, time.Now().Add(1*time.Hour)) if err != nil { log.Fatalf(\"Failed to sign url, err: %s\\n\", err.Error()) return } For more information about the signing utility, see the sign package in the AWS SDK for Go V2 API Reference.\n","categories":"","description":"Using the AWS SDK for Go V2 Amazon CloudFront Utilities","excerpt":"Using the AWS SDK for Go V2 Amazon CloudFront Utilities","ref":"/aws-sdk-go-v2/docs/sdk-utilities/cloudfront/","tags":"","title":"Amazon CloudFront Utilities"},{"body":"This AWS product or service follows the shared responsibility model through the specific Amazon Web Services (AWS) services it supports. For AWS service security information, see the AWS service security documentation page and AWS services that are in scope of AWS compliance efforts by compliance program.\nThe security and compliance of Amazon Web Services (AWS) services is assessed by third-party auditors as part of multiple AWS compliance programs. These include SOC, PCI, FedRAMP, HIPAA, and others. AWS provides a frequently updated list of AWS services in scope of specific compliance programs at AWS Services in Scope by Compliance Program.\nThird-party audit reports are available for you to download using AWS Artifact. For more information, see Downloading Reports in AWS Artifact.\nFor more information about AWS compliance programs, see AWS Compliance Programs.\nYour compliance responsibility when using this AWS product or service to access an AWS service is determined by the sensitivity of your data, your organization’s compliance objectives, and applicable laws and regulations. If your use of an AWS service is subject to compliance with standards such as HIPAA, PCI, or FedRAMP, AWS provides resources to help:\n Security and Compliance Quick Start Guides – Deployment guides that discuss architectural considerations and provide steps for deploying security-focused and compliance-focused baseline environments on AWS. Architecting for HIPAA Security and Compliance Whitepaper – A whitepaper that describes how companies can use AWS to create HIPAA-compliant applications. AWS Compliance Resources – A collection of workbooks and guides that might apply to your industry and location. AWS Config – A service that assesses how well your resource configurations comply with internal practices, industry guidelines, and regulations. AWS Security Hub – A comprehensive view of your security state within AWS that helps you check your compliance with security industry standards and best practices.  ","categories":"","description":"","excerpt":"This AWS product or service follows the shared responsibility model …","ref":"/aws-sdk-go-v2/docs/security/compliance-validation/","tags":"","title":"Compliance Validation for this AWS Product or Service"},{"body":"The AWS SDK for Go V2 provides the ability to configure a custom endpoint to be used for a service. In most cases you use a pre-configured endpoint for a service. Configuring custom endpoints, lets you do more, such as working with pre-release versions of a service.\nA EndpointResolver can be configured to provide custom endpoint resolution logic for service clients. You can use a custom endpoint resolver to override a service’s endpoint resolution logic for all endpoints, or a just specific regional endpoint. Custom endpoint resolver can trigger the service’s endpoint resolution logic to fallback if a custom resolver does not wish to resolve a requested endpoint. EndpointResolverWithOptionsFunc can be used to easily wrap functions to satisfy the EndpointResolverWithOptions interface.\nA EndpointResolver can be easily configured by passing the resolver wrapped with WithEndpointResolverWithOptions to LoadDefaultConfig, allowing for the ability to override endpoints when loading credentials, as well as configuring the resulting aws.Config with your custom endpoint resolver.\nThe endpoint resolver is given the service and region as a string, allowing for the resolver to dynamically drive its behavior. Each service client package has an exported ServiceID constant which can be used to determine which service client is invoking your endpoint resolver.\nAn endpoint resolver can use the EndpointNotFoundError sentinel error value to trigger fallback resolution to the service clients default resolution logic. This allows you to selectively override one or more endpoints seamlessly without having to handle fallback logic.\nIf your endpoint resolver implementation returns an error other than EndpointNotFoundError, endpoint resolution will stop and the service operation returns an error to your application.\nExamples Overriding Endpoint with Fallback The following code snippet shows how a single service endpoint can be overridden for DynamoDB with fallback behavior for other endpoints:\ncustomResolver := aws.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (aws.Endpoint, error) { if service == dynamodb.ServiceID \u0026\u0026 region == \"us-west-2\" { return aws.Endpoint{ PartitionID: \"aws\", URL: \"https://test.us-west-2.amazonaws.com\", SigningRegion: \"us-west-2\", }, nil } // returning EndpointNotFoundError will allow the service to fallback to it's default resolution  return aws.Endpoint{}, \u0026aws.EndpointNotFoundError{} }) cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithEndpointResolverWithOptions(customResolver)) Overriding Endpoint Without Fallback The following code snippet shows how a single service endpoint can be overridden for DynamoDB without fallback behavior for other endpoints:\ncustomResolver := aws.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (aws.Endpoint, error) { if service == dynamodb.ServiceID \u0026\u0026 region == \"us-west-2\" { return aws.Endpoint{ PartitionID: \"aws\", URL: \"https://test.us-west-2.amazonaws.com\", SigningRegion: \"us-west-2\", }, nil } return aws.Endpoint{}, fmt.Errorf(\"unknown endpoint requested\") }) cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithEndpointResolverWithOptions(customResolver)) Immutable Endpoints Setting an endpoint as immutable may prevent some service client features from functioning correctly, and could result in undefined behavior. Caution should be taken when defining an endpoint as immutable.\n Some service clients, such as Amazon S3, may modify the endpoint returned by the resolver for certain service operations. For example, the Amazon S3 will automatically handle Virtual Bucket Addressing by mutating the resolved endpoint. You can prevent the SDK from mutating your custom endpoints by setting HostnameImmutable totrue. For example:\ncustomResolver := aws.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (aws.Endpoint, error) { if service == dynamodb.ServiceID \u0026\u0026 region == \"us-west-2\" { return aws.Endpoint{ PartitionID: \"aws\", URL: \"https://test.us-west-2.amazonaws.com\", SigningRegion: \"us-west-2\", HostnameImmutable: true, }, nil } return aws.Endpoint{}, fmt.Errorf(\"unknown endpoint requested\") }) cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithEndpointResolverWithOptions(customResolver)) ","categories":"","description":"Customizing service client endpoints.","excerpt":"Customizing service client endpoints.","ref":"/aws-sdk-go-v2/docs/configuring-sdk/endpoints/","tags":"","title":"Configuring Client Endpoints"},{"body":"The AWS SDK for Go V2 uses a default HTTP client with default configuration values. Although you can change some of these configuration values, the default HTTP client and transport are not sufficiently configured for customers using the AWS SDK for Go V2 in an environment with high throughput and low latency requirements. This section describes how to configure a custom HTTP client, and use that client to create AWS SDK for Go V2 calls.\nTo assist you in creating a custom HTTP client, this section describes how to the NewBuildableClient to configure custom settings, and use that client with an AWS SDK for Go V2 service client.\nLet’s define what we want to customize.\nOverriding During Configuration Loading Custom HTTP clients can be provided when calling LoadDefaultConfig by wrapping the client using WithHTTPClient and passing the resulting value to LoadDefaultConfig. For example to pass customClient as our client:\ncfg, err := config.LoadDefaultConfig(context.TODO(), config.WithHTTPClient(customClient)) Timeout The BuildableHTTPClient can be configured with a request timeout limit. This timeout includes the time to connect, process any redirects, and read the complete response body. For example to modify the client timeout:\nimport \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" // ...  httpClient := http.NewBuildableClient().WithTimeout(time.Second*5) Dialer The BuildableHTTPClient provides a builder mechanics for constructing clients with modified Dialer options. The following example shows how to configure a clients Dialer settings.\nimport awshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" import \"net\" // ...  httpClient := awshttp.NewBuildableClient().WithDialerOptions(func(d *net.Dialer) { d.KeepAlive = -1 d.Timeout = time.Millisecond*500 }) Settings Dialer.KeepAlive This setting represents the keep-alive period for an active network connection.\nSet to a negative value to disable keep-alives.\nSet to 0 to enable keep-alives if supported by the protocol and operating system.\nNetwork protocols or operating systems that do not support keep-alives ignore this field. By default, TCP enables keep alive.\nSee https://golang.org/pkg/net/#Dialer.KeepAlive\nSet KeepAlive as time.Duration.\nDialer.Timeout This setting represents the maximum amount of time a dial waits for a connection to be created.\nDefault is 30 seconds.\nSee https://golang.org/pkg/net/#Dialer.Timeout\nSet Timeout as time.Duration.\nTransport The BuildableHTTPClient provides a builder mechanics for constructing clients with modified Transport options.\nConfiguring a Proxy If you cannot directly connect to the internet, you can use Go-supported environment variables (HTTP_PROXY / HTTPS_PROXY) or create a custom HTTP client to configure your proxy. The following example configures the client to use PROXY_URL as the proxy endpoint:\nimport awshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" import \"net/http\" // ...  httpClient := awshttp.NewBuildableClient().WithTransportOptions(func(tr *http.Transport) { proxyURL, err := url.Parse(\"PROXY_URL\") if err != nil { log.Fatal(err) } tr.Proxy = http.ProxyURL(proxyURL) }) Other Settings Below are a few other Transport settings that can be modified to tune the HTTP client. Any additional settings not described here can be found in the Transport type documentation. These settings can be applied as shown in the following example:\nimport awshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" import \"net/http\" // ...  httpClient := awshttp.NewBuildableClient().WithTransportOptions(func(tr *http.Transport) { tr.ExpectContinueTimeout = 0 tr.MaxIdleConns = 10 }) Transport.ExpectContinueTimeout If the request has an “Expect: 100-continue” header, this setting represents the maximum amount of time to wait for a server’s first response headers after fully writing the request headers, This time does not include the time to send the request header. The HTTP client sends its payload after this timeout is exhausted.\nDefault 1 second.\nSet to 0 for no timeout and send request payload without waiting. One use case is when you run into issues with proxies or third party services that take a session similar to the use of Amazon S3 in the function shown later.\nSee https://golang.org/pkg/net/http/#Transport.ExpectContinueTimeout\nSet ExpectContinue as time.Duration.\nTransport.IdleConnTimeout This setting represents the maximum amount of time to keep an idle network connection alive between HTTP requests.\nSet to 0 for no limit.\nSee https://golang.org/pkg/net/http/#Transport.IdleConnTimeout\nSet IdleConnTimeout as time.Duration.\nTransport.MaxIdleConns This setting represents the maximum number of idle (keep-alive) connections across all hosts. One use case for increasing this value is when you are seeing many connections in a short period from the same clients\n0 means no limit.\nSee https://golang.org/pkg/net/http/#Transport.MaxIdleConns\nSetMaxIdleConns as int.\nTransport.MaxIdleConnsPerHost This setting represents the maximum number of idle (keep-alive) connections to keep per-host. One use case for increasing this value is when you are seeing many connections in a short period from the same clients\nDefault is two idle connections per host.\nSet to 0 to use DefaultMaxIdleConnsPerHost (2).\nSee https://golang.org/pkg/net/http/#Transport.MaxIdleConnsPerHost\nSet MaxIdleConnsPerHost as int.\nTransport.ResponseHeaderTimeout This setting represents the maximum amount of time to wait for a client to read the response header.\nIf the client isn’t able to read the response’s header within this duration, the request fails with a timeout error.\nBe careful setting this value when using long-running Lambda functions, as the operation does not return any response headers until the Lambda function has finished or timed out. However, you can still use this option with the ** InvokeAsync** API operation.\nDefault is no timeout; wait forever.\nSee https://golang.org/pkg/net/http/#Transport.ResponseHeaderTimeout\nSet ResponseHeaderTimeout as time.Duration.\nTransport.TLSHandshakeTimeout This setting represents the maximum amount of time waiting for a TLS handshake to be completed.\nDefault is 10 seconds.\nZero means no timeout.\nSee https://golang.org/pkg/net/http/#Transport.TLSHandshakeTimeout\nSet TLSHandshakeTimeout as time.Duration.\n","categories":"","description":"Create a custom HTTP client with the AWS SDK for Go V2 to specify custom timeout values.","excerpt":"Create a custom HTTP client with the AWS SDK for Go V2 to specify …","ref":"/aws-sdk-go-v2/docs/configuring-sdk/custom-http/","tags":"","title":"Customizing the HTTP Client"},{"body":"AWS Identity and Access Management (IAM) is an Amazon Web Services (AWS) service that helps an administrator securely control access to AWS resources. IAM administrators control who can be authenticated (signed in) and authorized (have permissions) to use resources AWS services. IAM is an AWS service that you can use with no additional charge.\nTo use this AWS product or service to access AWS, you need an AWS account and AWS credentials. To increase the security of your AWS account, we recommend that you use an IAM user to provide access credentials instead of using your AWS account credentials.\nFor details about working with IAM, see IAM.\nFor an overview of IAM users and why they are important for the security of your account, see AWS Security Credentials in the Amazon Web Services General Reference.\nThis AWS product or service follows the shared responsibility model through the specific Amazon Web Services (AWS) services it supports. For AWS service security information, see the AWS service security documentation page and AWS services that are in scope of AWS compliance efforts by compliance program.\n","categories":"","description":"","excerpt":"AWS Identity and Access Management (IAM) is an Amazon Web Services …","ref":"/aws-sdk-go-v2/docs/security/iam/","tags":"","title":"Identity and Access Management for this AWS Product or Service"},{"body":"This AWS product or service follows the shared responsibility model through the specific Amazon Web Services (AWS) services it supports. For AWS service security information, see the AWS service security documentation page and AWS services that are in scope of AWS compliance efforts by compliance program .\nFor information about AWS security processes, see the AWS: Overview of Security Processes whitepaper.\n","categories":"","description":"","excerpt":"This AWS product or service follows the shared responsibility model …","ref":"/aws-sdk-go-v2/docs/security/infrastructure-security/","tags":"","title":"Infrastructure Security for this AWS Product or Service"},{"body":"The AWS SDK for Go V2 has logging facilities available that allow your application to enable debugging information for debugging and diagnosing request issues or failures. The Logger interface and ClientLogMode are the main components available to you for determining how and what should be logged by clients.\nLogger When constructing an Config using LoadDefaultConfig a default Logger is configured to send log messages to the process' standard error (stderr). A custom logger that satisfies the Logger interface can be passed as an argument to LoadDefaultConfig by wrapping it with config.WithLogger.\nFor example to configure our clients to use our applicationLogger:\ncfg, err := config.LoadDefaultConfig(context.TODO(), config.WithLogger(applicationLogger)) Now clients configured using the constructed aws.Config will send log messages to applicationLogger.\nContext-Aware Loggers A Logger implementation may implement the optional ContextLogger interface. Loggers that implement this interface will have their WithContext methods invoked with the current context. This allows your logging implementations to return a new Logger that can write additional logging metadata based on values present in the context.\nClientLogMode By default, service clients do not produce log messages. To configure clients to send log messages for debugging purposes, use the ClientLogMode member on Config. ClientLogMode can be set to enable debugging messaging for:\n Signature Version 4 (SigV4) Signing Request Retries HTTP Requests HTTP Responses  For example to enable logging of HTTP requests and retries:\ncfg, err := config.LoadDefaultConfig(context.TODO(), config.WithClientLogMode(aws.LogRetries | aws.LogRequest)) See ClientLogMode for the different client log modes available.\n","categories":"","description":"Using Logging facilities for debugging SDK requests.","excerpt":"Using Logging facilities for debugging SDK requests.","ref":"/aws-sdk-go-v2/docs/configuring-sdk/logging/","tags":"","title":"Logging"},{"body":"The Amazon Web Services (AWS) global infrastructure is built around AWS Regions and Availability Zones.\nAWS Regions provide multiple physically separated and isolated Availability Zones, which are connected with low-latency, high-throughput, and highly redundant networking.\nWith Availability Zones, you can design and operate applications and databases that automatically fail over between Availability Zones without interruption. Availability Zones are more highly available, fault tolerant, and scalable than traditional single or multiple data center infrastructures.\nFor more information about AWS Regions and Availability Zones, see AWS Global Infrastructure.\nThis AWS product or service follows the shared responsibility model through the specific Amazon Web Services (AWS) services it supports. For AWS service security information, see the AWS service security documentation page and AWS services that are in scope of AWS compliance efforts by compliance program.\n","categories":"","description":"","excerpt":"The Amazon Web Services (AWS) global infrastructure is built around …","ref":"/aws-sdk-go-v2/docs/security/disaster-recovery-resiliency/","tags":"","title":"Resilience for this AWS Product or Service"},{"body":"The shared responsibility model applies to data protection in this AWS product or service. As described in this model, AWS is responsible for protecting the global infrastructure that runs all of the AWS Cloud. You are responsible for maintaining control over your content that is hosted on this infrastructure. This content includes the security configuration and management tasks for the AWS services that you use. For more information about data privacy, see the Data Privacy FAQ. For information about data protection in Europe, see the AWS Shared Responsibility Model and GDPR blog post on the AWS Security Blog.\nFor data protection purposes, we recommend that you protect AWS account credentials and set up individual user accounts with AWS Identity and Access Management (IAM). That way each user is given only the permissions necessary to fulfill their job duties. We also recommend that you secure your data in the following ways:\n Use multi-factor authentication (MFA) with each account. Use SSL/TLS to communicate with AWS resources. We recommend TLS 1.2 or later. Set up API and user activity logging with AWS CloudTrail. Use AWS encryption solutions, with all default security controls within AWS services. Use advanced managed security services such as Amazon Macie, which assists in discovering and securing personal data that is stored in Amazon S3. If you require FIPS 140-2 validated cryptographic modules when accessing AWS through a command line interface or an API, use a FIPS endpoint. For more information about the available FIPS endpoints, see Federal Information Processing Standard (FIPS) 140-2.  We strongly recommend that you never put sensitive identifying information, such as your customers' account numbers, into free-form fields such as a Name field. This includes when you work with AWS SDK for Go V2 or other AWS services using the console, API, AWS CLI, or AWS SDKs. Any data that you enter into AWS SDK for Go V2 or other services might get picked up for inclusion in diagnostic logs. When you provide a URL to an external server, don’t include credentials information in the URL to validate your request to that server.\n","categories":"","description":"","excerpt":"The shared responsibility model applies to data protection in this AWS …","ref":"/aws-sdk-go-v2/docs/security/data-protection/","tags":"","title":"Data Protection in this AWS Product or Service"},{"body":"The AWS SDK for Go V2 configures the default HTTP client used by the SDK service clients to require a minimum version of TLS 1.2 or greater. When using the http.BuildableClient to customize the SDK HTTP client, the minimum TLS value is configured as TLS 1.2.\nIf your application constructs an HTTP client using a method other than the provided BuildableClient, you must configure your client to set the minimum TLS version to 1.2.\n Enforcing a Minimum TLS Version You can construct a custom an http.Client or use the SDK provided http.BuildableClient builder. The following example demonstrates how to specify a minimum TLS version of 1.3 using the http.BuildableClient.\nSome AWS Services do not yet support TLS 1.3; configuring this as your minimum version may affect SDK interoperability. We recommend testing this change with each service prior to production deployment.\n package main import ( \"context\" \"crypto/tls\" \"net/http\" awshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" \"github.com/aws/aws-sdk-go-v2/config\" ) func main() { // Create the custom HTTP client, configured for TLS 1.3 specified as the \t// minimum TLS version. \thttpClient := awshttp.NewBuildableClient().WithTransportOptions(func(tr *http.Transport) { if tr.TLSClientConfig == nil { tr.TLSClientConfig = \u0026tls.Config{} } tr.TLSClientConfig.MinVersion = tls.VersionTLS13 }) // Load the SDK's configuration, and specify the custom HTTP client to be used \t// by all SDK API clients created from this configuration. \tcfg, err := config.LoadDefaultConfig(context.TODO(), config.WithHTTPClient(httpClient)) // Use the loaded config and custom HTTP client to create SDK API client(s).  // ... } ","categories":"","description":"","excerpt":"The AWS SDK for Go V2 configures the default HTTP client used by the …","ref":"/aws-sdk-go-v2/docs/security/tls/","tags":"","title":"TLS Version in AWS SDK for Go V2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMGetAccessKeyLastUsedAPI defines the interface for the GetAccessKeyLastUsed function. // We use this interface to test the function using a mocked service. type IAMGetAccessKeyLastUsedAPI interface { GetAccessKeyLastUsed(ctx context.Context, params *iam.GetAccessKeyLastUsedInput, optFns ...func(*iam.Options)) (*iam.GetAccessKeyLastUsedOutput, error) } // WhenWasKeyUsed retrieves when an AWS Identity and Access Management (IAM) access key was last used, including the AWS Region and with which service. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a GetAccessKeyLastUsedOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetAccessKeyLastUsed. func WhenWasKeyUsed(c context.Context, api IAMGetAccessKeyLastUsedAPI, input *iam.GetAccessKeyLastUsedInput) (*iam.GetAccessKeyLastUsedOutput, error) { return api.GetAccessKeyLastUsed(c, input) } func main() { keyID := flag.String(\"k\", \"\", \"The ID of the access key\") flag.Parse() if *keyID == \"\" { fmt.Println(\"You must supply the ID of an access key (-k KEY-ID)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.GetAccessKeyLastUsedInput{ AccessKeyId: keyID, } result, err := WhenWasKeyUsed(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving when access key was last used:\") fmt.Println(err) return } fmt.Println(\"The key was last used:\", *result.AccessKeyLastUsed) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/accesskeylastused/","tags":"","title":"AccessKeyLastUsedv2"},{"body":"You can use the AWS SDK for Go V2 to access the Amazon EC2 Instance Metadata Service. The feature/ec2/imds Go package provides a Client type that can be used to access the Amazon EC2 Instance Metadata Service. The Client and associated operations can be used similar to the other AWS service clients provided by the SDK. To learn more information on how to configure the SDK, and use service clients see Configuring the SDK and Using AWS Services.\nThe client can help you easily retrieve information about instances on which your applications run, such as its AWS Region or local IP address. Typically, you must create and submit HTTP requests to retrieve instance metadata. Instead, create an imds.Client to access the Amazon EC2 Instance Metadata Service using a programmatic client like other AWS Services.\nFor example to construct a client:\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/feature/ec2/imds\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } client := imds.NewFromConfig(cfg) Then use the service client to retrieve information from a metadata category such as local-ipv4 (the private IP address of the instance).\nlocalip, err := client.GetMetadata(context.TODO(), \u0026imds.GetMetadataInput{ Path: \"local-ipv4\", }) if err != nil { log.Printf(\"Unable to retrieve the private IP address from the EC2 instance: %s\\n\", err) return } fmt.Printf(\"local-ip: %v\\n\", localip) For a list of all metadata categories, see Instance Metadata Categories in the Amazon EC2 User Guide.\nRetrieving an Instance’s Region There’s no instance metadata category that returns only the Region of an instance. Instead, use the included Region method to easily return an instance’s Region.\nregion, err := client.GetRegion(context.TODO(), \u0026imds.GetRegionInput{}) if err != nil { log.Printf(\"Unable to retrieve the region from the EC2 instance %v\\n\", err) } fmt.Printf(\"region: %v\\n\", region) For more information about the EC2 metadata utility, see the feature/ec2/imds package in the AWS SDK for Go V2 API Reference.\n","categories":"","description":"Using the AWS SDK for Go V2 Amazon EC2 Instance Metadata Service Client","excerpt":"Using the AWS SDK for Go V2 Amazon EC2 Instance Metadata Service …","ref":"/aws-sdk-go-v2/docs/sdk-utilities/ec2-imds/","tags":"","title":"Amazon EC2 Instance Metadata Service"},{"body":"Transfer Managers The Amazon Simple Storage Service upload and download managers can break up large objects, so they can be transferred in multiple parts, in parallel. This makes it easy to resume interrupted transfers.\nUpload Manager The Amazon Simple Storage Service upload manager determines if a file can be split into smaller parts and uploaded in parallel. You can customize the number of parallel uploads and the size of the uploaded parts.\nThe following example uses the Amazon S3 Uploader to upload a file. Using Uploader is similar to the s3.PutObject() operation.\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/aws-sdk-go-v2/feature/s3/manager\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } client := s3.NewFromConfig(cfg) uploader := manager.NewUploader(client) result, err := uploader.Upload(context.TODO(), \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-object-key\"), Body: uploadFile, }) Configuration Options When you instantiate an Uploader instance using NewUploader, you can specify several configuration options to customize how objects are uploaded. Options are overridden by providing one or more arguments to NewUploader. These options include:\n PartSize – Specifies the buffer size, in bytes, of each part to upload. The minimum size per part is 5 MiB. Concurrency – Specifies the number of parts to upload in parallel. LeavePartsOnError – Indicates whether to leave successfully uploaded parts in Amazon S3.  The Concurrency value limits the concurrent number of part uploads that can occur for a given Upload call. This is not a global client concurrency limit. Tweak the PartSize and Concurrency configuration values to find the optimal configuration. For example, systems with high-bandwidth connections can send bigger parts and more uploads in parallel.\nFor example, your application configures Uploader with a Concurrency of setting of 5. If your application then calls Upload from two different goroutines, the result is 10 concurrent part uploads (2 goroutines * 5 Concurrency).\nYour application is expected to limit the concurrent calls to Upload to prevent application resource exhaustion.\n Below is an example to set the default part size during Uploader creation:\nuploader := manager.NewUploader(client, func(u *Uploader) { u.PartSize = 10 * 1024 * 1024, // 10 MiB }) For more information about Uploader and its configurations, see Uploader in the AWS SDK for Go V2 API Reference.\nPutObjectInput Body Field (io.ReadSeeker vs. io.Reader) The Body field of the s3.PutObjectInput struct is an io.Reader type. However, this field can be populated with a type that satisfies both the io.ReadSeeker and io.ReaderAt interface to improve application resource utilization of the host environment. The following example creates the type ReadSeekerAt that satisfies both interfaces:\ntype ReadSeekerAt interface { io.ReadSeeker io.ReaderAt } For io.Reader types, the bytes of the reader must be buffered in memory before the part can be uploaded. When you increase the PartSize or Concurrency value, the required memory (RAM) for the Uploader increases significantly. The required memory is approximately PartSize * Concurrency. For example, specifying 100 MB for PartSize and 10 for Concurrency, requires at least 1 GB.\nBecause an io.Reader type cannot determine its size before reading its bytes, Uploader cannot calculate how many parts will be uploaded. Consequently, Uploader can reach the Amazon S3 upload limit of 10,000 parts for large files if you set the PartSize too low. If you try to upload more than 10,000 parts, the upload stops and returns an error.\nFor body values that implement the ReadSeekerAt type, the Uploader doesn’t buffer the body contents in memory before sending it to Amazon S3. Uploader calculates the expected number of parts before uploading the file to Amazon S3. If the current value of PartSize requires more than 10,000 parts to upload the file, Uploader increases the part size value so that fewer parts are required.\nHandling Failed Uploads If an upload to Amazon S3 fails, by default, Uploader uses the Amazon S3 AbortMultipartUpload operation to remove the uploaded parts. This functionality ensures that failed uploads do not consume Amazon S3 storage.\nYou can set LeavePartsOnError to true so that the Uploader doesn’t delete successfully uploaded parts. This is useful for resuming partially completed uploads. To operate on uploaded parts, you must get the UploadID of the failed upload. The following example demonstrates how to use the manager.MultiUploadFailure error interface type to get the UploadID.\nresult, err := uploader.Upload(context.TODO(), \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-object-key\"), Body: uploadFile, }) output, err := u.upload(input) if err != nil { var mu manager.MultiUploadFailure if errors.As(err, \u0026mu) { // Process error and its associated uploadID \tfmt.Println(\"Error:\", mu) _ = mu.UploadID() // retrieve the associated UploadID \t} else { // Process error generically \tfmt.Println(\"Error:\", err.Error()) } return } Overriding Uploader Options Per Upload You can override the Uploader options when calling Upload by providing one or more arguments to the method. These overrides are concurrency-safe modifications and do not affect ongoing uploads, or subsequent Upload calls to the manager. For example, to override the PartSize configuration for a specific upload request:\nparams := \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-key\"), Body: myBody, } resp, err := uploader.Upload(context.TODO(), params, func(u *manager.Uploader) { u.PartSize = 10 * 1024 * 1024, // 10 MiB }) Examples Upload a Folder to Amazon S3 The following example uses the path/filepath package to recursively gather a list of files and upload them to the specified Amazon S3 bucket. The keys of the Amazon S3 objects are prefixed with the file’s relative path.\npackage main import ( \"context\" \"log\" \"os\" \"path/filepath\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/feature/s3/manager\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) var ( localPath string bucket string prefix string ) func init() { if len(os.Args) != 4 { log.Fatalln(\"Usage:\", os.Args[0], \"\u003clocal path\u003e \u003cbucket\u003e \u003cprefix\u003e\") } localPath = os.Args[1] bucket = os.Args[2] prefix = os.Args[3] } func main() { walker := make(fileWalk) go func() { // Gather the files to upload by walking the path recursively \tif err := filepath.Walk(localPath, walker.Walk); err != nil { log.Fatalln(\"Walk failed:\", err) } close(walker) }() cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Fatalln(\"error:\", err) } // For each file found walking, upload it to Amazon S3 \tuploader := manager.NewUploader(s3.NewFromConfig(cfg)) for path := range walker { rel, err := filepath.Rel(localPath, path) if err != nil { log.Fatalln(\"Unable to get relative path:\", path, err) } file, err := os.Open(path) if err != nil { log.Println(\"Failed opening file\", path, err) continue } defer file.Close() result, err := uploader.Upload(context.TODO(), \u0026s3.PutObjectInput{ Bucket: \u0026bucket, Key: aws.String(filepath.Join(prefix, rel)), Body: file, }) if err != nil { log.Fatalln(\"Failed to upload\", path, err) } log.Println(\"Uploaded\", path, result.Location) } } type fileWalk chan string func (f fileWalk) Walk(path string, info os.FileInfo, err error) error { if err != nil { return err } if !info.IsDir() { f \u003c- path } return nil } Download Manager The Amazon S3 Downloader manager determines if a file can be split into smaller parts and downloaded in parallel. You can customize the number of parallel downloads and the size of the downloaded parts.\nExample: Download a File The following example uses the Amazon S3 Downloader to download a file. Using Downloader is similar to the s3.GetObject operation.\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/aws-sdk-go-v2/feature/s3/manager\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Println(\"error:\", err) return } client := s3.NewFromConfig(cfg) downloader := manager.NewDownloader(client) numBytes, err := downloader.Download(context.TODO(), downloadFile, \u0026s3.GetObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-key\"), }) The downloadFile parameter is an io.WriterAt type. The WriterAt interface enables the Downloader to write multiple parts of the file in parallel.\nConfiguration Options When you instantiate a Downloader instance, you can specify configuration options to customize how objects are downloaded:\n PartSize – Specifies the buffer size, in bytes, of each part to download. The minimum size per part is 5 MB. Concurrency – Specifies the number of parts to download in parallel.  The Concurrency value limits the concurrent number of part download that can occur for a given Download call. This is not a global client concurrency limit. Tweak the PartSize and Concurrency configuration values to find the optimal configuration. For example, systems with high-bandwidth connections can receive bigger parts and more downloads in parallel.\nFor example, your application configures Downloader with a Concurrency of 5. Your application then calls Download from two different goroutines, the result will be 10 concurrent part downloads (2 goroutines * 5 Concurrency).\nYour application is expected to limit the concurrent calls to Download to prevent application resource exhaustion.\n For more information about Downloader and its other configuration options, see manager.Downloader in the AWS SDK for Go V2 API Reference.\nOverriding Downloader Options Per Download You can override the Downloader options when calling Download by providing one or more functional arguments to the method. These overrides are concurrency safe modifications and do not affect ongoing uploads, or subsequent Download calls to the manager. For example, to override the PartSize configuration for a specific upload request:\nparams := \u0026s3.GetObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-key\"), } resp, err := downloader.Download(context.TODO(), targetWriter, params, func(u *manager.Downloader) { u.PartSize = 10 * 1024 * 1024, // 10 MiB }) Examples Download All Objects in a Bucket The following example uses pagination to gather a list of objects from an Amazon S3 bucket. Then it downloads each object to a local file.\npackage main import ( \"context\" \"fmt\" \"log\" \"os\" \"path/filepath\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/feature/s3/manager\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) var ( Bucket = \"MyBucket\" // Download from this bucket \tPrefix = \"logs/\" // Using this key prefix \tLocalDirectory = \"s3logs\" // Into this directory ) func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Fatalln(\"error:\", err) } client := s3.NewFromConfig(cfg) manager := manager.NewDownloader(client) paginator := s3.NewListObjectsV2Paginator(client, \u0026s3.ListObjectsV2Input{ Bucket: \u0026Bucket, Prefix: \u0026Prefix, }) for paginator.HasMorePages() { page, err := paginator.NextPage(context.TODO()) if err != nil { log.Fatalln(\"error:\", err) } for _, obj := range page.Contents { if err := downloadToFile(manager, LocalDirectory, Bucket, aws.ToString(obj.Key)); err != nil { log.Fatalln(\"error:\", err) } } } } func downloadToFile(downloader *manager.Downloader, targetDirectory, bucket, key string) error { // Create the directories in the path \tfile := filepath.Join(targetDirectory, key) if err := os.MkdirAll(filepath.Dir(file), 0775); err != nil { return err } // Set up the local file \tfd, err := os.Create(file) if err != nil { return err } defer fd.Close() // Download the file using the AWS SDK for Go \tfmt.Printf(\"Downloading s3://%s/%s to %s...\\n\", bucket, key, file) _, err = downloader.Download(context.TODO(), fd, \u0026s3.GetObjectInput{Bucket: \u0026bucket, Key: \u0026key}) return err } GetBucketRegion The GetBucketRegion is a utility function for determining the AWS Region location of an Amazon S3 Bucket. GetBucketRegion takes an Amazon S3 client and uses it to determine the location of the requested Bucket within the AWS Partition associated with the client’s configured Region.\nFor example to find the Region for the Bucket my-bucket:\ncfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { log.Println(\"error:\", err) return } bucket := \"my-bucket\" region, err := manager.GetBucketRegion(ctx, s3.NewFromConfig(cfg), bucket) if err != nil { var bnf manager.BucketNotFound if errors.As(err, \u0026bnf) { log.Printf(\"unable to find bucket %s's Region\\n\", bucket) } else { log.Println(\"error:\", err) } return } fmt.Printf(\"Bucket %s is in %s region\\n\", bucket, region) If GetBucketRegion is not able to resolve the location of a Bucket, the function returns a BucketNotFound error type as shown in the example.\nUnseekable Streaming Input For API operations like PutObject and UploadPart, the Amazon S3 client expects the value of the Body input parameter to implement the io.Seeker interface by default. The io.Seeker interface is used by the client to determine the length of the value to upload, and to compute payload hash for the request signature. If the Body input parameter value does not implement io.Seeker, your application will receive an error.\noperation error S3: PutObject, failed to compute payload hash: failed to seek body to start, request stream is not seekable You can change this behavior by modifying the operation method’s Middleware using functional options. The WithAPIOptions helper returns a functional option for zero or more middleware mutators. To disable the client computing the payload hash and use Unsigned Payload request signature add v4.SwapComputePayloadSHA256ForUnsignedPayloadMiddleware.\nresp, err := client.PutObject(context.TODO(), \u0026s3.PutObjectInput{ Bucket: \u0026bucketName, Key: \u0026objectName, Body: bytes.NewBuffer([]byte(`example object!`)), ContentLength: 15, // length of body }, s3.WithAPIOptions( v4.SwapComputePayloadSHA256ForUnsignedPayloadMiddleware, ))  Amazon S3 requires the content length to be provided for all object’s uploaded to a bucket. Since the Body input parameter does not implement io.Seeker interface the client will not be able to compute the ContentLength parameter for the request. The parameter must be provided by the application. The request will fail if the ContentLength parameter is not provided.\nUse the SDK’s Amazon S3 Upload Manager for uploads that are not seekable, and do not have a known length.\n ","categories":"","description":"","excerpt":"Transfer Managers The Amazon Simple Storage Service upload and …","ref":"/aws-sdk-go-v2/docs/sdk-utilities/s3/","tags":"","title":"Amazon S3 Utilities"},{"body":"AssumeRolev2.go This example gets temporary security credentials to access resources.\ngo run AssumeRolev2.go -r ROLE-ARN -s SESSION-NAME\n ROLE-ARN is the ARN of the role to assume. SESSION-NAME is the name of the assumed role session.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sts\" ) // STSAssumeRoleAPI defines the interface for the AssumeRole function. // We use this interface to test the function using a mocked service. type STSAssumeRoleAPI interface { AssumeRole(ctx context.Context, params *sts.AssumeRoleInput, optFns ...func(*sts.Options)) (*sts.AssumeRoleOutput, error) } // TakeRole gets temporary security credentials to access resources. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, an AssumeRoleOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to AssumeRole. func TakeRole(c context.Context, api STSAssumeRoleAPI, input *sts.AssumeRoleInput) (*sts.AssumeRoleOutput, error) { return api.AssumeRole(c, input) } func main() { roleARN := flag.String(\"r\", \"\", \"The Amazon Resource Name (ARN) of the role to assume\") sessionName := flag.String(\"s\", \"\", \"The name of the session\") if *roleARN == \"\" || *sessionName == \"\" { fmt.Println(\"You must supply a role ARN and session name\") fmt.Println(\"-r ROLE-ARN -s SESSION-NAME\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sts.NewFromConfig(cfg) input := \u0026sts.AssumeRoleInput{ RoleArn: roleARN, RoleSessionName: sessionName, } result, err := TakeRole(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error assuming the role:\") fmt.Println(err) return } fmt.Println(result.AssumedRoleUser) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"AssumeRolev2.go This example gets temporary security credentials to …","ref":"/aws-sdk-go-v2/docs/code-examples/sts/assumerole/","tags":"","title":"AssumeRolev2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMAttachRolePolicyAPI defines the interface for the AttachRolePolicy function. // We use this interface to test the function using a mocked service. type IAMAttachRolePolicyAPI interface { AttachRolePolicy(ctx context.Context, params *iam.AttachRolePolicyInput, optFns ...func(*iam.Options)) (*iam.AttachRolePolicyOutput, error) } // AttachDynamoFullPolicy attaches an Amazon DynamoDB full-access policy to an AWS Identity and Access Management (IAM) role. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, an AttachRolePolicyOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to AttachRolePolicy. func AttachDynamoFullPolicy(c context.Context, api IAMAttachRolePolicyAPI, input *iam.AttachRolePolicyInput) (*iam.AttachRolePolicyOutput, error) { return api.AttachRolePolicy(c, input) } func main() { roleName := flag.String(\"r\", \"\", \"The name of the IAM role\") flag.Parse() if *roleName == \"\" { fmt.Println(\"You must supply a role name (-r ROLE)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) policyArn := \"arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess\" input := \u0026iam.AttachRolePolicyInput{ PolicyArn: \u0026policyArn, RoleName: roleName, } _, err = AttachDynamoFullPolicy(context.TODO(), client, input) if err != nil { fmt.Println(\"Unable to attach DynamoDB full-access role policy to role\") return } fmt.Println(\"Role attached successfully\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/attachuserpolicy/","tags":"","title":"AttachUserPolicyv2"},{"body":" Welcome to the AWS SDK for Go V2 Learn More   Download             Modularized Model service dependencies in your application, and independently control service client updates using Go modules.\n    Paginators Easily iterate over API results that span multiple pages.\n    Waiters Validate AWS resources states before performing additional actions.\n    Utilities Amazon S3 Transfer Manager provides seamless concurrent multi-part file uploads. Amazon DynamoDB AttributeValue and Expression utilities allow easy integration of your application Go types.\n    Extensible Middleware allows you to extend or customize the transport request pipeline to fit your applications requirements.\n     ","categories":"","description":"","excerpt":" Welcome to the AWS SDK for Go V2 Learn More   Download …","ref":"/aws-sdk-go-v2/","tags":"","title":"AWS SDK for Go V2"},{"body":"ChangeMsgVisibilityv2.go This example sets the visibility timeout for a message in an Amazon SQS queue.\ngo run ChangeMsgVisibilityv2.go -q QUEUE-NAME -h RECEIPT-HANDLE -v VISIBILITY\n QUEUE-NAME is the name of the queue. RECEIPT-HANDLE is the receipt handle of the message. VISIBILITY is the duration, in seconds, that the message is not visible to other consumers. The example ensures the value is between 0 and 12 hours; the default is 30 seconds.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"strconv\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSSetMsgVisibilityAPI defines the interface for the GetQueueUrl and ChangeMessageVisibility functions. // We use this interface to test the functions using a mocked service. type SQSSetMsgVisibilityAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) ChangeMessageVisibility(ctx context.Context, params *sqs.ChangeMessageVisibilityInput, optFns ...func(*sqs.Options)) (*sqs.ChangeMessageVisibilityOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSSetMsgVisibilityAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } // SetMsgVisibility sets the visibility timeout for a message in an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a ChangeMessageVisibilityOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ChangeMessageVisibility. func SetMsgVisibility(c context.Context, api SQSSetMsgVisibilityAPI, input *sqs.ChangeMessageVisibilityInput) (*sqs.ChangeMessageVisibilityOutput, error) { return api.ChangeMessageVisibility(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") handle := flag.String(\"h\", \"\", \"The receipt handle of the message\") visibility := flag.Int(\"v\", 30, \"The duration, in seconds, that the message is not visible to other consumers\") flag.Parse() if *queue == \"\" || *handle == \"\" { fmt.Println(\"You must supply a queue name (-q QUEUE) and message receipt handle (-h HANDLE)\") return } if *visibility \u003c 0 { *visibility = 0 } if *visibility \u003e 12*60*60 { *visibility = 12 * 60 * 60 } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) gQInput := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } // Get URL of queue \turlResult, err := GetQueueURL(context.TODO(), client, gQInput) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } queueURL := urlResult.QueueUrl sVInput := \u0026sqs.ChangeMessageVisibilityInput{ ReceiptHandle: handle, QueueUrl: queueURL, VisibilityTimeout: int32(*visibility), } _, err = SetMsgVisibility(context.TODO(), client, sVInput) if err != nil { fmt.Println(\"Got an error setting the visibility of the message:\") fmt.Println(err) return } fmt.Println(\"Changed the visibility of the message with the handle \" + *handle + \" in the \" + *queue + \" to \" + strconv.Itoa(*visibility)) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ChangeMsgVisibilityv2.go This example sets the visibility timeout for …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/changemsgvisibility/","tags":"","title":"ChangeMsgVisibilityv2"},{"body":"ConfigureLPQueuev2.go This example configures an Amazon SQS queue to use long polling.\ngo run ConfigureLPQueuev2.go -q QUEUE-NAME [-w WAIT-TIME]\n QUEUE-NAME is the name of the queue to configure. WAIT-TIME is how long, in seconds, to wait. The example ensures the value is between 1 and 20; the default is 10.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"strconv\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSConfigureLPQueueAPI defines the interface for the GetQueueUrl and SetQueueAttributes functions. // We use this interface to test the function using a mocked service. type SQSConfigureLPQueueAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) SetQueueAttributes(ctx context.Context, params *sqs.SetQueueAttributesInput, optFns ...func(*sqs.Options)) (*sqs.SetQueueAttributesOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSConfigureLPQueueAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } // ConfigureLPQueue configures an Amazon SQS queue to use long polling. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a SetQueueAttributesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to MSetQueueAttributesETHOD. func ConfigureLPQueue(c context.Context, api SQSConfigureLPQueueAPI, input *sqs.SetQueueAttributesInput) (*sqs.SetQueueAttributesOutput, error) { return api.SetQueueAttributes(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") waitTimeString := flag.String(\"w\", \"10\", \"The wait time, in seconds, for long polling\") flag.Parse() if *queue == \"\" || *waitTimeString == \"\" { fmt.Println(\"You must supply a queue name (-q QUEUE) and wait time (-w WAIT-TIME)\") return } waitTime, err := strconv.Atoi(*waitTimeString) if err != nil { fmt.Println(*waitTimeString + \" is not an integer\") } if waitTime \u003c 1 { waitTime = 1 } if waitTime \u003e 20 { waitTime = 20 } *waitTimeString = strconv.Itoa(waitTime) cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) gQInput := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } result, err := GetQueueURL(context.TODO(), client, gQInput) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } queueURL := result.QueueUrl cQInput := \u0026sqs.SetQueueAttributesInput{ QueueUrl: queueURL, Attributes: map[string]string{ \"ReceiveMessageWaitTimeSeconds\": *waitTimeString, }, } _, err = ConfigureLPQueue(context.TODO(), client, cQInput) if err != nil { fmt.Println(\"Got an error configuring the queue:\") fmt.Println(err) return } fmt.Println(\"Configured queue with URL \" + *queueURL + \" to use long polling\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ConfigureLPQueuev2.go This example configures an Amazon SQS queue to …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/configurelpqueue/","tags":"","title":"ConfigureLPQueuev2"},{"body":"CopyObjectv2.go This example copies an Amazon S3 object from one bucket to another.\ngo run CopyObjectv2.go -s SOURCE -d DESTINATION -o OBJECT\n SOURCE is the name of the bucket containing the item to copy. DESTINATION is the name of the bucket to which the item is copied. OBJECT is the name of the object to copy.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"net/url\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3CopyObjectAPI defines the interface for the Amazon Simple Storage Service (Amazon S3) CopyObject function. // We use this interface to enable unit testing. type S3CopyObjectAPI interface { CopyObject(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options)) (*s3.CopyObjectOutput, error) } // CopyItem copies an Amazon S3 object from one bucket to another. // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a CopyObjectOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CopyObject. func CopyItem(c context.Context, api S3CopyObjectAPI, input *s3.CopyObjectInput) (*s3.CopyObjectOutput, error) { return api.CopyObject(c, input) } func main() { sourceBucket := flag.String(\"s\", \"\", \"The source bucket containing the object to copy\") destinationBucket := flag.String(\"d\", \"\", \"The destination bucket to which the object is copied\") objectName := flag.String(\"o\", \"\", \"The object to copy\") flag.Parse() if *sourceBucket == \"\" || *destinationBucket == \"\" || *objectName == \"\" { fmt.Println(\"You must supply the bucket to copy from (-s BUCKET), to (-td BUCKET), and object to copy (-o OBJECT\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.CopyObjectInput{ Bucket: aws.String(url.PathEscape(*sourceBucket)), CopySource: destinationBucket, Key: objectName, } _, err = CopyItem(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error copying item:\") fmt.Println(err) return } fmt.Println(\"Copied \" + *objectName + \" from \" + *sourceBucket + \" to \" + *destinationBucket) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CopyObjectv2.go This example copies an Amazon S3 object from one …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/copyobject/","tags":"","title":"CopyObjectv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IMACreateAccessKeyAPI defines the interface for the CreateAccessKey function. // We use this interface to test the function using a mocked service. type IAMCreateAccessKeyAPI interface { CreateAccessKey(ctx context.Context, params *iam.CreateAccessKeyInput, optFns ...func(*iam.Options)) (*iam.CreateAccessKeyOutput, error) } // MakeAccessKey creates a new AWS Identity and Access Management (IAM) access key for a user. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a CreateAccessKeyOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateAccessKey. func MakeAccessKey(c context.Context, api IAMCreateAccessKeyAPI, input *iam.CreateAccessKeyInput) (*iam.CreateAccessKeyOutput, error) { return api.CreateAccessKey(c, input) } func main() { userName := flag.String(\"u\", \"\", \"The name of the user\") flag.Parse() if *userName == \"\" { fmt.Println(\"You must supply a user name (-u USER)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.CreateAccessKeyInput{ UserName: userName, } result, err := MakeAccessKey(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error creating a new access key\") fmt.Println(err) return } fmt.Println(\"Created new access key with ID: \" + *result.AccessKey.AccessKeyId + \" and secret key: \" + *result.AccessKey.SecretAccessKey) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/createaccesskey/","tags":"","title":"CreateAccessKeyv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMCreateAccountAliasAPI defines the interface for the CreateAccountAlias function. // We use this interface to test the function using a mocked service. type IAMCreateAccountAliasAPI interface { CreateAccountAlias(ctx context.Context, params *iam.CreateAccountAliasInput, optFns ...func(*iam.Options)) (*iam.CreateAccountAliasOutput, error) } // MakeAccountAlias creates an alias for your AWS Identity and Access Management (IAM) account. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a CreateAccountAliasOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateAccountAlias. func MakeAccountAlias(c context.Context, api IAMCreateAccountAliasAPI, input *iam.CreateAccountAliasInput) (*iam.CreateAccountAliasOutput, error) { return api.CreateAccountAlias(c, input) } func main() { alias := flag.String(\"a\", \"\", \"The account alias\") flag.Parse() if *alias == \"\" { fmt.Println(\"You must supply an account alias (-a ALIAS)\") } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.CreateAccountAliasInput{ AccountAlias: alias, } _, err = MakeAccountAlias(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error creating an account alias\") fmt.Println(err) return } fmt.Printf(\"Created account alias \" + *alias) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/createaccountalias/","tags":"","title":"CreateAccountAliasv2"},{"body":"CreateBucketv2.go This example creates an Amazon S3 bucket.\ngo run CreateBucketv2.go -b BUCKET\n BUCKET is the name of the bucket to create.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3CreateBucketAPI defines the interface for the CreateBucket function. // We use this interface to test the function using a mocked service. type S3CreateBucketAPI interface { CreateBucket(ctx context.Context, params *s3.CreateBucketInput, optFns ...func(*s3.Options)) (*s3.CreateBucketOutput, error) } // MakeBucket creates an Amazon Simple Storage Service (Amazon S3) bucket. // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a CreateBucketOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateBucket. func MakeBucket(c context.Context, api S3CreateBucketAPI, input *s3.CreateBucketInput) (*s3.CreateBucketOutput, error) { return api.CreateBucket(c, input) } func main() { bucket := flag.String(\"b\", \"\", \"The name of the bucket\") flag.Parse() if *bucket == \"\" { fmt.Println(\"You must supply a bucket name (-b BUCKET)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.CreateBucketInput{ Bucket: bucket, } _, err = MakeBucket(context.TODO(), client, input) if err != nil { fmt.Println(\"Could not create bucket \" + *bucket) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateBucketv2.go This example creates an Amazon S3 bucket.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/createbucket/","tags":"","title":"CreateBucketv2"},{"body":"CreateCustomMetricv2.go This example creates a new Amazon CloudWatch metric in a namespace.\ngo run CreateCustomMetricv2.go -n NAMESPACE -m METRIC-NAME -s SECONDS -dn DIMENSION-NAME -dv DIMENSION-VALUE\n NAMESPACE is the namespace for the metric. METRIC-NAME is the name of the metric. SECONDS is the number of seconds for the metric. DIMENSION-NAME is the name of the dimension. DIMENSION-VALUE is the value of the dimension.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatch\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatch/types\" ) // CWPutMetricDataAPI defines the interface for the PutMetricData function. // We use this interface to test the function using a mocked service. type CWPutMetricDataAPI interface { PutMetricData(ctx context.Context, params *cloudwatch.PutMetricDataInput, optFns ...func(*cloudwatch.Options)) (*cloudwatch.PutMetricDataOutput, error) } // CreateCustomMetric creates a new Amazon CloudWatch metric in a namespace // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a PutMetricDataOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to PutMetricData func CreateCustomMetric(c context.Context, api CWPutMetricDataAPI, input *cloudwatch.PutMetricDataInput) (*cloudwatch.PutMetricDataOutput, error) { return api.PutMetricData(c, input) } func main() { namespace := flag.String(\"n\", \"\", \"The namespace for the metric\") metricName := flag.String(\"m\", \"\", \"The name of the metric\") value := flag.Float64(\"s\", 0.0, \"The number of seconds for the units\") dimensionName := flag.String(\"dn\", \"\", \"The name of the dimension\") dimensionValue := flag.String(\"dv\", \"\", \"The value of the dimension\") flag.Parse() if *namespace == \"\" || *metricName == \"\" || *dimensionName == \"\" || *dimensionValue == \"\" { fmt.Println(\"You must supply a namespace, metric name, dimension name, and dimension value\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := cloudwatch.NewFromConfig(cfg) input := \u0026cloudwatch.PutMetricDataInput{ Namespace: namespace, MetricData: []types.MetricDatum{ { MetricName: metricName, Unit: types.StandardUnitSeconds, Value: value, Dimensions: []types.Dimension{ { Name: dimensionName, Value: dimensionValue, }, }, }, }, } _, err = CreateCustomMetric(context.TODO(), client, input) if err != nil { fmt.Println() return } fmt.Println(\"Created a custom metric\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateCustomMetricv2.go This example creates a new Amazon CloudWatch …","ref":"/aws-sdk-go-v2/docs/code-examples/cloudwatch/createcustommetric/","tags":"","title":"CreateCustomMetricv2"},{"body":"CreateEnableMetricAlarmv2.go This example enables the specified Amazon CloudWatch alarm.\ngo run CreateEnableMetricAlarmv2.go -n INSTANCE-NAME -i INSTANCE-ID -a ALARM-NAME\n INSTANCE-NAME is the name of the Amazon Elastic Compute Cloud (Amazon EC2) instance for which the alarm is enabled. INSTANCE-ID is the ID of the Amazon EC2 instance for which the alarm is enabled. ALARM-NAME is the name of the alarm.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatch\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatch/types\" ) // CWEnableAlarmAPI defines the interface for the PutMetricAlarm function. // We use this interface to test the function using a mocked service. type CWEnableAlarmAPI interface { PutMetricAlarm(ctx context.Context, params *cloudwatch.PutMetricAlarmInput, optFns ...func(*cloudwatch.Options)) (*cloudwatch.PutMetricAlarmOutput, error) EnableAlarmActions(ctx context.Context, params *cloudwatch.EnableAlarmActionsInput, optFns ...func(*cloudwatch.Options)) (*cloudwatch.EnableAlarmActionsOutput, error) } // CreateMetricAlarm creates a metric alarm // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a PutMetricAlarmOutput object containing the result of the service call and nil // Otherwise, the error from a call to PutMetricAlarm func CreateMetricAlarm(c context.Context, api CWEnableAlarmAPI, input *cloudwatch.PutMetricAlarmInput) (*cloudwatch.PutMetricAlarmOutput, error) { return api.PutMetricAlarm(c, input) } // EnableAlarm enables the specified Amazon CloudWatch alarm // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a EnableAlarmActionsOutput object containing the result of the service call and nil // Otherwise, the error from a call to PutMetricAlarm func EnableAlarm(c context.Context, api CWEnableAlarmAPI, input *cloudwatch.EnableAlarmActionsInput) (*cloudwatch.EnableAlarmActionsOutput, error) { return api.EnableAlarmActions(c, input) } func main() { instanceName := flag.String(\"n\", \"\", \"The instance name\") instanceID := flag.String(\"i\", \"\", \"The instance ID\") alarmName := flag.String(\"a\", \"\", \"The alarm name\") flag.Parse() if *instanceName == \"\" || *instanceID == \"\" || *alarmName == \"\" { fmt.Println(\"You must supply an instance name, instance ID, and alarm name\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := cloudwatch.NewFromConfig(cfg) putInput := \u0026cloudwatch.PutMetricAlarmInput{ AlarmName: alarmName, ComparisonOperator: types.ComparisonOperatorGreaterThanOrEqualToThreshold, EvaluationPeriods: aws.Int32(1), MetricName: aws.String(\"CPUUtilization\"), Namespace: aws.String(\"AWS/EC2\"), Period: aws.Int32(60), Statistic: types.StatisticAverage, Threshold: aws.Float64(70.0), ActionsEnabled: aws.Bool(true), AlarmDescription: aws.String(\"Alarm when server CPU exceeds 70%\"), Unit: types.StandardUnitSeconds, AlarmActions: []string{ fmt.Sprintf(\"arn:aws:swf:\"+cfg.Region+\":%s:action/actions/AWS_EC2.InstanceId.Reboot/1.0\", instanceName), }, Dimensions: []types.Dimension{ { Name: aws.String(\"InstanceId\"), Value: instanceID, }, }, } _, err = CreateMetricAlarm(context.TODO(), client, putInput) if err != nil { fmt.Println(err) return } enableInput := \u0026cloudwatch.EnableAlarmActionsInput{ AlarmNames: []string{ *instanceID, }, } _, err = EnableAlarm(context.TODO(), client, enableInput) if err != nil { fmt.Println(err) return } fmt.Println(\"Enabled alarm \" + *alarmName + \" for EC2 instance \" + *instanceName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateEnableMetricAlarmv2.go This example enables the specified Amazon …","ref":"/aws-sdk-go-v2/docs/code-examples/cloudwatch/createenablemetricalarm/","tags":"","title":"CreateEnableMetricAlarmv2"},{"body":"CreateImagev2.go This example creates an Amazon EC2 image.\ngo run CreateImagev2.go -d DESCRIPTION -i IMAGE-ID -n IMAGE-NAME\n DESCRIPTION is the description of the image. IMAGE-ID is the ID of the instance. IMAGE-NAME is the name of the image.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ec2\" \"github.com/aws/aws-sdk-go-v2/service/ec2/types\" ) // EC2CreateImageAPI defines the interface for the CreateImage function. // We use this interface to test the function using a mocked service. type EC2CreateImageAPI interface { CreateImage(ctx context.Context, params *ec2.CreateImageInput, optFns ...func(*ec2.Options)) (*ec2.CreateImageOutput, error) } // MakeImage creates an Amazon Elastic Compute Cloud (Amazon EC2) image. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a CreateImageOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateImage. func MakeImage(c context.Context, api EC2CreateImageAPI, input *ec2.CreateImageInput) (*ec2.CreateImageOutput, error) { return api.CreateImage(c, input) } func main() { description := flag.String(\"d\", \"\", \"The description of the image\") instanceID := flag.String(\"i\", \"\", \"The ID of the instance\") name := flag.String(\"n\", \"\", \"The name of the image\") flag.Parse() if *description == \"\" || *instanceID == \"\" || *name == \"\" { fmt.Println(\"You must supply an image description, instance ID, and image name\") fmt.Println(\"(-d IMAGE-DESCRIPTION -i INSTANCE-ID -n IMAGE-NAME\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ec2.NewFromConfig(cfg) input := \u0026ec2.CreateImageInput{ Description: description, InstanceId: instanceID, Name: name, BlockDeviceMappings: []types.BlockDeviceMapping{ { DeviceName: aws.String(\"/dev/sda1\"), NoDevice: aws.String(\"\"), }, { DeviceName: aws.String(\"/dev/sdb\"), NoDevice: aws.String(\"\"), }, { DeviceName: aws.String(\"/dev/sdc\"), NoDevice: aws.String(\"\"), }, }, } resp, err := MakeImage(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error createing image:\") fmt.Println(err) return } fmt.Println(\"ID: \", resp.ImageId) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateImagev2.go This example creates an Amazon EC2 image.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/createimage/","tags":"","title":"CreateImagev2"},{"body":"CreateInstancev2.go This example creates a T2-Micro instance from the Amazon EC2 image ami-e7527ed7 and attaches a tag to the instance.\ngo run CreateInstancev2.go -n TAG-NAME -v TAG-VALUE\n TAG-NAME is the name of the tag to attach to the instance. TAG-VALUE is the value of the tag to attach to the instance.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ec2\" \"github.com/aws/aws-sdk-go-v2/service/ec2/types\" ) // EC2CreateInstanceAPI defines the interface for the RunInstances and CreateTags functions. // We use this interface to test the functions using a mocked service. type EC2CreateInstanceAPI interface { RunInstances(ctx context.Context, params *ec2.RunInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RunInstancesOutput, error) CreateTags(ctx context.Context, params *ec2.CreateTagsInput, optFns ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error) } // MakeInstance creates an Amazon Elastic Compute Cloud (Amazon EC2) instance. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a RunInstancesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to RunInstances. func MakeInstance(c context.Context, api EC2CreateInstanceAPI, input *ec2.RunInstancesInput) (*ec2.RunInstancesOutput, error) { return api.RunInstances(c, input) } // MakeTags creates tags for an Amazon Elastic Compute Cloud (Amazon EC2) instance. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a CreateTagsOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateTags. func MakeTags(c context.Context, api EC2CreateInstanceAPI, input *ec2.CreateTagsInput) (*ec2.CreateTagsOutput, error) { return api.CreateTags(c, input) } func main() { name := flag.String(\"n\", \"\", \"The name of the tag to attach to the instance\") value := flag.String(\"v\", \"\", \"The value of the tag to attach to the instance\") flag.Parse() if *name == \"\" || *value == \"\" { fmt.Println(\"You must supply a name and value for the tag (-n NAME -v VALUE)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ec2.NewFromConfig(cfg) input := \u0026ec2.RunInstancesInput{ ImageId: aws.String(\"ami-e7527ed7\"), InstanceType: types.InstanceTypeT2Micro, MinCount: 1, MaxCount: 1, } result, err := MakeInstance(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error creating an instance:\") fmt.Println(err) return } tagInput := \u0026ec2.CreateTagsInput{ Resources: []string{*result.Instances[0].InstanceId}, Tags: []types.Tag{ { Key: name, Value: value, }, }, } _, err = MakeTags(context.TODO(), client, tagInput) if err != nil { fmt.Println(\"Got an error tagging the instance:\") fmt.Println(err) return } fmt.Println(\"Created tagged instance with ID \" + *result.Instances[0].InstanceId) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateInstancev2.go This example creates a T2-Micro instance from the …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/createinstance/","tags":"","title":"CreateInstancev2"},{"body":"CreateKeyv2.go This example creates an AWS Key Management Service (AWS KMS) customer master key (CMK).\ngo run CreateKeyv2.go\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX-License-Identifier: Apache-2.0 package main import ( \"context\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/kms\" ) // KMSCreateKeyAPI defines the interface for the CreateKey function. // We use this interface to test the function using a mocked service. type KMSCreateKeyAPI interface { CreateKey(ctx context.Context, params *kms.CreateKeyInput, optFns ...func(*kms.Options)) (*kms.CreateKeyOutput, error) } // MakeKey creates an AWS Key Management Service (AWS KMS) customer master key (CMK). // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a CreateKeyOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateKey. func MakeKey(c context.Context, api KMSCreateKeyAPI, input *kms.CreateKeyInput) (*kms.CreateKeyOutput, error) { return api.CreateKey(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := kms.NewFromConfig(cfg) input := \u0026kms.CreateKeyInput{} result, err := MakeKey(context.TODO(), client, input) if err != nil { fmt.Println(\"Got error creating key:\") fmt.Println(err) return } fmt.Println(*result.KeyMetadata.KeyId) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateKeyv2.go This example creates an AWS Key Management Service (AWS …","ref":"/aws-sdk-go-v2/docs/code-examples/kms/createkey/","tags":"","title":"CreateKeyv2"},{"body":"CreateLPQueuev2.go This example creates a long-polling Amazon SQS queue.\ngo run CreateLPQueuev2.go -q QUEUE-NAME [-w WAIT-TIME]\n QUEUE-NAME is the name of the queue to create. WAIT-TIME is how long, in seconds, to wait. The example ensures the value is between 1 and 20; the default is 10.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"strconv\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSCreateQueueAPI defines the interface for the CreateQueue function. // We use this interface to test the function using a mocked service. type SQSCreateQueueAPI interface { CreateQueue(ctx context.Context, params *sqs.CreateQueueInput, optFns ...func(*sqs.Options)) (*sqs.CreateQueueOutput, error) } // CreateLPQueue creates an Amazon SQS queue with long polling enabled. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a CreateQueueOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateQueue. func CreateLPQueue(c context.Context, api SQSCreateQueueAPI, input *sqs.CreateQueueInput) (*sqs.CreateQueueOutput, error) { return api.CreateQueue(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") waitTime := flag.Int(\"w\", 10, \"How long, in seconds, to wait for long polling\") flag.Parse() if *queue == \"\" { fmt.Println(\"You must supply a queue name (-q QUEUE\") return } if *waitTime \u003c 1 { *waitTime = 1 } if *waitTime \u003e 20 { *waitTime = 20 } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) input := \u0026sqs.CreateQueueInput{ QueueName: queue, Attributes: map[string]string{ \"ReceiveMessageWaitTimeSeconds\": strconv.Itoa(*waitTime), }, } resp, err := CreateLPQueue(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error creating the long polling queue:\") fmt.Println(err) return } fmt.Println(\"URL for long polling queue \" + *queue + \": \" + *resp.QueueUrl) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateLPQueuev2.go This example creates a long-polling Amazon SQS …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/createlpqueue/","tags":"","title":"CreateLPQueuev2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"encoding/json\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMCreatePolicyAPI defines the interface for the CreatePolicy function. // We use this interface to test the function using a mocked service. type IAMCreatePolicyAPI interface { CreatePolicy(ctx context.Context, params *iam.CreatePolicyInput, optFns ...func(*iam.Options)) (*iam.CreatePolicyOutput, error) } // StatementEntry dictates what this policy allows or doesn't allow. type StatementEntry struct { Effect string Action []string Resource string } // PolicyDocument is our definition of our policies to be uploaded to AWS Identity and Access Management (IAM). type PolicyDocument struct { Version string Statement []StatementEntry } // CreatePolicyDoc creates a policy document. func CreatePolicyDoc() ([]byte, error) { policy := PolicyDocument{ Version: \"2012-10-17\", Statement: []StatementEntry{ { Effect: \"Allow\", Action: []string{ \"logs:CreateLogGroup\", // Allow for creating log groups \t}, Resource: \"RESOURCE ARN FOR logs:*\", }, { Effect: \"Allow\", // Allows for DeleteItem, GetItem, PutItem, Scan, and UpdateItem \tAction: []string{ \"dynamodb:DeleteItem\", \"dynamodb:GetItem\", \"dynamodb:PutItem\", \"dynamodb:Scan\", \"dynamodb:UpdateItem\", }, Resource: \"RESOURCE ARN FOR dynamodb:*\", }, }, } b, err := json.Marshal(\u0026policy) return b, err } // MakePolicy creates an IAM policy. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a CreatePolicyOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreatePolicy. func MakePolicy(c context.Context, api IAMCreatePolicyAPI, input *iam.CreatePolicyInput) (*iam.CreatePolicyOutput, error) { return api.CreatePolicy(c, input) } func main() { policyName := flag.String(\"n\", \"\", \"The name of the policy\") flag.Parse() if *policyName == \"\" { fmt.Println(\"You must supply the name of the policy (-n POLICY)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) b, err := CreatePolicyDoc() if err != nil { fmt.Println(\"Got an error creating the policy doc:\") fmt.Println(err) return } input := \u0026iam.CreatePolicyInput{ PolicyDocument: aws.String(string(b)), PolicyName: policyName, } _, err = MakePolicy(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error creating the policy:\") fmt.Println(err) return } fmt.Println(\"Created policy \" + *policyName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/createpolicy/","tags":"","title":"CreatePolicyv2"},{"body":"CreateQueuev2.go This example creates an Amazon SQS queue.\ngo run CreateQueuev2.go -q QUEUE-NAME\n QUEUE-NAME is the name of the queue to create.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSCreateQueueAPI defines the interface for the CreateQueue function. // We use this interface to test the function using a mocked service. type SQSCreateQueueAPI interface { CreateQueue(ctx context.Context, params *sqs.CreateQueueInput, optFns ...func(*sqs.Options)) (*sqs.CreateQueueOutput, error) } // CreateQueue creates an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a CreateQueueOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateQueue. func CreateQueue(c context.Context, api SQSCreateQueueAPI, input *sqs.CreateQueueInput) (*sqs.CreateQueueOutput, error) { return api.CreateQueue(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") flag.Parse() if *queue == \"\" { fmt.Println(\"You must supply a queue name (-q QUEUE\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) input := \u0026sqs.CreateQueueInput{ QueueName: queue, Attributes: map[string]string{ \"DelaySeconds\": \"60\", \"MessageRetentionPeriod\": \"86400\", }, } result, err := CreateQueue(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error creating the queue:\") fmt.Println(err) return } fmt.Println(\"URL: \" + *result.QueueUrl) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateQueuev2.go This example creates an Amazon SQS queue.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/createqueue/","tags":"","title":"CreateQueuev2"},{"body":"CreateTopicv2.go This example creates an Amazon SNS topic.\ngo run CreateTopicv2.go -t TOPIC\n TOPIC is the name of the topic to create.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sns\" ) // SNSCreateTopicAPI defines the interface for the CreateTopic function. // We use this interface to test the function using a mocked service. type SNSCreateTopicAPI interface { CreateTopic(ctx context.Context, params *sns.CreateTopicInput, optFns ...func(*sns.Options)) (*sns.CreateTopicOutput, error) } // MakeTopic creates an Amazon Simple Notification Service (Amazon SNS) topic. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a CreateTopicOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateTopic. func MakeTopic(c context.Context, api SNSCreateTopicAPI, input *sns.CreateTopicInput) (*sns.CreateTopicOutput, error) { return api.CreateTopic(c, input) } func main() { topic := flag.String(\"t\", \"\", \"The name of the topic\") flag.Parse() if *topic == \"\" { fmt.Println(\"You must supply the name of the topic\") fmt.Println(\"-t TOPIC\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sns.NewFromConfig(cfg) input := \u0026sns.CreateTopicInput{ Name: topic, } results, err := MakeTopic(context.TODO(), client, input) if err != nil { fmt.Println(err.Error()) return } fmt.Println(*results.TopicArn) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"CreateTopicv2.go This example creates an Amazon SNS topic.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/sns/createtopic/","tags":"","title":"CreateTopicv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMCreateUserAPI defines the interface for the CreateUser function. // We use this interface to test the function using a mocked service. type IAMCreateUserAPI interface { CreateUser(ctx context.Context, params *iam.CreateUserInput, optFns ...func(*iam.Options)) (*iam.CreateUserOutput, error) } // MakeUser creates an AWS Identity and Access Management (IAM) user. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a CreateUserOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to CreateUser. func MakeUser(c context.Context, api IAMCreateUserAPI, input *iam.CreateUserInput) (*iam.CreateUserOutput, error) { return api.CreateUser(c, input) } func main() { userName := flag.String(\"u\", \"\", \"The name of the user to create.\") flag.Parse() if *userName == \"\" { fmt.Println(\"You must supply a user name (-u USERNAME)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.CreateUserInput{ UserName: userName, } results, err := MakeUser(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error creating user \" + *userName) } fmt.Println(\"Created user \" + *results.User.UserName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/createuser/","tags":"","title":"CreateUserv2"},{"body":"DeadLetterQueuev2.go This example configures an Amazon SQS queue for messages that could not be delivered to another queue.\ngo run DeadLetterQueuev2.go -q QUEUE-NAME -d DEAD-LETTER-QUEUE-NAME\n QUEUE-NAME is the name of the queue from which the dead letters are sent. DEAD-LETTER-QUEUE-NAME is the name of the queue to which the dead letters are sent.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"encoding/json\" \"flag\" \"fmt\" \"strings\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSDeadLetterQueueAPI defines the interface for the GetQueueUrl and SetQueueAttributes functions. // We use this interface to test the function using a mocked service. type SQSDeadLetterQueueAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) SetQueueAttributes(ctx context.Context, params *sqs.SetQueueAttributesInput, optFns ...func(*sqs.Options)) (*sqs.SetQueueAttributesOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSDeadLetterQueueAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } // GetQueueArn gets the ARN of a queue based on its URL func GetQueueArn(queueURL *string) *string { parts := strings.Split(*queueURL, \"/\") subParts := strings.Split(parts[2], \".\") arn := \"arn:aws:\" + subParts[0] + \":\" + subParts[1] + \":\" + parts[3] + \":\" + parts[4] return \u0026arn } // ConfigureDeadLetterQueue configures an Amazon SQS queue for messages that could not be delivered to another queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a SetQueueAttributesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to SetQueueAttributes. func ConfigureDeadLetterQueue(c context.Context, api SQSDeadLetterQueueAPI, input *sqs.SetQueueAttributesInput) (*sqs.SetQueueAttributesOutput, error) { return api.SetQueueAttributes(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") dlQueue := flag.String(\"d\", \"\", \"The name of the dead-letter queue\") flag.Parse() if *queue == \"\" || *dlQueue == \"\" { fmt.Println(\"You must supply the names of the queue (-q QUEUE) and the dead-letter queue (-d DLQUEUE)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) gQInput := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } result, err := GetQueueURL(context.TODO(), client, gQInput) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } dlQueueURL := result.QueueUrl // Get the ARN for the dead-letter queue \tarn := GetQueueArn(dlQueueURL) // Our redrive policy for our queue \tpolicy := map[string]string{ \"deadLetterTargetArn\": *arn, \"maxReceiveCount\": \"10\", } // Marshal policy for SetQueueAttributes \tb, err := json.Marshal(policy) if err != nil { return } cQInput := \u0026sqs.SetQueueAttributesInput{ QueueUrl: dlQueueURL, Attributes: map[string]string{ \"RedrivePolicy\": string(b), }, } _, err = ConfigureDeadLetterQueue(context.Background(), client, cQInput) if err != nil { fmt.Println(\"Got an error configuring the dead-letter queue:\") fmt.Println(err) return } fmt.Println(\"Created dead-letter queue\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DeadLetterQueuev2.go This example configures an Amazon SQS queue for …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/deadletterqueue/","tags":"","title":"DeadLetterQueuev2"},{"body":"DecryptDatav2.go This example decrypts some text that was encrypted with an AWS Key Management Service (AWS KMS) customer master key (CMK).\ngo run DecryptDatav2.go -d DATA\n DATA is the encrypted data, as a string.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX-License-Identifier: Apache-2.0 package main import ( \"context\" b64 \"encoding/base64\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/kms\" ) // KMSDecryptAPI defines the interface for the Decrypt function. // We use this interface to test the function using a mocked service. type KMSDecryptAPI interface { Decrypt(ctx context.Context, params *kms.DecryptInput, optFns ...func(*kms.Options)) (*kms.DecryptOutput, error) } // DecodeData decrypts some text that was encrypted with an AWS Key Management Service (AWS KMS) customer master key (CMK). // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a DecryptOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to Decrypt. func DecodeData(c context.Context, api KMSDecryptAPI, input *kms.DecryptInput) (*kms.DecryptOutput, error) { return api.Decrypt(c, input) } func main() { data := flag.String(\"d\", \"\", \"The encrypted data, as a string\") flag.Parse() if *data == \"\" { fmt.Println(\"You must supply the encrypted data as a string\") fmt.Println(\"-d DATA\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := kms.NewFromConfig(cfg) blob, err := b64.StdEncoding.DecodeString(*data) if err != nil { panic(\"error converting string to blob, \" + err.Error()) } input := \u0026kms.DecryptInput{ CiphertextBlob: blob, } result, err := DecodeData(context.TODO(), client, input) if err != nil { fmt.Println(\"Got error decrypting data: \", err) return } fmt.Println(string(result.Plaintext)) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DecryptDatav2.go This example decrypts some text that was encrypted …","ref":"/aws-sdk-go-v2/docs/code-examples/kms/decryptdata/","tags":"","title":"DecryptDatav2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMDeleteAccessKeyAPI defines the interface for the DeleteAccessKey function. // We use this interface to test the function using a mocked service. type IAMDeleteAccessKeyAPI interface { DeleteAccessKey(ctx context.Context, params *iam.DeleteAccessKeyInput, optFns ...func(*iam.Options)) (*iam.DeleteAccessKeyOutput, error) } // RemoveAccessKey deletes an AWS Identity and Access Management (IAM) access key. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a DeleteAccessKeyOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DeleteAccessKey. func RemoveAccessKey(c context.Context, api IAMDeleteAccessKeyAPI, input *iam.DeleteAccessKeyInput) (*iam.DeleteAccessKeyOutput, error) { return api.DeleteAccessKey(c, input) } func main() { keyID := flag.String(\"k\", \"\", \"The ID of the access key\") userName := flag.String(\"u\", \"\", \"The name of the user\") flag.Parse() if *keyID == \"\" || *userName == \"\" { fmt.Println(\"You must supply the key ID and user name (-k KEY-ID -u USER-NAME\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.DeleteAccessKeyInput{ AccessKeyId: keyID, UserName: userName, } _, err = RemoveAccessKey(context.TODO(), client, input) if err != nil { fmt.Println(\"Error\", err) return } fmt.Println(\"Deleted key with ID \" + *keyID + \" from user \" + *userName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/deleteaccesskey/","tags":"","title":"DeleteAccessKeyv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMDeleteAccountAliasAPI defines the interface for the DeleteAccountAlias function. // We use this interface to test the function using a mocked service. type IAMDeleteAccountAliasAPI interface { DeleteAccountAlias(ctx context.Context, params *iam.DeleteAccountAliasInput, optFns ...func(*iam.Options)) (*iam.DeleteAccountAliasOutput, error) } // RemoveAccountAlias deletes an alias for your AWS Identity and Access Management (IAM) account. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a DeleteAccountAliasOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DeleteAccountAlias. func RemoveAccountAlias(c context.Context, api IAMDeleteAccountAliasAPI, input *iam.DeleteAccountAliasInput) (*iam.DeleteAccountAliasOutput, error) { return api.DeleteAccountAlias(c, input) } func main() { alias := flag.String(\"a\", \"\", \"The account alias\") flag.Parse() if *alias == \"\" { fmt.Println(\"You must supply an account alias (-a ALIAS)\") } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.DeleteAccountAliasInput{ AccountAlias: alias, } _, err = RemoveAccountAlias(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error deleting an account alias\") fmt.Println(err) return } fmt.Printf(\"Deleted account alias \" + *alias) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/deleteaccountalias/","tags":"","title":"DeleteAccountAliasv2"},{"body":"DeleteBucketv2.go This example deletes an Amazon S3 bucket.\ngo run DeleteBucketv2.go -b BUCKET\n BUCKET is the name of the bucket to delete.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3DeleteBucketAPI defines the interface for the DeleteBucket function. // We use this interface to test the function using a mocked service. type S3DeleteBucketAPI interface { DeleteBucket(ctx context.Context, params *s3.DeleteBucketInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOutput, error) } // RemoveBucket deletes an Amazon Simple Storage Service (Amazon S3) bucket // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a DeleteBucketOutput object containing the result of the service call and nil // Otherwise, an error from the call to CreateBucket func RemoveBucket(c context.Context, api S3DeleteBucketAPI, input *s3.DeleteBucketInput) (*s3.DeleteBucketOutput, error) { return api.DeleteBucket(c, input) } func main() { bucket := flag.String(\"b\", \"\", \"The name of the bucket\") flag.Parse() if *bucket == \"\" { fmt.Println(\"You must supply a bucket name (-b BUCKET)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.DeleteBucketInput{ Bucket: bucket, } _, err = RemoveBucket(context.TODO(), client, input) if err != nil { fmt.Println(\"Could not delete bucket \" + *bucket) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DeleteBucketv2.go This example deletes an Amazon S3 bucket.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/deletebucket/","tags":"","title":"DeleteBucketv2"},{"body":"DeleteMessagev2.go This example deletes a message from an Amazon SQS queue.\ngo run DeleteMessagev2.go -q QUEUE-NAME -m MESSAGE-HANDLE\n QUEUE-NAME is the name of the queue from which the message is deleted. MESSAGE-HANDLE is the handle of the message to delete.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSDeleteMessageAPI defines the interface for the GetQueueUrl and DeleteMessage functions. // We use this interface to test the functions using a mocked service. type SQSDeleteMessageAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) DeleteMessage(ctx context.Context, params *sqs.DeleteMessageInput, optFns ...func(*sqs.Options)) (*sqs.DeleteMessageOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSDeleteMessageAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } // RemoveMessage deletes a message from an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a DeleteMessageOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DeleteMessage. func RemoveMessage(c context.Context, api SQSDeleteMessageAPI, input *sqs.DeleteMessageInput) (*sqs.DeleteMessageOutput, error) { return api.DeleteMessage(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") messageHandle := flag.String(\"m\", \"\", \"The receipt handle of the message\") flag.Parse() if *queue == \"\" || *messageHandle == \"\" { fmt.Println(\"You must supply a queue name (-q QUEUE) and message receipt handle (-m MESSAGE-HANDLE)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) qUInput := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } // Get URL of queue \tresult, err := GetQueueURL(context.TODO(), client, qUInput) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } queueURL := result.QueueUrl dMInput := \u0026sqs.DeleteMessageInput{ QueueUrl: queueURL, ReceiptHandle: messageHandle, } _, err = RemoveMessage(context.TODO(), client, dMInput) if err != nil { fmt.Println(\"Got an error deleting the message:\") fmt.Println(err) return } fmt.Println(\"Deleted message from queue with URL \" + *queueURL) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DeleteMessagev2.go This example deletes a message from an Amazon SQS …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/deletemessage/","tags":"","title":"DeleteMessagev2"},{"body":"DeleteObjectv2.go This example deletes an Amazon S3 bucket object.\ngo run DeleteObjectv2.go -b BUCKET -o OBJECT\n BUCKET is the name of the bucket containing the item to delete. OBJECT is the name of the object to delete.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3DeleteObjectAPI defines the interface for the DeleteObject function. // We use this interface to test the function using a mocked service. type S3DeleteObjectAPI interface { DeleteObject(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectOutput, error) } // DeleteItem deletes an object from an Amazon Simple Storage Service (Amazon S3) bucket // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a DeleteObjectOutput object containing the result of the service call and nil // Otherwise, an error from the call to DeleteObject func DeleteItem(c context.Context, api S3DeleteObjectAPI, input *s3.DeleteObjectInput) (*s3.DeleteObjectOutput, error) { return api.DeleteObject(c, input) } func main() { bucket := flag.String(\"b\", \"\", \"The bucket from which the object is deleted\") objectName := flag.String(\"o\", \"\", \"The object to delete\") flag.Parse() if *bucket == \"\" || *objectName == \"\" { fmt.Println(\"You must supply the bucket (-b BUCKET), and object to delete (-o OBJECT\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.DeleteObjectInput{ Bucket: bucket, Key: objectName, } _, err = DeleteItem(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error deleting item:\") fmt.Println(err) return } fmt.Println(\"Deleted \" + *objectName + \" from \" + *bucket) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DeleteObjectv2.go This example deletes an Amazon S3 bucket object.\ngo …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/deleteobject/","tags":"","title":"DeleteObjectv2"},{"body":"DeleteParameterv2.go This example deletes a Systems Manager string parameter.\ngo run DeleteParameterv2.go -n NAME\n NAME is the name of the parameter to delete.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ssm\" ) // SSMDeleteParameterAPI defines the interface for the DeleteParameter function. // We use this interface to test the function using a mocked service. type SSMDeleteParameterAPI interface { DeleteParameter(ctx context.Context, params *ssm.DeleteParameterInput, optFns ...func(*ssm.Options)) (*ssm.DeleteParameterOutput, error) } // RemoveParameter deletes an AWS Systems Manager string parameter. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a DeleteParameterOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DeleteParameter. func RemoveParameter(c context.Context, api SSMDeleteParameterAPI, input *ssm.DeleteParameterInput) (*ssm.DeleteParameterOutput, error) { return api.DeleteParameter(c, input) } func main() { parameterName := flag.String(\"n\", \"\", \"The name of the parameter\") flag.Parse() if *parameterName == \"\" { fmt.Println(\"You must supply the name of the parameter\") fmt.Println(\"-n NAME\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ssm.NewFromConfig(cfg) input := \u0026ssm.DeleteParameterInput{ Name: parameterName, } _, err = RemoveParameter(context.TODO(), client, input) if err != nil { fmt.Println(err.Error()) return } fmt.Println(\"Deleted parameter \" + *parameterName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DeleteParameterv2.go This example deletes a Systems Manager string …","ref":"/aws-sdk-go-v2/docs/code-examples/ssm/deleteparameter/","tags":"","title":"DeleteParameterv2"},{"body":"DeleteQueuev2.go This example deletes an Amazon SQS queue.\ngo run DeleteQueuev2.go -q QUEUE-NAME\n QUEUE-NAME is the name of the queue to delete.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSDeleteQueueAPI defines the interface for the GetQueueUrl and DeleteQueue functions. // We use this interface to test the functions using a mocked service. type SQSDeleteQueueAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) DeleteQueue(ctx context.Context, params *sqs.DeleteQueueInput, optFns ...func(*sqs.Options)) (*sqs.DeleteQueueOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSDeleteQueueAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } // DeleteQueue deletes an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a DeleteQueueOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DeleteQueue. func DeleteQueue(c context.Context, api SQSDeleteQueueAPI, input *sqs.DeleteQueueInput) (*sqs.DeleteQueueOutput, error) { return api.DeleteQueue(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") flag.Parse() if *queue == \"\" { fmt.Println(\"You must supply a queue name (-q QUEUE\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) qInput := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } // Get the URL for the queue \tresult, err := GetQueueURL(context.TODO(), client, qInput) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } queueURL := result.QueueUrl dqInput := \u0026sqs.DeleteQueueInput{ QueueUrl: queueURL, } _, err = DeleteQueue(context.TODO(), client, dqInput) if err != nil { fmt.Println(\"Got an error deleting the queue:\") fmt.Println(err) return } fmt.Println(\"Deleted queue with URL \" + *queueURL) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DeleteQueuev2.go This example deletes an Amazon SQS queue.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/deletequeue/","tags":"","title":"DeleteQueuev2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMDeleteServerCertificateAPI defines the interface for the DeleteServerCertificate function. // We use this interface to test the function using a mocked service. type IAMDeleteServerCertificateAPI interface { DeleteServerCertificate(ctx context.Context, params *iam.DeleteServerCertificateInput, optFns ...func(*iam.Options)) (*iam.DeleteServerCertificateOutput, error) } // DeleteServerCert deletes an AWS Identity and Access Management (IAM) server certificate. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a DeleteServerCertificateOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DeleteServerCertificate. func DeleteServerCert(c context.Context, api IAMDeleteServerCertificateAPI, input *iam.DeleteServerCertificateInput) (*iam.DeleteServerCertificateOutput, error) { return api.DeleteServerCertificate(c, input) } func main() { certName := flag.String(\"c\", \"\", \"The name of the certificate\") flag.Parse() if *certName == \"\" { fmt.Println(\"You must supply the name of a certificate (-c CERT-NAME)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.DeleteServerCertificateInput{ ServerCertificateName: certName, } _, err = DeleteServerCert(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error deleting the server certificate:\") fmt.Println(err) return } fmt.Println(\"Deleted the server certificate \" + *certName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/deleteservercert/","tags":"","title":"DeleteServerCertv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMDeleteUserAPI defines the interface for the DeleteUser function. // We use this interface to test the function using a mocked service. type IAMDeleteUserAPI interface { DeleteUser(ctx context.Context, params *iam.DeleteUserInput, optFns ...func(*iam.Options)) (*iam.DeleteUserOutput, error) } // RemoveUser deletes an AWS Identity and Access Management (IAM) user. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a DeleteUserOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DeleteUser. func RemoveUser(c context.Context, api IAMDeleteUserAPI, input *iam.DeleteUserInput) (*iam.DeleteUserOutput, error) { return api.DeleteUser(c, input) } func main() { userName := flag.String(\"u\", \"\", \"The name of the user\") flag.Parse() if *userName == \"\" { fmt.Println(\"You must supply a user name (-u USERNAME)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.DeleteUserInput{ UserName: userName, } _, err = RemoveUser(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error deleting user \" + *userName) } fmt.Println(\"Deleted user \" + *userName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/deleteuser/","tags":"","title":"DeleteUserv2"},{"body":"DescribeAlarmsv2.go This example displays a list of your Amazon CloudWatch alarms.\ngo run DescribeAlarmsv2.go\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatch\" ) // CWDescribeAlarmsAPI defines the interface for the DescribeAlarms function. // We use this interface to test the function using a mocked service. type CWDescribeAlarmsAPI interface { DescribeAlarms(ctx context.Context, params *cloudwatch.DescribeAlarmsInput, optFns ...func(*cloudwatch.Options)) (*cloudwatch.DescribeAlarmsOutput, error) } // ListAlarms returns a list of your Amazon CloudWatch alarms // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a DescribeAlarmsOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to DescribeAlarms func ListAlarms(c context.Context, api CWDescribeAlarmsAPI, input *cloudwatch.DescribeAlarmsInput) (*cloudwatch.DescribeAlarmsOutput, error) { return api.DescribeAlarms(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := cloudwatch.NewFromConfig(cfg) input := \u0026cloudwatch.DescribeAlarmsInput{} resp, err := ListAlarms(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error listing alarms:\") fmt.Println(err) return } fmt.Println(\"Composite alarms:\") for _, alarm := range resp.CompositeAlarms { fmt.Println(\" \" + *alarm.AlarmName) } fmt.Println(\"Metric alarms:\") for _, alarm := range resp.MetricAlarms { fmt.Println(\" \" + *alarm.AlarmName) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DescribeAlarmsv2.go This example displays a list of your Amazon …","ref":"/aws-sdk-go-v2/docs/code-examples/cloudwatch/describealarms/","tags":"","title":"DescribeAlarmsv2"},{"body":"DescribeInstancesv2.go This example retrieves information about your Amazon EC2 instances.\ngo run DescribeInstancesv2.go\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ec2\" ) // EC2DescribeInstancesAPI defines the interface for the DescribeInstances function. // We use this interface to test the function using a mocked service. type EC2DescribeInstancesAPI interface { DescribeInstances(ctx context.Context, params *ec2.DescribeInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error) } // GetInstances retrieves information about your Amazon Elastic Compute Cloud (Amazon EC2) instances. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a DescribeInstancesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DescribeInstances. func GetInstances(c context.Context, api EC2DescribeInstancesAPI, input *ec2.DescribeInstancesInput) (*ec2.DescribeInstancesOutput, error) { return api.DescribeInstances(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ec2.NewFromConfig(cfg) input := \u0026ec2.DescribeInstancesInput{} result, err := GetInstances(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving information about your Amazon EC2 instances:\") fmt.Println(err) return } for _, r := range result.Reservations { fmt.Println(\"Reservation ID: \" + *r.ReservationId) fmt.Println(\"Instance IDs:\") for _, i := range r.Instances { fmt.Println(\" \" + *i.InstanceId) } fmt.Println(\"\") } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DescribeInstancesv2.go This example retrieves information about your …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/describeinstances/","tags":"","title":"DescribeInstancesv2"},{"body":"DescribeTablev2.go This example lists the following properties of a DynamoDB table.\n Number of items Size, in bytes Status, such as Active  go run DescribeTablev2.go -t TABLE\n TABLE is the name of the table.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/dynamodb\" ) // DynamoDBDescribeTableAPI defines the interface for the DescribeTable function. // We use this interface to enable unit testing. type DynamoDBDescribeTableAPI interface { DescribeTable(ctx context.Context, params *dynamodb.DescribeTableInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DescribeTableOutput, error) } // GetTableInfo retrieves information about the table. func GetTableInfo(c context.Context, api DynamoDBDescribeTableAPI, input *dynamodb.DescribeTableInput) (*dynamodb.DescribeTableOutput, error) { return api.DescribeTable(c, input) } func main() { table := flag.String(\"t\", \"\", \"The name of the table\") flag.Parse() if *table == \"\" { fmt.Println(\"You must specify a table name (-t TABLE)\") return } // Use the SDK's default configuration. \tcfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"unable to load SDK config, \" + err.Error()) } // Create an Amazon DynamoDB client. \tclient := dynamodb.NewFromConfig(cfg) // Build the input parameters for the request. \tinput := \u0026dynamodb.DescribeTableInput{ TableName: table, } resp, err := GetTableInfo(context.TODO(), client, input) if err != nil { panic(\"failed to describe table, \" + err.Error()) } fmt.Println(\"Info about \" + *table + \":\") fmt.Println(\" #items: \", resp.Table.ItemCount) fmt.Println(\" Size (bytes)\", resp.Table.TableSizeBytes) fmt.Println(\" Status: \", string(resp.Table.TableStatus)) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DescribeTablev2.go This example lists the following properties of a …","ref":"/aws-sdk-go-v2/docs/code-examples/dynamodb/describetable/","tags":"","title":"DescribeTablev2"},{"body":"DescribeVpcEndpointsv2.go This example retrieves information about your VPC endpoint connections.\ngo run DescribeVpcEndpointsv2.go [-r REGION]\n REGION is the region to get the endpoints from. This value is us-west-2 by default.  Source code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX-License-Identifier: Apache-2.0 package main import ( \"context\" \"encoding/json\" \"flag\" \"fmt\" \"strconv\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ec2\" ) // EC2DescribeVpcEndpointConnectionsAPI defines the interface for the DescribeVpcEndpointConnections function. // We use this interface to test the function using a mocked service. type EC2DescribeVpcEndpointConnectionsAPI interface { DescribeVpcEndpointConnections(ctx context.Context, params *ec2.DescribeVpcEndpointConnectionsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcEndpointConnectionsOutput, error) } // GetConnectionInfo retrieves information about your VPC endpoint connections. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a DescribeVpcEndpointConnectionsOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DescribeVpcEndpointConnections. func GetConnectionInfo(c context.Context, api EC2DescribeVpcEndpointConnectionsAPI, input *ec2.DescribeVpcEndpointConnectionsInput) (*ec2.DescribeVpcEndpointConnectionsOutput, error) { return api.DescribeVpcEndpointConnections(context.Background(), input) } func main() { region := flag.String(\"r\", \"us-west-2\", \"The region to get VPC info from.\") flag.Parse() if *region == \"\" { panic(\"You cannot supply an empty region\") } cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion(*region)) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ec2.NewFromConfig(cfg) input := \u0026ec2.DescribeVpcEndpointConnectionsInput{} resp, err := GetConnectionInfo(context.Background(), client, input) if err != nil { fmt.Println(\"Got an error retrieving information about your VPC endpoint:\") fmt.Println(err) return } cons := len(resp.VpcEndpointConnections) if cons == 0 { fmt.Println(\"Could not find any VCP endpoint connections in \" + *region) return } fmt.Println(\"VPC endpoint: Details:\") respDecrypted, _ := json.MarshalIndent(resp, \"\", \"\\t\") fmt.Println(string(respDecrypted)) fmt.Println() fmt.Println(\"Found \" + strconv.Itoa(cons) + \" VCP endpoint connection(s) in \" + *region) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DescribeVpcEndpointsv2.go This example retrieves information about …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/describevpcendpoints/","tags":"","title":"DescribeVpcEndpointsv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMDetachRolePolicyAPI defines the interface for the DetachRolePolicy function. // We use this interface to test the function using a mocked service. type IAMDetachRolePolicyAPI interface { DetachRolePolicy(ctx context.Context, params *iam.DetachRolePolicyInput, optFns ...func(*iam.Options)) (*iam.DetachRolePolicyOutput, error) } // DetachDynamoFullPolicy detaches an Amazon DynamoDB full-access policy from an AWS Identity and Access Management (IAM) role. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a DetachRolePolicyOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to DetachRolePolicy. func DetachDynamoFullPolicy(c context.Context, api IAMDetachRolePolicyAPI, input *iam.DetachRolePolicyInput) (*iam.DetachRolePolicyOutput, error) { return api.DetachRolePolicy(c, input) } func main() { roleName := flag.String(\"r\", \"\", \"The name of the IAM role\") flag.Parse() if *roleName == \"\" { fmt.Println(\"You must supply a role name (-r ROLE)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) policyArn := \"arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess\" input := \u0026iam.DetachRolePolicyInput{ PolicyArn: \u0026policyArn, RoleName: roleName, } _, err = DetachDynamoFullPolicy(context.TODO(), client, input) if err != nil { fmt.Println(\"Unable to detach DynamoDB full-access role policy from role\") return } fmt.Println(\"Role detached successfully\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/detachuserpolicy/","tags":"","title":"DetachUserPolicyv2"},{"body":"DisableAlarmv2.go This example disables an Amazon CloudWatch alarm.\ngo run DisableAlarmv2.go -a ALARM-NAME\n ALARM-NAME is the name of the alarm to disable.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatch\" ) // CWDisableAlarmAPI defines the interface for the DisableAlarmActions function. // We use this interface to test the function using a mocked service. type CWDisableAlarmAPI interface { DisableAlarmActions(ctx context.Context, params *cloudwatch.DisableAlarmActionsInput, optFns ...func(*cloudwatch.Options)) (*cloudwatch.DisableAlarmActionsOutput, error) } // DisableAlarm disables an Amazon CloudWatch alarm // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a DisableAlarmActionsOutput object containing the result of the service call and nil // Otherwise, nil and the error from the call to DisableAlarmActions func DisableAlarm(c context.Context, api CWDisableAlarmAPI, input *cloudwatch.DisableAlarmActionsInput) (*cloudwatch.DisableAlarmActionsOutput, error) { return api.DisableAlarmActions(c, input) } func main() { alarmName := flag.String(\"a\", \"\", \"The name of the alarm to disable\") flag.Parse() if *alarmName == \"\" { fmt.Println(\"You must supply an alarm name to disable\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := cloudwatch.NewFromConfig(cfg) input := \u0026cloudwatch.DisableAlarmActionsInput{ AlarmNames: []string{ *alarmName, }, } _, err = DisableAlarm(context.TODO(), client, input) if err != nil { fmt.Println(\"Could not disable alarm \" + *alarmName) } else { fmt.Println(\"Disabled alarm \" + *alarmName) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"DisableAlarmv2.go This example disables an Amazon CloudWatch alarm.\ngo …","ref":"/aws-sdk-go-v2/docs/code-examples/cloudwatch/disablealarm/","tags":"","title":"DisableAlarmv2"},{"body":"EncryptDatav2.go This example encrypts some text using an AWS Key Management Service (AWS KMS) customer master key (CMK).\ngo run EncryptDatav2.go -k KEYID -t TEXT\n KEYID is the ID for the AWS KMS key to use for encrypting the text. TEXT is the text to encrypt.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX-License-Identifier: Apache-2.0 package main import ( \"context\" b64 \"encoding/base64\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/kms\" ) // KMSEncryptAPI defines the interface for the Encrypt function. // We use this interface to test the function using a mocked service. type KMSEncryptAPI interface { Encrypt(ctx context.Context, params *kms.EncryptInput, optFns ...func(*kms.Options)) (*kms.EncryptOutput, error) } // EncryptText encrypts some text using an AWS Key Management Service (AWS KMS) customer master key (CMK). // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, an EncryptOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to Encrypt. func EncryptText(c context.Context, api KMSEncryptAPI, input *kms.EncryptInput) (*kms.EncryptOutput, error) { return api.Encrypt(c, input) } func main() { keyID := flag.String(\"k\", \"\", \"The ID of a KMS key\") text := flag.String(\"t\", \"\", \"The text to encrypt\") flag.Parse() if *keyID == \"\" || *text == \"\" { fmt.Println(\"You must supply the ID of a KMS key and some text\") fmt.Println(\"-k KEY-ID -t \\\"text\\\"\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := kms.NewFromConfig(cfg) input := \u0026kms.EncryptInput{ KeyId: keyID, Plaintext: []byte(*text), } result, err := EncryptText(context.TODO(), client, input) if err != nil { fmt.Println(\"Got error encrypting data:\") fmt.Println(err) return } blobString := b64.StdEncoding.EncodeToString(result.CiphertextBlob) fmt.Println(blobString) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"EncryptDatav2.go This example encrypts some text using an AWS Key …","ref":"/aws-sdk-go-v2/docs/code-examples/kms/encryptdata/","tags":"","title":"EncryptDatav2"},{"body":"GeneratePresignedURLv2.go This example retrieves a presigned URL for an Amazon Simple Storage Service (Amazon S3) bucket object.\ngo run GeneratePresignedURLv2.go -b BUCKET -k KEY\n BUCKET is the name of the bucket. KEY is the name of the object (key).  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" v4 \"github.com/aws/aws-sdk-go-v2/aws/signer/v4\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3PresignGetObjectAPI defines the interface for the PresignGetObject function. // We use this interface to test the function using a mocked service. type S3PresignGetObjectAPI interface { PresignGetObject( ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error) } // GetPresignedURL retrieves a presigned URL for an Amazon S3 bucket object. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, the presigned URL for the object and nil. // Otherwise, nil and an error from the call to PresignGetObject. func GetPresignedURL(c context.Context, api S3PresignGetObjectAPI, input *s3.GetObjectInput) (*v4.PresignedHTTPRequest, error) { return api.PresignGetObject(c, input) } func main() { bucket := flag.String(\"b\", \"\", \"The bucket\") key := flag.String(\"k\", \"\", \"The object key\") flag.Parse() if *bucket == \"\" || *key == \"\" { fmt.Println(\"You must supply a bucket name (-b BUCKET) and object key (-k KEY)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.GetObjectInput{ Bucket: bucket, Key: key, } psClient := s3.NewPresignClient(client) resp, err := GetPresignedURL(context.TODO(), psClient, input) if err != nil { fmt.Println(\"Got an error retrieving pre-signed object:\") fmt.Println(err) return } fmt.Println(\"The URL: \") fmt.Println(resp.URL) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"GeneratePresignedURLv2.go This example retrieves a presigned URL for …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/generatepresignedurl/","tags":"","title":"GeneratePresignedURLv2"},{"body":"GetBucketAclv2.go This example retrieves the access control list (ACL) for an Amazon S3 bucket.\ngo run GetBucketAclv2.go -b BUCKET\n BUCKET is the name of the bucket for which the ACL is retrieved.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3GetBucketAclAPI defines the interface for the GetBucketAcl function. // We use this interface to test the function using a mocked service. type S3GetBucketAclAPI interface { GetBucketAcl(ctx context.Context, params *s3.GetBucketAclInput, optFns ...func(*s3.Options)) (*s3.GetBucketAclOutput, error) } // FindBucketAcl retrieves the access control list (ACL) for an Amazon Simple Storage Service (Amazon S3) bucket. // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a GetBucketAclOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to GetBucketAcl func FindBucketAcl(c context.Context, api S3GetBucketAclAPI, input *s3.GetBucketAclInput) (*s3.GetBucketAclOutput, error) { return api.GetBucketAcl(c, input) } func main() { bucket := flag.String(\"b\", \"\", \"The bucket for which the ACL is returned\") flag.Parse() if *bucket == \"\" { fmt.Println(\"You must supply a bucket name (-b BUCKET)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.GetBucketAclInput{ Bucket: bucket, } result, err := FindBucketAcl(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving ACL for \" + *bucket) return } fmt.Println(\"Owner:\", *result.Owner.DisplayName) fmt.Println(\"\") fmt.Println(\"Grants\") for _, g := range result.Grants { // If we add a canned ACL, the name is nil \tif g.Grantee.DisplayName == nil { fmt.Println(\" Grantee: EVERYONE\") } else { fmt.Println(\" Grantee: \", *g.Grantee.DisplayName) } fmt.Println(\" Type: \", string(g.Grantee.Type)) fmt.Println(\" Permission:\", string(g.Permission)) fmt.Println(\"\") } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"GetBucketAclv2.go This example retrieves the access control list (ACL) …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/getbucketacl/","tags":"","title":"GetBucketAclv2"},{"body":"GetObjectAclv2.go This example retrieves the access control list (ACL) for an Amazon S3 bucket object.\ngo run GetObjectAclv2.go -b BUCKET -o OBJECT\n BUCKET is the name of the bucket containing the item. OBJECT is the name of the object for which the ACL is retrieved.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3GetObjectAclAPI defines the interface for the GetObjectAcl function. // We use this interface to test the function using a mocked service. type S3GetObjectAclAPI interface { GetObjectAcl(ctx context.Context, params *s3.GetObjectAclInput, optFns ...func(*s3.Options)) (*s3.GetObjectAclOutput, error) } // FindObjectAcl gets the access control list (ACL) for an Amazon Simple Storage Service (Amazon S3) bucket object // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a GetObjectAclOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to GetObjectAcl func FindObjectAcl(c context.Context, api S3GetObjectAclAPI, input *s3.GetObjectAclInput) (*s3.GetObjectAclOutput, error) { return api.GetObjectAcl(c, input) } func main() { bucket := flag.String(\"b\", \"\", \"The bucket containing the object\") objectName := flag.String(\"o\", \"\", \"The bucket object to get ACL from\") flag.Parse() if *bucket == \"\" || *objectName == \"\" { fmt.Println(\"You must supply a bucket (-b BUCKET) and object (-o OBJECT)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.GetObjectAclInput{ Bucket: bucket, Key: objectName, } result, err := FindObjectAcl(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error getting ACL for \" + *objectName) return } fmt.Println(\"Owner:\", *result.Owner.DisplayName) fmt.Println(\"\") fmt.Println(\"Grants\") for _, g := range result.Grants { fmt.Println(\" Grantee: \", *g.Grantee.DisplayName) fmt.Println(\" Type: \", string(g.Grantee.Type)) fmt.Println(\" Permission:\", string(g.Permission)) fmt.Println(\"\") } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"GetObjectAclv2.go This example retrieves the access control list (ACL) …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/getobjectacl/","tags":"","title":"GetObjectAclv2"},{"body":"GetParameterv2.go This example retrieves a Systems Manager string parameter.\ngo run GetParameterv2.go -n NAME\n NAME is the name of the parameter to retrieve.  Source code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ssm\" ) // SSMGetParameterAPI defines the interface for the GetParameter function. // We use this interface to test the function using a mocked service. type SSMGetParameterAPI interface { GetParameter(ctx context.Context, params *ssm.GetParameterInput, optFns ...func(*ssm.Options)) (*ssm.GetParameterOutput, error) } // FindParameter retrieves an AWS Systems Manager string parameter // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a GetParameterOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to GetParameter func FindParameter(c context.Context, api SSMGetParameterAPI, input *ssm.GetParameterInput) (*ssm.GetParameterOutput, error) { return api.GetParameter(c, input) } func main() { parameterName := flag.String(\"n\", \"\", \"The name of the parameter\") flag.Parse() if *parameterName == \"\" { fmt.Println(\"You must supply the name of the parameter\") fmt.Println(\"-n NAME\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ssm.NewFromConfig(cfg) input := \u0026ssm.GetParameterInput{ Name: parameterName, } results, err := FindParameter(context.TODO(), client, input) if err != nil { fmt.Println(err.Error()) return } fmt.Println(*results.Parameter.Value) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"GetParameterv2.go This example retrieves a Systems Manager string …","ref":"/aws-sdk-go-v2/docs/code-examples/ssm/getparameter/","tags":"","title":"GetParameterv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMGetPolicyAPI defines the interface for the GetPolicy function. // We use this interface to test the function using a mocked service. type IAMGetPolicyAPI interface { GetPolicy(ctx context.Context, params *iam.GetPolicyInput, optFns ...func(*iam.Options)) (*iam.GetPolicyOutput, error) } // GetPolicyDescription retrieves the description of the AWS Identity and Access Management (IAM) policy with the specified ARN. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a GetPolicyOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetPolicy. func GetPolicyDescription(c context.Context, api IAMGetPolicyAPI, input *iam.GetPolicyInput) (*iam.GetPolicyOutput, error) { return api.GetPolicy(c, input) } func main() { policyArn := flag.String(\"a\", \"\", \"The ARN of the policy to retrieve\") flag.Parse() if *policyArn == \"\" { fmt.Println(\"You must supply the ARN of the policy to retrieve (-a POLICY-ARN)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.GetPolicyInput{ PolicyArn: policyArn, } result, err := GetPolicyDescription(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving the description:\") fmt.Println(err) return } description := \"\" if nil == result.Policy { description = \"Policy nil\" } else { if nil == result.Policy.Description { description = \"Description nil\" } else { description = *result.Policy.Description } } fmt.Println(\"Description:\") fmt.Println(description) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/getpolicy/","tags":"","title":"GetPolicyv2"},{"body":"GetQueueURLv2.go This example gets the URL of an Amazon SQS queue.\ngo run GetQueueURLv2.go -q QUEUE-NAME\n QUEUE-NAME is the name of the queue or which the URL is retrieved.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSGetQueueUrlAPI defines the interface for the GetQueueUrl function. // We use this interface to test the function using a mocked service. type SQSGetQueueUrlAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSGetQueueUrlAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") flag.Parse() if *queue == \"\" { fmt.Println(\"You must supply a queue name (-q QUEUE\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) input := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } result, err := GetQueueURL(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } fmt.Println(\"URL: \" + *result.QueueUrl) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"GetQueueURLv2.go This example gets the URL of an Amazon SQS queue.\ngo …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/getqueueurl/","tags":"","title":"GetQueueURLv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMGetServerCertificateAPI defines the interface for the GetServerCertificate function. // We use this interface to test the function using a mocked service. type IAMGetServerCertificateAPI interface { GetServerCertificate(ctx context.Context, params *iam.GetServerCertificateInput, optFns ...func(*iam.Options)) (*iam.GetServerCertificateOutput, error) } // FindServerCert retrieves an AWS Identity and Access Management (IAM) server certificate. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a GetServerCertificateOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetServerCertificate. func FindServerCert(c context.Context, api IAMGetServerCertificateAPI, input *iam.GetServerCertificateInput) (*iam.GetServerCertificateOutput, error) { return api.GetServerCertificate(c, input) } func main() { certName := flag.String(\"c\", \"\", \"The name of the certificate\") flag.Parse() if *certName == \"\" { fmt.Println(\"You must supply the name of a certificate (-c CERT-NAME)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.GetServerCertificateInput{ ServerCertificateName: certName, } result, err := FindServerCert(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving the server certificate:\") fmt.Println(err) return } metadata := result.ServerCertificate.ServerCertificateMetadata fmt.Println(\"ARN: \" + *metadata.Arn) fmt.Println(\"Expiration: \" + (*metadata.Expiration).Format(\"2006-01-02 15:04:05 Monday\")) fmt.Println(\"Path: \" + *metadata.Path) fmt.Println(\"ServerCertificateId \" + *metadata.ServerCertificateId) fmt.Println(\"ServerCertificateName \" + *metadata.ServerCertificateName) fmt.Println(\"UploadDate: \" + (*metadata.UploadDate).Format(\"2006-01-02 15:04:05 Monday\")) fmt.Println(\"\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/getservercert/","tags":"","title":"GetServerCertv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMListAccessKeysAPI defines the interface for the ListAccessKeys function. // We use this interface to test the function using a mocked service. type IAMListAccessKeysAPI interface { ListAccessKeys(ctx context.Context, params *iam.ListAccessKeysInput, optFns ...func(*iam.Options)) (*iam.ListAccessKeysOutput, error) } // GetAccessKeys retrieves up to the AWS Identity and Access Management (IAM) access keys for a user. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a ListAccessKeysOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ListAccessKeys. func GetAccessKeys(c context.Context, api IAMListAccessKeysAPI, input *iam.ListAccessKeysInput) (*iam.ListAccessKeysOutput, error) { return api.ListAccessKeys(c, input) } func main() { maxItems := flag.Int(\"m\", 10, \"The maximum number of access keys to show\") userName := flag.String(\"u\", \"\", \"The name of the user\") flag.Parse() if *userName == \"\" { fmt.Println(\"You must supply the name of a user (-u USER)\") return } if *maxItems \u003c 0 { *maxItems = 10 } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.ListAccessKeysInput{ MaxItems: aws.Int32(int32(*maxItems)), UserName: userName, } result, err := GetAccessKeys(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving user access keys:\") fmt.Println(err) return } for _, key := range result.AccessKeyMetadata { fmt.Println(\"Status for access key \" + *key.AccessKeyId + \": \" + string(key.Status)) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/listaccesskeys/","tags":"","title":"ListAccessKeysv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMListAccountAliasesAPI defines the interface for the ListAccountAliases function. // We use this interface to test the function using a mocked service. type IAMListAccountAliasesAPI interface { ListAccountAliases(ctx context.Context, params *iam.ListAccountAliasesInput, optFns ...func(*iam.Options)) (*iam.ListAccountAliasesOutput, error) } // GetAccountAliases retrieves the aliases for your AWS Identity and Access Management (IAM) account. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a ListAccountAliasesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ListAccountAliases. func GetAccountAliases(c context.Context, api IAMListAccountAliasesAPI, input *iam.ListAccountAliasesInput) (*iam.ListAccountAliasesOutput, error) { return api.ListAccountAliases(c, input) } func main() { maxItems := flag.Int(\"m\", 10, \"Maximum number of aliases to list\") flag.Parse() if *maxItems \u003c 0 { *maxItems = 10 } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.ListAccountAliasesInput{ MaxItems: aws.Int32(int32(*maxItems)), } result, err := GetAccountAliases(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving account aliases\") fmt.Println(err) return } for i, alias := range result.AccountAliases { fmt.Printf(\"Alias %d: %s\\n\", i, alias) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/listaccountaliases/","tags":"","title":"ListAccountAliasesv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"strings\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" \"github.com/aws/aws-sdk-go-v2/service/iam/types\" ) func userPolicyHasAdmin(user types.UserDetail, admin string) bool { for _, policy := range user.UserPolicyList { if *policy.PolicyName == admin { return true } } return false } func attachedUserPolicyHasAdmin(user types.UserDetail, admin string) bool { for _, policy := range user.AttachedManagedPolicies { if *policy.PolicyName == admin { return true } } return false } func groupPolicyHasAdmin(c context.Context, client *iam.Client, group types.Group, admin string) (bool, error) { input := \u0026iam.ListGroupPoliciesInput{ GroupName: group.GroupName, } result, err := client.ListGroupPolicies(c, input) if err != nil { return false, err } // Wade through policies \tfor _, policyName := range result.PolicyNames { if policyName == admin { return true, nil } } return false, nil } func attachedGroupPolicyHasAdmin(c context.Context, client *iam.Client, group types.Group, admin string) (bool, error) { input := \u0026iam.ListAttachedGroupPoliciesInput{ GroupName: group.GroupName, } result, err := client.ListAttachedGroupPolicies(c, input) if err != nil { return false, err } for _, policy := range result.AttachedPolicies { if *policy.PolicyName == admin { return true, nil } } return false, nil } func usersGroupsHaveAdmin(c context.Context, client *iam.Client, user types.UserDetail, admin string) (bool, error) { input := \u0026iam.ListGroupsForUserInput{ UserName: user.UserName, } result, err := client.ListGroupsForUser(c, input) if err != nil { return false, err } for _, group := range result.Groups { groupPolicyHasAdmin, err := groupPolicyHasAdmin(c, client, group, admin) if err != nil { return false, err } if groupPolicyHasAdmin { return true, nil } attachedGroupPolicyHasAdmin, err := attachedGroupPolicyHasAdmin(c, client, group, admin) if err != nil { return false, err } if attachedGroupPolicyHasAdmin { return true, nil } } return false, nil } // GetNumUsersAndAdmins determines how many users have administrator privileges. // Inputs: // client is the AWS Identity and Access Management (IAM) service client. // c is the context of the method call, which includes the AWS Region. // Output: // If success, the list of users and admins, and nil. // Otherwise, \"\", \"\" and an error. func GetNumUsersAndAdmins(c context.Context, client *iam.Client) (string, string, error) { users := \"\" admins := \"\" filters := make([]types.EntityType, 1) filters[0] = types.EntityTypeUser input := \u0026iam.GetAccountAuthorizationDetailsInput{ Filter: filters, } resp, err := client.GetAccountAuthorizationDetails(c, input) if err != nil { return \"\", \"\", err } // The policy name that indicates administrator access \tadminName := \"AdministratorAccess\" // Wade through resulting users \tfor _, user := range resp.UserDetailList { isAdmin, err := isUserAdmin(c, client, user, adminName) if err != nil { return \"\", \"\", err } users += \" \" + *user.UserName if isAdmin { admins += \" \" + *user.UserName } } for resp.IsTruncated { input := \u0026iam.GetAccountAuthorizationDetailsInput{ Filter: filters, Marker: resp.Marker, } resp, err = client.GetAccountAuthorizationDetails(c, input) if err != nil { return \"\", \"\", err } // Wade through resulting users \tfor _, user := range resp.UserDetailList { isAdmin, err := isUserAdmin(c, client, user, adminName) if err != nil { return \"\", \"\", err } users += \" \" + *user.UserName if isAdmin { admins += \" \" + *user.UserName } } } return users, admins, nil } func isUserAdmin(c context.Context, client *iam.Client, user types.UserDetail, admin string) (bool, error) { // Check policy, attached policy, and groups (policy and attached policy) \tpolicyHasAdmin := userPolicyHasAdmin(user, admin) if policyHasAdmin { return true, nil } attachedPolicyHasAdmin := attachedUserPolicyHasAdmin(user, admin) if attachedPolicyHasAdmin { return true, nil } userGroupsHaveAdmin, err := usersGroupsHaveAdmin(c, client, user, admin) if err != nil { return false, err } if userGroupsHaveAdmin { return true, nil } return false, nil } func main() { showDetails := flag.Bool(\"d\", false, \"Whether to print out names of users and admins\") flag.Parse() cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) users, admins, err := GetNumUsersAndAdmins(context.TODO(), client) if err != nil { fmt.Println(\"Got an error finding users who are admins:\") fmt.Println(err) return } userList := strings.Split(users, \" \") adminList := strings.Split(admins, \" \") fmt.Println(\"\") fmt.Println(\"Found\", len(adminList)-1, \"admin(s) out of\", len(userList)-1, \"user(s)\") if *showDetails { fmt.Println(\"\") fmt.Println(\"Users\") for _, u := range userList { fmt.Println(\" \" + u) } fmt.Println(\"\") fmt.Println(\"Admins\") for _, a := range adminList { fmt.Println(\" \" + a) } } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/listadmins/","tags":"","title":"ListAdminsv2"},{"body":"ListBucketsv2.go This example lists your Amazon S3 buckets.\ngo run ListBucketsv2.go\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3ListBucketsAPI defines the interface for the ListBuckets function. // We use this interface to test the function using a mocked service. type S3ListBucketsAPI interface { ListBuckets(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options)) (*s3.ListBucketsOutput, error) } // GetAllBuckets retrieves a list of your Amazon Simple Storage Service (Amazon S3) buckets. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a ListBucketsOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ListBuckets. func GetAllBuckets(c context.Context, api S3ListBucketsAPI, input *s3.ListBucketsInput) (*s3.ListBucketsOutput, error) { return api.ListBuckets(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.ListBucketsInput{} result, err := GetAllBuckets(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving buckets:\") fmt.Println(err) return } fmt.Println(\"Buckets:\") for _, bucket := range result.Buckets { fmt.Println(*bucket.Name + \": \" + bucket.CreationDate.Format(\"2006-01-02 15:04:05 Monday\")) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ListBucketsv2.go This example lists your Amazon S3 buckets.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/listbuckets/","tags":"","title":"ListBucketsv2"},{"body":"ListMetricsv2.go This example displays the name, namespace, and dimension name of your Amazon CloudWatch metrics.\ngo run ListMetricsv2.go\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"fmt\" \"strconv\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatch\" ) // CWListMetricsAPI defines the interface for the ListMetrics function. // We use this interface to test the function using a mocked service. type CWListMetricsAPI interface { ListMetrics(ctx context.Context, params *cloudwatch.ListMetricsInput, optFns ...func(*cloudwatch.Options)) (*cloudwatch.ListMetricsOutput, error) } // GetMetrics gets the name, namespace, and dimension name of your Amazon CloudWatch metrics // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a ListMetricsOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to ListMetrics func GetMetrics(c context.Context, api CWListMetricsAPI, input *cloudwatch.ListMetricsInput) (*cloudwatch.ListMetricsOutput, error) { return api.ListMetrics(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := cloudwatch.NewFromConfig(cfg) input := \u0026cloudwatch.ListMetricsInput{} result, err := GetMetrics(context.TODO(), client, input) if err != nil { fmt.Println(\"Could not get metrics\") return } fmt.Println(\"Metrics:\") numMetrics := 0 for _, m := range result.Metrics { fmt.Println(\" Metric Name: \" + *m.MetricName) fmt.Println(\" Namespace: \" + *m.Namespace) fmt.Println(\" Dimensions:\") for _, d := range m.Dimensions { fmt.Println(\" \" + *d.Name + \": \" + *d.Value) } fmt.Println(\"\") numMetrics++ } fmt.Println(\"Found \" + strconv.Itoa(numMetrics) + \" metrics\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ListMetricsv2.go This example displays the name, namespace, and …","ref":"/aws-sdk-go-v2/docs/code-examples/cloudwatch/listmetrics/","tags":"","title":"ListMetricsv2"},{"body":"ListObjectsv2.go This example lists the objects in an Amazon S3 bucket.\ngo run ListObjectsv2.go -b BUCKET\n BUCKET is the name of the bucket for which the objects are listed.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3ListObjectsAPI defines the interface for the ListObjectsV2 function. // We use this interface to test the function using a mocked service. type S3ListObjectsAPI interface { ListObjectsV2(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options)) (*s3.ListObjectsV2Output, error) } // GetObjects retrieves the objects in an Amazon Simple Storage Service (Amazon S3) bucket // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a ListObjectsV2Output object containing the result of the service call and nil // Otherwise, nil and an error from the call to ListObjectsV2 func GetObjects(c context.Context, api S3ListObjectsAPI, input *s3.ListObjectsV2Input) (*s3.ListObjectsV2Output, error) { return api.ListObjectsV2(c, input) } func main() { bucket := flag.String(\"b\", \"\", \"The name of the bucket\") flag.Parse() if *bucket == \"\" { fmt.Println(\"You must supply the name of a bucket (-b BUCKET)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) input := \u0026s3.ListObjectsV2Input{ Bucket: bucket, } resp, err := GetObjects(context.TODO(), client, input) if err != nil { fmt.Println(\"Got error retrieving list of objects:\") fmt.Println(err) return } fmt.Println(\"Objects in \" + *bucket + \":\") for _, item := range resp.Contents { fmt.Println(\"Name: \", *item.Key) fmt.Println(\"Last modified: \", *item.LastModified) fmt.Println(\"Size: \", item.Size) fmt.Println(\"Storage class: \", item.StorageClass) fmt.Println(\"\") } fmt.Println(\"Found\", len(resp.Contents), \"items in bucket\", *bucket) fmt.Println(\"\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ListObjectsv2.go This example lists the objects in an Amazon S3 …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/listobjects/","tags":"","title":"ListObjectsv2"},{"body":"ListQueuesv2.go This example retrieves a list of your Amazon SQS queues.\ngo run ListQueuesv2.go\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) // SQSListQueuesAPI defines the interface for the ListQueues function. // We use this interface to test the function using a mocked service. type SQSListQueuesAPI interface { ListQueues(ctx context.Context, params *sqs.ListQueuesInput, optFns ...func(*sqs.Options)) (*sqs.ListQueuesOutput, error) } // GetQueues retrieves a list of your Amazon Simple Queue Service (Amazon SQS) queues. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a ListQueuesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ListQueues. func GetQueues(c context.Context, api SQSListQueuesAPI, input *sqs.ListQueuesInput) (*sqs.ListQueuesOutput, error) { return api.ListQueues(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) input := \u0026sqs.ListQueuesInput{} result, err := GetQueues(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving queue URLs:\") fmt.Println(err) return } for i, url := range result.QueueUrls { fmt.Printf(\"%d: %s\\n\", i+1, url) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ListQueuesv2.go This example retrieves a list of your Amazon SQS …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/listqueues/","tags":"","title":"ListQueuesv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMListServerCertificatesAPI defines the interface for the ListServerCertificates function. // We use this interface to test the function using a mocked service. type IAMListServerCertificatesAPI interface { ListServerCertificates(ctx context.Context, params *iam.ListServerCertificatesInput, optFns ...func(*iam.Options)) (*iam.ListServerCertificatesOutput, error) } // GetServerCerts retrieves the server certificates. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a ListServerCertificatesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ListServerCertificates. func GetServerCerts(c context.Context, api IAMListServerCertificatesAPI, input *iam.ListServerCertificatesInput) (*iam.ListServerCertificatesOutput, error) { return api.ListServerCertificates(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.ListServerCertificatesInput{} result, err := GetServerCerts(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving the server certificates:\") fmt.Println(err) return } if len(result.ServerCertificateMetadataList) \u003c 1 { fmt.Println(\"Could not find any server certificates\") return } for _, metadata := range result.ServerCertificateMetadataList { fmt.Println(\"ARN: \" + *metadata.Arn) fmt.Println(\"Expiration: \" + (*metadata.Expiration).Format(\"2006-01-02 15:04:05 Monday\")) fmt.Println(\"Path: \" + *metadata.Path) fmt.Println(\"ServerCertificateId \" + *metadata.ServerCertificateId) fmt.Println(\"ServerCertificateName \" + *metadata.ServerCertificateName) fmt.Println(\"UploadDate: \" + (*metadata.UploadDate).Format(\"2006-01-02 15:04:05 Monday\")) fmt.Println(\"\") } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/listservercerts/","tags":"","title":"ListServerCertsv2"},{"body":"ListSubscriptionsv2.go This example lists the topic and subscription Amazon Resource Names (ARNs) for your Amazon SNS subscriptions.\ngo run ListSubscriptionsv2.go\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sns\" ) // SNSListSubscriptionsAPI defines the interface for the ListSubscriptions function. // We use this interface to test the function using a mocked service. type SNSListSubscriptionsAPI interface { ListSubscriptions(ctx context.Context, params *sns.ListSubscriptionsInput, optFns ...func(*sns.Options)) (*sns.ListSubscriptionsOutput, error) } // GetSubscriptions retrieves a list of your Amazon Simple Notification Service (Amazon SNS) subscriptions. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a ListSubscriptionsOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ListSubscriptions. func GetSubscriptions(c context.Context, api SNSListSubscriptionsAPI, input *sns.ListSubscriptionsInput) (*sns.ListSubscriptionsOutput, error) { return api.ListSubscriptions(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sns.NewFromConfig(cfg) input := \u0026sns.ListSubscriptionsInput{} result, err := GetSubscriptions(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving the subscriptions:\") fmt.Println(err) return } fmt.Println(\"Topic ARN\") fmt.Println(\"Subscription ARN\") fmt.Println(\"-------------------------\") for _, s := range result.Subscriptions { fmt.Println(*s.TopicArn) fmt.Println(*s.SubscriptionArn) fmt.Println(\"\") } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ListSubscriptionsv2.go This example lists the topic and subscription …","ref":"/aws-sdk-go-v2/docs/code-examples/sns/listsubscriptions/","tags":"","title":"ListSubscriptionsv2"},{"body":"ListTopicsv2.go This example lists the ARNs for your Amazon SNS topics.\ngo run ListTopicsv2.go\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sns\" ) // SNSListTopicsAPI defines the interface for the ListTopics function. // We use this interface to test the function using a mocked service. type SNSListTopicsAPI interface { ListTopics(ctx context.Context, params *sns.ListTopicsInput, optFns ...func(*sns.Options)) (*sns.ListTopicsOutput, error) } // GetTopics retrieves information about the Amazon Simple Notification Service (Amazon SNS) topics // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a ListTopicsOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to ListTopics func GetTopics(c context.Context, api SNSListTopicsAPI, input *sns.ListTopicsInput) (*sns.ListTopicsOutput, error) { return api.ListTopics(c, input) } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sns.NewFromConfig(cfg) input := \u0026sns.ListTopicsInput{} results, err := GetTopics(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving information about the SNS topics:\") fmt.Println(err) return } for _, t := range results.Topics { fmt.Println(*t.TopicArn) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ListTopicsv2.go This example lists the ARNs for your Amazon SNS …","ref":"/aws-sdk-go-v2/docs/code-examples/sns/listtopics/","tags":"","title":"ListTopicsv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMListUsersAPI defines the interface for the ListUsers function. // We use this interface to test the function using a mocked service. type IAMListUsersAPI interface { ListUsers(ctx context.Context, params *iam.ListUsersInput, optFns ...func(*iam.Options)) (*iam.ListUsersOutput, error) } // GetUsers retrieves a list of your AWS Identity and Access Management (IAM) users. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a ListUsersOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ListUsers. func GetUsers(c context.Context, api IAMListUsersAPI, input *iam.ListUsersInput) (*iam.ListUsersOutput, error) { return api.ListUsers(c, input) } func main() { maxUsers := flag.Int(\"m\", 10, \"The maximum number of users to return\") flag.Parse() if *maxUsers \u003c 0 { *maxUsers = 10 } if *maxUsers \u003e 100 { *maxUsers = 1000 } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.ListUsersInput{ MaxItems: aws.Int32(int32((*maxUsers))), } result, err := GetUsers(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error retrieving users:\") fmt.Println(err) return } for _, user := range result.Users { fmt.Println(*user.UserName+\" created on\", *user.CreateDate) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/listusers/","tags":"","title":"ListUsersv2"},{"body":"MonitorInstancesv2.go This example enables or disables monitoring for an Amazon EC2 instance.\ngo run MonitorInstancesv2.go -m MODE -i INSTANCE-ID\n MODE is either “OFF” to disable monitoring or “ON” to enable monitoring. INSTANCE-ID is the ID of the instance.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"errors\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ec2\" \"github.com/aws/smithy-go\" ) // EC2MonitorInstancesAPI defines the interface for the MonitorInstances and UnmonitorInstances functions. // We use this interface to test the function using a mocked service. type EC2MonitorInstancesAPI interface { MonitorInstances(ctx context.Context, params *ec2.MonitorInstancesInput, optFns ...func(*ec2.Options)) (*ec2.MonitorInstancesOutput, error) UnmonitorInstances(ctx context.Context, params *ec2.UnmonitorInstancesInput, optFns ...func(*ec2.Options)) (*ec2.UnmonitorInstancesOutput, error) } // EnableMonitoring enables monitoring for an Amazon EC2 instance. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a MonitorInstancesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to MonitorInstances. func EnableMonitoring(c context.Context, api EC2MonitorInstancesAPI, input *ec2.MonitorInstancesInput) (*ec2.MonitorInstancesOutput, error) { resp, err := api.MonitorInstances(c, input) // Do we have a DryRunOperation error? \tvar apiErr smithy.APIError if errors.As(err, \u0026apiErr) \u0026\u0026 apiErr.ErrorCode() == \"DryRunOperation\" { fmt.Println(\"User has permission to enable monitoring.\") input.DryRun = false return api.MonitorInstances(c, input) } return resp, err } // DisableMonitoring disables monitoring for an Amazon EC2 instance. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a UnmonitorInstancesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to UnmonitorInstances. func DisableMonitoring(c context.Context, api EC2MonitorInstancesAPI, input *ec2.UnmonitorInstancesInput) (*ec2.UnmonitorInstancesOutput, error) { resp, err := api.UnmonitorInstances(c, input) // Do we have a DryRunOperation error? \tvar apiErr smithy.APIError if errors.As(err, \u0026apiErr) \u0026\u0026 apiErr.ErrorCode() == \"DryRunOperation\" { fmt.Println(\"User has permission to disable monitoring.\") input.DryRun = false return api.UnmonitorInstances(c, input) } return resp, err } func main() { monitor := flag.String(\"m\", \"\", \"ON to enable monitoring; OFF to disable monitoring\") instanceID := flag.String(\"i\", \"\", \"The ID of the instance to monitor\") flag.Parse() fmt.Println(\"Monitor: \" + *monitor) fmt.Println(\"InstanceID: \" + *instanceID) if *instanceID == \"\" || (*monitor != \"ON\" \u0026\u0026 *monitor != \"OFF\") { fmt.Println(\"You must supply the ID of the instance to enable/disable monitoring (-i INSTANCE-ID)\") fmt.Println(\"and whether to enable monitoring (-m ON) or disable monitoring (-m OFF)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ec2.NewFromConfig(cfg) if *monitor == \"ON\" { input := \u0026ec2.MonitorInstancesInput{ InstanceIds: []string{ *instanceID, }, DryRun: true, } result, err := EnableMonitoring(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error enabling monitoring for instance:\") fmt.Println(err) return } fmt.Println(\"Successfully enabled monitoring for instance: \" + *result.InstanceMonitorings[0].InstanceId) } else if *monitor == \"OFF\" { input := \u0026ec2.UnmonitorInstancesInput{ InstanceIds: []string{ *instanceID, }, DryRun: true, } result, err := DisableMonitoring(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error disabling monitoring for instance:\") fmt.Println(err) return } fmt.Println(\"Successfully disabled monitoring for instance: \" + *result.InstanceMonitorings[0].InstanceId) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"MonitorInstancesv2.go This example enables or disables monitoring for …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/monitorinstances/","tags":"","title":"MonitorInstancesv2"},{"body":"Publishv2.go This example publishes a message to an Amazon SNS topic.\ngo run Publishv2.go -m MESSAGE -t TOPIC-ARN\n MESSAGE is the message to publish. TOPIC-ARN is the ARN of the topic to which the message is published.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sns\" ) // SNSPublishAPI defines the interface for the Publish function. // We use this interface to test the function using a mocked service. type SNSPublishAPI interface { Publish(ctx context.Context, params *sns.PublishInput, optFns ...func(*sns.Options)) (*sns.PublishOutput, error) } // PublishMessage publishes a message to an Amazon Simple Notification Service (Amazon SNS) topic // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a PublishOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to Publish func PublishMessage(c context.Context, api SNSPublishAPI, input *sns.PublishInput) (*sns.PublishOutput, error) { return api.Publish(c, input) } func main() { msg := flag.String(\"m\", \"\", \"The message to send to the subscribed users of the topic\") topicARN := flag.String(\"t\", \"\", \"The ARN of the topic to which the user subscribes\") flag.Parse() if *msg == \"\" || *topicARN == \"\" { fmt.Println(\"You must supply a message and topic ARN\") fmt.Println(\"-m MESSAGE -t TOPIC-ARN\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sns.NewFromConfig(cfg) input := \u0026sns.PublishInput{ Message: msg, TopicArn: topicARN, } result, err := PublishMessage(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error publishing the message:\") fmt.Println(err) return } fmt.Println(\"Message ID: \" + *result.MessageId) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"Publishv2.go This example publishes a message to an Amazon SNS topic. …","ref":"/aws-sdk-go-v2/docs/code-examples/sns/publish/","tags":"","title":"Publishv2"},{"body":"PutEventv2.go This example sends an Amazon CloudWatch event to Amazon EventBridge.\ngo run PutEventv2.go -l LAMBDA-ARN -f EVENT-FILE\n LAMBDA-ARN is the ARN of the AWS Lambda function of which the event is concerned. EVENT-FILE is the local file specifying details of the event to send to Amazon EventBridge.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"encoding/json\" \"flag\" \"fmt\" \"io/ioutil\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatchevents\" \"github.com/aws/aws-sdk-go-v2/service/cloudwatchevents/types\" ) // CWEPutEventsAPI defines the interface for the PutEvents function. // We use this interface to test the function using a mocked service. type CWEPutEventsAPI interface { PutEvents(ctx context.Context, params *cloudwatchevents.PutEventsInput, optFns ...func(*cloudwatchevents.Options)) (*cloudwatchevents.PutEventsOutput, error) } // Event represents the information for a new event type Event struct { Details []struct { Key string `json:\"Key\"` Value string `json:\"Value\"` } `json:\"Details\"` DetailType string `json:\"DetailType\"` Source string `json:\"Source\"` } func getEventInfo(eventFile string) (Event, error) { var e Event content, err := ioutil.ReadFile(eventFile) if err != nil { return e, err } // Convert []byte to string \ttext := string(content) // Marshall JSON string in text into global struct \terr = json.Unmarshal([]byte(text), \u0026e) if err != nil { return e, err } // Make sure we got the info we need \tif e.DetailType == \"\" { e.DetailType = \"appRequestSubmitted\" } if e.Source == \"\" { e.Source = \"com.mycompany.myapp\" } if e.Details == nil { d := []byte(`\"{ \"key1\": \"value1\", \"key2\": \"value2\" }`) e.DetailType = string(d[:]) } return e, nil } // CreateEvent sends an Amazon CloudWatch event to Amazon EventBridge // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a PutEventsOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to PutEvents func CreateEvent(c context.Context, api CWEPutEventsAPI, input *cloudwatchevents.PutEventsInput) (*cloudwatchevents.PutEventsOutput, error) { return api.PutEvents(c, input) } func main() { lambdaARN := flag.String(\"l\", \"\", \"The ARN of the AWS Lambda function\") eventFile := flag.String(\"f\", \"\", \"The JSON file containing the event to send\") flag.Parse() if *lambdaARN == \"\" || *eventFile == \"\" { fmt.Println(\"You must supply a Lambda ARN with -l LAMBDA-ARN and event file with -f EVENT-FILE.json\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := cloudwatchevents.NewFromConfig(cfg) event, err := getEventInfo(*eventFile) if err != nil { fmt.Println(\"Got an error calling getEventInfo:\") fmt.Println(err) return } myDetails := \"{ \" for _, d := range event.Details { myDetails = myDetails + \"\\\"\" + d.Key + \"\\\": \\\"\" + d.Value + \"\\\",\" } myDetails = myDetails + \" }\" input := \u0026cloudwatchevents.PutEventsInput{ Entries: []types.PutEventsRequestEntry{ { Detail: \u0026myDetails, DetailType: \u0026event.DetailType, Resources: []string{ *lambdaARN, }, Source: \u0026event.Source, }, }, } _, err = CreateEvent(context.TODO(), client, input) if err != nil { fmt.Println(\"Could not create event:\") fmt.Println(err) return } fmt.Println(\"Created event\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"PutEventv2.go This example sends an Amazon CloudWatch event to Amazon …","ref":"/aws-sdk-go-v2/docs/code-examples/cloudwatch/putevent/","tags":"","title":"PutEventv2"},{"body":"PutObjectv2.go This example creates an Amazon S3 bucket object from a local file.\ngo run PutObjectv2.go -b BUCKET -f FILE\n BUCKET is the name of the bucket to which the file is uploaded. FILE is the name of the local file to upload.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"os\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) // S3PutObjectAPI defines the interface for the PutObject function. // We use this interface to test the function using a mocked service. type S3PutObjectAPI interface { PutObject(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error) } // PutFile uploads a file to an Amazon Simple Storage Service (Amazon S3) bucket // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a PutObjectOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to PutObject func PutFile(c context.Context, api S3PutObjectAPI, input *s3.PutObjectInput) (*s3.PutObjectOutput, error) { return api.PutObject(c, input) } func main() { bucket := flag.String(\"b\", \"\", \"The bucket to upload the file to\") filename := flag.String(\"f\", \"\", \"The file to upload\") flag.Parse() if *bucket == \"\" || *filename == \"\" { fmt.Println(\"You must supply a bucket name (-b BUCKET) and file name (-f FILE)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := s3.NewFromConfig(cfg) file, err := os.Open(*filename) if err != nil { fmt.Println(\"Unable to open file \" + *filename) return } defer file.Close() input := \u0026s3.PutObjectInput{ Bucket: bucket, Key: filename, Body: file, } _, err = PutFile(context.TODO(), client, input) if err != nil { fmt.Println(\"Got error uploading file:\") fmt.Println(err) return } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"PutObjectv2.go This example creates an Amazon S3 bucket object from a …","ref":"/aws-sdk-go-v2/docs/code-examples/s3/putobject/","tags":"","title":"PutObjectv2"},{"body":"PutParameterv2.go This example creates a Systems Manager string parameter.\ngo run PutParameterv2.go -n NAME -v VALUE\n NAME is the name of the parameter to create. VALUE is the value of the parameter to create.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ssm\" \"github.com/aws/aws-sdk-go-v2/service/ssm/types\" ) // SSMPutParameterAPI defines the interface for the PutParameter function. // We use this interface to test the function using a mocked service. type SSMPutParameterAPI interface { PutParameter(ctx context.Context, params *ssm.PutParameterInput, optFns ...func(*ssm.Options)) (*ssm.PutParameterOutput, error) } // AddStringParameter creates an AWS Systems Manager string parameter // Inputs: // c is the context of the method call, which includes the AWS Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a PutParameterOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to PutParameter func AddStringParameter(c context.Context, api SSMPutParameterAPI, input *ssm.PutParameterInput) (*ssm.PutParameterOutput, error) { return api.PutParameter(c, input) } func main() { parameterName := flag.String(\"n\", \"\", \"The name of the parameter\") parameterValue := flag.String(\"v\", \"\", \"The value of the parameter\") flag.Parse() if *parameterName == \"\" { fmt.Println(\"You must supply the name of the parameter\") fmt.Println(\"-n NAME\") return } if *parameterValue == \"\" { fmt.Println(\"You must supply the value of the parameter\") fmt.Println(\"-v VALUE\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ssm.NewFromConfig(cfg) input := \u0026ssm.PutParameterInput{ Name: parameterName, Value: parameterValue, Type: types.ParameterTypeString, } results, err := AddStringParameter(context.TODO(), client, input) if err != nil { fmt.Println(err.Error()) return } fmt.Println(\"Parameter version:\", results.Version) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"PutParameterv2.go This example creates a Systems Manager string …","ref":"/aws-sdk-go-v2/docs/code-examples/ssm/putparameter/","tags":"","title":"PutParameterv2"},{"body":"RebootInstancesv2.go This example reboots an Amazon EC2 instance.\ngo run RebootInstancesv2.go -i INSTANCE-ID\n INSTANCE-ID is the ID of the instance to reboot.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"errors\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ec2\" \"github.com/aws/smithy-go\" ) // EC2RebootInstancesAPI defines the interface for the RebootInstances function. // We use this interface to test the function using a mocked service. type EC2RebootInstancesAPI interface { RebootInstances(ctx context.Context, params *ec2.RebootInstancesInput, optFns ...func(*ec2.Options)) (*ec2.RebootInstancesOutput, error) } // RebootInstance reboots an Amazon Elastic Compute Cloud (Amazon EC2) instance. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a RebootInstancesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to RebootInstances. func RebootInstance(c context.Context, api EC2RebootInstancesAPI, input *ec2.RebootInstancesInput) (*ec2.RebootInstancesOutput, error) { resp, err := api.RebootInstances(c, input) var apiErr smithy.APIError if errors.As(err, \u0026apiErr) \u0026\u0026 apiErr.ErrorCode() == \"DryRunOperation\" { fmt.Println(\"User has permission to enable monitoring.\") input.DryRun = false return api.RebootInstances(c, input) } return resp, err } func main() { instanceID := flag.String(\"i\", \"\", \"The ID of the instance to reboot\") flag.Parse() if *instanceID == \"\" { fmt.Println(\"You must supply an instance ID (-i INSTANCE-ID\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ec2.NewFromConfig(cfg) input := \u0026ec2.RebootInstancesInput{ InstanceIds: []string{ *instanceID, }, DryRun: true, } _, err = RebootInstance(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error rebooting the instance\") fmt.Println(err) return } fmt.Println(\"Rebooted instance with ID \" + *instanceID) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"RebootInstancesv2.go This example reboots an Amazon EC2 instance.\ngo …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/rebootinstances/","tags":"","title":"RebootInstancesv2"},{"body":"ReceiveLPMessagev2.go This example gets the most recent message from a long-polling Amazon SQS queue.\ngo run ReceiveLPMessagev2.go -q QUEUE-NAME\n QUEUE-NAME is the name of the queue from which the message is retrieved.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" \"github.com/aws/aws-sdk-go-v2/service/sqs/types\" ) // SQSGetLPMsgAPI defines the interface for the GetQueueUrl and ReceiveMessage functions. // We use this interface to test the functions using a mocked service. type SQSGetLPMsgAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) ReceiveMessage(ctx context.Context, params *sqs.ReceiveMessageInput, optFns ...func(*sqs.Options)) (*sqs.ReceiveMessageOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSGetLPMsgAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } // GetLPMessages gets the messages from an Amazon SQS long polling queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a ReceiveMessageOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ReceiveMessage. func GetLPMessages(c context.Context, api SQSGetLPMsgAPI, input *sqs.ReceiveMessageInput) (*sqs.ReceiveMessageOutput, error) { return api.ReceiveMessage(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") waitTime := flag.Int(\"w\", 10, \"How long the queue waits for messages\") flag.Parse() if *queue == \"\" { fmt.Println(\"You must supply a queue name (-q QUEUE\") return } if *waitTime \u003c 0 { *waitTime = 0 } if *waitTime \u003e 20 { *waitTime = 20 } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) qInput := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } result, err := GetQueueURL(context.TODO(), client, qInput) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } queueURL := result.QueueUrl mInput := \u0026sqs.ReceiveMessageInput{ QueueUrl: queueURL, AttributeNames: []types.QueueAttributeName{ \"SentTimestamp\", }, MaxNumberOfMessages: 1, MessageAttributeNames: []string{ \"All\", }, WaitTimeSeconds: int32(*waitTime), } resp, err := GetLPMessages(context.TODO(), client, mInput) if err != nil { fmt.Println(\"Got an error receiving messages:\") fmt.Println(err) return } fmt.Println(\"Message IDs:\") for _, msg := range resp.Messages { fmt.Println(\" \" + *msg.MessageId) } } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ReceiveLPMessagev2.go This example gets the most recent message from a …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/receivelpmessage/","tags":"","title":"ReceiveLPMessagev2"},{"body":"ReceiveMessagev2.go This example gets the most recent message from an Amazon SQS queue.\ngo run ReceiveMessagev2.go -q QUEUE-NAME\n QUEUE-NAME is the name of the queue from which the message is retrieved.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" \"github.com/aws/aws-sdk-go-v2/service/sqs/types\" ) // SQSReceiveMessageAPI defines the interface for the GetQueueUrl function. // We use this interface to test the function using a mocked service. type SQSReceiveMessageAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) ReceiveMessage(ctx context.Context, params *sqs.ReceiveMessageInput, optFns ...func(*sqs.Options)) (*sqs.ReceiveMessageOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSReceiveMessageAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } // GetMessages gets the most recent message from an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a ReceiveMessageOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ReceiveMessage. func GetMessages(c context.Context, api SQSReceiveMessageAPI, input *sqs.ReceiveMessageInput) (*sqs.ReceiveMessageOutput, error) { return api.ReceiveMessage(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") timeout := flag.Int(\"t\", 5, \"How long, in seconds, that the message is hidden from others\") flag.Parse() if *queue == \"\" { fmt.Println(\"You must supply the name of a queue (-q QUEUE)\") return } if *timeout \u003c 0 { *timeout = 0 } if *timeout \u003e 12*60*60 { *timeout = 12 * 60 * 60 } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) gQInput := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } // Get URL of queue \turlResult, err := GetQueueURL(context.TODO(), client, gQInput) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } queueURL := urlResult.QueueUrl gMInput := \u0026sqs.ReceiveMessageInput{ MessageAttributeNames: []string{ string(types.QueueAttributeNameAll), }, QueueUrl: queueURL, MaxNumberOfMessages: 1, VisibilityTimeout: int32(*timeout), } msgResult, err := GetMessages(context.TODO(), client, gMInput) if err != nil { fmt.Println(\"Got an error receiving messages:\") fmt.Println(err) return } fmt.Println(\"Message ID: \" + *msgResult.Messages[0].MessageId) fmt.Println(\"Message Handle: \" + *msgResult.Messages[0].ReceiptHandle) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ReceiveMessagev2.go This example gets the most recent message from an …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/receivemessage/","tags":"","title":"ReceiveMessagev2"},{"body":"ReEncryptDatav2.go This example reencrypts some text using an AWS Key Management Service (AWS KMS) customer master key (CMK).\ngo run ReEncryptDatav2.go -k KeyID -d DATA\n KeyID is the ID of the AWS KMS key to use for reencrypting the data. DATA is the data to reencrypt, as a string.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/kms\" ) // KMSReEncryptAPI defines the interface for the ReEncrypt function. // We use this interface to test the function using a mocked service. type KMSReEncryptAPI interface { ReEncrypt(ctx context.Context, params *kms.ReEncryptInput, optFns ...func(*kms.Options)) (*kms.ReEncryptOutput, error) } // ReEncryptText reencrypts some text using a new AWS Key Management Service (AWS KMS) customer master key (CMK). // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a ReEncryptOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to ReEncrypt. func ReEncryptText(c context.Context, api KMSReEncryptAPI, input *kms.ReEncryptInput) (*kms.ReEncryptOutput, error) { return api.ReEncrypt(c, input) } func main() { keyID := flag.String(\"k\", \"\", \"The ID of a KMS key\") data := flag.String(\"d\", \"\", \"The data to reencrypt, as a string\") flag.Parse() if *keyID == \"\" || *data == \"\" { fmt.Println(\"You must supply the ID of a KMS key and data\") fmt.Println(\"-k KEY-ID -d DATA\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := kms.NewFromConfig(cfg) blob := []byte(*data) input := \u0026kms.ReEncryptInput{ CiphertextBlob: blob, DestinationKeyId: keyID, } result, err := ReEncryptText(context.TODO(), client, input) if err != nil { fmt.Println(\"Got error reencrypting data:\") fmt.Println(err) return } fmt.Println(\"Blob (base-64 byte array):\") fmt.Println(result.CiphertextBlob) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ReEncryptDatav2.go This example reencrypts some text using an AWS Key …","ref":"/aws-sdk-go-v2/docs/code-examples/kms/reencryptdata/","tags":"","title":"ReEncryptDatav2"},{"body":"The AWS SDK for Go V2 enables you to configure the retry behavior of requests to HTTP services. By default, service clients use retry.Standard as their default retryer. If the default configuration or behavior does not meet your application requirements, you can adjust the retryer configuration or provide your own retryer implementation.\nThe AWS SDK for Go V2 provides a aws.Retryer interface that defines the set of methods required by a retry implementation to implement. The SDK provides two implementations for retries: retry.Standard and aws.NoOpRetryer.\nStandard Retryer The retry.Standard retryer is the default aws.Retryer implementation used by SDK clients. The standard retryer is a rate limited retryer with a configurable number of max attempts, and the ability to tune the request back off policy.\nThe following table defines the default values for this retryer:\n   Property Default     Max Number of Attempts 3   Max Back Off Delay 20 seconds    When a retryable error occurs while invoking your request, the standard retryer will use its provided configuration to delay and subsequently retry the request. Retries add to the overall latency of your request, and you must configure retryer if the default configuration does not meet your application requirements.\nSee the retry package documentation for details on what errors are considered as retryable by the standard retryer implementation.\nNopRetryer The aws.NopRetryer is a aws.Retryer implementation that is provided if you wish to disable all retry attempts. When invoking a service client operation, this retryer will only allow the request to be attempted once, and any resulting error will be returned to the calling application.\nCustomizing Behavior The SDK provides a set of helper utilities that wrap an aws.Retryer implementation, and returns the provided retryer wrapped with the desired retry behavior. You can override the default retryer for all clients, per client, or per operation depending on your applications requirements. To see additional examples showing how to do this see the retry package documentation examples.\nIf specifying a global aws.Retryer implementation using config.WithRetryer, you must ensure that you return a new instance of the aws.Retryer each invocation. This will ensure that you won’t create a global retry token bucket across all service clients.  Limiting the max number of attempts You use retry.AddWithMaxAttempts to wrap an aws.Retryer implementation to set the max number attempts to your desired value. Setting max attempts to zero will allow the SDK to retry all retryable errors until the request succeeds, or a non-retryable error is returned.\nFor example, you can the following code to wrap the standard client retryer with a maximum of five attempts:\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/aws/retry\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRetryer(func() aws.Retryer { return retry.AddWithMaxAttempts(retry.NewStandard(), 5) })) if err != nil { return err } client := s3.NewFromConfig(cfg) Limiting the max back off delay You use retry.AddWithMaxBackoffDelay to wrap an aws.Retryer implementation and limit the max back off delay that is allowed to occur between retrying a failed request.\nFor example, you can the following code to wrap the standard client retryer with a desired max delay of five seconds:\nimport \"context\" import \"time\" import \"github.com/aws/aws-sdk-go-v2/aws/retry\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRetryer(func() aws.Retryer { return retry.AddWithMaxBackoffDelay(retry.NewStandard(), time.Second*5) })) if err != nil { return err } client := s3.NewFromConfig(cfg) Retry additional API error codes You use retry.AddWithErrorCodes to wrap an aws.Retryer implementation and include additional API error codes that should be considered retryable.\nFor example, you can the following code to wrap the standard client retryer to include the Amazon S3 NoSuchBucketException exception as retryable.\nimport \"context\" import \"time\" import \"github.com/aws/aws-sdk-go-v2/aws/retry\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/aws-sdk-go-v2/service/s3/types\" // ...  cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRetryer(func() aws.Retryer { return retry.AddWithErrorCodes(retry.NewStandard(), (*types.NoSuchBucketException)(nil).ErrorCode()) })) if err != nil { return err } client := s3.NewFromConfig(cfg) Timeouts You use the context package to set timeouts or deadlines when invoking a service client operation. Use the context.WithDeadline to wrap your applications context and set a deadline to a specific time by which the invoked operation must be completed. To set a timeout after a certain time.Duration use context.WithTimeout. The SDK passes the provided context.Context to the HTTP transport client when invoking a service API. If the context passed to the SDK is cancelled or becomes cancelled while invoking the operation, the SDK will not retry the request further and will return to the calling application. You must handle context cancellation appropriately in your application in cases where the context provided to the SDK has become cancelled.\nSetting a timeout The following example shows how to set a timeout for a service client operation.\nimport \"context\" import \"time\" // ...  ctx := context.TODO() // or appropriate context.Context value for your application  client := s3.NewFromConfig(cfg) // create a new context from the previous ctx with a timeout, e.g. 5 seconds ctx, cancel := context.WithTimeout(ctx, 5*time.Second) defer cancel() resp, err := client.GetObject(ctx, \u0026s3.GetObjectInput{ // input parameters }) if err != nil { // handle error } ","categories":"","description":"","excerpt":"The AWS SDK for Go V2 enables you to configure the retry behavior of …","ref":"/aws-sdk-go-v2/docs/configuring-sdk/retries-timeouts/","tags":"","title":"Retries and Timeouts"},{"body":"ScanItemsv2.go This example retrieves the Amazon DynamoDB items with a rating above a specified value in a specified year.\ngo run ScanItemsv2.go -t TABLE -r RATING -y YEAR\n TABLE is the name of the table. RATING is the rating of the item, from 0.0 to 10.0. YEAR is the year of the item, which must be greater than 1900.  The unit test accepts similar values in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX-License-Identifier: Apache-2.0 package main import ( \"context\" \"flag\" \"fmt\" \"strconv\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue\" \"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression\" \"github.com/aws/aws-sdk-go-v2/service/dynamodb\" ) // DynamoDBScanAPI defines the interface for the Scan function. // We use this interface to test the function using a mocked service. type DynamoDBScanAPI interface { Scan(ctx context.Context, params *dynamodb.ScanInput, optFns ...func(*dynamodb.Options)) (*dynamodb.ScanOutput, error) } // Item holds info about the items returned by Scan type Item struct { Title string Info struct { Rating float64 } } // GetItems retrieves the Amazon DynamoDB items above a minimum rating in a specified year. // Note that this example only works if the table has a schema with: // year as a number (int) // info.rating as a number (float) // title as a string // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a ScanOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to Scan. func GetItems(c context.Context, api DynamoDBScanAPI, input *dynamodb.ScanInput) (*dynamodb.ScanOutput, error) { return api.Scan(c, input) } // Get the items above a minimum rating in a specific year. func main() { table := flag.String(\"t\", \"\", \"The name of the table to scan.\") rating := flag.Float64(\"r\", -1.0, \"The minimum rating for a movie to retrieve.\") year := flag.Int(\"y\", 1899, \"The year when the movie was released.\") verbose := flag.Bool(\"v\", false, \"Whether to show info about the movie.\") flag.Parse() if *table == \"\" || *rating \u003c 0.0 || *year \u003c 1900 { fmt.Println(\"You must supply the name of the table, a rating above zero, and a year after 1900:\") fmt.Println(\"-t TABLE -r RATING -y YEAR\") return } // Get items in that year. \tfilt1 := expression.Name(\"year\").Equal(expression.Value(*year)) // Get items with a rating above the minimum. \tfilt2 := expression.Name(\"info.rating\").GreaterThan(expression.Value(*rating)) // Get back the title and rating (we know the year). \tproj := expression.NamesList(expression.Name(\"title\"), expression.Name(\"info.rating\")) expr, err := expression.NewBuilder().WithFilter(filt1).WithFilter(filt2).WithProjection(proj).Build() if err != nil { fmt.Println(\"Got error building expression:\") fmt.Println(err.Error()) return } input := \u0026dynamodb.ScanInput{ ExpressionAttributeNames: expr.Names(), ExpressionAttributeValues: expr.Values(), FilterExpression: expr.Filter(), ProjectionExpression: expr.Projection(), TableName: table, } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"unable to load SDK config, \" + err.Error()) } client := dynamodb.NewFromConfig(cfg) resp, err := GetItems(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error scanning the table:\") fmt.Println(err.Error()) return } items := []Item{} err = attributevalue.UnmarshalListOfMaps(resp.Items, \u0026items) if err != nil { panic(fmt.Sprintf(\"failed to unmarshal Dynamodb Scan Items, %v\", err)) } for _, item := range items { if *verbose { fmt.Println(\"Title: \", item.Title) fmt.Println(\"Rating:\", item.Info.Rating) fmt.Println() } } numItems := strconv.Itoa(len(items)) fmt.Println(\"Found\", numItems, \"movie(s) with a rating above\", *rating, \"in\", *year) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"ScanItemsv2.go This example retrieves the Amazon DynamoDB items with a …","ref":"/aws-sdk-go-v2/docs/code-examples/dynamodb/scanitems/","tags":"","title":"ScanItemsv2"},{"body":"SendMessagev2.go This example sends a message to an Amazon SQS queue.\ngo run SendMessagev2.go -q QUEUE-NAME\n QUEUE-NAME is the name of the queue to which the message is sent.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" \"github.com/aws/aws-sdk-go-v2/service/sqs/types\" ) // SQSSendMessageAPI defines the interface for the GetQueueUrl and SendMessage functions. // We use this interface to test the functions using a mocked service. type SQSSendMessageAPI interface { GetQueueUrl(ctx context.Context, params *sqs.GetQueueUrlInput, optFns ...func(*sqs.Options)) (*sqs.GetQueueUrlOutput, error) SendMessage(ctx context.Context, params *sqs.SendMessageInput, optFns ...func(*sqs.Options)) (*sqs.SendMessageOutput, error) } // GetQueueURL gets the URL of an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a GetQueueUrlOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to GetQueueUrl. func GetQueueURL(c context.Context, api SQSSendMessageAPI, input *sqs.GetQueueUrlInput) (*sqs.GetQueueUrlOutput, error) { return api.GetQueueUrl(c, input) } // SendMsg sends a message to an Amazon SQS queue. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a SendMessageOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to SendMessage. func SendMsg(c context.Context, api SQSSendMessageAPI, input *sqs.SendMessageInput) (*sqs.SendMessageOutput, error) { return api.SendMessage(c, input) } func main() { queue := flag.String(\"q\", \"\", \"The name of the queue\") flag.Parse() if *queue == \"\" { fmt.Println(\"You must supply the name of a queue (-q QUEUE)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sqs.NewFromConfig(cfg) // Get URL of queue \tgQInput := \u0026sqs.GetQueueUrlInput{ QueueName: queue, } result, err := GetQueueURL(context.TODO(), client, gQInput) if err != nil { fmt.Println(\"Got an error getting the queue URL:\") fmt.Println(err) return } queueURL := result.QueueUrl sMInput := \u0026sqs.SendMessageInput{ DelaySeconds: 10, MessageAttributes: map[string]types.MessageAttributeValue{ \"Title\": { DataType: aws.String(\"String\"), StringValue: aws.String(\"The Whistler\"), }, \"Author\": { DataType: aws.String(\"String\"), StringValue: aws.String(\"John Grisham\"), }, \"WeeksOn\": { DataType: aws.String(\"Number\"), StringValue: aws.String(\"6\"), }, }, MessageBody: aws.String(\"Information about the NY Times fiction bestseller for the week of 12/11/2016.\"), QueueUrl: queueURL, } resp, err := SendMsg(context.TODO(), client, sMInput) if err != nil { fmt.Println(\"Got an error sending the message:\") fmt.Println(err) return } fmt.Println(\"Sent message with ID: \" + *resp.MessageId) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"SendMessagev2.go This example sends a message to an Amazon SQS queue. …","ref":"/aws-sdk-go-v2/docs/code-examples/sqs/sendmessage/","tags":"","title":"SendMessagev2"},{"body":"StartInstancesv2.go This example starts an Amazon EC2 instance.\ngo run StartInstancesv2.go -i INSTANCE-ID\n INSTANCE-ID is the ID of the instance to start.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"errors\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ec2\" \"github.com/aws/smithy-go\" ) // EC2StartInstancesAPI defines the interface for the StartInstances function. // We use this interface to test the function using a mocked service. type EC2StartInstancesAPI interface { StartInstances(ctx context.Context, params *ec2.StartInstancesInput, optFns ...func(*ec2.Options)) (*ec2.StartInstancesOutput, error) } // StartInstance starts an Amazon Elastic Compute Cloud (Amazon EC2) instance. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a StartInstancesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to StartInstances. func StartInstance(c context.Context, api EC2StartInstancesAPI, input *ec2.StartInstancesInput) (*ec2.StartInstancesOutput, error) { resp, err := api.StartInstances(c, input) var apiErr smithy.APIError if errors.As(err, \u0026apiErr) \u0026\u0026 apiErr.ErrorCode() == \"DryRunOperation\" { fmt.Println(\"User has permission to start an instance.\") input.DryRun = false return api.StartInstances(c, input) } return resp, err } func main() { instanceID := flag.String(\"i\", \"\", \"The ID of the instance to start\") flag.Parse() if *instanceID == \"\" { fmt.Println(\"You must supply an instance ID (-i INSTANCE-ID\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ec2.NewFromConfig(cfg) input := \u0026ec2.StartInstancesInput{ InstanceIds: []string{ *instanceID, }, DryRun: true, } _, err = StartInstance(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error starting the instance\") fmt.Println(err) return } fmt.Println(\"Started instance with ID \" + *instanceID) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"StartInstancesv2.go This example starts an Amazon EC2 instance.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/startinstances/","tags":"","title":"StartInstancesv2"},{"body":"StopInstancesv2.go This example stops an Amazon EC2 instance.\ngo run StopInstancesv2.go -i INSTANCE-ID\n INSTANCE-ID is the ID of the instance to stop.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"errors\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/ec2\" \"github.com/aws/smithy-go\" ) // EC2StopInstancesAPI defines the interface for the StopInstances function. // We use this interface to test the function using a mocked service. type EC2StopInstancesAPI interface { StopInstances(ctx context.Context, params *ec2.StopInstancesInput, optFns ...func(*ec2.Options)) (*ec2.StopInstancesOutput, error) } // StopInstance stops an Amazon Elastic Compute Cloud (Amazon EC2) instance. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If success, a StopInstancesOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to StopInstances. func StopInstance(c context.Context, api EC2StopInstancesAPI, input *ec2.StopInstancesInput) (*ec2.StopInstancesOutput, error) { resp, err := api.StopInstances(c, input) var apiErr smithy.APIError if errors.As(err, \u0026apiErr) \u0026\u0026 apiErr.ErrorCode() == \"DryRunOperation\" { fmt.Println(\"User has permission to stop instances.\") input.DryRun = false return api.StopInstances(c, input) } return resp, err } func main() { instanceID := flag.String(\"i\", \"\", \"The ID of the instance to stop\") flag.Parse() if *instanceID == \"\" { fmt.Println(\"You must supply an instance ID (-i INSTANCE-ID\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := ec2.NewFromConfig(cfg) input := \u0026ec2.StopInstancesInput{ InstanceIds: []string{ *instanceID, }, DryRun: true, } _, err = StopInstance(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error stopping the instance\") fmt.Println(err) return } fmt.Println(\"Stopped instance with ID \" + *instanceID) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"StopInstancesv2.go This example stops an Amazon EC2 instance.\ngo run …","ref":"/aws-sdk-go-v2/docs/code-examples/ec2/stopinstances/","tags":"","title":"StopInstancesv2"},{"body":"Subscribev2.go This example subscribes a user, by email address, to an Amazon SNS topic.\ngo run Subscribev2.go -m EMAIL-ADDRESS -t TOPIC-ARN\n EMAIL-ADDRESS is the email address of the user subscribing to the topic. TOPIC-ARN is the ARN of the topic.  The unit test accepts a similar value in config.json.\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sns\" ) // SNSSubscribeAPI defines the interface for the Subscribe function. // We use this interface to test the function using a mocked service. type SNSSubscribeAPI interface { Subscribe(ctx context.Context, params *sns.SubscribeInput, optFns ...func(*sns.Options)) (*sns.SubscribeOutput, error) } // SubscribeTopic subscribes a user to an Amazon Simple Notification Service (Amazon SNS) topic by their email address // Inputs: // c is the context of the method call, which includes the Region // api is the interface that defines the method call // input defines the input arguments to the service call. // Output: // If success, a SubscribeOutput object containing the result of the service call and nil // Otherwise, nil and an error from the call to Subscribe func SubscribeTopic(c context.Context, api SNSSubscribeAPI, input *sns.SubscribeInput) (*sns.SubscribeOutput, error) { return api.Subscribe(c, input) } func main() { email := flag.String(\"e\", \"\", \"The email address of the user subscribing to the topic\") topicARN := flag.String(\"t\", \"\", \"The ARN of the topic to which the user subscribes\") flag.Parse() if *email == \"\" || *topicARN == \"\" { fmt.Println(\"You must supply an email address and topic ARN\") fmt.Println(\"-e EMAIL -t TOPIC-ARN\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := sns.NewFromConfig(cfg) input := \u0026sns.SubscribeInput{ Endpoint: email, Protocol: aws.String(\"email\"), ReturnSubscriptionArn: true, // Return the ARN, even if user has yet to confirm \tTopicArn: topicARN, } result, err := SubscribeTopic(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error subscribing to the topic:\") fmt.Println(err) return } fmt.Println(*result.SubscriptionArn) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"Subscribev2.go This example subscribes a user, by email address, to an …","ref":"/aws-sdk-go-v2/docs/code-examples/sns/subscribe/","tags":"","title":"Subscribev2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" \"github.com/aws/aws-sdk-go-v2/service/iam/types\" ) // IAMUpdateAccessKeyAPI defines the interface for the UpdateAccessKey function. // We use this interface to test the function using a mocked service. type IAMUpdateAccessKeyAPI interface { UpdateAccessKey(ctx context.Context, params *iam.UpdateAccessKeyInput, optFns ...func(*iam.Options)) (*iam.UpdateAccessKeyOutput, error) } // ActivateKey sets the status of an AWS Identity and Access Management (IAM) access key to active. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a UpdateAccessKeyOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to UpdateAccessKey. func ActivateKey(c context.Context, api IAMUpdateAccessKeyAPI, input *iam.UpdateAccessKeyInput) (*iam.UpdateAccessKeyOutput, error) { return api.UpdateAccessKey(c, input) } func main() { keyID := flag.String(\"k\", \"\", \"The ID of the access key\") userName := flag.String(\"u\", \"\", \"The name of the user\") flag.Parse() if *keyID == \"\" || *userName == \"\" { fmt.Println(\"You must supply an access key ID and user name (-k KEY-ID -u USER-NAME)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.UpdateAccessKeyInput{ AccessKeyId: keyID, Status: types.StatusTypeActive, UserName: userName, } _, err = ActivateKey(context.TODO(), client, input) if err != nil { fmt.Println(\"Error\", err) return } fmt.Println(\"Access Key activated\") } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/updateaccesskey/","tags":"","title":"UpdateAccessKeyv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMUpdateServerCertificateAPI defines the interface for the MEUpdateServerCertificateTHOD function. // We use this interface to test the function using a mocked service. type IAMUpdateServerCertificateAPI interface { UpdateServerCertificate(ctx context.Context, params *iam.UpdateServerCertificateInput, optFns ...func(*iam.Options)) (*iam.UpdateServerCertificateOutput, error) } // RenameServerCert renames an AWS Identity and Access Management (IAM) server certificate. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a (*iam.UpdateServerCertificateOutput, error)Output object containing the result of the service call and nil. // Otherwise, nil and an error from the call to (*iam.UpdateServerCertificateOutput, error). func RenameServerCert(c context.Context, api IAMUpdateServerCertificateAPI, input *iam.UpdateServerCertificateInput) (*iam.UpdateServerCertificateOutput, error) { return api.UpdateServerCertificate(c, input) } func main() { certName := flag.String(\"c\", \"\", \"The name of the certificate\") newName := flag.String(\"n\", \"\", \"The new name of the certificate\") flag.Parse() if *certName == \"\" { fmt.Println(\"You must supply the original and new names of a certificate (-c CERT-NAME -n NEW-NAME)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.UpdateServerCertificateInput{ ServerCertificateName: certName, NewServerCertificateName: newName, } _, err = RenameServerCert(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error renaming the server certificate:\") fmt.Println(err) return } fmt.Println(\"Renamed the server certificate from \" + *certName + \" to \" + *newName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/updateservercert/","tags":"","title":"UpdateServerCertv2"},{"body":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. // SPDX - License - Identifier: Apache - 2.0 package main import ( \"context\" \"flag\" \"fmt\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/iam\" ) // IAMUpdateUserAPI defines the interface for the UpdateUser function. // We use this interface to test the function using a mocked service. type IAMUpdateUserAPI interface { UpdateUser(ctx context.Context, params *iam.UpdateUserInput, optFns ...func(*iam.Options)) (*iam.UpdateUserOutput, error) } // RenameUser changes the name for an AWS Identity and Access Management (IAM) user. // Inputs: // c is the context of the method call, which includes the AWS Region. // api is the interface that defines the method call. // input defines the input arguments to the service call. // Output: // If successful, a UpdateUserOutput object containing the result of the service call and nil. // Otherwise, nil and an error from the call to UpdateUser. func RenameUser(c context.Context, api IAMUpdateUserAPI, input *iam.UpdateUserInput) (*iam.UpdateUserOutput, error) { return api.UpdateUser(c, input) } func main() { userName := flag.String(\"u\", \"\", \"The name of the user\") newName := flag.String(\"n\", \"\", \"The new name of the user\") flag.Parse() if *userName == \"\" || *newName == \"\" { fmt.Println(\"You must supply a user name and new name (-u USERNAME -n NEW-NAME)\") return } cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(\"configuration error, \" + err.Error()) } client := iam.NewFromConfig(cfg) input := \u0026iam.UpdateUserInput{ UserName: userName, NewUserName: newName, } _, err = RenameUser(context.TODO(), client, input) if err != nil { fmt.Println(\"Got an error updating user \" + *userName) } fmt.Println(\"Updated user name from: \" + *userName + \" to: \" + *newName) } See the complete example in GitHub.\n","categories":"","description":"","excerpt":"404: Not Found\nSource code // Copyright Amazon.com, Inc. or its …","ref":"/aws-sdk-go-v2/docs/code-examples/iam/updateuser/","tags":"","title":"UpdateUserv2"}]