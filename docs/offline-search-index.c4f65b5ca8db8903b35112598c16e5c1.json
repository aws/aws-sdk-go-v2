[{"body":"Welcome to the AWS SDK for Go. The AWS SDK for Go provides APIs and utilities that developers can use to build Go applications that use AWS services, such as Amazon Elastic Compute Cloud (Amazon EC2) and Amazon Simple Storage Service (Amazon S3).\nThe SDK removes the complexity of coding directly against a web service interface. It hides a lot of the lower-level plumbing, such as authentication, request retries, and error handling.\nThe SDK also includes helpful utilities. For example, the Amazon S3 download and upload manager can automatically break up large objects into multiple parts and transfer them in parallel.\nUse the AWS SDK for Go Developer Guide to help you install, configure, and use the SDK. The guide provides configuration information, sample code, and an introduction to the SDK utilities.\n","excerpt":"Welcome to the AWS SDK for Go. The AWS SDK for Go provides APIs and …","ref":"/aws-sdk-go-v2/docs/","title":"Documentation"},{"body":"The AWS SDK for Go requires Go 1.15 or later. You can view your current version of Go by running the following command.\ngo version For information about installing or upgrading your version of Go, see https://golang.org/doc/install.\nGet an Amazon Account Before you can use the AWS SDK for Go V2, you must have an Amazon account. See How do I create and activate a new AWS account? for details.\nInstall the AWS SDK for Go V2 The AWS SDK for Go V2 uses Go Modules, which was a feature introduced in Go 1.11. To get started initialize your local project by running the following Go command.\ngo mod init example After initializing your Go Module project you will be able to retrieve the SDK, and it’s required dependencies using the go get command. These dependencies will be recorded in the go.mod file which was created by the previous command.\nThe following commands show how to retrieve the standard set of SDK modules to use in your application.\ngo get github.com/aws/aws-sdk-go-v2 go get github.com/aws/aws-sdk-go-v2/config This will retrieve the core SDK module, and the config module which is used for loading the AWS shared configuration.\nNext you can install one or more AWS service API clients required by your application. All API clients are located under github.com/aws/aws-sdk-go-v2/service import hierarchy. A complete set of currently supported API clients can be found here. To install a service client, execute the following command to retrieve the module and record the dependency in your go.mod file. In this example we retrieve the Amazon S3 API client.\ngo get github.com/aws/aws-sdk-go-v2/service/s3 Get your AWS access keys Access keys consist of an access key ID and secret access key, which are used to sign programmatic requests that you make to AWS. If you don’t have access keys, you can create them by using the AWS Management Console. We recommend that you use IAM access keys instead of AWS root account access keys. IAM lets you securely control access to AWS services and resources in your AWS account. Note\nTo create access keys, you must have permissions to perform the required IAM actions. For more information, see Granting IAM User Permission to Manage Password Policy and Credentials in the IAM User Guide.\n To get your access key ID and secret access key.  Open the IAM console On the navigation menu, choose Users. Choose your IAM user name (not the check box). Open the Security credentials tab, and then choose Create access key. To see the new access key, choose Show. Your credentials resemble the following:  Access key ID: AKIAIOSFODNN7EXAMPLE Secret access key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY   To download the key pair, choose Download .csv file. Store the keys in a secure location.  Keep the keys confidential to protect your AWS account, and never email them. Do not share them outside your organization, even if an inquiry appears to come from AWS or Amazon.com. No one who legitimately represents Amazon will ever ask you for your secret key.\n Related topics  What Is IAM? in IAM User Guide. AWS Security Credentials in Amazon Web Services General Reference.  Import Packages After you have installed the SDK, you import AWS packages into your Go applications to use the SDK, as shown in the following example, which imports the AWS, Config, and Amazon S3 libraries:\nimport ( \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) ","excerpt":"The AWS SDK for Go requires Go 1.15 or later. You can view your …","ref":"/aws-sdk-go-v2/docs/getting-started/","title":"Getting Started with the AWS SDK for Go V2"},{"body":"In the AWS SDK for Go V2, you can configure common settings for service clients, such as the logger, log level, and retry configuration. Most settings are optional. However, for each service client, you must specify an AWS Region and your credentials. The SDK uses these values to send requests to the correct Region and sign requests with the correct credentials. You can specify these values as programmatically in code, or via the execution environment.\nLoading AWS Shared Configuration There are a number of ways to initialize a service API client, but the following is the most common pattern recommended to users.\nTo configure the SDK to use the AWS shared configuration use the following code:\nimport ( \"log\" \"github.com/aws/aws-sdk-go-v2/config\" ) // ...  cfg, err := config.LoadDefaultConfig() if err != nil { log.Fatalf(\"failed to load configuration, %v\", err) } config.LoadDefaultConfig() will construct an aws.Config using the AWS shared configuration sources. This includes configuring a credential provider. configuring the AWS Region, and loading service specific configuration. Service clients can be constructed using the loaded aws.Config, providing a consistent pattern for constructing clients.\nFor more information about AWS Shared Configuration see the AWS Tools and SDKs Shared Configuration and Credentials Reference Guide \nSpecifying the AWS Region When you specify the Region, you specify where to send requests, such as us-west-2 or us-east-2. For a list of Regions for each service, see Regions and Endpoints in the Amazon Web Services General Reference.\nThe SDK does not have a default Region. To specify a Region:\n  Set the AWS_REGION environment variable to the default Region\n  Set the region explicitly using config.WithRegion as an argument to config.LoadDefaultConfig when loading configuration.\n  If you set a Region using all of these techniques, the SDK uses the Region you explicitly specified.\nConfigure Region with Environment Variable Linux, macOS, or Unix export AWS_REGION=us-west-2 Windows set AWS_REGION=us-west-2 Specify Region Programmatically cfg, err := config.LoadDefaultConfig(config.WithRegion(\"us-west-2\")) Specifying Credentials The AWS SDK for Go V2 requires credentials (an access key and secret access key) to sign requests to AWS. You can specify your credentials in several locations, depending on your particular use case. For information about obtaining credentials, see Getting Started.\nWhen you initialize an aws.Config instance using config.LoadDefaultConfig, the SDK uses its default credential chain to find AWS credentials. This default credential chain looks for credentials in the following order:\n Environment variables.  Static Credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN) Web Identity Token (AWS_WEB_IDENTITY_TOKEN_FILE)   Shared credentials file.  ~/.aws/credentials ~/.aws/config   If your application uses an ECS task definition or RunTask API operation, IAM role for tasks. If your application is running on an Amazon EC2 instance, IAM role for Amazon EC2.  The SDK detects and uses the built-in providers automatically, without requiring manual configurations. For example, if you use IAM roles for Amazon EC2 instances, your applications automatically use the instance’s credentials. You don’t need to manually configure credentials in your application.\nAs a best practice, AWS recommends that you specify credentials in the following order:\n  Use IAM roles for tasks if your application uses an ECS task definition or RunTask API operation.\n  Use IAM roles for Amazon EC2 (if your application is running on an Amazon EC2 instance).\nIAM roles provide applications on the instance temporary security credentials to make AWS calls. IAM roles provide an easy way to distribute and manage credentials on multiple Amazon EC2 instances.\n  Use a shared credentials file.\nThis credentials file is the same one used by other SDKs and the . If you’re already using a shared credentials file, you can also use it for this purpose.\n  Use environment variables.\nSetting environment variables is useful if you’re doing development work on a machine other than an Amazon EC2 instance.\n  IAM Roles for Tasks If your application uses an Amazon ECS task definition or RunTask operation, use IAM Roles for Tasks to specify an IAM role that can be used by the containers in a task.\nIAM Roles for Amazon EC2 Instances If you are running your application on an Amazon EC2 instance, use the instance’s IAM role to get temporary security credentials to make calls to AWS.\nIf you have configured your instance to use IAM roles, the SDK uses these credentials for your application automatically. You don’t need to manually specify these credentials.\nShared Credentials File A credential file is a plaintext file that contains your access keys. The file must be on the same machine on which you’re running your application. The file must be named credentials and located in the .aws/ folder in your home directory. The home directory can vary by operating system. In Windows, you can refer to your home directory by using the environment variable :code:%UserProfile%. In Unix-like systems, you can use the environment variable :code:$HOME or :code:~ (tilde).\nIf you already use this file for other SDKs and tools (like the ), you don’t need to change anything to use the files in this SDK. If you use different credentials for different tools or applications, you can use profiles to configure multiple access keys in the same configuration file.\nCreating the Credentials File If you don’t have a shared credentials file (.aws/credentials), you can use any text editor to create one in your home directory. Add the following content to your credentials file, replacing \u003cYOUR_ACCESS_KEY_ID\u003e and \u003cYOUR_SECRET_ACCESS_KEY\u003e with your credentials.\n[default] aws_access_key_id = \u003cYOUR_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_SECRET_ACCESS_KEY\u003e The [default] heading defines credentials for the default profile, which the SDK will use unless you configure it to use another profile.\nYou can also use temporary security credentials by adding the session tokens to your profile, as shown in the following example:\n[temp] aws_access_key_id = \u003cYOUR_TEMP_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_TEMP_SECRET_ACCESS_KEY\u003e aws_session_token = \u003cYOUR_SESSION_TOKEN\u003e Specifying Profiles You can include multiple access keys in the same configuration file by associating each set of access keys with a profile. For example, in your credentials file, you can declare multiple profiles, as follows.\n[default] aws_access_key_id = \u003cYOUR_DEFAULT_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_DEFAULT_SECRET_ACCESS_KEY\u003e [test-account] aws_access_key_id = \u003cYOUR_TEST_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_TEST_SECRET_ACCESS_KEY\u003e [prod-account] ; work profile aws_access_key_id = \u003cYOUR_PROD_ACCESS_KEY_ID\u003e aws_secret_access_key = \u003cYOUR_PROD_SECRET_ACCESS_KEY\u003e By default, the SDK checks the AWS_PROFILE environment variable to determine which profile to use. If no AWS_PROFILE variable is set, the SDK uses the default profile.\nSometimes, you may to want to use a different profile with your application. For example let’s say you want to use the test-account credentials with your myapp application. You can your application and use this profile by using the following command:\n$ AWS_PROFILE=test-account myapp You can also use instruct the SDK to select a profile by either os.Setenv(\"AWS_PROFILE\", \"test-account\") before calling config.LoadDefaultConfig, or by passing an explicit profile as an argument as shown in the following example:\ncfg, err := config.LoadDefaultConfig(config.WithSharedConfigProfile(\"test-account\"))  If you specify credentials in environment variables, the SDK always uses those credentials, no matter which profile you specify.\n Environment Variables By default, the SDK detects AWS credentials set in your environment and uses them to sign requests to AWS. That way you don’t need to manage credentials in your applications.\nThe SDK looks for credentials in the following environment variables:\n AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN (optional)  The following examples show how you configure the environment variables.\nLinux, OS X, or Unix $ export AWS_ACCESS_KEY_ID=YOUR_AKID $ export AWS_SECRET_ACCESS_KEY=YOUR_SECRET_KEY $ export AWS_SESSION_TOKEN=TOKEN Windows \u003e set AWS_ACCESS_KEY_ID=YOUR_AKID \u003e set AWS_SECRET_ACCESS_KEY=YOUR_SECRET_KEY \u003e set AWS_SESSION_TOKEN=TOKEN Specify Credentials Programmatically config.LoadDefaultConfig allows you to provide an explicit aws.CredentialProvider when loading the shared configuration sources. To pass an explicity credential provider when loading shared configuration use config.WithCredentialsProvider. For example, if customProvider references an instance of aws.CredentialProvider implementation, it can be passed during configuration loading like so:\ncfg, err := config.LoadDefaultConfig(config.WithCredentialsProvider(customProvider)) If you explicitly provide credentials, as in this example, the SDK uses only those credentials.\nAll credential providers passed to or returned by LoadDefaultConfig are wrapped in a CredentialsCache automatically. This enables caching and concurrency safe credential access. If you explicitly configure a provider on aws.Config directly you must explicitly wrap the provider with this type.\n Static Credentials You can hard-code credentials in your application by using the credentials.StaticCredentialsProvider credential provider to explicitly set the access keys to be used. For example:\ncfg, err := config.LoadDefaultConfig( config.WithCredentialsProvider(aws.StaticCredentialsProvider(\"AKID\", \"SECRET_KEY\", \"TOKEN\")), )  Do not embed credentials inside an application. Use this method only for testing purposes.\n Other Credentials Providers The SDK provides other methods for retrieving credentials in the credentials module. For example, you can retrieve temporary security credentials from AWS Security Token Service or credentials from encrypted storage.\nAvailable Credential Providers:\n  ec2rolecreds – Retrieve Credentials from Amazon EC2 Instances Roles via Amazon EC2 IMDS.\n  endpointcreds – Retrieve Credentials from an arbitrary HTTP endpoint.\n  processcreds – Retrieve Credentials from an external process that will be invoked by the host environment’s shell.\n  stscreds – Retrieve Credentials from AWS STS\n  ","excerpt":"In the AWS SDK for Go V2, you can configure common settings for …","ref":"/aws-sdk-go-v2/docs/configuring-sdk/","title":"Configuring the AWS SDK for Go V2"},{"body":"Amazon CloudFront URL Signer The Amazon CloudFront URL signer simplifies the process of creating signed URLs. A signed URL includes information, such as an expiration date and time, that enables you to control access to your content. Signed URLs are useful when you want to distribute content through the internet, but want to restrict access to certain users (for example, to users who have paid a fee).\nTo sign a URL, create a URLSigner instance with your CloudFront key pair ID and the associated private key. Then call the Sign or SignWithPolicy method and include the URL to sign. For more information about Amazon CloudFront key pairs, see Creating CloudFront Key Pairs for Your Trusted Signers in the CloudFront Developer Guide.\nThe following example creates a signed URL that’s valid for one hour after it is created.\nimport \"github.com/aws/aws-sdk-go-v2/feature/cloudfront/sign\" // ...  signer := sign.NewURLSigner(keyID, privKey) signedURL, err := signer.Sign(rawURL, time.Now().Add(1*time.Hour)) if err != nil { log.Fatalf(\"Failed to sign url, err: %s\\n\", err.Error()) return } For more information about the signing utility, see the sign package in the AWS SDK for Go V2 API Reference.\n","excerpt":"Amazon CloudFront URL Signer The Amazon CloudFront URL signer …","ref":"/aws-sdk-go-v2/docs/sdk-utilities/cloudfront/","title":"Amazon CloudFront Utilities"},{"body":"This AWS product or service follows the shared responsibility model through the specific Amazon Web Services (AWS) services it supports. For AWS service security information, see the AWS service security documentation page and AWS services that are in scope of AWS compliance efforts by compliance program.\nThe security and compliance of Amazon Web Services (AWS) services is assessed by third-party auditors as part of multiple AWS compliance programs. These include SOC, PCI, FedRAMP, HIPAA, and others. AWS provides a frequently updated list of AWS services in scope of specific compliance programs at AWS Services in Scope by Compliance Program.\nThird-party audit reports are available for you to download using AWS Artifact. For more information, see Downloading Reports in AWS Artifact.\nFor more information about AWS compliance programs, see AWS Compliance Programs.\nYour compliance responsibility when using this AWS product or service to access an AWS service is determined by the sensitivity of your data, your organization’s compliance objectives, and applicable laws and regulations. If your use of an AWS service is subject to compliance with standards such as HIPAA, PCI, or FedRAMP, AWS provides resources to help:\n Security and Compliance Quick Start Guides – Deployment guides that discuss architectural considerations and provide steps for deploying security-focused and compliance-focused baseline environments on AWS. Architecting for HIPAA Security and Compliance Whitepaper – A whitepaper that describes how companies can use AWS to create HIPAA-compliant applications. AWS Compliance Resources – A collection of workbooks and guides that might apply to your industry and location. AWS Config – A service that assesses how well your resource configurations comply with internal practices, industry guidelines, and regulations. AWS Security Hub – A comprehensive view of your security state within AWS that helps you check your compliance with security industry standards and best practices.  ","excerpt":"This AWS product or service follows the shared responsibility model …","ref":"/aws-sdk-go-v2/docs/security/compliance-validation/","title":"Compliance Validation for this AWS Product or Service"},{"body":"In most cases you use the endpoint that is pre-configured for a service. However, you can specify a custom endpoint, such as for pre-release versions of the service.\nA EndpointResolver can be configured to provide custom endpoint resolution logic for service clients. A custom endpoint resolver has the ability to override the resolution of a service’s endpoint resolution for all endpoints, or a just specific regional endpoint. Custom endpoint resolver have the ability trigger the service’s endpoint resolution logic to fallback if a custom resolver does not wish to resolve a requested endpoint. EndpointResolverFunc can be used to easily wrap functions to satisfy the EndpointResolver interface.\nA EndpointResolver can be easily configured by passing the resolver wrapped with WithEndpointResolver to LoadDefaultConfig, allowing for the ability to override endpoints when loading credentials, as well as configuring the resulting aws.Config with your custom endpoint resolver.\nThe endpoint resolver is given the service and region as a string, allowing for the resolver to dynamically drive its behavior. Each service client package has an exported ServiceID constant which can be used to determine which service client is invoking your endpoint resolver.\nAn endpoint resolver can use the EndpointNotFoundError sentinel error value to trigger fallback resolution to the service clients default resolution logic. This allows you to selectively override one or more endpoints seamlessly without having to handle fallback logic.\nIf your endpoint resolver implementation returns an error other than EndpointNotFoundError, endpoint resolution will stop and the service operation returns an error to your application.\nExamples Overriding Endpoint with Fallback The following code snippet shows how a single service endpoint can be overridden for DynamoDB with fallback behavior for other endpoints:\ncustomResolver := aws.EndpointResolverFunc(func(service, region string) (aws.Endpoint, error) { if service == dynamodb.ServiceID \u0026\u0026 region == \"us-west-2\" { return aws.Endpoint{ PartitionID: \"aws\", URL: \"https://test.us-west-2.amazonaws.com\", SigningRegion: \"us-west-2\", }, nil } // returning EndpointNotFoundError will allow the service to fallback to it's default resolution  return aws.Endpoint{}, \u0026aws.EndpointNotFoundError{} }) cfg, err := config.LoadDefaultConfig(config.WithEndpointResolver(customResolver)) Overriding Endpoint Without Fallback The following code snippet shows how a single service endpoint can be overridden for DynamoDB without fallback behavior for other endpoints:\ncustomResolver := aws.EndpointResolverFunc(func(service, region string) (aws.Endpoint, error) { if service == dynamodb.ServiceID \u0026\u0026 region == \"us-west-2\" { return aws.Endpoint{ PartitionID: \"aws\", URL: \"https://test.us-west-2.amazonaws.com\", SigningRegion: \"us-west-2\", }, nil } return aws.Endpoint{}, fmt.Errorf(\"unknown endpoint requested\") }) cfg, err := config.LoadDefaultConfig(config.WithEndpointResolver(customResolver)) Immutable Endpoints Setting an endpoint as immutable may prevent some service client features from functioning correctly, and could result in undefined behavior. Caution should be taken when defining an endpoint as immutable.\n Some service clients, such as Amazon S3, can modify the endpoint returned by the resolver for certain service operations. For example, the Amazon S3 will automatically handle Virtual Bucket Addressing by mutating the resolved endpoint. You can prevent the SDK from mutating your custom endpoints by setting HostnameImmutable totrue. For example:\ncustomResolver := aws.EndpointResolverFunc(func(service, region string) (aws.Endpoint, error) { if service == dynamodb.ServiceID \u0026\u0026 region == \"us-west-2\" { return aws.Endpoint{ PartitionID: \"aws\", URL: \"https://test.us-west-2.amazonaws.com\", SigningRegion: \"us-west-2\", HostnameImmutable: true, }, nil } return aws.Endpoint{}, fmt.Errorf(\"unknown endpoint requested\") }) cfg, err := config.LoadDefaultConfig(config.WithEndpointResolver(customResolver)) ","excerpt":"In most cases you use the endpoint that is pre-configured for a …","ref":"/aws-sdk-go-v2/docs/configuring-sdk/endpoints/","title":"Configuring Client Endpoints"},{"body":"The AWS SDK for Go V2 returns errors that satisfy the Go error interface type You can use the Error() method to get a formatted string of the SDK error message without any special handling. Errors returned by the SDK may implement an Unwrap method. The Unwrap method is used by the SDK to provide additional contextual information to errors, while providing access to the underlying error or chain of errors. The Unwrap method should be used with the errors.As to handle unwrapping error chains.\nIt is important that your application check whether an error occurred after invoking a function or method that can return an error interface type. The most basic form of error handling looks similar to the following example:\nif err != nil { // Handle error \treturn } Logging Errors The simplest form of error handling is traditionally to log or print the error message before returning or exiting from the application. For example:\nimport \"log\" // ...  if err != nil { log.Printf(\"error: %s\", err.Error()) return } Service Client Errors The SDK wraps All errors returned by service clients with the smithy.OperationError error type. OperationError provides contextual information about the service name and operation that is associated with an underlying error. This information can be useful for applications that perform batches of operations to one or more services, with a centralized error handling mechanism. Your application can use errors.As to access this OperationError metadata.\nFor example:\nimport \"log\" import \"github.com/awslabs/smithy-go\" // ...  if err != nil { var oe *smithy.OperationError if errors.As(err, \u0026oe) { log.Printf(\"failed to call service: %s, operation: %s, error: %v\", oe.Service(), oe.Operation(), oe.Unwrap()) } return } API Error Responses Service operations can return modeled error types to indicate specific errors. These modeled types can be used with errors.As to unwrap and determine if the operation failure was due to a specific error. For example Amazon S3 CreateBucket can return a BucketAlreadyExists error if a bucket of the same name already exists.\nFor example, to check if an error was a BucketAlreadyExists error:\nimport \"log\" import \"github.com/aws/aws-sdk-go-v2/service/s3/types\" // ...  if err != nil { var bne *types.BucketAlreadyExists if errors.As(err, \u0026bne) { log.Println(\"error:\", bne) } return } All service API response errors implement the smithy.APIError interface type. This interface can be used to handle both modeled or un-modeled service error responses. This type provides access to the error code and message returned by the service. Additionally, this type provides indication of whether the fault of the error was due to the client or server if known. For example:\nimport \"log\" import \"github.com/awslabs/smithy-go\" // ...  if err != nil { var ae smithy.APIError if errors.As(err, \u0026ae) { log.Printf(\"code: %s, message: %s, fault: %s\", ae.ErrorCode(), ae.ErrorMessage(), ae.ErrorFault().String()) } return } Retrieving Request Identifiers When working with AWS Support, you may be asked to provide the request identifier that identifiers the request you are attempting to troubleshoot. You can use http.ResponseError and use the ServiceRequestID() method to retrieve the request identifier associated with error response.\nFor example:\nimport \"log\" import awshttp \"github.com/aws/transport/http\" // ...  if err != nil { var re *awshttp.ResponseError if errors.As(err, \u0026re) { log.Printf(\"requestID: %s, error: %v\", re.ServiceRequestID(), re.Unwrap()); } return } Amazon S3 Request Identifiers Amazon S3 requests contain additional identifiers that can be used to assist AWS Support with troubleshooting your request. Amazon S3 requests can contain a RequestId and HostId pair that can be retrieved from Amazon S3 operation errors if available.\nFor example:\nimport \"log\" // ...  if err != nil { var re interface { ServiceHostID() string ServiceRequestID() string } if errors.As(err, \u0026re) { log.Printf(\"requestID: %s, hostID: %s request failure\", re.ServiceRequestID(), re.ServiceHostID()); } return } ","excerpt":"The AWS SDK for Go V2 returns errors that satisfy the Go error …","ref":"/aws-sdk-go-v2/docs/handling-errors/","title":"Handling Errors in the AWS SDK for Go V2"},{"body":"The AWS SDK for Go V2 uses a default HTTP client with default configuration values. Although you can change some of these configuration values, the default HTTP client and transport are not sufficiently configured for customers using the AWS SDK for Go V2 in an environment with high throughput and low latency requirements. This section describes how to configure a custom HTTP client, and use that client to create AWS SDK for Go V2 calls.\nTo assist you in creating a custom HTTP client, this section describes how to the NewBuildableClient to configure custom settings, and use that client with an AWS SDK for Go V2 service client.\nLet’s define what we want to customize.\nOverriding During Configuration Loading Custom HTTP clients can be provided when calling LoadDefaultConfig by wrapping the client using WithHTTPClient and passing the resulting value to LoadDefaultConfig. For example to pass customClient as our client:\ncfg, err := config.LoadDefaultConfig(config.WithHTTPClient(customClient)) Timeout The BuildableHTTPClient can be configured with a request timeout limit. This timeout includes the time to connect, process any redirects, and read the complete response body. For example to modify the client timeout:\nimport \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" // ...  httpClient := http.NewBuildableClient().WithTimeout(time.Second*5) Dialer The BuildableHTTPClient provides a builder mechanics for constructing clients with modified Dialer options. The following example shows how to configure a clients Dialer settings.\nimport awshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" import \"net\" // ...  httpClient := awshttp.NewBuildableClient().WithDialerOptions(func(d *net.Dialer) { d.KeepAlive = -1 d.Timeout = time.Millisecond*500 }) Settings Dialer.KeepAlive This setting represents the keep-alive period for an active network connection.\nSet to a negative value to disable keep-alives.\nSet to 0 to enable keep-alives if supported by the protocol and operating system.\nNetwork protocols or operating systems that do not support keep-alives ignore this field. By default, TCP enables keep alive.\nSee https://golang.org/pkg/net/#Dialer.KeepAlive\nSet KeepAlive as time.Duration.\nDialer.Timeout This setting represents the maximum amount of time a dial waits for a connection to be created.\nDefault is 30 seconds.\nSee https://golang.org/pkg/net/#Dialer.Timeout\nSet Timeout as time.Duration.\nTransport The BuildableHTTPClient provides a builder mechanics for constructing clients with modified Transport options.\nConfiguring a Proxy If you cannot directly connect to the internet, you can use Go-supported environment variables (HTTP_PROXY / HTTPS_PROXY) or create a custom HTTP client to configure your proxy. The following example configures the client to use PROXY_URL as the proxy endpoint:\nimport awshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" import \"net/http\" // ...  httpClient := awshttp.NewBuildableClient().WithTransportOptions(func(tr *http.Transport) { proxyURL, err := url.Parse(\"PROXY_URL\") if err != nil { log.Fatal(err) } tr.Proxy = http.ProxyURL(proxyURL) }) Other Settings Below are a few other Transport settings that can be modified to tune the HTTP client. Any additional settings not described here can be found in the Transport type documentation. These settings can be applied as shown in the following example:\nimport awshttp \"github.com/aws/aws-sdk-go-v2/aws/transport/http\" import \"net/http\" // ...  httpClient := awshttp.NewBuildableClient().WithTransportOptions(func(tr *http.Transport) { tr.ExpectContinueTimeout = 0 tr.MaxIdleConns = 10 }) Transport.ExpectContinueTimeout If the request has an “Expect: 100-continue” header, this setting represents the maximum amount of time to wait for a server’s first response headers after fully writing the request headers, This time does not include the time to send the request header. The HTTP client sends its payload after this timeout is exhausted.\nDefault 1 second.\nSet to 0 for no timeout and send request payload without waiting. One use case is when you run into issues with proxies or third party services that take a session similar to the use of Amazon S3 in the function shown later.\nSee https://golang.org/pkg/net/http/#Transport.ExpectContinueTimeout\nSet ExpectContinue as time.Duration.\nTransport.IdleConnTimeout This setting represents the maximum amount of time to keep an idle network connection alive between HTTP requests.\nSet to 0 for no limit.\nSee https://golang.org/pkg/net/http/#Transport.IdleConnTimeout\nSet IdleConnTimeout as time.Duration.\nTransport.MaxIdleConns This setting represents the maximum number of idle (keep-alive) connections across all hosts. One use case for increasing this value is when you are seeing many connections in a short period from the same clients\n0 means no limit.\nSee https://golang.org/pkg/net/http/#Transport.MaxIdleConns\nSetMaxIdleConns as int.\nTransport.MaxIdleConnsPerHost This setting represents the maximum number of idle (keep-alive) connections to keep per-host. One use case for increasing this value is when you are seeing many connections in a short period from the same clients\nDefault is two idle connections per host.\nSet to 0 to use DefaultMaxIdleConnsPerHost (2).\nSee https://golang.org/pkg/net/http/#Transport.MaxIdleConnsPerHost\nSet MaxIdleConnsPerHost as int.\nTransport.ResponseHeaderTimeout This setting represents the maximum amount of time to wait for a client to read the response header.\nIf the client isn’t able to read the response’s header within this duration, the request fails with a timeout error.\nBe careful setting this value when using long-running Lambda functions, as the operation does not return any response headers until the Lambda function has finished or timed out. However, you can still use this option with the ** InvokeAsync** API operation.\nDefault is no timeout; wait forever.\nSee https://golang.org/pkg/net/http/#Transport.ResponseHeaderTimeout\nSet ResponseHeaderTimeout as time.Duration.\nTransport.TLSHandshakeTimeout This setting represents the maximum amount of time waiting for a TLS handshake to be completed.\nDefault is 10 seconds.\nZero means no timeout.\nSee https://golang.org/pkg/net/http/#Transport.TLSHandshakeTimeout\nSet TLSHandshakeTimeout as time.Duration.\n","excerpt":"The AWS SDK for Go V2 uses a default HTTP client with default …","ref":"/aws-sdk-go-v2/docs/configuring-sdk/custom-http/","title":"Customizing the HTTP Client"},{"body":"AWS Identity and Access Management (IAM) is an Amazon Web Services (AWS) service that helps an administrator securely control access to AWS resources. IAM administrators control who can be authenticated (signed in) and authorized (have permissions) to use resources AWS services. IAM is an AWS service that you can use with no additional charge.\nTo use this AWS product or service to access AWS, you need an AWS account and AWS credentials. To increase the security of your AWS account, we recommend that you use an IAM user to provide access credentials instead of using your AWS account credentials.\nFor details about working with IAM, see IAM.\nFor an overview of IAM users and why they are important for the security of your account, see AWS Security Credentials in the Amazon Web Services General Reference.\nThis AWS product or service follows the shared responsibility model through the specific Amazon Web Services (AWS) services it supports. For AWS service security information, see the AWS service security documentation page and AWS services that are in scope of AWS compliance efforts by compliance program.\n","excerpt":"AWS Identity and Access Management (IAM) is an Amazon Web Services …","ref":"/aws-sdk-go-v2/docs/security/iam/","title":"Identity and Access Management for this AWS Product or Service"},{"body":"This AWS product or service follows the shared responsibility model through the specific Amazon Web Services (AWS) services it supports. For AWS service security information, see the AWS service security documentation page and AWS services that are in scope of AWS compliance efforts by compliance program .\nFor information about AWS security processes, see the AWS: Overview of Security Processes whitepaper.\n","excerpt":"This AWS product or service follows the shared responsibility model …","ref":"/aws-sdk-go-v2/docs/security/infrastructure-security/","title":"Infrastructure Security for this AWS Product or Service"},{"body":"The AWS SDK for Go V2 has logging facilities available that allow your application to enable debugging information for debugging and diagnosing request issues or failures. The Logger interface and ClientLogMode are the main components available to you for determining how and what should be logged by clients.\nLogger When constructing an Config using LoadDefaultConfig a default Logger will is configured to send log messages to process' standard error (stderr). A custom logger that satisfies the Logger interface can be passed as an argument to LoadDefaultConfig by wrapping it with config.WithLogger.\nFor example to configure our clients to use our applicationLogger:\ncfg, err := config.LoadDefaultConfig(config.WithLogger(applicationLogger)) Now clients configured using the constructed aws.Config will send log messages to applicationLogger.\nContext-Aware Loggers A Logger implementation may implement the optional ContextLogger interface. Loggers that implement this interface will have their WithContext methods invoked with the current context. This allows your logging implementations to return a new Logger that can write additional logging metadata based on values present in the context.\nClientLogMode By default, service clients do not produce log messages. To configure clients to send log messages for debugging purposes, use the ClientLogMode member on Config. ClientLogMode can be set to enable debugging messaging for:\n Signature Version 4 (SigV4) Signing Request Retries HTTP Requests HTTP Responses  For example to enable logging of HTTP requests and retries:\ncfg, err := config.LoadDefaultConfig(config.WithClientLogMode(aws.LogRetries | aws.LogRequest)) See ClientLogMode for the different client log modes available.\n","excerpt":"The AWS SDK for Go V2 has logging facilities available that allow your …","ref":"/aws-sdk-go-v2/docs/configuring-sdk/logging/","title":"Logging"},{"body":"The Amazon Web Services (AWS) global infrastructure is built around AWS Regions and Availability Zones.\nAWS Regions provide multiple physically separated and isolated Availability Zones, which are connected with low-latency, high-throughput, and highly redundant networking.\nWith Availability Zones, you can design and operate applications and databases that automatically fail over between Availability Zones without interruption. Availability Zones are more highly available, fault tolerant, and scalable than traditional single or multiple data center infrastructures.\nFor more information about AWS Regions and Availability Zones, see AWS Global Infrastructure.\nThis AWS product or service follows the shared responsibility model through the specific Amazon Web Services (AWS) services it supports. For AWS service security information, see the AWS service security documentation page and AWS services that are in scope of AWS compliance efforts by compliance program.\n","excerpt":"The Amazon Web Services (AWS) global infrastructure is built around …","ref":"/aws-sdk-go-v2/docs/security/disaster-recovery-resiliency/","title":"Resilience for this AWS Product or Service"},{"body":"The AWS SDK for Go V2 includes the following utilities to help you more easily use AWS services. Find the SDK utilities in their related AWS service package.\n","excerpt":"The AWS SDK for Go V2 includes the following utilities to help you …","ref":"/aws-sdk-go-v2/docs/sdk-utilities/","title":"Using the AWS SDK for Go V2 Utilities"},{"body":"To make calls to an AWS service, you must first construct a service client instance. A service client provides low-level access to every API action for that service. For example, you create an Amazon S3 service client to make calls to Amazon S3 APIs.\nWhen you call service operations, you pass in input parameters as a struct. A successful call will result in an output struct containing the service API response. For example, after you successfully call an Amazon S3 create bucket action, the action returns an output struct with the bucket’s location.\nFor the list of service clients, including their methods and parameters, see the AWS SDK for Go V2 API Reference\nConstructing a Service Client Service clients can be constructed using either the New or NewFromConfig functions available in service client’s Go package. Each function will return a Client struct type containing the methods for invoking the service APIs. The New and NewFromConfig each provide the same set of configurable options for constructing a service client, but but provide slightly different construction patterns that we will look at in the following sections.\nNewFromConfig NewFromConfig function provides a consistent interface for constructing service clients using the aws.Config. An aws.Config can be loaded using the config.LoadDefaultConfig. For more information on constructing an aws.Config see Configure the SDK. The following example shows how to construct an Amazon S3 service client using the aws.Configand the NewFromConfig function:\nimport \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig() if err != nil { panic(err) } client := s3.NewFromConfig(cfg) Overriding Configuration NewFromConfig can take one or more functional arguments that can mutate a client’s configuration Options struct. This allows you to make specific overrides such as changing the Region, or modifying service specific options such as Amazon S3 UseAccelerate option. For example:\nimport \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig() if err != nil { panic(err) } client := s3.NewFromConfig(cfg, func(o *s3.Options) { o.Region = \"us-west-2\" o.UseAccelerate = true }) Overrides to the client Options value is determined by the order that the functional arguments are given to NewFromConfig.\nNew New is considered a more advanced form of client construction. We recommend you use NewFromConfig for client construction, as it allows construction using the aws.Config struct. This removes the need to construct an Options struct instance for each service client your application requires.\n New function is a client constructor provides an interface for constructing clients using only the client packages Options struct for defining the client’s configuration options. For example to construct Amazon S3 client using New:\nimport \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/credentials\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  client := s3.New(s3.Options{ Region: \"us-west-2\", Credentials: \u0026aws.CredentialsCache{Provider: credentials.NewStaticCredentials(accessKey, secretKey)}. }) Overriding Configuration New can take one or more functional arguments that can mutate a client’s configuration Options struct. This allows you to make specific overrides such as changing the Region or modifying service specific options such as Amazon S3 UseAccelerate option. For example:\nimport \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/credentials\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  options := s3.Options{ Region: \"us-west-2\", Credentials: \u0026aws.CredentialsCache{Provider: credentials.NewStaticCredentials(accessKey, secretKey)}. } client := s3.New(options, func(o *s3.Options) { o.Region = \"us-east-1\" o.UseAccelerate = true }) Overrides to the client Options value is determined by the order that the functional arguments are given to New.\nCalling Service Operations After you have a service client instance, you can use it to call a service’s operations. For example to call the Amazon S3 GetObject operation:\nresponse, err := client.GetObject(context.TODO(), \u0026s3.GetObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"obj-key\"), }) When you call a service operation, the SDK synchronously validates the input, serializes the request, signs it with your credentials, sends it to AWS, and then deserializes a response or an error. In most cases, you can call service operations directly. Each service operation client method will return an operation response struct, and an error interface type. You should always check error type to determine if an error occurred before attempting to access the service operation’s response struct.\nPassing Parameters to a Service Operation Each service operation method takes a context.Context value that can be used for setting request deadlines that will be honored by the SDK. In addition, each service operation will take a \u003cOperationName\u003eInput struct found in the service’s respective Go package. You pass in API input parameters using the operation input struct.\nOperation input structures can have input parameters such as the standard Go numerics, boolean, string, map, and list types. In more complex API operations a service may have more complex modeling of input parameters. These other types such as service specific structures and enum values are found in the service’s types Go package.\nIn addition, services may distinguish between the default value of a Go type and whether the value was set or not by the user. In these cases, input parameters may require you to pass a pointer reference to the type in question. For standard Go types like numerics, boolean, and string there are \u003cType\u003e and From\u003cType\u003e convenience functions available in the aws to ease this conversion. For example aws.String can be used to convert a string to a *string type for input parameters that require a pointer to a string. Inversely aws.ToString can be used to transform a *string to a string while providing protection from dereferencing a nil pointer. The To\u003cType\u003e functions are helpful when handling service responses.\nLet’s look at an example of how we can use a Amazon S3 client to call the GetObject API, and construct our input using the types package, and aws.\u003cType\u003e helpers.\nimport \"context\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/aws-sdk-go-v2/service/s3/types\" // ...  cfg, err := config.LoadDefaultConfig() if err != nil { panic(err) } client := s3.NewFromConfig(cfg) resp, err := client.GetObject(context.TODO(), \u0026s3.GetObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"keyName\"), RequestPayer: types.RequestPayerRequester, }) Overriding Client Options For Operation Call Similar to how client operation options can be modified during construction of a client using functional arguments, the client options can be modified at the time the operation method is called by providing one or more functional arguments to the service operation method. This action is concurrency safe and will not affect other concurrent operations on the client.\nFor example to override the client region from “us-west-2” to “us-east-1”:\ncfg, err := config.LoadDefaultConfig(config.WithRegion(\"us-west-2\")) if err != nil { log.Printf(\"error: %v\", err) return } client := s3.NewFromConfig(cfg) params := \u0026s3.GetObjectInput{ // ... } resp, err := client.GetObject(context.TODO(), params, func(o *Options) { o.Region = \"us-east-1\" }) Handling Operation Responses Each service operation has an associated output struct that contains the service’s operation response members. The output struct follows the following naming pattern \u003cOperationName\u003eOutput. Some operations may have no members defined for their operation output. After calling a service operation, the return error argument type should always be checked to determine if an error occurred while invoking the service operation. Errors returned can range from client-side input validation errors to service-side error responses returned to the client. The operation’s output struct should not be accessed in the event that a non-nil error is returned by the client.\nFor example to log an operation error and prematurely return from the calling function:\nresponse, err := client.GetObject(context.TODO()) if err != nil { log.Printf(\"GetObject error: %v\", err) return } For more information on error handling, including how to inspect for specific error types, see the Handling Errors documentation.\nResponses with io.ReadCloser Some API operations return a response struct that contain an output member that is an io.ReadCloser. If you’re making requests with these operations, always be sure to call io.ReadCloser member’s Close method after you’ve completed reading the content.\nFor example Amazon S3 GetObject operation returns a response whose Body member is an io.ReadCloser:\nresp, err := s3svc.GetObject(context.TODO(), \u0026s3.GetObjectInput{...}) if err != nil { // handle error  return } // Make sure to always close the response Body when finished defer resp.Body.Close() decoder := json.NewDecoder(resp.Body) if err := decoder.Decode(\u0026myStruct); err != nil { // handle error  return } Response Metadata All service operation output structs include a ResultMetadata member of type middleware.Metadata. middleware.Metadata is used by the SDK middleware to provide additional information from a service response that is not modeled by the service. This includes metadata like the RequestID. For example to retrieve the RequestID associated with a service response to assit AWS Support in troubleshooting a request:\nimport \"fmt\" import \"log\" import \"github.com/aws/aws-sdk-go-v2/aws/middleware\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ..  resp, err := client.GetObject(context.TODO(), \u0026s3.GetObjectInput{ // ... }) if err != nil { log.Printf(\"error: %v\", err) return } requestID, ok := middleware.GetRequestIDMetadata(resp.ResultMetadata) if !ok { fmt.Println(\"RequestID not included with request\") } fmt.Printf(\"RequestID: %s\\n\", requestID) Concurrently Using Service Clients You can create goroutines that concurrently use the same service client to send multiple requests. You can use a service client with as many goroutines as you want.\nIn the following example, an service client is used in multiple goroutines. This example concurrently uploads two objects to an Amazon S3 bucket.\nimport \"log\" import \"strings\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig() if err != nil { log.Printf(\"error: %v\", err) return } client := s3.NewFromConfig(cfg) type result struct { Output *s3.PutObjectOutput Err error } results := make(chan result, 2) var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() output, err := client.PutObject(context.TODO(), \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"foo\"), Body: strings.NewReader(\"foo body content\"), }) results \u003c- result{Output: output, Err: err} }() go func() { defer wg.Done() output, err := client.PutObject(context.TODO(), \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"bar\"), Body: strings.NewReader(\"bar body content\"), }) results \u003c- result{Output: output, Err: err} }() wg.Wait() close(results) for result := range results { if result.Err != nil { log.Printf(\"error: %v\", result.Err) continue } fmt.Printf(\"etag: %v\", aws.ToString(result.Output.ETag)) } Using Operation Paginators Typically, when you retrieve a list of items, you may need to check the output struct for a token or marker to confirm whether the AWS service returned all results from your request. If present, you use the token or marker to request the next page of results. Instead of managing these tokens or markers, you can use the service package’s available paginator types.\nPaginator helpers are available for supported service operations, and can be found in the service client’s Go package. To construct a paginator for a supported operation, use the New\u003cOperationName\u003ePaginator function. Paginator construct functions take the service Client, the operation’s \u003cOperationName\u003eInput input parameters, and an optional set of functional arguments allowing you to configure other optional paginator settings.\nThe returned operation paginator type provides a convenient way to iterate over a paginated operation until you have reached the last page, or you have found the item(s) that your application was searching for. A paginator type has two methods: HasMorePages and NextPage. HasMorePages returns a boolean value of true if the first page has not been retrieved, or if additional pages available to retrieve using the operation. To retrieve the first or subsequent pages of the operation, the NextPage operation must be called. NextPage takes context.Context and returns the operation output and any corresponding error. Like the client operation method return parameters, the return error should always be checked before attempting to use the returned response structure. See Handling Operation Responses\nThe following example uses the ListObjectsV2 paginator to list up to three pages of object keys from the ListObjectV2operation. Each page consists of up to 10 keys, which is defined by the Limit paginator option.\nimport \"log\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" // ...  cfg, err := config.LoadDefaultConfig() if err != nil { log.Printf(\"error: %v\", err) return } client := s3.NewFromConfig(cfg) params := \u0026s3.ListObjectsV2Input{ Bucket: aws.String(\"my-bucket\"), } pagiantor := s3.NewListObjectsV2Paginator(client, params, func(o *ListObjectsV2PaginatorOptions) { o.Limit = 10 }) pageNum := 0 for pagiantor.HasMorePages() \u0026\u0026 pageNum \u003c 3 { output, err := pagiantor.NextPage(context.TODO()) if err != nil { log.Printf(\"error: %v\", err) return } for _, value := range page.Contents { fmt.Println(*value.Key) } pageNum++ } Similar to client operation method, the client options like the request Region can be modified by providing one or more functional arguments to NextPage. For more information about overriding client options when calling an operation see Overriding Clients For Operation\nUsing Waiters Waiters are not currently supported in the current AWS SDK for Go V2 developer preview release.\n ","excerpt":"To make calls to an AWS service, you must first construct a service …","ref":"/aws-sdk-go-v2/docs/making-requests/","title":"Using the AWS SDK for Go V2 with AWS Services"},{"body":"You can use AWS Cloud9 with the AWS SDK for Go V2 to write and run your Go code using just a browser. AWS Cloud9 includes tools such as a code editor and terminal. Because the AWS Cloud9 IDE is cloud based, you can work on your projects from your office, home, or anywhere using an internet-connected machine. For general information about AWS Cloud9, see the AWS Cloud9 User Guide.\nFollow these instructions to set up AWS Cloud9 with the AWS SDK for Go V2:\nSet up Your AWS Account to Use AWS Cloud9 Start to use AWS Cloud9 by signing in to the AWS Cloud9 console as an AWS Identity and Access Management (IAM) entity (for example, an IAM user) in your AWS account who has access permissions for AWS Cloud9.\nTo set up an IAM entity in your AWS account to access AWS Cloud9, and to sign in to the AWS Cloud9 console, see Team Setup for AWS Cloud9 in the AWS Cloud9 User Guide.\nSet up Your AWS Cloud9 Development Environment After you sign in to the AWS Cloud9 console, use the console to create an AWS Cloud9 development environment. After you create the environment, AWS Cloud9 opens the IDE for that environment.\nSee Creating an Environment in AWS Cloud9 in the AWS Cloud9 User Guide for details.\nAs you create your environment in the console for the first time, we recommend that you choose the option to Create a new instance for environment (EC2). This option tells AWS Cloud9 to create an environment, launch an Amazon EC2 instance, and then connect the new instance to the new environment. This is the fastest way to begin using AWS Cloud9.\n Set up the AWS SDK for Go V2 After AWS Cloud9 opens the IDE for your development environment, use the IDE to set up the AWS SDK for Go V2 in your environment, as follows.\n  If the terminal isn’t already open in the IDE, open it. On the menu bar in the IDE, choose Window, New Terminal.\n  Validate the AWS Cloud9 available Go version.\ngo version If the Go version reports a version less than 1.15, or the IDE can’t find the Go binary follow the guide to Install/Upgrade Go.\n  Follow the Getting Started guide to set up a Go project under ~/environment, or follow the steps to Download Example Code\n  Download Example Code Use the terminal you opened in the previous step to download example code for the AWS SDK for Go V2 into the AWS Cloud9 development environment.\nTo do this, run the following command. This command downloads a copy of all the code examples used in the official AWS SDK documentation into your environment’s root directory.\ngit clone https://github.com/awsdocs/aws-doc-sdk-examples.git To find code examples for the AWS SDK for Go V2, use the Environment window to open the ENVIRONMENT_NAME/aws-doc-sdk-examples/gov2 directory, where ENVIRONMENT_NAME is the name of your development environment.\nRun Example Code To run code in your AWS Cloud9 development environment, see Run Your Code in the AWS Cloud9 User Guide.\nInstalling/Upgrading AWS Cloud9 Go Version If the IDE can’t find Go or version of Go does’t meet the minimum require version, run the following commands, one at a time in this order, to install it. (These commands assume you chose the option to Create a new instance for environment (EC2), earlier in this topic. Also, these commands assume the latest stable version of Go at the time this topic was written; for more information, see Downloads on The Go Programming Language website.)\nwget https://golang.org/dl/go1.15.5.linux-amd64.tar.gz # Download the Go installer. sudo tar -C /usr/local -xzf ./go1.15.5.linux-amd64.tar.gz # Install Go. rm ./go1.15.5.linux-amd64.tar.gz # Delete the Go installer, as you no longer need it. After you install Go, add the path to the Go binary to your PATH environment variable. To do this, add the following code to the end of your shell profile file (for example, ~/.bashrc in Amazon Linux, assuming you chose the option to Create a new instance for environment (EC2), earlier in this topic), and then save the file.\n PATH=$PATH:/usr/local/go/bin After you save the file, source the ~/.bashrc file so that the terminal can now find the Go binary you just referenced. To do this, run the following command. (This command assumes you chose the option to Create a new instance for environment (EC2), earlier in this topic.)\n. ~/.bashrc ","excerpt":"You can use AWS Cloud9 with the AWS SDK for Go V2 to write and run …","ref":"/aws-sdk-go-v2/docs/cloud9-go/","title":"Using AWS Cloud9 with the AWS SDK for Go V2"},{"body":"The shared responsibility model applies to data protection in this AWS product or service. As described in this model, AWS is responsible for protecting the global infrastructure that runs all of the AWS Cloud. You are responsible for maintaining control over your content that is hosted on this infrastructure. This content includes the security configuration and management tasks for the AWS services that you use. For more information about data privacy, see the Data Privacy FAQ. For information about data protection in Europe, see the AWS Shared Responsibility Model and GDPR blog post on the AWS Security Blog.\nFor data protection purposes, we recommend that you protect AWS account credentials and set up individual user accounts with AWS Identity and Access Management (IAM). That way each user is given only the permissions necessary to fulfill their job duties. We also recommend that you secure your data in the following ways:\n Use multi-factor authentication (MFA) with each account. Use SSL/TLS to communicate with AWS resources. We recommend TLS 1.2 or later. Set up API and user activity logging with AWS CloudTrail. Use AWS encryption solutions, with all default security controls within AWS services. Use advanced managed security services such as Amazon Macie, which assists in discovering and securing personal data that is stored in Amazon S3. If you require FIPS 140-2 validated cryptographic modules when accessing AWS through a command line interface or an API, use a FIPS endpoint. For more information about the available FIPS endpoints, see Federal Information Processing Standard (FIPS) 140-2.  We strongly recommend that you never put sensitive identifying information, such as your customers' account numbers, into free-form fields such as a Name field. This includes when you work with AWS SDK for Go V2 or other AWS services using the console, API, AWS CLI, or AWS SDKs. Any data that you enter into AWS SDK for Go V2 or other services might get picked up for inclusion in diagnostic logs. When you provide a URL to an external server, don’t include credentials information in the URL to validate your request to that server.\n","excerpt":"The shared responsibility model applies to data protection in this AWS …","ref":"/aws-sdk-go-v2/docs/security/data-protection/","title":"Data Protection in this AWS Product or Service"},{"body":"The AWS SDK for Go V2 configures the default HTTP client used by the SDK service clients to require a minimum version of TLS 1.2 or greater. When using the http.BuildableClient to customize the SDK HTTP client, the minimum TLS value is configured as TLS 1.2.\nIf your application constructs an HTTP client using a method other than the provided BuildableClient, you must configure your client to set the minimum TLS version to 1.2.\n ","excerpt":"The AWS SDK for Go V2 configures the default HTTP client used by the …","ref":"/aws-sdk-go-v2/docs/security/tls/","title":"Enforcing TLS Version 1.2 in AWS SDK for Go V2"},{"body":"Cloud security at Amazon Web Services (AWS) is the highest priority. As an AWS customer, you benefit from a data center and network architecture that is built to meet the requirements of the most security-sensitive organizations. Security is a shared responsibility between AWS and you. The Shared Responsibility Model describes this as Security of the Cloud and Security in the Cloud.\nSecurity of the Cloud– AWS is responsible for protecting the infrastructure that runs all of the services offered in the AWS Cloud and providing you with services that you can use securely. Our security responsibility is the highest priority at AWS, and the effectiveness of our security is regularly tested and verified by third-party auditors as part of the AWS Compliance Programs.\nSecurity in the Cloud– Your responsibility is determined by the AWS service you are using, and other factors including the sensitivity of your data, your organization’s requirements, and applicable laws and regulations.\n","excerpt":"Cloud security at Amazon Web Services (AWS) is the highest priority. …","ref":"/aws-sdk-go-v2/docs/security/","title":"Security for this AWS Product or Service"},{"body":"You can use the AWS SDK for Go V2 to access the Amazon EC2 Instance Metadata Service. The ec2imds Go package provide a Client type that can be used to access the Amazon EC2 Instance Metadata Service. The Client and associated operations can be used similarly to the other AWS service clients provided by the SDK. To learn more information on how to configure the SDK, and use service clients see Configuring the SDK and Using AWS Services.\nThe client can help you easily retrieve information about instances on which your applications run, such as its AWS Region or local IP address. Typically, you must create and submit HTTP requests to retrieve instance metadata. Instead, create an ec2imds.Client to access the Amazon EC2 Instance Metadata Service using a programmatic client like other AWS Services.\nFor example to construct a client:\nimport \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/ec2imds\" // ...  cfg, err := config.LoadDefaultConfig() if err != nil { log.Printf(\"error: %v\", err) return } client := ec2imds.NewFromConfig(cfg) Then use the service client to retrieve information from a metadata category such as local-ipv4 (the private IP address of the instance).\nlocalip, err := client.GetMetadata(context.Background(), \u0026ec2imds.GetMetadataInput{ Path: \"local-ipv4\", }) if err != nil { log.Printf(\"Unable to retrieve the private IP address from the EC2 instance: %s\\n\", err) return } fmt.Printf(\"local-ip: %v\\n\", localip) For a list of all metadata categories, see Instance Metadata Categories in the \u003cnil\u003e User Guide.\nRetrieving an Instance’s Region There’s no instance metadata category that returns only the Region of an instance. Instead, use the included Region method to easily return an instance’s Region.\nregion, err := client.GetRegion(context.Background(), \u0026ec2imds.GetRegionInput{}) if err != nil { log.Printf(\"Unable to retrieve the region from the EC2 instance %v\\n\", err) } fmt.Printf(\"region: %v\\n\", region) For more information about the EC2 metadata utility, see the ec2imds package in the AWS SDK for Go V2 API Reference.\n","excerpt":"You can use the AWS SDK for Go V2 to access the Amazon EC2 Instance …","ref":"/aws-sdk-go-v2/docs/sdk-utilities/ec2-imds/","title":"Amazon EC2 Instance Metadata Service"},{"body":"Transfer Managers The Amazon Simple Storage Service upload and download managers can break up large objects, so they can be transferred in multiple parts, in parallel. This makes it easy to resume interrupted transfers.\nUpload Manager The Amazon Simple Storage Service upload manager determines if a file can be split into smaller parts and uploaded in parallel. You can customize the number of parallel uploads and the size of the uploaded parts.\nThe following example uses the Amazon S3 Uploader to upload a file. Using Uploader is similar to the s3.PutObject() operation.\nimport \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/aws-sdk-go-v2/feature/s3/manager\" // ...  cfg, err := config.LoadDefaultConfig() if err != nil { log.Printf(\"error: %v\", err) return } client := s3.NewFromConfig(cfg) uploader := manager.NewUploader(client) result, err := uploader.Upload(context.Background(), \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-object-okey\"), Body: uploadFile, }) Configuration Options When you instantiate an Uploader instance using NewUploader, you can specify several configuration options to customize how objects are uploaded. Options are overridden by providing one or more arguments to NewUploader. These options include:\n PartSize – Specifies the buffer size, in bytes, of each part to upload. The minimum size per part is 5 MiB. Concurrency – Specifies the number of parts to upload in parallel. LeavePartsOnError – Indicates whether to leave successfully uploaded parts in Amazon S3.  The Concurrency value limits the concurrent number of part uploads that can occur for a given Upload call. This is not a global client concurrency limit. Tweak the PartSize and Concurrency configuration values to find the optimal configuration. For example, systems with high-bandwidth connections can send bigger parts and more uploads in parallel.\nFor example, your application configures Uploader with a Concurrency of setting of 5. If your application then calls Upload from two different goroutines, the result is 10 concurrent part uploads (2 goroutines * 5 Concurrency).\nYour application is expected to limit the concurrent calls to Upload to prevent application resource exhaustion.\n For example, to check the default part size during Uploader creation:\nuploader := manager.NewUploader(client, func(u *Uploader) { u.PartSize = 10 * 1024 * 1024, // 10 MiB }) For more information about Uploader and its configurations, see Uploader in the AWS SDK for Go V2 API Reference.\nPutObjectInput Body Field (io.ReadSeeker vs. io.Reader) The Body field of the s3.PutObjectInput struct is an io.Reader type. However, this field can be populated with a type that satisfies both the io.ReadSeeker and io.ReaderAt interface to improve application resource utilization of the host environment. The following example creates the type ReadSeekerAt that satisfies both interfaces:\ntype ReadSeekerAt interface { io.ReadSeeker io.ReaderAt } For body values that implement the ReadSeekerAt type, the Uploader doesn’t buffer the body contents in memory before sending it to Amazon S3. Uploader calculates the expected number of parts before uploading the file to Amazon S3. If the current value of PartSize requires more than 10,000 parts to upload the file, Uploader increases the part size value so that fewer parts are required.\nFor io.Reader types, the bytes of the reader must be buffered in memory before the part can be uploaded. When you increase the PartSize or Concurrency value, the required memory (RAM) for the Uploader increases significantly. The required memory is approximately PartSize * Concurrency. For example, specifying 100 MB for PartSize and 10 for Concurrency, requires at least 1 GB.\nBecause an io.Reader type cannot determine its size before reading its bytes, Uploader cannot calculate how many parts will be uploaded. Consequently, Uploader can reach the Amazon S3 upload limit of 10,000 parts for large files if you set the PartSize too low. If you try to upload more than 10,000 parts, the upload stops and returns an error.\nHandling Failed Uploads If an upload to Amazon S3 fails, by default, Uploader uses the Amazon S3 AbortMultipartUpload operation to remove the uploaded parts. This functionality ensures that failed uploads do not consume Amazon S3 storage.\nYou can set LeavePartsOnError to true so that the Uploader doesn’t delete successfully uploaded parts. This is useful for resuming partially completed uploads. To operate on uploaded parts, you must get the UploadID of the failed upload. The following example demonstrates how to use the manager.MultiUploadFailure error interface type to get the UploadID.\nresult, err := uploader.Upload(context.Background(), \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-object-okey\"), Body: uploadFile, }) output, err := u.upload(input) if err != nil { var mu manager.MultiUploadFailure if errors.As(err, \u0026mu) { // Process error and its associated uploadID \tfmt.Println(\"Error:\", mu) _ = mu.UploadID() // retrieve the associated UploadID \t} else { // Process error generically \tfmt.Println(\"Error:\", err.Error()) } return } Overriding Uploader Options Per Upload You can override the Uploader options when calling Upload by providing one or more arguments to the method. These overrides are concurrency-safe modifications and do not affect ongoing uploads, or subsequent Upload calls to the manager. For example, to override the PartSize configuration for a specific upload request:\nparams := \u0026s3.PutObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-key\"), Body: myBody, } resp, err := uploader.Upload(context.Background(), params, func(u *manager.Uploader) { u.PartSize = 10 * 1024 * 1024, // 10 MiB }) Examples Upload a Folder to Amazon S3 The following example uses the path/filepath package to recursively gather a list of files and upload them to the specified Amazon S3 bucket. The keys of the Amazon S3 objects are prefixed with the file’s relative path.\npackage main import ( \"context\" \"log\" \"os\" \"path/filepath\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/feature/s3/manager\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) var ( localPath string bucket string prefix string ) func init() { if len(os.Args) != 4 { log.Fatalln(\"Usage:\", os.Args[0], \"\u003clocal path\u003e \u003cbucket\u003e \u003cprefix\u003e\") } localPath = os.Args[1] bucket = os.Args[2] prefix = os.Args[3] } func main() { walker := make(fileWalk) go func() { // Gather the files to upload by walking the path recursively \tif err := filepath.Walk(localPath, walker.Walk); err != nil { log.Fatalln(\"Walk failed:\", err) } close(walker) }() cfg, err := config.LoadDefaultConfig() if err != nil { log.Fatalln(\"error:\", err) } // For each file found walking, upload it to Amazon S3 \tuploader := manager.NewUploader(s3.NewFromConfig(cfg)) for path := range walker { rel, err := filepath.Rel(localPath, path) if err != nil { log.Fatalln(\"Unable to get relative path:\", path, err) } file, err := os.Open(path) if err != nil { log.Println(\"Failed opening file\", path, err) continue } defer file.Close() result, err := uploader.Upload(context.Background(), \u0026s3.PutObjectInput{ Bucket: \u0026bucket, Key: aws.String(filepath.Join(prefix, rel)), Body: file, }) if err != nil { log.Fatalln(\"Failed to upload\", path, err) } log.Println(\"Uploaded\", path, result.Location) } } type fileWalk chan string func (f fileWalk) Walk(path string, info os.FileInfo, err error) error { if err != nil { return err } if !info.IsDir() { f \u003c- path } return nil } Download Manager The Amazon S3 Downloader manager determines if a file can be split into smaller parts and downloaded in parallel. You can customize the number of parallel downloads and the size of the downloaded parts.\nExample: Download a File The following example uses the Amazon S3 Downloader to download a file. Using Downloader is similar to the [s3.GetObject]({% apiref “service/s3#Client.GetObject” %}}) operation.\nimport \"github.com/aws/aws-sdk-go-v2/aws\" import \"github.com/aws/aws-sdk-go-v2/config\" import \"github.com/aws/aws-sdk-go-v2/service/s3\" import \"github.com/aws/aws-sdk-go-v2/feature/s3/manager\" // ...  cfg, err := config.LoadDefaultConfig() if err != nil { log.Println(\"error:\", err) return } client := s3.NewFromConfig(cfg) downloader := manager.NewDownloader(client) numBytes, err := downloader.Download(context.Background(), downloadFile, \u0026s3.GetObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-key\"), }) The downloadFile parameter is an io.WriterAt type. The WriterAt interface enables the Downloader to write multiple parts of the file in parallel.\nConfiguration Options When you instantiate a Downloader instance, you can specify configuration options to customize how objects are downloaded:\n PartSize – Specifies the buffer size, in bytes, of each part to download. The minimum size per part is 5 MB. Concurrency – Specifies the number of parts to download in parallel.  The Concurrency value limits the concurrent number of part download that can occur for a given Download call. This is not a global client concurrency limit. Tweak the PartSize and Concurrency configuration values to find the optimal configuration. For example, systems with high-bandwidth connections can recieve bigger parts and more downloads in parallel.\nFor example, your application configures Downloader with a Concurrency of 5. Your application then calls Download from two different goroutines, the result will be 10 concurrent part downloads (2 goroutines * 5 Concurrency).\nYour application is expected to limit the concurrent calls to Download to prevent application resource exhaustion.\n For more information about Downloader and its other configuration options, see manager.Downloader in the AWS SDK for Go V2 API Reference.\nOverriding Downloader Options Per Download You can override the Downloader options when calling Download by providing one or more functional arguments to the method. These overrides are concurrency safe modifications and do not affect ongoing uploads, or subsequent Download calls to the manager. For example, to override the PartSize configuration for a specific upload request:\nparams := \u0026s3.GetObjectInput{ Bucket: aws.String(\"my-bucket\"), Key: aws.String(\"my-key\"), } resp, err := downloader.Download(context.Background(), targetWriter, params, func(u *manager.Downloader) { u.PartSize = 10 * 1024 * 1024, // 10 MiB }) Examples Download All Objects in a Bucket The following example uses pagination to gather a list of objects from an Amazon S3 bucket. Then it downloads each object to a local file.\npackage main import ( \"context\" \"fmt\" \"log\" \"os\" \"path/filepath\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/feature/s3/manager\" \"github.com/aws/aws-sdk-go-v2/service/s3\" ) var ( Bucket = \"MyBucket\" // Download from this bucket \tPrefix = \"logs/\" // Using this key prefix \tLocalDirectory = \"s3logs\" // Into this directory ) func main() { cfg, err := config.LoadDefaultConfig() if err != nil { log.Fatalln(\"error:\", err) } client := s3.NewFromConfig(cfg) manager := manager.NewDownloader(client) paginator := s3.NewListObjectsV2Paginator(client, \u0026s3.ListObjectsV2Input{ Bucket: \u0026Bucket, Prefix: \u0026Prefix, }) for paginator.HasMorePages() { page, err := paginator.NextPage(context.Background()) if err != nil { log.Fatalln(\"error:\", err) } for _, obj := range page.Contents { if err := downloadToFile(manager, LocalDirectory, Bucket, aws.ToString(obj.Key)); err != nil { log.Fatalln(\"error:\", err) } } } } func downloadToFile(downloader *manager.Downloader, targetDirectory, bucket, key string) error { // Create the directories in the path \tfile := filepath.Join(targetDirectory, key) if err := os.MkdirAll(filepath.Dir(file), 0775); err != nil { return err } // Set up the local file \tfd, err := os.Create(file) if err != nil { return err } defer fd.Close() // Download the file using the AWS SDK for Go \tfmt.Printf(\"Downloading s3://%s/%s to %s...\\n\", bucket, key, file) _, err = downloader.Download(context.Background(), fd, \u0026s3.GetObjectInput{Bucket: \u0026bucket, Key: \u0026key}) return err } GetBucketRegion The GetBucketRegion is a utility function for determining the AWS Region location of an Amazon S3 Bucket. GetBucketRegion takes an Amazon S3 client and uses it to determine the location of the requested Bucket within the AWS Partition associated with the client’s configured Region.\nFor example to find the Region for the Bucket my-bucket:\ncfg, err := config.LoadDefaultConfig() if err != nil { log.Println(\"error:\", err) return } bucket := \"my-bucket\" region, err := manager.GetBucketRegion(ctx, s3.NewFromConfig(cfg), bucket) if err != nil { var bnf manager.BucketNotFound if errors.As(err, \u0026bnf) { log.Printf(\"unable to find bucket %s's Region\\n\", bucket) } else { log.Println(\"error:\", err) } return } fmt.Printf(\"Bucket %s is in %s region\\n\", bucket, region) If GetBucketRegion is not able to resolve the location of a Bucket, the function returns a BucketNotFound error type as shown in the example.\n","excerpt":"Transfer Managers The Amazon Simple Storage Service upload and …","ref":"/aws-sdk-go-v2/docs/sdk-utilities/s3/","title":"Amazon S3 Utilities"},{"body":" Welcome to the AWS SDK for Go V2 Learn More   Download          ","excerpt":" Welcome to the AWS SDK for Go V2 Learn More   Download          ","ref":"/aws-sdk-go-v2/","title":"AWS SDK for Go V2"}]