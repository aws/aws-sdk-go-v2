package enhancedclient

import (
	"fmt"
	"reflect"
	"slices"
	"strings"
	"testing"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

type order struct {
	OrderID      string            `dynamodbav:"order_id,partition,autogenerated:key" dynamodbindex:"TotalAmountIndex,global,sort"`
	CreatedAt    int64             `dynamodbav:"created_at,sort" dynamodbindex:"CustomerIndex,sort"`
	CustomerID   string            `dynamodbav:"customer_id" dynamodbindex:"CustomerIndex,global,partition"`
	TotalAmount  float64           `dynamodbav:"total" dynamodbindex:"TotalAmountIndex,global,partition"`
	IgnoredField string            `dynamodbav:"-"`
	Version      int64             `dynamodbav:"version,version" dynamodbindex:"OrderVersionIndex,local,sort"`
	Metadata     map[string]string `dynamodbav:"metadata"`
	address
	Notes             []string `dynamodbav:",preserveempty,stringset"`
	customerNote      string   `dynamodbav:"note" dynamodbgetter:"Note" dynamodbsetter:"SetNote" dynamodbindex:"NoteIndex,global,partition"`
	CustomerFirstName string   `dynamodbav:"first_name"`
	CustomerLastName  string   `dynamodbav:"last_name"`
}

// Getter method for customerNote
func (o *order) Note() string {
	return o.customerNote
}

// Setter method for customerNote
func (o *order) SetNote(note string) {
	o.customerNote = strings.TrimSpace(note)
}

type address struct {
	Street string `dynamodbav:"street"`
	City   string `dynamodbav:"city"`
	Zip    string `dynamodbav:"zip" dynamodbindex:"RegionIndex,global,partition"`
}

func TestSchema(t *testing.T) {
	actual, err := NewSchema[order]()
	if err != nil {
		t.Fatalf("NewSchema error: %v", err)
	}

	if len(actual.cachedFields.fields) != 13 {
		t.Fatalf("expected %d cachedFields, found %d", 13, len(actual.cachedFields.fields))
	}

	// | Index Name          | Partition Key | Sort Key     | Type | Notes                       |
	// | ------------------- | ------------- | ------------ | ---- | --------------------------- |
	// | `CustomerIndex`     | `customer_id` | `created_at` | GSI  | Already present             |
	// | `TotalAmountIndex`  | `total`       | `order_id`   | GSI  | Useful for order bucketing  |
	// | `OrderVersionIndex` | `order_id`    | `version`    | LSI  | Good for optimistic locking |
	// | `RegionIndex`       | `zip`         | (none)       | GSI  | Region-based querying       |
	// | `NoteIndex`         | `note`        | (optional)   | GSI  | Requires public exposure    |
	expected := &Schema[order]{
		typ:         reflect.TypeFor[order](),
		tableName:   pointer("order"),
		billingMode: types.BillingModePayPerRequest,
		keySchema: []types.KeySchemaElement{
			{AttributeName: pointer("order_id"), KeyType: types.KeyTypeHash},
			{AttributeName: pointer("created_at"), KeyType: types.KeyTypeRange},
		},
		attributeDefinitions: []types.AttributeDefinition{
			{AttributeName: pointer("order_id"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("created_at"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("customer_id"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("total"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("version"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("zip"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("note"), AttributeType: types.ScalarAttributeTypeS},
		},
		localSecondaryIndexes: []types.LocalSecondaryIndex{
			{
				IndexName: pointer("OrderVersionIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("order_id"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("version"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
		},
		globalSecondaryIndexes: []types.GlobalSecondaryIndex{
			{
				IndexName: pointer("CustomerIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("customer_id"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("created_at"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("TotalAmountIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("total"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("order_id"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("RegionIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("zip"), KeyType: types.KeyTypeHash},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("NoteIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("note"), KeyType: types.KeyTypeHash},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
		},
		cachedFields: &cachedFields{
			fields: []field{
				{
					Name:        "order_id",
					NameFromTag: true,
					Index:       []int{0},
					Type:        reflect.TypeFor[string](),
					tag: tag{
						Name:          "order_id",
						Partition:     true,
						AutoGenerated: true,
						Generator:     "key",
						Indexes: []Index{
							{
								Name:   "TotalAmountIndex",
								Global: true,
								Sort:   true,
							},
						},
					},
				},
				{
					Name:        "created_at",
					NameFromTag: true,
					Index:       []int{1},
					Type:        reflect.TypeFor[int64](),
					tag: tag{
						Name: "created_at",
						Sort: true,
						Indexes: []Index{
							{
								Name: "CustomerIndex",
								Sort: true,
							},
						},
					},
				},
				{
					Name:        "customer_id",
					NameFromTag: true,
					Index:       []int{2},
					Type:        reflect.TypeFor[string](),
					tag: tag{
						Name: "customer_id",
						Indexes: []Index{
							{
								Name:      "CustomerIndex",
								Global:    true,
								Partition: true,
							},
						},
					},
				},
				{
					Name:        "total",
					NameFromTag: true,
					Index:       []int{3},
					Type:        reflect.TypeFor[float64](),
					tag: tag{
						Name: "total",
						Indexes: []Index{
							{
								Name:      "TotalAmountIndex",
								Global:    true,
								Partition: true,
							},
						},
					},
				},
				{
					Name:        "version",
					NameFromTag: true,
					Index:       []int{5},
					Type:        reflect.TypeFor[int64](),
					tag: tag{
						Name:    "version",
						Version: true,
						Indexes: []Index{
							{
								Name:  "OrderVersionIndex",
								Sort:  true,
								Local: true,
							},
						},
					},
				},
				{
					Name:        "metadata",
					NameFromTag: true,
					Index:       []int{6},
					Type:        reflect.TypeFor[map[string]string](),
					tag: tag{
						Name: "metadata",
					},
				},
				{
					Name:        "street",
					NameFromTag: true,
					Index:       []int{7, 0},
					Type:        reflect.TypeFor[string](),
					tag: tag{
						Name: "street",
					},
				},
				{
					Name:        "city",
					NameFromTag: true,
					Index:       []int{7, 1},
					Type:        reflect.TypeFor[string](),
					tag: tag{
						Name: "city",
					},
				},
				{
					Name:        "zip",
					NameFromTag: true,
					Index:       []int{7, 2},
					Type:        reflect.TypeFor[string](),
					tag: tag{
						Name: "zip",
						Indexes: []Index{
							{
								Name:      "RegionIndex",
								Global:    true,
								Partition: true,
							},
						},
					},
				},
				{
					Name:  "Notes",
					Index: []int{8},
					Type:  reflect.TypeFor[[]string](),
					tag: tag{
						PreserveEmpty: true,
						AsStrSet:      true,
					},
				},
				{
					Name:        "note",
					NameFromTag: true,
					Index:       []int{9},
					Type:        reflect.TypeFor[string](),
					tag: tag{
						Name:   "note",
						Getter: "Note",
						Setter: "SetNote",
						Indexes: []Index{
							{
								Name:      "NoteIndex",
								Global:    true,
								Partition: true,
							},
						},
					},
				},
				{
					Name:        "first_name",
					NameFromTag: true,
					Index:       []int{10},
					Type:        reflect.TypeFor[string](),
					tag: tag{
						Name: "first_name",
					},
				},
				{
					Name:        "last_name",
					NameFromTag: true,
					Index:       []int{11},
					Type:        reflect.TypeFor[string](),
					tag: tag{
						Name: "last_name",
					},
				},
			},
			fieldsByName: map[string]int{
				"order_id":    0,
				"created_at":  1,
				"customer_id": 2,
				"total":       3,
				"version":     4,
				"metadata":    5,
				"street":      6,
				"city":        7,
				"zip":         8,
				"Notes":       9,
				"note":        10,
				"first_name":  11,
				"last_name":   12,
			},
		},
		enc: NewEncoder[order](),
		dec: NewDecoder[order](),
	}

	// reflect.DeepEqual cannot compare function pointers
	expected.enc.options.EncodeTime = nil
	expected.dec.options.DecodeTime.N = nil
	expected.dec.options.DecodeTime.S = nil
	actual.enc.options.EncodeTime = nil
	actual.dec.options.DecodeTime.N = nil
	actual.dec.options.DecodeTime.S = nil

	// stuff must be properly sorted when comparing, otherwise reflect.DeepEqual fails
	slices.SortStableFunc(expected.globalSecondaryIndexes, gsiSortFunc)
	slices.SortStableFunc(actual.globalSecondaryIndexes, gsiSortFunc)

	for idx := range expected.globalSecondaryIndexes {
		slices.SortStableFunc(expected.globalSecondaryIndexes[idx].KeySchema, ksSortFunc)
		slices.SortStableFunc(actual.globalSecondaryIndexes[idx].KeySchema, ksSortFunc)
	}

	if diff := cmpDiff(expected, actual); len(diff) > 0 {
		t.Fatalf("unexpected schema diff: %s", diff)
	}
}

func TestSchemaEncodeDecode(t *testing.T) {
	o := order{
		OrderID:      "8488941c-0db5-4ace-a8af-3716f2a883bd",
		CreatedAt:    1136239445,
		CustomerID:   "507b0215-8413-4dcb-837b-8eaea3812d51",
		TotalAmount:  12.34,
		IgnoredField: "ignored",
		Version:      0,
		Metadata: map[string]string{
			"string": "string",
			"1":      "1",
			"1.2":    "1.2",
		},
		address: address{
			Street: "ba5da75d-9fcc-45bc-b2a3-d0b86c0b5919",
			City:   "c2b86a82-9623-4007-a1ba-112c013f0719",
			Zip:    "c5262613-aae4-40be-88f6-788f817dd280",
		},
		Notes: []string{
			"50debaa8-313c-4113-b90a-9b722fd56ef6",
			"d43fdfbd-91e2-4aa9-a46d-64ccc260eb55",
			"d8218acf-13b0-458a-9f9c-eaca10b3c080",
		},
		customerNote:      "e5dbdcc9-9778-4ef0-90f9-108d1c6f6bf3",
		CustomerFirstName: "9bcf2a68-7602-42a5-ac70-fc93b2dc17af",
		CustomerLastName:  "1e73f306-3362-49da-af74-41e1befff588",
	}

	m := map[string]types.AttributeValue{
		"order_id": &types.AttributeValueMemberS{
			Value: "8488941c-0db5-4ace-a8af-3716f2a883bd",
		},
		"created_at": &types.AttributeValueMemberN{
			Value: "1136239445",
		},
		"customer_id": &types.AttributeValueMemberS{
			Value: "507b0215-8413-4dcb-837b-8eaea3812d51",
		},
		"total": &types.AttributeValueMemberN{
			Value: "12.34",
		},
		"version": &types.AttributeValueMemberN{
			Value: "0",
		},
		"metadata": &types.AttributeValueMemberM{
			Value: map[string]types.AttributeValue{
				"string": &types.AttributeValueMemberS{
					Value: "string",
				},
				"1": &types.AttributeValueMemberS{
					Value: "1",
				},
				"1.2": &types.AttributeValueMemberS{
					Value: "1.2",
				},
			},
		},
		"street": &types.AttributeValueMemberS{
			Value: "ba5da75d-9fcc-45bc-b2a3-d0b86c0b5919",
		},
		"city": &types.AttributeValueMemberS{
			Value: "c2b86a82-9623-4007-a1ba-112c013f0719",
		},
		"zip": &types.AttributeValueMemberS{
			Value: "c5262613-aae4-40be-88f6-788f817dd280",
		},
		"Notes": &types.AttributeValueMemberSS{
			Value: []string{
				"50debaa8-313c-4113-b90a-9b722fd56ef6",
				"d43fdfbd-91e2-4aa9-a46d-64ccc260eb55",
				"d8218acf-13b0-458a-9f9c-eaca10b3c080",
			},
		},
		"note": &types.AttributeValueMemberS{
			Value: "e5dbdcc9-9778-4ef0-90f9-108d1c6f6bf3",
		},
		"first_name": &types.AttributeValueMemberS{
			Value: "9bcf2a68-7602-42a5-ac70-fc93b2dc17af",
		},
		"last_name": &types.AttributeValueMemberS{
			Value: "1e73f306-3362-49da-af74-41e1befff588",
		},
	}

	s, _ := NewSchema[order]()

	// new map vs old map
	nm, err := s.Encode(&o)
	if err != nil {
		t.Fatalf("unexpected error for Encode(): %v", err)
	}

	if !reflect.DeepEqual(m, nm) {
		keys := make([]string, len(m))
		for k, v := range m {
			nmv := nm[k]

			if !reflect.DeepEqual(v, nmv) {
				keys = append(keys, k)
			}
		}

		t.Fatalf("new map vs old map: keys have different values: %v", keys)
	}

	no, err := s.Decode(m)
	if err != nil {
		t.Fatalf("unexpected error for Decode(): %v", err)
	}
	if no == nil {
		t.Fatalf("unexpected empty object from Decode()")
	}

	// ignored cachedFields will not be populated in the new object
	o.IgnoredField = ""
	// o is a pointer so we need to compare with &o
	if diff := cmpDiff(&o, no); len(diff) != 0 {
		t.Fatalf("returned object is different: %s", diff)
	}
}

func TestSchemaTableName(t *testing.T) {
	cases := []struct {
		input         *string
		expected      *string
		skipWithTable bool
	}{
		{
			input:         nil,
			expected:      pointer("order"),
			skipWithTable: true,
		},
		{
			input:    nil,
			expected: nil,
		},
		{
			input:    pointer(""),
			expected: pointer(""),
		},
		{
			input:    pointer("oRdEr"),
			expected: pointer("oRdEr"),
		},
	}

	for i, c := range cases {
		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
			s, _ := NewSchema[order]()
			if !c.skipWithTable {
				s.WithTableName(c.input)
			}

			if diff := cmpDiff(c.expected, s.TableName()); len(diff) > 0 {
				t.Fatalf("unexpected table name diff: %v", diff)
			}
		})
	}
}

func TestSchemaCreateTableInput(t *testing.T) {
	s, err := NewSchema[order]()
	if err != nil {
		t.Fatalf("error building schema: %v", err)
	}

	expected := &dynamodb.CreateTableInput{
		TableName: pointer("order"),
		KeySchema: []types.KeySchemaElement{
			{AttributeName: pointer("order_id"), KeyType: types.KeyTypeHash},
			{AttributeName: pointer("created_at"), KeyType: types.KeyTypeRange},
		},
		AttributeDefinitions: []types.AttributeDefinition{
			{AttributeName: pointer("order_id"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("created_at"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("customer_id"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("total"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("version"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("zip"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("note"), AttributeType: types.ScalarAttributeTypeS},
		},
		LocalSecondaryIndexes: []types.LocalSecondaryIndex{
			{
				IndexName: pointer("OrderVersionIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("order_id"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("version"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
		},
		GlobalSecondaryIndexes: []types.GlobalSecondaryIndex{
			{
				IndexName: pointer("CustomerIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("customer_id"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("created_at"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("TotalAmountIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("total"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("order_id"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("RegionIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("zip"), KeyType: types.KeyTypeHash},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("NoteIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("note"), KeyType: types.KeyTypeHash},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
		},
		BillingMode: types.BillingModePayPerRequest,
	}

	actual, err := s.createTableInput()

	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	slices.SortStableFunc(expected.GlobalSecondaryIndexes, gsiSortFunc)
	slices.SortStableFunc(actual.GlobalSecondaryIndexes, gsiSortFunc)

	for idx := range expected.GlobalSecondaryIndexes {
		slices.SortStableFunc(expected.GlobalSecondaryIndexes[idx].KeySchema, ksSortFunc)
		slices.SortStableFunc(actual.GlobalSecondaryIndexes[idx].KeySchema, ksSortFunc)
	}

	if diff := cmpDiff(expected, actual); len(diff) > 0 {
		t.Fatalf("unexpected diff: %v", diff)
	}
}

func TestSchemaDescribeTableInput(t *testing.T) {
	s, _ := NewSchema[order]()

	expected := &dynamodb.DescribeTableInput{
		TableName: pointer("order"),
	}

	actual, err := s.describeTableInput()

	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if diff := cmpDiff(expected, actual); len(diff) > 0 {
		t.Fatalf("unexpected diff: %v", diff)
	}
}

func TestSchemaDeleteTableInput(t *testing.T) {
	s, _ := NewSchema[order]()

	expected := &dynamodb.DeleteTableInput{
		TableName: pointer("order"),
	}

	actual, err := s.deleteTableInput()

	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if diff := cmpDiff(expected, actual); len(diff) > 0 {
		t.Fatalf("unexpected diff: %v", diff)
	}
}

func gsiSortFunc(a, b types.GlobalSecondaryIndex) int {
	switch {
	case *a.IndexName > *b.IndexName:
		return 1
	case *a.IndexName < *b.IndexName:
		return -1
	default:
		return 0
	}
}
