package enhancedclient

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"slices"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

func TestSchema(t *testing.T) {
	actual, err := NewSchema[order]()
	if err != nil {
		t.Fatalf("NewSchema error: %v", err)
	}

	if len(actual.cachedFields.fields) != 17 {
		t.Fatalf("expected %d CachedFields, found %d", 17, len(actual.cachedFields.fields))
	}

	// | Index Name          | Partition Key | Sort Key     | Type | Notes                       |
	// | ------------------- | ------------- | ------------ | ---- | --------------------------- |
	// | `CustomerIndex`     | `customer_id` | `created_at` | GSI  | Already present             |
	// | `TotalAmountIndex`  | `total`       | `order_id`   | GSI  | Useful for order bucketing  |
	// | `OrderVersionIndex` | `order_id`    | `version`    | LSI  | Good for optimistic locking |
	// | `RegionIndex`       | `zip`         | (none)       | GSI  | Region-based querying       |
	// | `NoteIndex`         | `note`        | (optional)   | GSI  | Requires public exposure    |
	expected := &Schema[order]{
		typ:         reflect.TypeFor[order](),
		tableName:   pointer("order"),
		billingMode: types.BillingModePayPerRequest,
		keySchema: []types.KeySchemaElement{
			{AttributeName: pointer("order_id"), KeyType: types.KeyTypeHash},
			{AttributeName: pointer("created_at"), KeyType: types.KeyTypeRange},
		},
		attributeDefinitions: []types.AttributeDefinition{
			{AttributeName: pointer("order_id"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("created_at"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("customer_id"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("total"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("version"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("zip"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("note"), AttributeType: types.ScalarAttributeTypeS},
		},
		localSecondaryIndexes: []types.LocalSecondaryIndex{
			{
				IndexName: pointer("OrderVersionIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("order_id"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("version"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
		},
		globalSecondaryIndexes: []types.GlobalSecondaryIndex{
			{
				IndexName: pointer("CustomerIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("customer_id"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("created_at"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("TotalAmountIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("total"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("order_id"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("RegionIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("zip"), KeyType: types.KeyTypeHash},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("NoteIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("note"), KeyType: types.KeyTypeHash},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
		},
		cachedFields: &CachedFields{
			fields: []Field{
				{
					Name:        "order_id",
					NameFromTag: true,
					Index:       []int{0},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name:          "order_id",
						Partition:     true,
						AutoGenerated: true,
						Options:       map[string][]string{"autogenerated": {"key"}},
						Indexes: []Index{
							{
								Name:   "TotalAmountIndex",
								Global: true,
								Sort:   true,
							},
						},
					},
				},
				{
					Name:        "created_at",
					NameFromTag: true,
					Index:       []int{1},
					Type:        reflect.TypeFor[int64](),
					Tag: Tag{
						Name:          "created_at",
						Sort:          true,
						AutoGenerated: true,
						Options:       map[string][]string{"autogenerated": {"timestamp"}},
						Indexes: []Index{
							{
								Name: "CustomerIndex",
								Sort: true,
							},
						},
					},
				},
				{
					Name:        "updated_at",
					NameFromTag: true,
					Index:       []int{2},
					Type:        reflect.TypeFor[time.Time](),
					Tag: Tag{
						Name:          "updated_at",
						AutoGenerated: true,
						Options:       map[string][]string{"autogenerated": {"timestamp", "always"}},
					},
				},
				{
					Name:        "customer_id",
					NameFromTag: true,
					Index:       []int{3},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name: "customer_id",
						Indexes: []Index{
							{
								Name:      "CustomerIndex",
								Global:    true,
								Partition: true,
							},
						},
					},
				},
				{
					Name:        "total",
					NameFromTag: true,
					Index:       []int{4},
					Type:        reflect.TypeFor[float64](),
					Tag: Tag{
						Name: "total",
						Indexes: []Index{
							{
								Name:      "TotalAmountIndex",
								Global:    true,
								Partition: true,
							},
						},
					},
				},
				{
					Name:        "version",
					NameFromTag: true,
					Index:       []int{6},
					Type:        reflect.TypeFor[int64](),
					Tag: Tag{
						Name:    "version",
						Version: true,
						Indexes: []Index{
							{
								Name:  "OrderVersionIndex",
								Sort:  true,
								Local: true,
							},
						},
					},
				},
				{
					Name:        "versionString",
					NameFromTag: true,
					Index:       []int{7},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name:    "versionString",
						Version: true,
					},
				},
				{
					Name:        "counter_up",
					NameFromTag: true,
					Index:       []int{8},
					Type:        reflect.TypeFor[int64](),
					Tag: Tag{
						Name:          "counter_up",
						AtomicCounter: true,
						Options: map[string][]string{
							"atomiccounter": {"start=0", "delta=5"},
						},
					},
				},
				{
					Name:        "counter_down",
					NameFromTag: true,
					Index:       []int{9},
					Type:        reflect.TypeFor[int64](),
					Tag: Tag{
						Name:          "counter_down",
						AtomicCounter: true,
						Options: map[string][]string{
							"atomiccounter": {"start=0", "delta=-5"},
						},
					},
				},
				{
					Name:        "metadata",
					NameFromTag: true,
					Index:       []int{10},
					Type:        reflect.TypeFor[map[string]string](),
					Tag: Tag{
						Name: "metadata",
					},
				},
				{
					Name:        "street",
					NameFromTag: true,
					Index:       []int{11, 0},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name: "street",
					},
				},
				{
					Name:        "city",
					NameFromTag: true,
					Index:       []int{11, 1},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name: "city",
					},
				},
				{
					Name:        "zip",
					NameFromTag: true,
					Index:       []int{11, 2},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name: "zip",
						Indexes: []Index{
							{
								Name:      "RegionIndex",
								Global:    true,
								Partition: true,
							},
						},
					},
				},
				{
					Name:  "Notes",
					Index: []int{12},
					Type:  reflect.TypeFor[[]string](),
					Tag: Tag{
						PreserveEmpty: true,
						AsStrSet:      true,
					},
				},
				{
					Name:        "note",
					NameFromTag: true,
					Index:       []int{13},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name:   "note",
						Getter: "Note",
						Setter: "SetNote",
						Indexes: []Index{
							{
								Name:      "NoteIndex",
								Global:    true,
								Partition: true,
							},
						},
					},
				},
				{
					Name:        "first_name",
					NameFromTag: true,
					Index:       []int{14},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name: "first_name",
					},
				},
				{
					Name:        "last_name",
					NameFromTag: true,
					Index:       []int{15},
					Type:        reflect.TypeFor[string](),
					Tag: Tag{
						Name: "last_name",
					},
				},
			},
			fieldsByName: map[string]int{
				"order_id":      0,
				"created_at":    1,
				"updated_at":    2,
				"customer_id":   3,
				"total":         4,
				"version":       5,
				"versionString": 6,
				"counter_up":    7,
				"counter_down":  8,
				"metadata":      9,
				"street":        10,
				"city":          11,
				"zip":           12,
				"Notes":         13,
				"note":          14,
				"first_name":    15,
				"last_name":     16,
			},
		},
		extensions: map[ExecutionPhase][]Extension{
			"before_write": {
				&VersionExtension[order]{},
				&AtomicCounterExtension[order]{},
				&AutogenerateExtension[order]{},
			},
		},
		enc: NewEncoder[order](),
		dec: NewDecoder[order](),
	}

	// reflect.DeepEqual cannot compare function pointers
	expected.enc.options.EncodeTime = nil
	expected.dec.options.DecodeTime.N = nil
	expected.dec.options.DecodeTime.S = nil
	actual.enc.options.EncodeTime = nil
	actual.dec.options.DecodeTime.N = nil
	actual.dec.options.DecodeTime.S = nil

	// stuff must be properly sorted when comparing, otherwise reflect.DeepEqual fails
	slices.SortStableFunc(expected.globalSecondaryIndexes, gsiSortFunc)
	slices.SortStableFunc(actual.globalSecondaryIndexes, gsiSortFunc)

	for idx := range expected.globalSecondaryIndexes {
		slices.SortStableFunc(expected.globalSecondaryIndexes[idx].KeySchema, ksSortFunc)
		slices.SortStableFunc(actual.globalSecondaryIndexes[idx].KeySchema, ksSortFunc)
	}

	if diff := cmpDiff(expected, actual); len(diff) > 0 {
		t.Fatalf("unexpected schema diff: %s", diff)
	}
}

func TestSchemaEncodeDecode(t *testing.T) {
	now := time.Now().UTC()

	o := order{
		OrderID:       "8488941c-0db5-4ace-a8af-3716f2a883bd",
		CreatedAt:     1136239445,
		UpdatedAt:     now,
		CustomerID:    "507b0215-8413-4dcb-837b-8eaea3812d51",
		TotalAmount:   12.34,
		IgnoredField:  "ignored",
		Version:       0,
		VersionString: "0",
		CounterUp:     0,
		CounterDown:   0,
		Metadata: map[string]string{
			"string": "string",
			"1":      "1",
			"1.2":    "1.2",
		},
		address: address{
			Street: "ba5da75d-9fcc-45bc-b2a3-d0b86c0b5919",
			City:   "c2b86a82-9623-4007-a1ba-112c013f0719",
			Zip:    "c5262613-aae4-40be-88f6-788f817dd280",
		},
		Notes: []string{
			"50debaa8-313c-4113-b90a-9b722fd56ef6",
			"d43fdfbd-91e2-4aa9-a46d-64ccc260eb55",
			"d8218acf-13b0-458a-9f9c-eaca10b3c080",
		},
		customerNote:      "e5dbdcc9-9778-4ef0-90f9-108d1c6f6bf3",
		CustomerFirstName: "9bcf2a68-7602-42a5-ac70-fc93b2dc17af",
		CustomerLastName:  "1e73f306-3362-49da-af74-41e1befff588",
	}

	m := map[string]types.AttributeValue{
		"order_id": &types.AttributeValueMemberS{
			Value: "8488941c-0db5-4ace-a8af-3716f2a883bd",
		},
		"created_at": &types.AttributeValueMemberN{
			Value: "1136239445",
		},
		"updated_at": &types.AttributeValueMemberS{
			Value: now.Format(time.RFC3339Nano),
		},
		"customer_id": &types.AttributeValueMemberS{
			Value: "507b0215-8413-4dcb-837b-8eaea3812d51",
		},
		"total": &types.AttributeValueMemberN{
			Value: "12.34",
		},
		"version": &types.AttributeValueMemberN{
			Value: "0",
		},
		"versionString": &types.AttributeValueMemberS{
			Value: "0",
		},
		"counter_up": &types.AttributeValueMemberN{
			Value: "0",
		},
		"counter_down": &types.AttributeValueMemberN{
			Value: "0",
		},
		"metadata": &types.AttributeValueMemberM{
			Value: map[string]types.AttributeValue{
				"string": &types.AttributeValueMemberS{
					Value: "string",
				},
				"1": &types.AttributeValueMemberS{
					Value: "1",
				},
				"1.2": &types.AttributeValueMemberS{
					Value: "1.2",
				},
			},
		},
		"street": &types.AttributeValueMemberS{
			Value: "ba5da75d-9fcc-45bc-b2a3-d0b86c0b5919",
		},
		"city": &types.AttributeValueMemberS{
			Value: "c2b86a82-9623-4007-a1ba-112c013f0719",
		},
		"zip": &types.AttributeValueMemberS{
			Value: "c5262613-aae4-40be-88f6-788f817dd280",
		},
		"Notes": &types.AttributeValueMemberSS{
			Value: []string{
				"50debaa8-313c-4113-b90a-9b722fd56ef6",
				"d43fdfbd-91e2-4aa9-a46d-64ccc260eb55",
				"d8218acf-13b0-458a-9f9c-eaca10b3c080",
			},
		},
		"note": &types.AttributeValueMemberS{
			Value: "e5dbdcc9-9778-4ef0-90f9-108d1c6f6bf3",
		},
		"first_name": &types.AttributeValueMemberS{
			Value: "9bcf2a68-7602-42a5-ac70-fc93b2dc17af",
		},
		"last_name": &types.AttributeValueMemberS{
			Value: "1e73f306-3362-49da-af74-41e1befff588",
		},
	}

	s, _ := NewSchema[order]()

	// new map vs old map
	nm, err := s.Encode(&o)
	if err != nil {
		t.Fatalf("unexpected error for Encode(): %v", err)
	}

	if diff := cmpDiff(m, nm); len(diff) > 0 {
		e := json.NewEncoder(os.Stdout)
		e.SetIndent("", "  ")
		_ = e.Encode(m)
		_ = e.Encode(nm)
		t.Fatalf("new map vs old map: keys have different values: %v", diff)
	}

	no, err := s.Decode(m)
	if err != nil {
		t.Fatalf("unexpected error for Decode(): %v", err)
	}
	if no == nil {
		t.Fatalf("unexpected empty object from Decode()")
	}

	// ignored CachedFields will not be populated in the new object
	o.IgnoredField = ""
	// o is a pointer so we need to compare with &o
	if diff := cmpDiff(&o, no); len(diff) != 0 {
		t.Fatalf("returned object is different: %s", diff)
	}
}

func TestSchemaTableName(t *testing.T) {
	cases := []struct {
		input         *string
		expected      *string
		skipWithTable bool
	}{
		{
			input:         nil,
			expected:      pointer("order"),
			skipWithTable: true,
		},
		{
			input:    nil,
			expected: nil,
		},
		{
			input:    pointer(""),
			expected: pointer(""),
		},
		{
			input:    pointer("oRdEr"),
			expected: pointer("oRdEr"),
		},
	}

	for i, c := range cases {
		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
			s, _ := NewSchema[order]()
			if !c.skipWithTable {
				s.WithTableName(c.input)
			}

			if diff := cmpDiff(c.expected, s.TableName()); len(diff) > 0 {
				t.Fatalf("unexpected table name diff: %v", diff)
			}
		})
	}
}

func TestSchemaCreateTableInput(t *testing.T) {
	s, err := NewSchema[order]()
	if err != nil {
		t.Fatalf("error building schema: %v", err)
	}

	expected := &dynamodb.CreateTableInput{
		TableName: pointer("order"),
		KeySchema: []types.KeySchemaElement{
			{AttributeName: pointer("order_id"), KeyType: types.KeyTypeHash},
			{AttributeName: pointer("created_at"), KeyType: types.KeyTypeRange},
		},
		AttributeDefinitions: []types.AttributeDefinition{
			{AttributeName: pointer("order_id"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("created_at"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("customer_id"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("total"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("version"), AttributeType: types.ScalarAttributeTypeN},
			{AttributeName: pointer("zip"), AttributeType: types.ScalarAttributeTypeS},
			{AttributeName: pointer("note"), AttributeType: types.ScalarAttributeTypeS},
		},
		LocalSecondaryIndexes: []types.LocalSecondaryIndex{
			{
				IndexName: pointer("OrderVersionIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("order_id"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("version"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
		},
		GlobalSecondaryIndexes: []types.GlobalSecondaryIndex{
			{
				IndexName: pointer("CustomerIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("customer_id"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("created_at"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("TotalAmountIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("total"), KeyType: types.KeyTypeHash},
					{AttributeName: pointer("order_id"), KeyType: types.KeyTypeRange},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("RegionIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("zip"), KeyType: types.KeyTypeHash},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
			{
				IndexName: pointer("NoteIndex"),
				KeySchema: []types.KeySchemaElement{
					{AttributeName: pointer("note"), KeyType: types.KeyTypeHash},
				},
				Projection: &types.Projection{
					NonKeyAttributes: nil,
					ProjectionType:   types.ProjectionTypeAll,
				},
			},
		},
		BillingMode: types.BillingModePayPerRequest,
	}

	actual, err := s.createTableInput()

	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	slices.SortStableFunc(expected.GlobalSecondaryIndexes, gsiSortFunc)
	slices.SortStableFunc(actual.GlobalSecondaryIndexes, gsiSortFunc)

	for idx := range expected.GlobalSecondaryIndexes {
		slices.SortStableFunc(expected.GlobalSecondaryIndexes[idx].KeySchema, ksSortFunc)
		slices.SortStableFunc(actual.GlobalSecondaryIndexes[idx].KeySchema, ksSortFunc)
	}

	if diff := cmpDiff(expected, actual); len(diff) > 0 {
		t.Fatalf("unexpected diff: %v", diff)
	}
}

func TestSchemaDescribeTableInput(t *testing.T) {
	s, _ := NewSchema[order]()

	expected := &dynamodb.DescribeTableInput{
		TableName: pointer("order"),
	}

	actual, err := s.describeTableInput()

	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if diff := cmpDiff(expected, actual); len(diff) > 0 {
		t.Fatalf("unexpected diff: %v", diff)
	}
}

func TestSchemaDeleteTableInput(t *testing.T) {
	s, _ := NewSchema[order]()

	expected := &dynamodb.DeleteTableInput{
		TableName: pointer("order"),
	}

	actual, err := s.deleteTableInput()

	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if diff := cmpDiff(expected, actual); len(diff) > 0 {
		t.Fatalf("unexpected diff: %v", diff)
	}
}

func gsiSortFunc(a, b types.GlobalSecondaryIndex) int {
	switch {
	case *a.IndexName > *b.IndexName:
		return 1
	case *a.IndexName < *b.IndexName:
		return -1
	default:
		return 0
	}
}
