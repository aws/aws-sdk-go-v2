package enhancedclient

import (
	"context"
	"fmt"
	"reflect"

	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
)

func (t *Table[T]) createExtensionContext() context.Context {
	ctx := context.Background()
	if t.options.Schema != nil {
		ctx = context.WithValue(ctx, TableSchemaKey{}, t.options.Schema)
		ctx = context.WithValue(ctx, CachedFieldsKey{}, t.options.Schema.cachedFields)
	} else {
		ctx = context.WithValue(ctx, TableSchemaKey{}, (*Schema[T])(nil))
		ctx = context.WithValue(ctx, CachedFieldsKey{}, (*CachedFields)(nil))
	}

	return ctx
}

func (t *Table[T]) createUpdateExpression(v *T) (expression.Expression, error) {
	empty := expression.Expression{}

	if t.options.Schema == nil || t.options.Schema.cachedFields == nil {
		return empty, fmt.Errorf("empty schema or schema cache fields for Table[%T]", *new(T))
	}

	ctx := t.createExtensionContext()

	var conditionBuilder *expression.ConditionBuilder
	var filterBuilder *expression.ConditionBuilder
	var keyConditionBuilder *expression.KeyConditionBuilder
	var projectionBuilder *expression.ProjectionBuilder
	updateBuilder := &expression.UpdateBuilder{}

	r := reflect.ValueOf(v)

	for _, f := range t.options.Schema.cachedFields.All() {
		// skip items that will be autogenerated or pk or sk
		if f.AutoGenerated || f.Version || f.AtomicCounter || f.Partition || f.Sort {
			continue
		}

		var cv reflect.Value
		if f.Tag.Getter != "" {
			cv = r.MethodByName(f.Tag.Getter).
				Call([]reflect.Value{})[0]
		} else {
			cv = r.Elem().FieldByIndex(f.Index)
		}

		*updateBuilder = updateBuilder.Set(expression.Name(f.Name), expression.Value(cv.Interface()))
	}

	for _, e := range t.options.ExtensionRegistry.beforeWriters {
		if b, ok := e.(ConditionExpressionBuilder[T]); ok {
			if err := b.BuildCondition(ctx, v, &conditionBuilder); err != nil {
				return empty, fmt.Errorf("error during ConditionExpressionBuilder[%T]: %v", e, err)
			}
		}
		if b, ok := e.(FilterExpressionBuilder[T]); ok {
			if err := b.BuildFilter(ctx, v, &filterBuilder); err != nil {
				return empty, fmt.Errorf("error during FilterExpressionBuilder[%T]: %v", e, err)
			}
		}
		if b, ok := e.(KeyConditionBuilder[T]); ok {
			if err := b.BuildKeyCondition(ctx, v, &keyConditionBuilder); err != nil {
				return empty, fmt.Errorf("error during KeyConditionBuilder[%T]: %v", e, err)
			}
		}
		if b, ok := e.(ProjectionExpressionBuilder[T]); ok {
			if err := b.BuildProjection(ctx, v, &projectionBuilder); err != nil {
				return empty, fmt.Errorf("error during ProjectionExpressionBuilder[%T]: %v", e, err)
			}
		}
		if b, ok := e.(UpdateExpressionBuilder[T]); ok {
			if err := b.BuildUpdate(ctx, v, &updateBuilder); err != nil {
				return empty, fmt.Errorf("error during UpdateExpressionBuilder[%T]: %v", e, err)
			}
		}
	}

	builder := expression.NewBuilder()
	if conditionBuilder != nil {
		builder = builder.WithCondition(*conditionBuilder)
	}
	if filterBuilder != nil {
		builder = builder.WithFilter(*filterBuilder)
	}
	if keyConditionBuilder != nil {
		builder = builder.WithKeyCondition(*keyConditionBuilder)
	}
	if projectionBuilder != nil {
		builder = builder.WithProjection(*projectionBuilder)
	}
	if updateBuilder != nil {
		builder = builder.WithUpdate(*updateBuilder)
	}

	return builder.Build()
}

func (t *Table[T]) applyBeforeReadExtensions(v *T) error {
	if t.options.ExtensionRegistry == nil {
		return nil
	}

	ctx := t.createExtensionContext()

	for _, br := range t.options.ExtensionRegistry.beforeReaders {
		if err := br.BeforeRead(ctx, v); err != nil {
			return fmt.Errorf("error during applyBeforeReadExtensions %T: %v", br, err)
		}
	}

	return nil
}

func (t *Table[T]) applyAfterReadExtensions(v *T) error {
	if t.options.ExtensionRegistry == nil {
		return nil
	}

	ctx := t.createExtensionContext()

	for _, ar := range t.options.ExtensionRegistry.afterReaders {
		if err := ar.AfterRead(ctx, v); err != nil {
			return fmt.Errorf("error during applyAfterReadExtensions %T: %v", ar, err)
		}
	}

	return nil
}

func (t *Table[T]) applyBeforeWriteExtensions(v *T) error {
	if t.options.ExtensionRegistry == nil {
		return nil
	}

	ctx := t.createExtensionContext()

	for _, bw := range t.options.ExtensionRegistry.beforeWriters {
		if err := bw.BeforeWrite(ctx, v); err != nil {
			return fmt.Errorf("error during applyBeforeWriteExtensions %T: %v", bw, err)
		}
	}

	return nil
}

func (t *Table[T]) applyAfterWriteExtensions(v *T) error {
	if t.options.ExtensionRegistry == nil {
		return nil
	}

	ctx := t.createExtensionContext()

	for _, aw := range t.options.ExtensionRegistry.afterWriters {
		if err := aw.AfterWrite(ctx, v); err != nil {
			return fmt.Errorf("error during applyBeforeWriteExtensions %T: %v", aw, err)
		}
	}

	return nil
}

// @TODO: implement when adding Scan() and Query()
// func (t *Table[T]) applyBeforeScannersExtensions(v *T) error { return nil }
// func (t *Table[T]) applyAfterScannersExtensions(v *T) error  { return nil }
// func (t *Table[T]) applyBeforeQueriersExtensions(v *T) error { return nil }
// func (t *Table[T]) applyAfterQueriersExtensions(v []T) error { return nil }
