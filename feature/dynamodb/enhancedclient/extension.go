package enhancedclient

import (
	"context"
	cryptorand "crypto/rand"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	smythyrand "github.com/aws/smithy-go/rand"
)

type CachedFieldsKey struct{}
type TableSchemaKey struct{}

type ExecutionPhase string

const (
	BeforeWrite ExecutionPhase = "before_write"
	AfterRead   ExecutionPhase = "after_read"
	BeforeScan  ExecutionPhase = "before_scan"
	BeforeQuery ExecutionPhase = "before_query"
)

type Extension interface {
	IsExtension()
}

type BeforeWriter[T any] interface {
	Extension
	BeforeWrite(context.Context, *T) error
}

type AfterReader[T any] interface {
	Extension
	AfterRead(context.Context, *T) error
}

type BeforeQuerier interface {
	Extension
	BeforeQuery(context.Context, *dynamodb.QueryInput) error
}

type BeforeScanner interface {
	Extension
	BeforeScan(context.Context, *dynamodb.ScanInput) error
}

type ConditionExpressionBuilder[T any] interface {
	Extension
	BuildCondition(context.Context, *T, **expression.ConditionBuilder) error
}
type FilterExpressionBuilder[T any] interface {
	Extension
	BuildFilter(context.Context, *T, **expression.ConditionBuilder) error
}
type KeyConditionBuilder[T any] interface {
	Extension
	BuildKeyCondition(context.Context, *T, **expression.KeyConditionBuilder) error
}
type ProjectionExpressionBuilder[T any] interface {
	Extension
	BuildProjection(context.Context, *T, **expression.ProjectionBuilder) error
}
type UpdateExpressionBuilder[T any] interface {
	Extension
	BuildUpdate(context.Context, *T, **expression.UpdateBuilder) error
}

type AutogenerateExtension[T any] struct {
}

func (a *AutogenerateExtension[T]) IsExtension() {}

func (a *AutogenerateExtension[T]) BeforeWrite(ctx context.Context, item *T) error {
	cachedFields := ctx.Value(CachedFieldsKey{}).(*CachedFields)

	for _, f := range cachedFields.All() {
		if !f.AutoGenerated {
			continue
		}

		opts, ok := f.Tag.Option("autogenerated")
		if !ok || len(opts) < 1 {
			return fmt.Errorf("option autogenerated expects at least 1 option, e.g. autogenerated:key or autogenerated:timestamp")
		}

		switch opts[0] {
		case "key":
			if err := a.processKey(item, f, opts[1:]); err != nil {
				return err
			}
		case "timestamp":
			if err := a.processTimestamp(item, f, opts[1:]); err != nil {
				return err
			}
		default:
			return fmt.Errorf(`option autogenerated can only process key and timestamp as first argument, "%s" given`, opts[0])
		}
	}

	return nil
}

func (a *AutogenerateExtension[T]) BuildUpdate(ctx context.Context, item *T, ub **expression.UpdateBuilder) error {
	cachedFields := ctx.Value(CachedFieldsKey{}).(*CachedFields)

	for _, f := range cachedFields.All() {
		if !f.AutoGenerated {
			continue
		}

		opts, ok := f.Tag.Option("autogenerated")
		if !ok || len(opts) < 1 {
			return fmt.Errorf("option autogenerated expects at least 1 option, e.g. autogenerated:key or autogenerated:timestamp")
		}

		switch opts[0] {
		case "key":
			if err := a.buildKeyUpdate(item, f, ub); err != nil {
				return err
			}
		case "timestamp":
			if err := a.buildTimestampUpdate(item, f, ub); err != nil {
				return err
			}
		default:
			return fmt.Errorf(`option autogenerated can only process key and timestamp as first argument, "%s" given`, opts[0])
		}
	}

	return nil
}

func (a *AutogenerateExtension[T]) processKey(v *T, f Field, opts []string) error {
	r := reflect.ValueOf(v)
	var cv reflect.Value

	if f.Tag.Getter != "" {
		cv = r.MethodByName(f.Tag.Getter).
			Call([]reflect.Value{})[0]
	} else {
		var err error
		cv, err = r.Elem().FieldByIndexErr(f.Index)
		if err != nil { //&& unwrap(s.options.ErrorOnMissingField) {
			return err
		}
	}

	shouldUpdate := cv.IsZero() || inArray("always", opts)
	if !shouldUpdate {
		return nil
	}

	s, err := smythyrand.NewUUID(cryptorand.Reader).GetUUID()
	if err != nil {
		return fmt.Errorf("error generating UUID: %v", err)
	}

	if !cv.CanAddr() && f.Tag.Setter != "" {
		cv = reflect.New(cv.Type()).Elem()
	}

	switch cv.Kind() {
	case reflect.String:
		cv.SetString(s)
	case reflect.Slice, reflect.Array:
		if cv.Type().Elem().Kind() == reflect.Uint8 {
			cv.SetBytes([]byte(s))
		}
	default:
		return fmt.Errorf("unable to assign autogenerated key to type %s, can only assign to string and []byte", cv.Type())
	}

	if f.Tag.Setter != "" {
		r.MethodByName(f.Tag.Setter).
			Call([]reflect.Value{
				cv,
			})
	}

	return nil
}

func (a *AutogenerateExtension[T]) processTimestamp(v *T, f Field, opts []string) error {
	r := reflect.ValueOf(v)
	var cv reflect.Value

	if f.Tag.Getter != "" {
		cv = r.MethodByName(f.Tag.Getter).
			Call([]reflect.Value{})[0]
	} else {
		var err error
		cv, err = r.Elem().FieldByIndexErr(f.Index)
		if err != nil { //&& unwrap(s.options.ErrorOnMissingField) {
			return err
		}
	}

	shouldUpdate := cv.IsZero() || inArray("always", opts)
	if !shouldUpdate {
		return nil
	}

	now := time.Now()

	if !cv.CanAddr() && f.Tag.Setter != "" {
		cv = reflect.New(cv.Type()).Elem()
	}

	switch cv.Kind() {
	case reflect.String:
		cv.SetString(now.Format(time.RFC3339))
	case reflect.Slice, reflect.Array:
		if cv.Type().Elem().Kind() == reflect.Uint8 {
			cv.SetBytes([]byte(now.Format(time.RFC3339)))
		}
	case reflect.Uint64, reflect.Int64:
		n := reflect.ValueOf(now.UnixNano()).Convert(cv.Type())
		cv.Set(n)
	default:
		if _, ok := cv.Interface().(time.Time); !ok {
			return fmt.Errorf("unable to assign autogenerated key to type %s, can only assign to string, []byte and time.Time", cv.Type())
		} else {
			cv.Set(reflect.ValueOf(now))
		}
	}

	if f.Tag.Setter != "" {
		r.MethodByName(f.Tag.Setter).
			Call([]reflect.Value{
				cv,
			})
	}

	return nil
}

func (a *AutogenerateExtension[T]) buildKeyUpdate(v *T, f Field, ub **expression.UpdateBuilder) error {
	var update expression.UpdateBuilder
	if ub != nil && *ub != nil {
		update = **ub
	}

	r := reflect.ValueOf(v)
	var cv reflect.Value

	if f.Tag.Getter != "" {
		cv = r.MethodByName(f.Tag.Getter).
			Call([]reflect.Value{})[0]
	} else {
		var err error
		cv, err = r.Elem().FieldByIndexErr(f.Index)
		if err != nil { //&& unwrap(s.options.ErrorOnMissingField) {
			return err
		}
	}

	// pk and sk cannot be updated
	if !cv.IsZero() && (f.Sort || f.Partition) {
		return nil
	}

	switch cv.Kind() {
	case reflect.String:
		update = update.Set(expression.Name(f.Name), expression.Value(cv.String()))
	case reflect.Slice, reflect.Array:
		if cv.Type().Elem().Kind() == reflect.Uint8 {
			update = update.Set(expression.Name(f.Name), expression.Value(cv.Bytes()))
		}
	default:
		return fmt.Errorf("unable to process update for autogenerated key to type %s, can only process to string and []byte", cv.Type())
	}

	return nil
}

func (a *AutogenerateExtension[T]) buildTimestampUpdate(v *T, f Field, ub **expression.UpdateBuilder) error {
	var update expression.UpdateBuilder
	if ub != nil && *ub != nil {
		update = **ub
	}

	r := reflect.ValueOf(v)
	var cv reflect.Value

	if f.Tag.Getter != "" {
		cv = r.MethodByName(f.Tag.Getter).
			Call([]reflect.Value{})[0]
	} else {
		var err error
		cv, err = r.Elem().FieldByIndexErr(f.Index)
		if err != nil { //&& unwrap(s.options.ErrorOnMissingField) {
			return err
		}
	}

	// pk and sk cannot be updated
	if !cv.IsZero() && (f.Sort || f.Partition) {
		return nil
	}

	if cv.IsZero() {
		update = update.Set(expression.Name(f.Name), expression.Value(nil))
		*ub = &update

		return nil
	}

	switch cv.Kind() {
	case reflect.String, reflect.Uint64, reflect.Int64:
		update = update.Set(expression.Name(f.Name), expression.Value(cv.Interface()))
		*ub = &update
	case reflect.Slice, reflect.Array:
		if cv.Type().Elem().Kind() == reflect.Uint8 {
			update = update.Set(expression.Name(f.Name), expression.Value(cv.Interface()))
			*ub = &update
			break
		}
		fallthrough
	default:
		if _, ok := cv.Interface().(time.Time); !ok {
			return fmt.Errorf("unable to process update for autogenerated key to type %s, can only process to string, []byte and time.Time", cv.Type())
		} else {
			update = update.Set(expression.Name(f.Name), expression.Value(cv.Interface()))
			*ub = &update
		}
	}

	return nil
}

type VersionExtension[T any] struct{}

func (v *VersionExtension[T]) IsExtension() {}

func (v *VersionExtension[T]) BuildCondition(ctx context.Context, item *T, cb **expression.ConditionBuilder) error {
	cachedFields := ctx.Value(CachedFieldsKey{}).(*CachedFields)

	r := reflect.ValueOf(item)
	var condition expression.ConditionBuilder
	if cb != nil && *cb != nil {
		condition = **cb
	}

	for _, f := range cachedFields.All() {
		if !f.Version {
			continue
		}

		var cv reflect.Value
		if f.Tag.Getter != "" {
			cv = r.MethodByName(f.Tag.Getter).
				Call([]reflect.Value{})[0]
		} else {
			cv = r.Elem().FieldByIndex(f.Index)
		}

		if condition.IsSet() {
			condition = condition.And(
				//expression.Equal(
				//	expression.Name(f.Name),
				//	expression.Value(cv.Interface()),
				//),
				expression.Or(
					expression.AttributeNotExists(expression.Name(f.Name)),
					expression.Equal(
						expression.Name(f.Name),
						expression.Value(cv.Interface()),
					),
				),
			)
		} else {
			//condition = expression.Equal(expression.Name(f.Name), expression.Value(cv.Interface()))
			condition = expression.Or(
				expression.AttributeNotExists(expression.Name(f.Name)),
				expression.Equal(
					expression.Name(f.Name),
					expression.Value(cv.Interface()),
				),
			)
		}
	}

	if condition.IsSet() {
		*cb = &condition
	}

	return nil
}

func (v *VersionExtension[T]) BuildUpdate(ctx context.Context, item *T, ub **expression.UpdateBuilder) error {
	cachedFields := ctx.Value(CachedFieldsKey{}).(*CachedFields)

	r := reflect.ValueOf(item)
	var update expression.UpdateBuilder
	if ub != nil && *ub != nil {
		update = **ub
	}

	for _, f := range cachedFields.All() {
		if !f.Version {
			continue
		}

		var cv reflect.Value
		if f.Tag.Getter != "" {
			cv = r.MethodByName(f.Tag.Getter).
				Call([]reflect.Value{})[0]
		} else {
			cv = r.Elem().FieldByIndex(f.Index)
		}

		switch cv.Kind() {
		case reflect.String:
			if cv.IsZero() {
				cv.SetString("0")
			}
			i, err := strconv.ParseInt(cv.String(), 10, 64)
			if err != nil {
				return fmt.Errorf("unable to convert string value of version field %s to number", f.Name)
			}
			update = update.Set(expression.Name(f.Name), expression.Value(fmt.Sprintf("%d", i+1)))
			*ub = &update
		case reflect.Int64:
			i := cv.Int()
			update = update.Set(expression.Name(f.Name), expression.Value(i+1))
			*ub = &update
		case reflect.Uint64:
			i := cv.Uint()
			update = update.Set(expression.Name(f.Name), expression.Value(i+1))
			*ub = &update
		default:
			return fmt.Errorf("unable to use %s as version field %s, can only use uint64, int64 and string", cv.Type(), f.Tag.Getter)
		}
	}

	return nil
}

type AtomicCounterExtension[T any] struct{}

func (v *AtomicCounterExtension[T]) IsExtension() {}

func (v *AtomicCounterExtension[T]) BuildUpdate(ctx context.Context, item *T, ub **expression.UpdateBuilder) error {
	cachedFields := ctx.Value(CachedFieldsKey{}).(*CachedFields)

	var update expression.UpdateBuilder
	if ub != nil && *ub != nil {
		update = **ub
	}

	for _, f := range cachedFields.All() {
		if !f.AtomicCounter {
			continue
		}

		if f.Type.Kind() < reflect.Int || f.Type.Kind() > reflect.Uint64 {
			return fmt.Errorf("atomic counter field %s has unsupported type %s", f.Name, f.Type.Kind())
		}

		dflt := 0
		delta := 1

		if opts, ok := f.Option("atomiccounter"); ok {
			for _, opt := range opts {
				parts := strings.Split(opt, "=")
				if len(parts) != 2 {
					return fmt.Errorf(`field %s has the tag atomiccounter missonfigured, options must look like "atomiccounter|start=0|delta=1", "%s" given`, f.Name, opt)
				}

				val, err := strconv.Atoi(parts[1])
				if err != nil {
					return err
				}

				switch parts[0] {
				case "start":
					dflt = val
				case "delta":
					delta = val
				default:
					return fmt.Errorf(`unknown options "%s" passed to "atomiccounter" on field %s`, parts[0], f.Name)
				}
			}
		}

		update = update.Set(
			expression.Name(f.Name),
			expression.Plus(
				expression.IfNotExists(
					expression.Name(f.Name),
					expression.Value(dflt-delta),
				),
				expression.Value(delta),
			),
		)
		*ub = &update
	}

	return nil
}
