package enhancedclient

import (
	"context"
	"fmt"
	"reflect"

	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
)

func (s *Schema[T]) createExtensionContext() context.Context {
	ctx := context.Background()
	ctx = context.WithValue(ctx, TableSchemaKey{}, s)
	ctx = context.WithValue(ctx, CachedFieldsKey{}, s.cachedFields)

	return ctx
}

func (s *Schema[T]) createUpdateExpression(v *T) (expression.Expression, error) {
	ctx := s.createExtensionContext()

	var conditionBuilder *expression.ConditionBuilder
	var filterBuilder *expression.ConditionBuilder
	var keyConditionBuilder *expression.KeyConditionBuilder
	var projectionBuilder *expression.ProjectionBuilder
	updateBuilder := &expression.UpdateBuilder{}

	r := reflect.ValueOf(v)

	for _, f := range s.cachedFields.All() {
		// skip items that will be autogenerated or pk or sk
		if f.AutoGenerated || f.Version || f.AtomicCounter || f.Partition || f.Sort {
			continue
		}

		var cv reflect.Value
		if f.Tag.Getter != "" {
			cv = r.MethodByName(f.Tag.Getter).
				Call([]reflect.Value{})[0]
		} else {
			cv = r.Elem().FieldByIndex(f.Index)
		}

		*updateBuilder = updateBuilder.Set(expression.Name(f.Name), expression.Value(cv.Interface()))
	}

	empty := expression.Expression{}

	for _, e := range s.extensions[BeforeWrite] {
		if b, ok := e.(ConditionExpressionBuilder[T]); ok {
			if err := b.BuildCondition(ctx, v, &conditionBuilder); err != nil {
				return empty, fmt.Errorf("error during ConditionExpressionBuilder[%s][%T]: %v", BeforeWrite, e, err)
			}
		}
		if b, ok := e.(FilterExpressionBuilder[T]); ok {
			if err := b.BuildFilter(ctx, v, &filterBuilder); err != nil {
				return empty, fmt.Errorf("error during FilterExpressionBuilder[%s][%T]: %v", BeforeWrite, e, err)
			}
		}
		if b, ok := e.(KeyConditionBuilder[T]); ok {
			if err := b.BuildKeyCondition(ctx, v, &keyConditionBuilder); err != nil {
				return empty, fmt.Errorf("error during KeyConditionBuilder[%s][%T]: %v", BeforeWrite, e, err)
			}
		}
		if b, ok := e.(ProjectionExpressionBuilder[T]); ok {
			if err := b.BuildProjection(ctx, v, &projectionBuilder); err != nil {
				return empty, fmt.Errorf("error during ProjectionExpressionBuilder[%s][%T]: %v", BeforeWrite, e, err)
			}
		}
		if b, ok := e.(UpdateExpressionBuilder[T]); ok {
			if err := b.BuildUpdate(ctx, v, &updateBuilder); err != nil {
				return empty, fmt.Errorf("error during UpdateExpressionBuilder[%s][%T]: %v", BeforeWrite, e, err)
			}
		}
	}

	builder := expression.NewBuilder()
	if conditionBuilder != nil {
		builder = builder.WithCondition(*conditionBuilder)
	}
	if filterBuilder != nil {
		builder = builder.WithFilter(*filterBuilder)
	}
	if keyConditionBuilder != nil {
		builder = builder.WithKeyCondition(*keyConditionBuilder)
	}
	if projectionBuilder != nil {
		builder = builder.WithProjection(*projectionBuilder)
	}
	if updateBuilder != nil {
		builder = builder.WithUpdate(*updateBuilder)
	}

	return builder.Build()
}

func (s *Schema[T]) applyBeforeWriteExtensions(v *T) error {
	ctx := s.createExtensionContext()

	for _, e := range s.extensions[BeforeWrite] {
		if b, ok := e.(BeforeWriter[T]); ok {
			if err := b.BeforeWrite(ctx, v); err != nil {
				return fmt.Errorf("error during appyExtension[%s][%T]: %v", BeforeWrite, e, err)
			}
		}
	}

	return nil
}

func (s *Schema[T]) applyAfterReadExtensions(v *T) error {
	ctx := s.createExtensionContext()

	for _, e := range s.extensions[AfterRead] {
		if b, ok := e.(AfterReader[T]); ok {
			if err := b.AfterRead(ctx, v); err != nil {
				return fmt.Errorf("error during appyExtension[%s][%T]: %v", AfterRead, e, err)
			}
		}
	}

	return nil
}
