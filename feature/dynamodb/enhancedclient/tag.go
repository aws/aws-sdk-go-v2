package enhancedclient

import (
	"reflect"
	"strings"
)

const (
	defaultTagKey = "dynamodbav"
	tagIndex      = "dynamodbindex"
	tagGetter     = "dynamodbgetter"
	tagSetter     = "dynamodbsetter"
)

type Tag struct {
	Name          string              // `dynamodbav`
	Ignore        bool                // `dynamodbav:"-"
	OmitEmpty     bool                // `dynamodbav:",omitempty"`
	OmitEmptyElem bool                // `dynamodbav:",omitemptyelem"`
	NullEmpty     bool                // `dynamodbav:",nullempty"`
	NullEmptyElem bool                // `dynamodbav:",nullemptyelem"`
	AsString      bool                // `dynamodbav:",string"`
	AsBinSet      bool                // `dynamodbav:",binaryset"`
	AsNumSet      bool                // `dynamodbav:",numberset"`
	AsStrSet      bool                // `dynamodbav:",stringset"`
	AsUnixTime    bool                // `dynamodbav:",unixtime"`
	Version       bool                // `dynamodbav:",version"`
	PreserveEmpty bool                // `dynamodbav:",preserveempty"`
	JSON          bool                // `dynamodbav:",json"`
	AutoGenerated bool                // `dynamodbav:",autogenerated"`
	AtomicCounter bool                // `dynamodbav:",atomiccounter"` OR `dynamodbav:",atomiccounter|10|5"` (with startValue and delta)
	EnumAsString  bool                // `dynamodbav:",enumasstring"`
	Partition     bool                // `dynamodbav:",partition"`
	Sort          bool                // `dynamodbav:",sort"`
	Converter     bool                // `dynamodbav:",converter|int64"`
	Getter        string              // @DynamoDBGetter = "dynamodbgetter"
	Setter        string              // @DynamoDBSetter = "dynamodbsetter"
	Indexes       []Index             // @DynamoDBIndex = "dynamodbindex"
	Options       map[string][]string // keys can be written as <key>:<options>
}

func (t *Tag) Option(k string) ([]string, bool) {
	if t.Options == nil {
		return nil, false
	}

	v, ok := t.Options[k]

	return v, ok
}

func (t *Tag) parseAVTag(structTag reflect.StructTag) {
	tagStr := structTag.Get(defaultTagKey)
	if len(tagStr) == 0 {
		return
	}

	t.parseTagStr(tagStr)

	t.parseIndexTag(structTag)

	t.parseGetterAndSetter(structTag)
}

func (t *Tag) parseStructTag(tag string, structTag reflect.StructTag) {
	tagStr := structTag.Get(tag)
	if len(tagStr) == 0 {
		return
	}

	t.parseTagStr(tagStr)
}

func (t *Tag) parseTagStr(tagStr string) {
	parts := strings.Split(tagStr, ",")
	if len(parts) == 0 {
		return
	}

	if name := parts[0]; name == "-" {
		t.Name = ""
		t.Ignore = true
	} else {
		t.Name = name
		t.Ignore = false
	}

	for _, opt := range parts[1:] {
		if strings.Contains(opt, "|") {
			if t.Options == nil {
				t.Options = map[string][]string{}
			}

			subOpts := strings.Split(opt, "|")
			opt = subOpts[0]
			subOpts = subOpts[1:]
			if _, ok := t.Options[opt]; ok {
				panic("tag already present with options")
			} else {
				t.Options[opt] = subOpts
			}
		}

		switch opt {
		case "omitempty":
			t.OmitEmpty = true
		case "omitemptyelem":
			t.OmitEmptyElem = true
		case "nullempty":
			t.NullEmpty = true
		case "nullemptyelem":
			t.NullEmptyElem = true
		case "string":
			t.AsString = true
		case "binaryset":
			t.AsBinSet = true
		case "numberset":
			t.AsNumSet = true
		case "stringset":
			t.AsStrSet = true
		case "unixtime":
			t.AsUnixTime = true
		case "version":
			t.Version = true
		case "preserveempty":
			t.PreserveEmpty = true
		case "json":
			t.JSON = true
		case "enumasstring":
			t.EnumAsString = true
		case "partition":
			t.Partition = true
		case "sort":
			t.Sort = true
		case "autogenerated":
			t.AutoGenerated = true
		case "atomiccounter":
			t.AtomicCounter = true
		case "converter":
			t.Converter = true
		default:
			continue
		}
	}
}

func (t *Tag) parseIndexTag(structTag reflect.StructTag) {
	idxString := structTag.Get(tagIndex)
	if len(idxString) == 0 {
		return
	}

	indexes := strings.Split(idxString, ";")

	if len(indexes) == 0 {
		return
	}

	t.Indexes = make([]Index, len(indexes))

	for c, index := range indexes {
		parts := strings.Split(index, ",")
		if len(parts) == 0 {
			continue
		}

		t.Indexes[c].Name = parts[0]

		for _, part := range parts[1:] {
			switch part {
			case "global":
				t.Indexes[c].Global = true
			case "local":
				t.Indexes[c].Local = true
			case "partition":
				t.Indexes[c].Partition = true
			case "sort":
				t.Indexes[c].Sort = true
			}
		}
	}
}

func (t *Tag) parseGetterAndSetter(structTag reflect.StructTag) {
	t.Getter = structTag.Get(tagGetter)
	t.Setter = structTag.Get(tagSetter)
}
