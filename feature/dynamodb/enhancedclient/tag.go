package enhancedclient

import (
	"reflect"
	"strings"
)

const defaultTagKey = "dynamodbav"
const tagIndex = "dynamodbindex"
const tagGetter = "dynamodbgetter"
const tagSetter = "dynamodbsetter"

type tag struct {
	Name          string  // `dynamodbav`
	Ignore        bool    // `dynamodbav:"-"
	OmitEmpty     bool    // `dynamodbav:",omitempty"`
	OmitEmptyElem bool    // `dynamodbav:",omitemptyelem"`
	NullEmpty     bool    // `dynamodbav:",nullempty"`
	NullEmptyElem bool    // `dynamodbav:",nullemptyelem"`
	AsString      bool    // `dynamodbav:",string"`
	AsBinSet      bool    // `dynamodbav:",binaryset"`
	AsNumSet      bool    // `dynamodbav:",numberset"`
	AsStrSet      bool    // `dynamodbav:",stringset"`
	AsUnixTime    bool    // `dynamodbav:",unixtime"`
	Version       bool    // `dynamodbav:",version"`
	PreserveEmpty bool    // `dynamodbav:",preserveempty"`
	JSON          bool    // `dynamodbav:",json"`
	AutoGenerated bool    // `dynamodbav:",autogenerated"`
	Generator     string  // `dynamodbav:",autogenerated:key"`
	AtomicCounter bool    // `dynamodbav:",atomiccounter"`
	EnumAsString  bool    // `dynamodbav:",enumasstring"`
	Partition     bool    // `dynamodbav:",partition"`
	Sort          bool    // `dynamodbav:",sort"`
	Getter        string  // @DynamoDBGetter = "dynamodbgetter"
	Setter        string  // @DynamoDBSetter = "dynamodbsetter"
	Indexes       []Index // @DynamoDBIndex = "dynamodbindex"
}

func (t *tag) parseAVTag(structTag reflect.StructTag) {
	tagStr := structTag.Get(defaultTagKey)
	if len(tagStr) == 0 {
		return
	}

	t.parseTagStr(tagStr)

	t.parseIndexTag(structTag)

	t.parseGetterAndSetter(structTag)
}

func (t *tag) parseStructTag(tag string, structTag reflect.StructTag) {
	tagStr := structTag.Get(tag)
	if len(tagStr) == 0 {
		return
	}

	t.parseTagStr(tagStr)
}

func (t *tag) parseTagStr(tagStr string) {
	parts := strings.Split(tagStr, ",")
	if len(parts) == 0 {
		return
	}

	if name := parts[0]; name == "-" {
		t.Name = ""
		t.Ignore = true
	} else {
		t.Name = name
		t.Ignore = false
	}

	for _, opt := range parts[1:] {
		switch opt {
		case "omitempty":
			t.OmitEmpty = true
		case "omitemptyelem":
			t.OmitEmptyElem = true
		case "nullempty":
			t.NullEmpty = true
		case "nullemptyelem":
			t.NullEmptyElem = true
		case "string":
			t.AsString = true
		case "binaryset":
			t.AsBinSet = true
		case "numberset":
			t.AsNumSet = true
		case "stringset":
			t.AsStrSet = true
		case "unixtime":
			t.AsUnixTime = true
		case "version":
			t.Version = true
		case "preserveempty":
			t.PreserveEmpty = true
		case "json":
			t.JSON = true
		case "atomiccounter":
			t.AtomicCounter = true
		case "enumasstring":
			t.EnumAsString = true
		case "partition":
			t.Partition = true
		case "sort":
			t.Sort = true
		default:
			optParts := strings.Split(opt, ":")
			if len(optParts) == 0 {
				continue
			}
			switch optParts[0] {
			case "autogenerated":
				t.AutoGenerated = true
				if len(optParts) > 1 {
					t.Generator = optParts[1]
				}
			}
		}
	}
}

func (t *tag) parseIndexTag(structTag reflect.StructTag) {
	idxString := structTag.Get(tagIndex)
	if len(idxString) == 0 {
		return
	}

	indexes := strings.Split(idxString, ";")

	if len(indexes) == 0 {
		return
	}

	t.Indexes = make([]Index, len(indexes))

	for c, index := range indexes {
		parts := strings.Split(index, ",")
		if len(parts) == 0 {
			continue
		}

		t.Indexes[c].Name = parts[0]

		for _, part := range parts[1:] {
			switch part {
			case "global":
				t.Indexes[c].Global = true
			case "local":
				t.Indexes[c].Local = true
			case "partition":
				t.Indexes[c].Partition = true
			case "sort":
				t.Indexes[c].Sort = true
			}
		}
	}
}

func (t *tag) parseGetterAndSetter(structTag reflect.StructTag) {
	t.Getter = structTag.Get(tagGetter)
	t.Setter = structTag.Get(tagSetter)
}
