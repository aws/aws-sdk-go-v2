package enhancedclient

import (
	"reflect"
	"strconv"
	"testing"
	"time"
)

func TestAutogenerateExtension(t *testing.T) {

}

type autogenerateTestStruct struct {
	// props to work with
	InputString           string
	InputByteArray        []byte
	InputNumber           int64
	privateInputString    string
	privateInputByteArray []byte
	privateInputNumber    int64
	InputTime             time.Time
	privateInputTime      time.Time

	// test stuff
	field    Field
	error    bool
	validate func(autogenerateTestStruct) bool
}

func (a *autogenerateTestStruct) GetPrivateInputString() string {
	return a.privateInputString
}

func (a *autogenerateTestStruct) SetPrivateInputString(s string) {
	a.privateInputString = s
}

func (a *autogenerateTestStruct) GetPrivateInputByteArray() []byte {
	return a.privateInputByteArray
}

func (a *autogenerateTestStruct) SetPrivateInputByteArray(s []byte) {
	a.privateInputByteArray = s
}

func (a *autogenerateTestStruct) GetPrivateInputNumber() int64 {
	return a.privateInputNumber
}

func (a *autogenerateTestStruct) SetPrivateInputNumber(s int64) {
	a.privateInputNumber = s
}

func (a *autogenerateTestStruct) GetPrivateInputTime() time.Time {
	return a.privateInputTime
}

func (a *autogenerateTestStruct) SetPrivateInputTime(s time.Time) {
	a.privateInputTime = s
}

func TestAutogenerateExtensionProcessKey(t *testing.T) {
	cases := []autogenerateTestStruct{
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"key"},
					},
				},
				Name:        "inputString",
				NameFromTag: false,
				Index:       []int{0},
				Type:        reflect.TypeFor[string](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return len(a.InputString) > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"key"},
					},
				},
				Name:        "inputByteArray",
				NameFromTag: false,
				Index:       []int{1},
				Type:        reflect.TypeFor[[]byte](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return len(a.InputByteArray) > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"key"},
					},
				},
				Name:        "inputNumber",
				NameFromTag: false,
				Index:       []int{2},
				Type:        reflect.TypeFor[int64](),
			},
			error: true,
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"key"},
					},
					Getter: "GetPrivateInputString",
					Setter: "SetPrivateInputString",
				},
				Name:        "inputString",
				NameFromTag: false,
				Index:       []int{3},
				Type:        reflect.TypeFor[string](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return len(a.privateInputString) > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"key"},
					},
					Getter: "GetPrivateInputByteArray",
					Setter: "SetPrivateInputByteArray",
				},
				Name:        "inputByteArray",
				NameFromTag: false,
				Index:       []int{4},
				Type:        reflect.TypeFor[[]byte](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return len(a.privateInputByteArray) > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"key"},
					},
					Getter: "GetPrivateInputNumber",
					Setter: "SetPrivateInputNumber",
				},
				Name:        "inputNumber",
				NameFromTag: false,
				Index:       []int{5},
				Type:        reflect.TypeFor[int64](),
			},
			error: true,
		},
	}

	for i, c := range cases {
		t.Run(strconv.Itoa(i), func(t *testing.T) {
			ext := AutogenerateExtension[autogenerateTestStruct]{}
			err := ext.processKey(&c, c.field, []string{})

			if !c.error && err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if c.error && err == nil {
				t.Fatal("expected error")
			}

			if c.validate != nil && !c.validate(c) {
				t.Fatalf("failed to validate scenario")
			}
		})
	}
}

func TestAutogenerateExtensionProcessTimestamp(t *testing.T) {
	cases := []autogenerateTestStruct{
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"timestamp"},
					},
				},
				Name:        "inputString",
				NameFromTag: false,
				Index:       []int{0},
				Type:        reflect.TypeFor[string](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return len(a.InputString) > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"timestamp"},
					},
				},
				Name:        "inputByteArray",
				NameFromTag: false,
				Index:       []int{1},
				Type:        reflect.TypeFor[[]byte](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return len(a.InputByteArray) > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"timestamp"},
					},
				},
				Name:        "inputNumber",
				NameFromTag: false,
				Index:       []int{2},
				Type:        reflect.TypeFor[int64](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return a.InputNumber > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"timestamp"},
					},
					Getter: "GetPrivateInputString",
					Setter: "SetPrivateInputString",
				},
				Name:        "inputString",
				NameFromTag: false,
				Index:       []int{3},
				Type:        reflect.TypeFor[string](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return len(a.privateInputString) > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"timestamp"},
					},
					Getter: "GetPrivateInputByteArray",
					Setter: "SetPrivateInputByteArray",
				},
				Name:        "inputByteArray",
				NameFromTag: false,
				Index:       []int{4},
				Type:        reflect.TypeFor[[]byte](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return len(a.privateInputByteArray) > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"timestamp"},
					},
					Getter: "GetPrivateInputNumber",
					Setter: "SetPrivateInputNumber",
				},
				Name:        "inputNumber",
				NameFromTag: false,
				Index:       []int{5},
				Type:        reflect.TypeFor[int64](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return a.privateInputNumber > 0
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"timestamp"},
					},
				},
				Name:        "inputTime",
				NameFromTag: false,
				Index:       []int{6},
				Type:        reflect.TypeFor[int64](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return !a.InputTime.IsZero()
			},
		},
		{
			field: Field{
				Tag: Tag{
					AutoGenerated: true,
					Options: map[string][]string{
						"autogenerated": {"timestamp"},
					},
					Getter: "GetPrivateInputTime",
					Setter: "SetPrivateInputTime",
				},
				Name:        "privateInputTime",
				NameFromTag: false,
				Index:       []int{7},
				Type:        reflect.TypeFor[int64](),
			},
			validate: func(a autogenerateTestStruct) bool {
				return !a.privateInputTime.IsZero()
			},
		},
	}

	for i, c := range cases {
		t.Run(strconv.Itoa(i), func(t *testing.T) {
			ext := AutogenerateExtension[autogenerateTestStruct]{}
			err := ext.processTimestamp(&c, c.field, []string{})

			if !c.error && err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if c.error && err == nil {
				t.Fatal("expected error")
			}

			if c.validate != nil && !c.validate(c) {
				t.Fatalf("failed to validate scenario")
			}
		})
	}
}
