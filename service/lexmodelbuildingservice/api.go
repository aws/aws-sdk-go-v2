// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package lexmodelbuildingservice

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opCreateBotVersion = "CreateBotVersion"

// CreateBotVersionRequest is a API request type for the CreateBotVersion API operation.
type CreateBotVersionRequest struct {
	*aws.Request
	Input *CreateBotVersionInput
	Copy  func(*CreateBotVersionInput) CreateBotVersionRequest
}

// Send marshals and sends the CreateBotVersion API request.
func (r CreateBotVersionRequest) Send() (*CreateBotVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateBotVersionOutput), nil
}

// CreateBotVersionRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Creates a new version of the bot based on the $LATEST version. If the $LATEST
// version of this resource hasn't changed since you created the last version,
// Amazon Lex doesn't create a new version. It returns the last created version.
//
// You can update only the $LATEST version of the bot. You can't update the
// numbered versions that you create with the CreateBotVersion operation.
//
// When you create the first version of a bot, Amazon Lex sets the version to
// 1. Subsequent versions increment by 1. For more information, see versioning-intro.
//
// This operation requires permission for the lex:CreateBotVersion action.
//
//    // Example sending a request using the CreateBotVersionRequest method.
//    req := client.CreateBotVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateBotVersion
func (c *LexModelBuildingService) CreateBotVersionRequest(input *CreateBotVersionInput) CreateBotVersionRequest {
	op := &aws.Operation{
		Name:       opCreateBotVersion,
		HTTPMethod: "POST",
		HTTPPath:   "/bots/{name}/versions",
	}

	if input == nil {
		input = &CreateBotVersionInput{}
	}

	output := &CreateBotVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBotVersionRequest{Request: req, Input: input, Copy: c.CreateBotVersionRequest}
}

const opCreateIntentVersion = "CreateIntentVersion"

// CreateIntentVersionRequest is a API request type for the CreateIntentVersion API operation.
type CreateIntentVersionRequest struct {
	*aws.Request
	Input *CreateIntentVersionInput
	Copy  func(*CreateIntentVersionInput) CreateIntentVersionRequest
}

// Send marshals and sends the CreateIntentVersion API request.
func (r CreateIntentVersionRequest) Send() (*CreateIntentVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateIntentVersionOutput), nil
}

// CreateIntentVersionRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Creates a new version of an intent based on the $LATEST version of the intent.
// If the $LATEST version of this intent hasn't changed since you last updated
// it, Amazon Lex doesn't create a new version. It returns the last version
// you created.
//
// You can update only the $LATEST version of the intent. You can't update the
// numbered versions that you create with the CreateIntentVersion operation.
//
// When you create a version of an intent, Amazon Lex sets the version to 1.
// Subsequent versions increment by 1. For more information, see versioning-intro.
//
// This operation requires permissions to perform the lex:CreateIntentVersion
// action.
//
//    // Example sending a request using the CreateIntentVersionRequest method.
//    req := client.CreateIntentVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateIntentVersion
func (c *LexModelBuildingService) CreateIntentVersionRequest(input *CreateIntentVersionInput) CreateIntentVersionRequest {
	op := &aws.Operation{
		Name:       opCreateIntentVersion,
		HTTPMethod: "POST",
		HTTPPath:   "/intents/{name}/versions",
	}

	if input == nil {
		input = &CreateIntentVersionInput{}
	}

	output := &CreateIntentVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateIntentVersionRequest{Request: req, Input: input, Copy: c.CreateIntentVersionRequest}
}

const opCreateSlotTypeVersion = "CreateSlotTypeVersion"

// CreateSlotTypeVersionRequest is a API request type for the CreateSlotTypeVersion API operation.
type CreateSlotTypeVersionRequest struct {
	*aws.Request
	Input *CreateSlotTypeVersionInput
	Copy  func(*CreateSlotTypeVersionInput) CreateSlotTypeVersionRequest
}

// Send marshals and sends the CreateSlotTypeVersion API request.
func (r CreateSlotTypeVersionRequest) Send() (*CreateSlotTypeVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateSlotTypeVersionOutput), nil
}

// CreateSlotTypeVersionRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Creates a new version of a slot type based on the $LATEST version of the
// specified slot type. If the $LATEST version of this resource has not changed
// since the last version that you created, Amazon Lex doesn't create a new
// version. It returns the last version that you created.
//
// You can update only the $LATEST version of a slot type. You can't update
// the numbered versions that you create with the CreateSlotTypeVersion operation.
//
// When you create a version of a slot type, Amazon Lex sets the version to
// 1. Subsequent versions increment by 1. For more information, see versioning-intro.
//
// This operation requires permissions for the lex:CreateSlotTypeVersion action.
//
//    // Example sending a request using the CreateSlotTypeVersionRequest method.
//    req := client.CreateSlotTypeVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateSlotTypeVersion
func (c *LexModelBuildingService) CreateSlotTypeVersionRequest(input *CreateSlotTypeVersionInput) CreateSlotTypeVersionRequest {
	op := &aws.Operation{
		Name:       opCreateSlotTypeVersion,
		HTTPMethod: "POST",
		HTTPPath:   "/slottypes/{name}/versions",
	}

	if input == nil {
		input = &CreateSlotTypeVersionInput{}
	}

	output := &CreateSlotTypeVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateSlotTypeVersionRequest{Request: req, Input: input, Copy: c.CreateSlotTypeVersionRequest}
}

const opDeleteBot = "DeleteBot"

// DeleteBotRequest is a API request type for the DeleteBot API operation.
type DeleteBotRequest struct {
	*aws.Request
	Input *DeleteBotInput
	Copy  func(*DeleteBotInput) DeleteBotRequest
}

// Send marshals and sends the DeleteBot API request.
func (r DeleteBotRequest) Send() (*DeleteBotOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBotOutput), nil
}

// DeleteBotRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes all versions of the bot, including the $LATEST version. To delete
// a specific version of the bot, use the DeleteBotVersion operation.
//
// If a bot has an alias, you can't delete it. Instead, the DeleteBot operation
// returns a ResourceInUseException exception that includes a reference to the
// alias that refers to the bot. To remove the reference to the bot, delete
// the alias. If you get the same exception again, delete the referring alias
// until the DeleteBot operation is successful.
//
// This operation requires permissions for the lex:DeleteBot action.
//
//    // Example sending a request using the DeleteBotRequest method.
//    req := client.DeleteBotRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBot
func (c *LexModelBuildingService) DeleteBotRequest(input *DeleteBotInput) DeleteBotRequest {
	op := &aws.Operation{
		Name:       opDeleteBot,
		HTTPMethod: "DELETE",
		HTTPPath:   "/bots/{name}",
	}

	if input == nil {
		input = &DeleteBotInput{}
	}

	output := &DeleteBotOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBotRequest{Request: req, Input: input, Copy: c.DeleteBotRequest}
}

const opDeleteBotAlias = "DeleteBotAlias"

// DeleteBotAliasRequest is a API request type for the DeleteBotAlias API operation.
type DeleteBotAliasRequest struct {
	*aws.Request
	Input *DeleteBotAliasInput
	Copy  func(*DeleteBotAliasInput) DeleteBotAliasRequest
}

// Send marshals and sends the DeleteBotAlias API request.
func (r DeleteBotAliasRequest) Send() (*DeleteBotAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBotAliasOutput), nil
}

// DeleteBotAliasRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes an alias for the specified bot.
//
// You can't delete an alias that is used in the association between a bot and
// a messaging channel. If an alias is used in a channel association, the DeleteBot
// operation returns a ResourceInUseException exception that includes a reference
// to the channel association that refers to the bot. You can remove the reference
// to the alias by deleting the channel association. If you get the same exception
// again, delete the referring association until the DeleteBotAlias operation
// is successful.
//
//    // Example sending a request using the DeleteBotAliasRequest method.
//    req := client.DeleteBotAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotAlias
func (c *LexModelBuildingService) DeleteBotAliasRequest(input *DeleteBotAliasInput) DeleteBotAliasRequest {
	op := &aws.Operation{
		Name:       opDeleteBotAlias,
		HTTPMethod: "DELETE",
		HTTPPath:   "/bots/{botName}/aliases/{name}",
	}

	if input == nil {
		input = &DeleteBotAliasInput{}
	}

	output := &DeleteBotAliasOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBotAliasRequest{Request: req, Input: input, Copy: c.DeleteBotAliasRequest}
}

const opDeleteBotChannelAssociation = "DeleteBotChannelAssociation"

// DeleteBotChannelAssociationRequest is a API request type for the DeleteBotChannelAssociation API operation.
type DeleteBotChannelAssociationRequest struct {
	*aws.Request
	Input *DeleteBotChannelAssociationInput
	Copy  func(*DeleteBotChannelAssociationInput) DeleteBotChannelAssociationRequest
}

// Send marshals and sends the DeleteBotChannelAssociation API request.
func (r DeleteBotChannelAssociationRequest) Send() (*DeleteBotChannelAssociationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBotChannelAssociationOutput), nil
}

// DeleteBotChannelAssociationRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes the association between an Amazon Lex bot and a messaging platform.
//
// This operation requires permission for the lex:DeleteBotChannelAssociation
// action.
//
//    // Example sending a request using the DeleteBotChannelAssociationRequest method.
//    req := client.DeleteBotChannelAssociationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotChannelAssociation
func (c *LexModelBuildingService) DeleteBotChannelAssociationRequest(input *DeleteBotChannelAssociationInput) DeleteBotChannelAssociationRequest {
	op := &aws.Operation{
		Name:       opDeleteBotChannelAssociation,
		HTTPMethod: "DELETE",
		HTTPPath:   "/bots/{botName}/aliases/{aliasName}/channels/{name}",
	}

	if input == nil {
		input = &DeleteBotChannelAssociationInput{}
	}

	output := &DeleteBotChannelAssociationOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBotChannelAssociationRequest{Request: req, Input: input, Copy: c.DeleteBotChannelAssociationRequest}
}

const opDeleteBotVersion = "DeleteBotVersion"

// DeleteBotVersionRequest is a API request type for the DeleteBotVersion API operation.
type DeleteBotVersionRequest struct {
	*aws.Request
	Input *DeleteBotVersionInput
	Copy  func(*DeleteBotVersionInput) DeleteBotVersionRequest
}

// Send marshals and sends the DeleteBotVersion API request.
func (r DeleteBotVersionRequest) Send() (*DeleteBotVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBotVersionOutput), nil
}

// DeleteBotVersionRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes a specific version of a bot. To delete all versions of a bot, use
// the DeleteBot operation.
//
// This operation requires permissions for the lex:DeleteBotVersion action.
//
//    // Example sending a request using the DeleteBotVersionRequest method.
//    req := client.DeleteBotVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotVersion
func (c *LexModelBuildingService) DeleteBotVersionRequest(input *DeleteBotVersionInput) DeleteBotVersionRequest {
	op := &aws.Operation{
		Name:       opDeleteBotVersion,
		HTTPMethod: "DELETE",
		HTTPPath:   "/bots/{name}/versions/{version}",
	}

	if input == nil {
		input = &DeleteBotVersionInput{}
	}

	output := &DeleteBotVersionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBotVersionRequest{Request: req, Input: input, Copy: c.DeleteBotVersionRequest}
}

const opDeleteIntent = "DeleteIntent"

// DeleteIntentRequest is a API request type for the DeleteIntent API operation.
type DeleteIntentRequest struct {
	*aws.Request
	Input *DeleteIntentInput
	Copy  func(*DeleteIntentInput) DeleteIntentRequest
}

// Send marshals and sends the DeleteIntent API request.
func (r DeleteIntentRequest) Send() (*DeleteIntentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteIntentOutput), nil
}

// DeleteIntentRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes all versions of the intent, including the $LATEST version. To delete
// a specific version of the intent, use the DeleteIntentVersion operation.
//
// You can delete a version of an intent only if it is not referenced. To delete
// an intent that is referred to in one or more bots (see how-it-works), you
// must remove those references first.
//
// If you get the ResourceInUseException exception, it provides an example reference
// that shows where the intent is referenced. To remove the reference to the
// intent, either update the bot or delete it. If you get the same exception
// when you attempt to delete the intent again, repeat until the intent has
// no references and the call to DeleteIntent is successful.
//
// This operation requires permission for the lex:DeleteIntent action.
//
//    // Example sending a request using the DeleteIntentRequest method.
//    req := client.DeleteIntentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteIntent
func (c *LexModelBuildingService) DeleteIntentRequest(input *DeleteIntentInput) DeleteIntentRequest {
	op := &aws.Operation{
		Name:       opDeleteIntent,
		HTTPMethod: "DELETE",
		HTTPPath:   "/intents/{name}",
	}

	if input == nil {
		input = &DeleteIntentInput{}
	}

	output := &DeleteIntentOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteIntentRequest{Request: req, Input: input, Copy: c.DeleteIntentRequest}
}

const opDeleteIntentVersion = "DeleteIntentVersion"

// DeleteIntentVersionRequest is a API request type for the DeleteIntentVersion API operation.
type DeleteIntentVersionRequest struct {
	*aws.Request
	Input *DeleteIntentVersionInput
	Copy  func(*DeleteIntentVersionInput) DeleteIntentVersionRequest
}

// Send marshals and sends the DeleteIntentVersion API request.
func (r DeleteIntentVersionRequest) Send() (*DeleteIntentVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteIntentVersionOutput), nil
}

// DeleteIntentVersionRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes a specific version of an intent. To delete all versions of a intent,
// use the DeleteIntent operation.
//
// This operation requires permissions for the lex:DeleteIntentVersion action.
//
//    // Example sending a request using the DeleteIntentVersionRequest method.
//    req := client.DeleteIntentVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteIntentVersion
func (c *LexModelBuildingService) DeleteIntentVersionRequest(input *DeleteIntentVersionInput) DeleteIntentVersionRequest {
	op := &aws.Operation{
		Name:       opDeleteIntentVersion,
		HTTPMethod: "DELETE",
		HTTPPath:   "/intents/{name}/versions/{version}",
	}

	if input == nil {
		input = &DeleteIntentVersionInput{}
	}

	output := &DeleteIntentVersionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteIntentVersionRequest{Request: req, Input: input, Copy: c.DeleteIntentVersionRequest}
}

const opDeleteSlotType = "DeleteSlotType"

// DeleteSlotTypeRequest is a API request type for the DeleteSlotType API operation.
type DeleteSlotTypeRequest struct {
	*aws.Request
	Input *DeleteSlotTypeInput
	Copy  func(*DeleteSlotTypeInput) DeleteSlotTypeRequest
}

// Send marshals and sends the DeleteSlotType API request.
func (r DeleteSlotTypeRequest) Send() (*DeleteSlotTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteSlotTypeOutput), nil
}

// DeleteSlotTypeRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes all versions of the slot type, including the $LATEST version. To
// delete a specific version of the slot type, use the DeleteSlotTypeVersion
// operation.
//
// You can delete a version of a slot type only if it is not referenced. To
// delete a slot type that is referred to in one or more intents, you must remove
// those references first.
//
// If you get the ResourceInUseException exception, the exception provides an
// example reference that shows the intent where the slot type is referenced.
// To remove the reference to the slot type, either update the intent or delete
// it. If you get the same exception when you attempt to delete the slot type
// again, repeat until the slot type has no references and the DeleteSlotType
// call is successful.
//
// This operation requires permission for the lex:DeleteSlotType action.
//
//    // Example sending a request using the DeleteSlotTypeRequest method.
//    req := client.DeleteSlotTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteSlotType
func (c *LexModelBuildingService) DeleteSlotTypeRequest(input *DeleteSlotTypeInput) DeleteSlotTypeRequest {
	op := &aws.Operation{
		Name:       opDeleteSlotType,
		HTTPMethod: "DELETE",
		HTTPPath:   "/slottypes/{name}",
	}

	if input == nil {
		input = &DeleteSlotTypeInput{}
	}

	output := &DeleteSlotTypeOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteSlotTypeRequest{Request: req, Input: input, Copy: c.DeleteSlotTypeRequest}
}

const opDeleteSlotTypeVersion = "DeleteSlotTypeVersion"

// DeleteSlotTypeVersionRequest is a API request type for the DeleteSlotTypeVersion API operation.
type DeleteSlotTypeVersionRequest struct {
	*aws.Request
	Input *DeleteSlotTypeVersionInput
	Copy  func(*DeleteSlotTypeVersionInput) DeleteSlotTypeVersionRequest
}

// Send marshals and sends the DeleteSlotTypeVersion API request.
func (r DeleteSlotTypeVersionRequest) Send() (*DeleteSlotTypeVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteSlotTypeVersionOutput), nil
}

// DeleteSlotTypeVersionRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes a specific version of a slot type. To delete all versions of a slot
// type, use the DeleteSlotType operation.
//
// This operation requires permissions for the lex:DeleteSlotTypeVersion action.
//
//    // Example sending a request using the DeleteSlotTypeVersionRequest method.
//    req := client.DeleteSlotTypeVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteSlotTypeVersion
func (c *LexModelBuildingService) DeleteSlotTypeVersionRequest(input *DeleteSlotTypeVersionInput) DeleteSlotTypeVersionRequest {
	op := &aws.Operation{
		Name:       opDeleteSlotTypeVersion,
		HTTPMethod: "DELETE",
		HTTPPath:   "/slottypes/{name}/version/{version}",
	}

	if input == nil {
		input = &DeleteSlotTypeVersionInput{}
	}

	output := &DeleteSlotTypeVersionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteSlotTypeVersionRequest{Request: req, Input: input, Copy: c.DeleteSlotTypeVersionRequest}
}

const opDeleteUtterances = "DeleteUtterances"

// DeleteUtterancesRequest is a API request type for the DeleteUtterances API operation.
type DeleteUtterancesRequest struct {
	*aws.Request
	Input *DeleteUtterancesInput
	Copy  func(*DeleteUtterancesInput) DeleteUtterancesRequest
}

// Send marshals and sends the DeleteUtterances API request.
func (r DeleteUtterancesRequest) Send() (*DeleteUtterancesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteUtterancesOutput), nil
}

// DeleteUtterancesRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Deletes stored utterances.
//
// Amazon Lex stores the utterances that users send to your bot. Utterances
// are stored for 15 days for use with the GetUtterancesView operation, and
// then stored indefinitely for use in improving the ability of your bot to
// respond to user input.
//
// Use the DeleteStoredUtterances operation to manually delete stored utterances
// for a specific user.
//
// This operation requires permissions for the lex:DeleteUtterances action.
//
//    // Example sending a request using the DeleteUtterancesRequest method.
//    req := client.DeleteUtterancesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteUtterances
func (c *LexModelBuildingService) DeleteUtterancesRequest(input *DeleteUtterancesInput) DeleteUtterancesRequest {
	op := &aws.Operation{
		Name:       opDeleteUtterances,
		HTTPMethod: "DELETE",
		HTTPPath:   "/bots/{botName}/utterances/{userId}",
	}

	if input == nil {
		input = &DeleteUtterancesInput{}
	}

	output := &DeleteUtterancesOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteUtterancesRequest{Request: req, Input: input, Copy: c.DeleteUtterancesRequest}
}

const opGetBot = "GetBot"

// GetBotRequest is a API request type for the GetBot API operation.
type GetBotRequest struct {
	*aws.Request
	Input *GetBotInput
	Copy  func(*GetBotInput) GetBotRequest
}

// Send marshals and sends the GetBot API request.
func (r GetBotRequest) Send() (*GetBotOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBotOutput), nil
}

// GetBotRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns metadata information for a specific bot. You must provide the bot
// name and the bot version or alias.
//
// This operation requires permissions for the lex:GetBot action.
//
//    // Example sending a request using the GetBotRequest method.
//    req := client.GetBotRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBot
func (c *LexModelBuildingService) GetBotRequest(input *GetBotInput) GetBotRequest {
	op := &aws.Operation{
		Name:       opGetBot,
		HTTPMethod: "GET",
		HTTPPath:   "/bots/{name}/versions/{versionoralias}",
	}

	if input == nil {
		input = &GetBotInput{}
	}

	output := &GetBotOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBotRequest{Request: req, Input: input, Copy: c.GetBotRequest}
}

const opGetBotAlias = "GetBotAlias"

// GetBotAliasRequest is a API request type for the GetBotAlias API operation.
type GetBotAliasRequest struct {
	*aws.Request
	Input *GetBotAliasInput
	Copy  func(*GetBotAliasInput) GetBotAliasRequest
}

// Send marshals and sends the GetBotAlias API request.
func (r GetBotAliasRequest) Send() (*GetBotAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBotAliasOutput), nil
}

// GetBotAliasRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns information about an Amazon Lex bot alias. For more information about
// aliases, see versioning-aliases.
//
// This operation requires permissions for the lex:GetBotAlias action.
//
//    // Example sending a request using the GetBotAliasRequest method.
//    req := client.GetBotAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotAlias
func (c *LexModelBuildingService) GetBotAliasRequest(input *GetBotAliasInput) GetBotAliasRequest {
	op := &aws.Operation{
		Name:       opGetBotAlias,
		HTTPMethod: "GET",
		HTTPPath:   "/bots/{botName}/aliases/{name}",
	}

	if input == nil {
		input = &GetBotAliasInput{}
	}

	output := &GetBotAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBotAliasRequest{Request: req, Input: input, Copy: c.GetBotAliasRequest}
}

const opGetBotAliases = "GetBotAliases"

// GetBotAliasesRequest is a API request type for the GetBotAliases API operation.
type GetBotAliasesRequest struct {
	*aws.Request
	Input *GetBotAliasesInput
	Copy  func(*GetBotAliasesInput) GetBotAliasesRequest
}

// Send marshals and sends the GetBotAliases API request.
func (r GetBotAliasesRequest) Send() (*GetBotAliasesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBotAliasesOutput), nil
}

// GetBotAliasesRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns a list of aliases for a specified Amazon Lex bot.
//
// This operation requires permissions for the lex:GetBotAliases action.
//
//    // Example sending a request using the GetBotAliasesRequest method.
//    req := client.GetBotAliasesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotAliases
func (c *LexModelBuildingService) GetBotAliasesRequest(input *GetBotAliasesInput) GetBotAliasesRequest {
	op := &aws.Operation{
		Name:       opGetBotAliases,
		HTTPMethod: "GET",
		HTTPPath:   "/bots/{botName}/aliases/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetBotAliasesInput{}
	}

	output := &GetBotAliasesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBotAliasesRequest{Request: req, Input: input, Copy: c.GetBotAliasesRequest}
}

// Paginate pages iterates over the pages of a GetBotAliasesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetBotAliases operation.
//		req := client.GetBotAliasesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetBotAliasesRequest) Paginate(opts ...aws.Option) GetBotAliasesPager {
	return GetBotAliasesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetBotAliasesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetBotAliasesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetBotAliasesPager struct {
	aws.Pager
}

func (p *GetBotAliasesPager) CurrentPage() *GetBotAliasesOutput {
	return p.Pager.CurrentPage().(*GetBotAliasesOutput)
}

const opGetBotChannelAssociation = "GetBotChannelAssociation"

// GetBotChannelAssociationRequest is a API request type for the GetBotChannelAssociation API operation.
type GetBotChannelAssociationRequest struct {
	*aws.Request
	Input *GetBotChannelAssociationInput
	Copy  func(*GetBotChannelAssociationInput) GetBotChannelAssociationRequest
}

// Send marshals and sends the GetBotChannelAssociation API request.
func (r GetBotChannelAssociationRequest) Send() (*GetBotChannelAssociationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBotChannelAssociationOutput), nil
}

// GetBotChannelAssociationRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns information about the association between an Amazon Lex bot and a
// messaging platform.
//
// This operation requires permissions for the lex:GetBotChannelAssociation
// action.
//
//    // Example sending a request using the GetBotChannelAssociationRequest method.
//    req := client.GetBotChannelAssociationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotChannelAssociation
func (c *LexModelBuildingService) GetBotChannelAssociationRequest(input *GetBotChannelAssociationInput) GetBotChannelAssociationRequest {
	op := &aws.Operation{
		Name:       opGetBotChannelAssociation,
		HTTPMethod: "GET",
		HTTPPath:   "/bots/{botName}/aliases/{aliasName}/channels/{name}",
	}

	if input == nil {
		input = &GetBotChannelAssociationInput{}
	}

	output := &GetBotChannelAssociationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBotChannelAssociationRequest{Request: req, Input: input, Copy: c.GetBotChannelAssociationRequest}
}

const opGetBotChannelAssociations = "GetBotChannelAssociations"

// GetBotChannelAssociationsRequest is a API request type for the GetBotChannelAssociations API operation.
type GetBotChannelAssociationsRequest struct {
	*aws.Request
	Input *GetBotChannelAssociationsInput
	Copy  func(*GetBotChannelAssociationsInput) GetBotChannelAssociationsRequest
}

// Send marshals and sends the GetBotChannelAssociations API request.
func (r GetBotChannelAssociationsRequest) Send() (*GetBotChannelAssociationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBotChannelAssociationsOutput), nil
}

// GetBotChannelAssociationsRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns a list of all of the channels associated with the specified bot.
//
// The GetBotChannelAssociations operation requires permissions for the lex:GetBotChannelAssociations
// action.
//
//    // Example sending a request using the GetBotChannelAssociationsRequest method.
//    req := client.GetBotChannelAssociationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotChannelAssociations
func (c *LexModelBuildingService) GetBotChannelAssociationsRequest(input *GetBotChannelAssociationsInput) GetBotChannelAssociationsRequest {
	op := &aws.Operation{
		Name:       opGetBotChannelAssociations,
		HTTPMethod: "GET",
		HTTPPath:   "/bots/{botName}/aliases/{aliasName}/channels/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetBotChannelAssociationsInput{}
	}

	output := &GetBotChannelAssociationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBotChannelAssociationsRequest{Request: req, Input: input, Copy: c.GetBotChannelAssociationsRequest}
}

// Paginate pages iterates over the pages of a GetBotChannelAssociationsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetBotChannelAssociations operation.
//		req := client.GetBotChannelAssociationsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetBotChannelAssociationsRequest) Paginate(opts ...aws.Option) GetBotChannelAssociationsPager {
	return GetBotChannelAssociationsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetBotChannelAssociationsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetBotChannelAssociationsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetBotChannelAssociationsPager struct {
	aws.Pager
}

func (p *GetBotChannelAssociationsPager) CurrentPage() *GetBotChannelAssociationsOutput {
	return p.Pager.CurrentPage().(*GetBotChannelAssociationsOutput)
}

const opGetBotVersions = "GetBotVersions"

// GetBotVersionsRequest is a API request type for the GetBotVersions API operation.
type GetBotVersionsRequest struct {
	*aws.Request
	Input *GetBotVersionsInput
	Copy  func(*GetBotVersionsInput) GetBotVersionsRequest
}

// Send marshals and sends the GetBotVersions API request.
func (r GetBotVersionsRequest) Send() (*GetBotVersionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBotVersionsOutput), nil
}

// GetBotVersionsRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Gets information about all of the versions of a bot.
//
// The GetBotVersions operation returns a BotMetadata object for each version
// of a bot. For example, if a bot has three numbered versions, the GetBotVersions
// operation returns four BotMetadata objects in the response, one for each
// numbered version and one for the $LATEST version.
//
// The GetBotVersions operation always returns at least one version, the $LATEST
// version.
//
// This operation requires permissions for the lex:GetBotVersions action.
//
//    // Example sending a request using the GetBotVersionsRequest method.
//    req := client.GetBotVersionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotVersions
func (c *LexModelBuildingService) GetBotVersionsRequest(input *GetBotVersionsInput) GetBotVersionsRequest {
	op := &aws.Operation{
		Name:       opGetBotVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/bots/{name}/versions/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetBotVersionsInput{}
	}

	output := &GetBotVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBotVersionsRequest{Request: req, Input: input, Copy: c.GetBotVersionsRequest}
}

// Paginate pages iterates over the pages of a GetBotVersionsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetBotVersions operation.
//		req := client.GetBotVersionsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetBotVersionsRequest) Paginate(opts ...aws.Option) GetBotVersionsPager {
	return GetBotVersionsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetBotVersionsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetBotVersionsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetBotVersionsPager struct {
	aws.Pager
}

func (p *GetBotVersionsPager) CurrentPage() *GetBotVersionsOutput {
	return p.Pager.CurrentPage().(*GetBotVersionsOutput)
}

const opGetBots = "GetBots"

// GetBotsRequest is a API request type for the GetBots API operation.
type GetBotsRequest struct {
	*aws.Request
	Input *GetBotsInput
	Copy  func(*GetBotsInput) GetBotsRequest
}

// Send marshals and sends the GetBots API request.
func (r GetBotsRequest) Send() (*GetBotsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBotsOutput), nil
}

// GetBotsRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns bot information as follows:
//
//    * If you provide the nameContains field, the response includes information
//    for the $LATEST version of all bots whose name contains the specified
//    string.
//
//    * If you don't specify the nameContains field, the operation returns information
//    about the $LATEST version of all of your bots.
//
// This operation requires permission for the lex:GetBots action.
//
//    // Example sending a request using the GetBotsRequest method.
//    req := client.GetBotsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBots
func (c *LexModelBuildingService) GetBotsRequest(input *GetBotsInput) GetBotsRequest {
	op := &aws.Operation{
		Name:       opGetBots,
		HTTPMethod: "GET",
		HTTPPath:   "/bots/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetBotsInput{}
	}

	output := &GetBotsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBotsRequest{Request: req, Input: input, Copy: c.GetBotsRequest}
}

// Paginate pages iterates over the pages of a GetBotsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetBots operation.
//		req := client.GetBotsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetBotsRequest) Paginate(opts ...aws.Option) GetBotsPager {
	return GetBotsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetBotsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetBotsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetBotsPager struct {
	aws.Pager
}

func (p *GetBotsPager) CurrentPage() *GetBotsOutput {
	return p.Pager.CurrentPage().(*GetBotsOutput)
}

const opGetBuiltinIntent = "GetBuiltinIntent"

// GetBuiltinIntentRequest is a API request type for the GetBuiltinIntent API operation.
type GetBuiltinIntentRequest struct {
	*aws.Request
	Input *GetBuiltinIntentInput
	Copy  func(*GetBuiltinIntentInput) GetBuiltinIntentRequest
}

// Send marshals and sends the GetBuiltinIntent API request.
func (r GetBuiltinIntentRequest) Send() (*GetBuiltinIntentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBuiltinIntentOutput), nil
}

// GetBuiltinIntentRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns information about a built-in intent.
//
// This operation requires permission for the lex:GetBuiltinIntent action.
//
//    // Example sending a request using the GetBuiltinIntentRequest method.
//    req := client.GetBuiltinIntentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinIntent
func (c *LexModelBuildingService) GetBuiltinIntentRequest(input *GetBuiltinIntentInput) GetBuiltinIntentRequest {
	op := &aws.Operation{
		Name:       opGetBuiltinIntent,
		HTTPMethod: "GET",
		HTTPPath:   "/builtins/intents/{signature}",
	}

	if input == nil {
		input = &GetBuiltinIntentInput{}
	}

	output := &GetBuiltinIntentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBuiltinIntentRequest{Request: req, Input: input, Copy: c.GetBuiltinIntentRequest}
}

const opGetBuiltinIntents = "GetBuiltinIntents"

// GetBuiltinIntentsRequest is a API request type for the GetBuiltinIntents API operation.
type GetBuiltinIntentsRequest struct {
	*aws.Request
	Input *GetBuiltinIntentsInput
	Copy  func(*GetBuiltinIntentsInput) GetBuiltinIntentsRequest
}

// Send marshals and sends the GetBuiltinIntents API request.
func (r GetBuiltinIntentsRequest) Send() (*GetBuiltinIntentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBuiltinIntentsOutput), nil
}

// GetBuiltinIntentsRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Gets a list of built-in intents that meet the specified criteria.
//
// This operation requires permission for the lex:GetBuiltinIntents action.
//
//    // Example sending a request using the GetBuiltinIntentsRequest method.
//    req := client.GetBuiltinIntentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinIntents
func (c *LexModelBuildingService) GetBuiltinIntentsRequest(input *GetBuiltinIntentsInput) GetBuiltinIntentsRequest {
	op := &aws.Operation{
		Name:       opGetBuiltinIntents,
		HTTPMethod: "GET",
		HTTPPath:   "/builtins/intents/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetBuiltinIntentsInput{}
	}

	output := &GetBuiltinIntentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBuiltinIntentsRequest{Request: req, Input: input, Copy: c.GetBuiltinIntentsRequest}
}

// Paginate pages iterates over the pages of a GetBuiltinIntentsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetBuiltinIntents operation.
//		req := client.GetBuiltinIntentsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetBuiltinIntentsRequest) Paginate(opts ...aws.Option) GetBuiltinIntentsPager {
	return GetBuiltinIntentsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetBuiltinIntentsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetBuiltinIntentsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetBuiltinIntentsPager struct {
	aws.Pager
}

func (p *GetBuiltinIntentsPager) CurrentPage() *GetBuiltinIntentsOutput {
	return p.Pager.CurrentPage().(*GetBuiltinIntentsOutput)
}

const opGetBuiltinSlotTypes = "GetBuiltinSlotTypes"

// GetBuiltinSlotTypesRequest is a API request type for the GetBuiltinSlotTypes API operation.
type GetBuiltinSlotTypesRequest struct {
	*aws.Request
	Input *GetBuiltinSlotTypesInput
	Copy  func(*GetBuiltinSlotTypesInput) GetBuiltinSlotTypesRequest
}

// Send marshals and sends the GetBuiltinSlotTypes API request.
func (r GetBuiltinSlotTypesRequest) Send() (*GetBuiltinSlotTypesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBuiltinSlotTypesOutput), nil
}

// GetBuiltinSlotTypesRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Gets a list of built-in slot types that meet the specified criteria.
//
// For a list of built-in slot types, see Slot Type Reference (https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/slot-type-reference)
// in the Alexa Skills Kit.
//
// This operation requires permission for the lex:GetBuiltInSlotTypes action.
//
//    // Example sending a request using the GetBuiltinSlotTypesRequest method.
//    req := client.GetBuiltinSlotTypesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinSlotTypes
func (c *LexModelBuildingService) GetBuiltinSlotTypesRequest(input *GetBuiltinSlotTypesInput) GetBuiltinSlotTypesRequest {
	op := &aws.Operation{
		Name:       opGetBuiltinSlotTypes,
		HTTPMethod: "GET",
		HTTPPath:   "/builtins/slottypes/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetBuiltinSlotTypesInput{}
	}

	output := &GetBuiltinSlotTypesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBuiltinSlotTypesRequest{Request: req, Input: input, Copy: c.GetBuiltinSlotTypesRequest}
}

// Paginate pages iterates over the pages of a GetBuiltinSlotTypesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetBuiltinSlotTypes operation.
//		req := client.GetBuiltinSlotTypesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetBuiltinSlotTypesRequest) Paginate(opts ...aws.Option) GetBuiltinSlotTypesPager {
	return GetBuiltinSlotTypesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetBuiltinSlotTypesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetBuiltinSlotTypesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetBuiltinSlotTypesPager struct {
	aws.Pager
}

func (p *GetBuiltinSlotTypesPager) CurrentPage() *GetBuiltinSlotTypesOutput {
	return p.Pager.CurrentPage().(*GetBuiltinSlotTypesOutput)
}

const opGetExport = "GetExport"

// GetExportRequest is a API request type for the GetExport API operation.
type GetExportRequest struct {
	*aws.Request
	Input *GetExportInput
	Copy  func(*GetExportInput) GetExportRequest
}

// Send marshals and sends the GetExport API request.
func (r GetExportRequest) Send() (*GetExportOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetExportOutput), nil
}

// GetExportRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Exports the contents of a Amazon Lex resource in a specified format.
//
//    // Example sending a request using the GetExportRequest method.
//    req := client.GetExportRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetExport
func (c *LexModelBuildingService) GetExportRequest(input *GetExportInput) GetExportRequest {
	op := &aws.Operation{
		Name:       opGetExport,
		HTTPMethod: "GET",
		HTTPPath:   "/exports/",
	}

	if input == nil {
		input = &GetExportInput{}
	}

	output := &GetExportOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetExportRequest{Request: req, Input: input, Copy: c.GetExportRequest}
}

const opGetImport = "GetImport"

// GetImportRequest is a API request type for the GetImport API operation.
type GetImportRequest struct {
	*aws.Request
	Input *GetImportInput
	Copy  func(*GetImportInput) GetImportRequest
}

// Send marshals and sends the GetImport API request.
func (r GetImportRequest) Send() (*GetImportOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetImportOutput), nil
}

// GetImportRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Gets information about an import job started with the StartImport operation.
//
//    // Example sending a request using the GetImportRequest method.
//    req := client.GetImportRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetImport
func (c *LexModelBuildingService) GetImportRequest(input *GetImportInput) GetImportRequest {
	op := &aws.Operation{
		Name:       opGetImport,
		HTTPMethod: "GET",
		HTTPPath:   "/imports/{importId}",
	}

	if input == nil {
		input = &GetImportInput{}
	}

	output := &GetImportOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetImportRequest{Request: req, Input: input, Copy: c.GetImportRequest}
}

const opGetIntent = "GetIntent"

// GetIntentRequest is a API request type for the GetIntent API operation.
type GetIntentRequest struct {
	*aws.Request
	Input *GetIntentInput
	Copy  func(*GetIntentInput) GetIntentRequest
}

// Send marshals and sends the GetIntent API request.
func (r GetIntentRequest) Send() (*GetIntentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetIntentOutput), nil
}

// GetIntentRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns information about an intent. In addition to the intent name, you
// must specify the intent version.
//
// This operation requires permissions to perform the lex:GetIntent action.
//
//    // Example sending a request using the GetIntentRequest method.
//    req := client.GetIntentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntent
func (c *LexModelBuildingService) GetIntentRequest(input *GetIntentInput) GetIntentRequest {
	op := &aws.Operation{
		Name:       opGetIntent,
		HTTPMethod: "GET",
		HTTPPath:   "/intents/{name}/versions/{version}",
	}

	if input == nil {
		input = &GetIntentInput{}
	}

	output := &GetIntentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetIntentRequest{Request: req, Input: input, Copy: c.GetIntentRequest}
}

const opGetIntentVersions = "GetIntentVersions"

// GetIntentVersionsRequest is a API request type for the GetIntentVersions API operation.
type GetIntentVersionsRequest struct {
	*aws.Request
	Input *GetIntentVersionsInput
	Copy  func(*GetIntentVersionsInput) GetIntentVersionsRequest
}

// Send marshals and sends the GetIntentVersions API request.
func (r GetIntentVersionsRequest) Send() (*GetIntentVersionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetIntentVersionsOutput), nil
}

// GetIntentVersionsRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Gets information about all of the versions of an intent.
//
// The GetIntentVersions operation returns an IntentMetadata object for each
// version of an intent. For example, if an intent has three numbered versions,
// the GetIntentVersions operation returns four IntentMetadata objects in the
// response, one for each numbered version and one for the $LATEST version.
//
// The GetIntentVersions operation always returns at least one version, the
// $LATEST version.
//
// This operation requires permissions for the lex:GetIntentVersions action.
//
//    // Example sending a request using the GetIntentVersionsRequest method.
//    req := client.GetIntentVersionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntentVersions
func (c *LexModelBuildingService) GetIntentVersionsRequest(input *GetIntentVersionsInput) GetIntentVersionsRequest {
	op := &aws.Operation{
		Name:       opGetIntentVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/intents/{name}/versions/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetIntentVersionsInput{}
	}

	output := &GetIntentVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetIntentVersionsRequest{Request: req, Input: input, Copy: c.GetIntentVersionsRequest}
}

// Paginate pages iterates over the pages of a GetIntentVersionsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetIntentVersions operation.
//		req := client.GetIntentVersionsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetIntentVersionsRequest) Paginate(opts ...aws.Option) GetIntentVersionsPager {
	return GetIntentVersionsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetIntentVersionsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetIntentVersionsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetIntentVersionsPager struct {
	aws.Pager
}

func (p *GetIntentVersionsPager) CurrentPage() *GetIntentVersionsOutput {
	return p.Pager.CurrentPage().(*GetIntentVersionsOutput)
}

const opGetIntents = "GetIntents"

// GetIntentsRequest is a API request type for the GetIntents API operation.
type GetIntentsRequest struct {
	*aws.Request
	Input *GetIntentsInput
	Copy  func(*GetIntentsInput) GetIntentsRequest
}

// Send marshals and sends the GetIntents API request.
func (r GetIntentsRequest) Send() (*GetIntentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetIntentsOutput), nil
}

// GetIntentsRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns intent information as follows:
//
//    * If you specify the nameContains field, returns the $LATEST version of
//    all intents that contain the specified string.
//
//    *  If you don't specify the nameContains field, returns information about
//    the $LATEST version of all intents.
//
// The operation requires permission for the lex:GetIntents action.
//
//    // Example sending a request using the GetIntentsRequest method.
//    req := client.GetIntentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntents
func (c *LexModelBuildingService) GetIntentsRequest(input *GetIntentsInput) GetIntentsRequest {
	op := &aws.Operation{
		Name:       opGetIntents,
		HTTPMethod: "GET",
		HTTPPath:   "/intents/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetIntentsInput{}
	}

	output := &GetIntentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetIntentsRequest{Request: req, Input: input, Copy: c.GetIntentsRequest}
}

// Paginate pages iterates over the pages of a GetIntentsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetIntents operation.
//		req := client.GetIntentsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetIntentsRequest) Paginate(opts ...aws.Option) GetIntentsPager {
	return GetIntentsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetIntentsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetIntentsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetIntentsPager struct {
	aws.Pager
}

func (p *GetIntentsPager) CurrentPage() *GetIntentsOutput {
	return p.Pager.CurrentPage().(*GetIntentsOutput)
}

const opGetSlotType = "GetSlotType"

// GetSlotTypeRequest is a API request type for the GetSlotType API operation.
type GetSlotTypeRequest struct {
	*aws.Request
	Input *GetSlotTypeInput
	Copy  func(*GetSlotTypeInput) GetSlotTypeRequest
}

// Send marshals and sends the GetSlotType API request.
func (r GetSlotTypeRequest) Send() (*GetSlotTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSlotTypeOutput), nil
}

// GetSlotTypeRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns information about a specific version of a slot type. In addition
// to specifying the slot type name, you must specify the slot type version.
//
// This operation requires permissions for the lex:GetSlotType action.
//
//    // Example sending a request using the GetSlotTypeRequest method.
//    req := client.GetSlotTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotType
func (c *LexModelBuildingService) GetSlotTypeRequest(input *GetSlotTypeInput) GetSlotTypeRequest {
	op := &aws.Operation{
		Name:       opGetSlotType,
		HTTPMethod: "GET",
		HTTPPath:   "/slottypes/{name}/versions/{version}",
	}

	if input == nil {
		input = &GetSlotTypeInput{}
	}

	output := &GetSlotTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSlotTypeRequest{Request: req, Input: input, Copy: c.GetSlotTypeRequest}
}

const opGetSlotTypeVersions = "GetSlotTypeVersions"

// GetSlotTypeVersionsRequest is a API request type for the GetSlotTypeVersions API operation.
type GetSlotTypeVersionsRequest struct {
	*aws.Request
	Input *GetSlotTypeVersionsInput
	Copy  func(*GetSlotTypeVersionsInput) GetSlotTypeVersionsRequest
}

// Send marshals and sends the GetSlotTypeVersions API request.
func (r GetSlotTypeVersionsRequest) Send() (*GetSlotTypeVersionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSlotTypeVersionsOutput), nil
}

// GetSlotTypeVersionsRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Gets information about all versions of a slot type.
//
// The GetSlotTypeVersions operation returns a SlotTypeMetadata object for each
// version of a slot type. For example, if a slot type has three numbered versions,
// the GetSlotTypeVersions operation returns four SlotTypeMetadata objects in
// the response, one for each numbered version and one for the $LATEST version.
//
// The GetSlotTypeVersions operation always returns at least one version, the
// $LATEST version.
//
// This operation requires permissions for the lex:GetSlotTypeVersions action.
//
//    // Example sending a request using the GetSlotTypeVersionsRequest method.
//    req := client.GetSlotTypeVersionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotTypeVersions
func (c *LexModelBuildingService) GetSlotTypeVersionsRequest(input *GetSlotTypeVersionsInput) GetSlotTypeVersionsRequest {
	op := &aws.Operation{
		Name:       opGetSlotTypeVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/slottypes/{name}/versions/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetSlotTypeVersionsInput{}
	}

	output := &GetSlotTypeVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSlotTypeVersionsRequest{Request: req, Input: input, Copy: c.GetSlotTypeVersionsRequest}
}

// Paginate pages iterates over the pages of a GetSlotTypeVersionsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetSlotTypeVersions operation.
//		req := client.GetSlotTypeVersionsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetSlotTypeVersionsRequest) Paginate(opts ...aws.Option) GetSlotTypeVersionsPager {
	return GetSlotTypeVersionsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetSlotTypeVersionsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetSlotTypeVersionsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetSlotTypeVersionsPager struct {
	aws.Pager
}

func (p *GetSlotTypeVersionsPager) CurrentPage() *GetSlotTypeVersionsOutput {
	return p.Pager.CurrentPage().(*GetSlotTypeVersionsOutput)
}

const opGetSlotTypes = "GetSlotTypes"

// GetSlotTypesRequest is a API request type for the GetSlotTypes API operation.
type GetSlotTypesRequest struct {
	*aws.Request
	Input *GetSlotTypesInput
	Copy  func(*GetSlotTypesInput) GetSlotTypesRequest
}

// Send marshals and sends the GetSlotTypes API request.
func (r GetSlotTypesRequest) Send() (*GetSlotTypesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSlotTypesOutput), nil
}

// GetSlotTypesRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Returns slot type information as follows:
//
//    * If you specify the nameContains field, returns the $LATEST version of
//    all slot types that contain the specified string.
//
//    *  If you don't specify the nameContains field, returns information about
//    the $LATEST version of all slot types.
//
// The operation requires permission for the lex:GetSlotTypes action.
//
//    // Example sending a request using the GetSlotTypesRequest method.
//    req := client.GetSlotTypesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotTypes
func (c *LexModelBuildingService) GetSlotTypesRequest(input *GetSlotTypesInput) GetSlotTypesRequest {
	op := &aws.Operation{
		Name:       opGetSlotTypes,
		HTTPMethod: "GET",
		HTTPPath:   "/slottypes/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetSlotTypesInput{}
	}

	output := &GetSlotTypesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSlotTypesRequest{Request: req, Input: input, Copy: c.GetSlotTypesRequest}
}

// Paginate pages iterates over the pages of a GetSlotTypesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetSlotTypes operation.
//		req := client.GetSlotTypesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetSlotTypesRequest) Paginate(opts ...aws.Option) GetSlotTypesPager {
	return GetSlotTypesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetSlotTypesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetSlotTypesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetSlotTypesPager struct {
	aws.Pager
}

func (p *GetSlotTypesPager) CurrentPage() *GetSlotTypesOutput {
	return p.Pager.CurrentPage().(*GetSlotTypesOutput)
}

const opGetUtterancesView = "GetUtterancesView"

// GetUtterancesViewRequest is a API request type for the GetUtterancesView API operation.
type GetUtterancesViewRequest struct {
	*aws.Request
	Input *GetUtterancesViewInput
	Copy  func(*GetUtterancesViewInput) GetUtterancesViewRequest
}

// Send marshals and sends the GetUtterancesView API request.
func (r GetUtterancesViewRequest) Send() (*GetUtterancesViewOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetUtterancesViewOutput), nil
}

// GetUtterancesViewRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Use the GetUtterancesView operation to get information about the utterances
// that your users have made to your bot. You can use this list to tune the
// utterances that your bot responds to.
//
// For example, say that you have created a bot to order flowers. After your
// users have used your bot for a while, use the GetUtterancesView operation
// to see the requests that they have made and whether they have been successful.
// You might find that the utterance "I want flowers" is not being recognized.
// You could add this utterance to the OrderFlowers intent so that your bot
// recognizes that utterance.
//
// After you publish a new version of a bot, you can get information about the
// old version and the new so that you can compare the performance across the
// two versions.
//
// Utterance statistics are generated once a day. Data is available for the
// last 15 days. You can request information for up to 5 versions in each request.
// The response contains information about a maximum of 100 utterances for each
// version.
//
// This operation requires permissions for the lex:GetUtterancesView action.
//
//    // Example sending a request using the GetUtterancesViewRequest method.
//    req := client.GetUtterancesViewRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetUtterancesView
func (c *LexModelBuildingService) GetUtterancesViewRequest(input *GetUtterancesViewInput) GetUtterancesViewRequest {
	op := &aws.Operation{
		Name:       opGetUtterancesView,
		HTTPMethod: "GET",
		HTTPPath:   "/bots/{botname}/utterances?view=aggregation",
	}

	if input == nil {
		input = &GetUtterancesViewInput{}
	}

	output := &GetUtterancesViewOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetUtterancesViewRequest{Request: req, Input: input, Copy: c.GetUtterancesViewRequest}
}

const opPutBot = "PutBot"

// PutBotRequest is a API request type for the PutBot API operation.
type PutBotRequest struct {
	*aws.Request
	Input *PutBotInput
	Copy  func(*PutBotInput) PutBotRequest
}

// Send marshals and sends the PutBot API request.
func (r PutBotRequest) Send() (*PutBotOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutBotOutput), nil
}

// PutBotRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Creates an Amazon Lex conversational bot or replaces an existing bot. When
// you create or update a bot you are only required to specify a name, a locale,
// and whether the bot is directed toward children under age 13. You can use
// this to add intents later, or to remove intents from an existing bot. When
// you create a bot with the minimum information, the bot is created or updated
// but Amazon Lex returns the response FAILED. You can build the bot after you add one or more intents. For more information
// about Amazon Lex bots, see how-it-works.
//
// If you specify the name of an existing bot, the fields in the request replace
// the existing values in the $LATESTversion of the bot. Amazon Lex removes any fields that you don't provide
// values for in the request, except for the idleTTLInSecondsand privacySettingsfields, which are set to their default values. If you don't specify values
// for required fields, Amazon Lex throws an exception.
//
// This operation requires permissions for the lex:PutBotaction. For more information, see auth-and-access-control
//
//    // Example sending a request using the PutBotRequest method.
//    req := client.PutBotRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutBot
func (c *LexModelBuildingService) PutBotRequest(input *PutBotInput) PutBotRequest {
	op := &aws.Operation{
		Name:       opPutBot,
		HTTPMethod: "PUT",
		HTTPPath:   "/bots/{name}/versions/$LATEST",
	}

	if input == nil {
		input = &PutBotInput{}
	}

	output := &PutBotOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutBotRequest{Request: req, Input: input, Copy: c.PutBotRequest}
}

const opPutBotAlias = "PutBotAlias"

// PutBotAliasRequest is a API request type for the PutBotAlias API operation.
type PutBotAliasRequest struct {
	*aws.Request
	Input *PutBotAliasInput
	Copy  func(*PutBotAliasInput) PutBotAliasRequest
}

// Send marshals and sends the PutBotAlias API request.
func (r PutBotAliasRequest) Send() (*PutBotAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutBotAliasOutput), nil
}

// PutBotAliasRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Creates an alias for the specified version of the bot or replaces an alias
// for the specified bot. To change the version of the bot that the alias points
// to, replace the alias. For more information about aliases, see versioning-aliases.
//
// This operation requires permissions for the lex:PutBotAlias action.
//
//    // Example sending a request using the PutBotAliasRequest method.
//    req := client.PutBotAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutBotAlias
func (c *LexModelBuildingService) PutBotAliasRequest(input *PutBotAliasInput) PutBotAliasRequest {
	op := &aws.Operation{
		Name:       opPutBotAlias,
		HTTPMethod: "PUT",
		HTTPPath:   "/bots/{botName}/aliases/{name}",
	}

	if input == nil {
		input = &PutBotAliasInput{}
	}

	output := &PutBotAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutBotAliasRequest{Request: req, Input: input, Copy: c.PutBotAliasRequest}
}

const opPutIntent = "PutIntent"

// PutIntentRequest is a API request type for the PutIntent API operation.
type PutIntentRequest struct {
	*aws.Request
	Input *PutIntentInput
	Copy  func(*PutIntentInput) PutIntentRequest
}

// Send marshals and sends the PutIntent API request.
func (r PutIntentRequest) Send() (*PutIntentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutIntentOutput), nil
}

// PutIntentRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Creates an intent or replaces an existing intent.
//
// To define the interaction between the user and your bot, you use one or more
// intents. For a pizza ordering bot, for example, you would create an OrderPizza
// intent.
//
// To create an intent or replace an existing intent, you must provide the following:
//
//    * Intent name. For example, OrderPizza.
//
//    * Sample utterances. For example, "Can I order a pizza, please." and "I
//    want to order a pizza."
//
//    * Information to be gathered. You specify slot types for the information
//    that your bot will request from the user. You can specify standard slot
//    types, such as a date or a time, or custom slot types such as the size
//    and crust of a pizza.
//
//    * How the intent will be fulfilled. You can provide a Lambda function
//    or configure the intent to return the intent information to the client
//    application. If you use a Lambda function, when all of the intent information
//    is available, Amazon Lex invokes your Lambda function. If you configure
//    your intent to return the intent information to the client application.
//
//
// You can specify other optional information in the request, such as:
//
//    * A confirmation prompt to ask the user to confirm an intent. For example,
//    "Shall I order your pizza?"
//
//    * A conclusion statement to send to the user after the intent has been
//    fulfilled. For example, "I placed your pizza order."
//
//    * A follow-up prompt that asks the user for additional activity. For example,
//    asking "Do you want to order a drink with your pizza?"
//
// If you specify an existing intent name to update the intent, Amazon Lex replaces
// the values in the $LATEST version of the intent with the values in the request.
// Amazon Lex removes fields that you don't provide in the request. If you don't
// specify the required fields, Amazon Lex throws an exception. When you update
// the $LATEST version of an intent, the status field of any bot that uses the
// $LATEST version of the intent is set to NOT_BUILT.
//
// For more information, see how-it-works.
//
// This operation requires permissions for the lex:PutIntent action.
//
//    // Example sending a request using the PutIntentRequest method.
//    req := client.PutIntentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutIntent
func (c *LexModelBuildingService) PutIntentRequest(input *PutIntentInput) PutIntentRequest {
	op := &aws.Operation{
		Name:       opPutIntent,
		HTTPMethod: "PUT",
		HTTPPath:   "/intents/{name}/versions/$LATEST",
	}

	if input == nil {
		input = &PutIntentInput{}
	}

	output := &PutIntentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutIntentRequest{Request: req, Input: input, Copy: c.PutIntentRequest}
}

const opPutSlotType = "PutSlotType"

// PutSlotTypeRequest is a API request type for the PutSlotType API operation.
type PutSlotTypeRequest struct {
	*aws.Request
	Input *PutSlotTypeInput
	Copy  func(*PutSlotTypeInput) PutSlotTypeRequest
}

// Send marshals and sends the PutSlotType API request.
func (r PutSlotTypeRequest) Send() (*PutSlotTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutSlotTypeOutput), nil
}

// PutSlotTypeRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Creates a custom slot type or replaces an existing custom slot type.
//
// To create a custom slot type, specify a name for the slot type and a set
// of enumeration values, which are the values that a slot of this type can
// assume. For more information, see how-it-works.
//
// If you specify the name of an existing slot type, the fields in the request
// replace the existing values in the $LATEST version of the slot type. Amazon
// Lex removes the fields that you don't provide in the request. If you don't
// specify required fields, Amazon Lex throws an exception. When you update
// the $LATEST version of a slot type, if a bot uses the $LATEST version of
// an intent that contains the slot type, the bot's status field is set to NOT_BUILT.
//
// This operation requires permissions for the lex:PutSlotType action.
//
//    // Example sending a request using the PutSlotTypeRequest method.
//    req := client.PutSlotTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutSlotType
func (c *LexModelBuildingService) PutSlotTypeRequest(input *PutSlotTypeInput) PutSlotTypeRequest {
	op := &aws.Operation{
		Name:       opPutSlotType,
		HTTPMethod: "PUT",
		HTTPPath:   "/slottypes/{name}/versions/$LATEST",
	}

	if input == nil {
		input = &PutSlotTypeInput{}
	}

	output := &PutSlotTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutSlotTypeRequest{Request: req, Input: input, Copy: c.PutSlotTypeRequest}
}

const opStartImport = "StartImport"

// StartImportRequest is a API request type for the StartImport API operation.
type StartImportRequest struct {
	*aws.Request
	Input *StartImportInput
	Copy  func(*StartImportInput) StartImportRequest
}

// Send marshals and sends the StartImport API request.
func (r StartImportRequest) Send() (*StartImportOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartImportOutput), nil
}

// StartImportRequest returns a request value for making API operation for
// Amazon Lex Model Building Service.
//
// Starts a job to import a resource to Amazon Lex.
//
//    // Example sending a request using the StartImportRequest method.
//    req := client.StartImportRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/StartImport
func (c *LexModelBuildingService) StartImportRequest(input *StartImportInput) StartImportRequest {
	op := &aws.Operation{
		Name:       opStartImport,
		HTTPMethod: "POST",
		HTTPPath:   "/imports/",
	}

	if input == nil {
		input = &StartImportInput{}
	}

	output := &StartImportOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartImportRequest{Request: req, Input: input, Copy: c.StartImportRequest}
}

// Provides information about a bot alias.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/BotAliasMetadata
type BotAliasMetadata struct {
	_ struct{} `type:"structure"`

	// The name of the bot to which the alias points.
	BotName *string `locationName:"botName" min:"2" type:"string"`

	// The version of the Amazon Lex bot to which the alias points.
	BotVersion *string `locationName:"botVersion" min:"1" type:"string"`

	// Checksum of the bot alias.
	Checksum *string `locationName:"checksum" type:"string"`

	// The date that the bot alias was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the bot alias.
	Description *string `locationName:"description" type:"string"`

	// The date that the bot alias was updated. When you create a resource, the
	// creation date and last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the bot alias.
	Name *string `locationName:"name" min:"1" type:"string"`
}

// String returns the string representation
func (s BotAliasMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BotAliasMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BotAliasMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BotVersion != nil {
		v := *s.BotVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents an association between an Amazon Lex bot and an external messaging
// platform.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/BotChannelAssociation
type BotChannelAssociation struct {
	_ struct{} `type:"structure"`

	// An alias pointing to the specific version of the Amazon Lex bot to which
	// this association is being made.
	BotAlias *string `locationName:"botAlias" min:"1" type:"string"`

	// Provides information necessary to communicate with the messaging platform.
	BotConfiguration map[string]string `locationName:"botConfiguration" min:"1" type:"map"`

	// The name of the Amazon Lex bot to which this association is being made.
	//
	// Currently, Amazon Lex supports associations with Facebook and Slack, and
	// Twilio.
	BotName *string `locationName:"botName" min:"2" type:"string"`

	// The date that the association between the Amazon Lex bot and the channel
	// was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A text description of the association you are creating.
	Description *string `locationName:"description" type:"string"`

	// If status is FAILED, Amazon Lex provides the reason that it failed to create
	// the association.
	FailureReason *string `locationName:"failureReason" type:"string"`

	// The name of the association between the bot and the channel.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The status of the bot channel.
	//
	//    * CREATED - The channel has been created and is ready for use.
	//
	//    * IN_PROGRESS - Channel creation is in progress.
	//
	//    * FAILED - There was an error creating the channel. For information about
	//    the reason for the failure, see the failureReason field.
	Status ChannelStatus `locationName:"status" type:"string" enum:"true"`

	// Specifies the type of association by indicating the type of channel being
	// established between the Amazon Lex bot and the external messaging platform.
	Type ChannelType `locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s BotChannelAssociation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BotChannelAssociation) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BotChannelAssociation) MarshalFields(e protocol.FieldEncoder) error {
	if s.BotAlias != nil {
		v := *s.BotAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.BotConfiguration) > 0 {
		v := s.BotConfiguration

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "botConfiguration", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FailureReason != nil {
		v := *s.FailureReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "failureReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Provides information about a bot. .
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/BotMetadata
type BotMetadata struct {
	_ struct{} `type:"structure"`

	// The date that the bot was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the bot.
	Description *string `locationName:"description" type:"string"`

	// The date that the bot was updated. When you create a bot, the creation date
	// and last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the bot.
	Name *string `locationName:"name" min:"2" type:"string"`

	// The status of the bot.
	Status Status `locationName:"status" type:"string" enum:"true"`

	// The version of the bot. For a new bot, the version is always $LATEST.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s BotMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BotMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BotMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides metadata for a built-in intent.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/BuiltinIntentMetadata
type BuiltinIntentMetadata struct {
	_ struct{} `type:"structure"`

	// A unique identifier for the built-in intent. To find the signature for an
	// intent, see Standard Built-in Intents (https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/standard-intents)
	// in the Alexa Skills Kit.
	Signature *string `locationName:"signature" type:"string"`

	// A list of identifiers for the locales that the intent supports.
	SupportedLocales []Locale `locationName:"supportedLocales" type:"list"`
}

// String returns the string representation
func (s BuiltinIntentMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BuiltinIntentMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BuiltinIntentMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.Signature != nil {
		v := *s.Signature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "signature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SupportedLocales) > 0 {
		v := s.SupportedLocales

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "supportedLocales", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Provides information about a slot used in a built-in intent.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/BuiltinIntentSlot
type BuiltinIntentSlot struct {
	_ struct{} `type:"structure"`

	// A list of the slots defined for the intent.
	Name *string `locationName:"name" type:"string"`
}

// String returns the string representation
func (s BuiltinIntentSlot) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BuiltinIntentSlot) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BuiltinIntentSlot) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides information about a built in slot type.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/BuiltinSlotTypeMetadata
type BuiltinSlotTypeMetadata struct {
	_ struct{} `type:"structure"`

	// A unique identifier for the built-in slot type. To find the signature for
	// a slot type, see Slot Type Reference (https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/slot-type-reference)
	// in the Alexa Skills Kit.
	Signature *string `locationName:"signature" type:"string"`

	// A list of target locales for the slot.
	SupportedLocales []Locale `locationName:"supportedLocales" type:"list"`
}

// String returns the string representation
func (s BuiltinSlotTypeMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BuiltinSlotTypeMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BuiltinSlotTypeMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.Signature != nil {
		v := *s.Signature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "signature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SupportedLocales) > 0 {
		v := s.SupportedLocales

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "supportedLocales", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Specifies a Lambda function that verifies requests to a bot or fulfills the
// user's request to a bot..
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CodeHook
type CodeHook struct {
	_ struct{} `type:"structure"`

	// The version of the request-response that you want Amazon Lex to use to invoke
	// your Lambda function. For more information, see using-lambda.
	//
	// MessageVersion is a required field
	MessageVersion *string `locationName:"messageVersion" min:"1" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) of the Lambda function.
	//
	// Uri is a required field
	Uri *string `locationName:"uri" min:"20" type:"string" required:"true"`
}

// String returns the string representation
func (s CodeHook) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CodeHook) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CodeHook) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CodeHook"}

	if s.MessageVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("MessageVersion"))
	}
	if s.MessageVersion != nil && len(*s.MessageVersion) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MessageVersion", 1))
	}

	if s.Uri == nil {
		invalidParams.Add(aws.NewErrParamRequired("Uri"))
	}
	if s.Uri != nil && len(*s.Uri) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("Uri", 20))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CodeHook) MarshalFields(e protocol.FieldEncoder) error {
	if s.MessageVersion != nil {
		v := *s.MessageVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "messageVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Uri != nil {
		v := *s.Uri

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "uri", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateBotVersionRequest
type CreateBotVersionInput struct {
	_ struct{} `type:"structure"`

	// Identifies a specific revision of the $LATEST version of the bot. If you
	// specify a checksum and the $LATEST version of the bot has a different checksum,
	// a PreconditionFailedException exception is returned and Amazon Lex doesn't
	// publish a new version. If you don't specify a checksum, Amazon Lex publishes
	// the $LATEST version.
	Checksum *string `locationName:"checksum" type:"string"`

	// The name of the bot that you want to create a new version of. The name is
	// case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"2" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateBotVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBotVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBotVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateBotVersionInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 2))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBotVersionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateBotVersionResponse
type CreateBotVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The message that Amazon Lex uses to abort a conversation. For more information,
	// see PutBot.
	AbortStatement *Statement `locationName:"abortStatement" type:"structure"`

	// Checksum identifying the version of the bot that was created.
	Checksum *string `locationName:"checksum" type:"string"`

	// For each Amazon Lex bot created with the Amazon Lex Model Building Service,
	// you must specify whether your use of Amazon Lex is related to a website,
	// program, or other application that is directed or targeted, in whole or in
	// part, to children under age 13 and subject to the Children's Online Privacy
	// Protection Act (COPPA) by specifying true or false in the childDirected field.
	// By specifying true in the childDirected field, you confirm that your use
	// of Amazon Lex is related to a website, program, or other application that
	// is directed or targeted, in whole or in part, to children under age 13 and
	// subject to COPPA. By specifying false in the childDirected field, you confirm
	// that your use of Amazon Lex is not related to a website, program, or other
	// application that is directed or targeted, in whole or in part, to children
	// under age 13 and subject to COPPA. You may not specify a default value for
	// the childDirected field that does not accurately reflect whether your use
	// of Amazon Lex is related to a website, program, or other application that
	// is directed or targeted, in whole or in part, to children under age 13 and
	// subject to COPPA.
	//
	// If your use of Amazon Lex relates to a website, program, or other application
	// that is directed in whole or in part, to children under age 13, you must
	// obtain any required verifiable parental consent under COPPA. For information
	// regarding the use of Amazon Lex in connection with websites, programs, or
	// other applications that are directed or targeted, in whole or in part, to
	// children under age 13, see the Amazon Lex FAQ. (https://aws.amazon.com/lex/faqs#data-security)
	ChildDirected *bool `locationName:"childDirected" type:"boolean"`

	// The message that Amazon Lex uses when it doesn't understand the user's request.
	// For more information, see PutBot.
	ClarificationPrompt *Prompt `locationName:"clarificationPrompt" type:"structure"`

	// The date when the bot version was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the bot.
	Description *string `locationName:"description" type:"string"`

	// If status is FAILED, Amazon Lex provides the reason that it failed to build
	// the bot.
	FailureReason *string `locationName:"failureReason" type:"string"`

	// The maximum time in seconds that Amazon Lex retains the data gathered in
	// a conversation. For more information, see PutBot.
	IdleSessionTTLInSeconds *int64 `locationName:"idleSessionTTLInSeconds" min:"60" type:"integer"`

	// An array of Intent objects. For more information, see PutBot.
	Intents []Intent `locationName:"intents" type:"list"`

	// The date when the $LATEST version of this bot was updated.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// Specifies the target locale for the bot.
	Locale Locale `locationName:"locale" type:"string" enum:"true"`

	// The name of the bot.
	Name *string `locationName:"name" min:"2" type:"string"`

	// When you send a request to create or update a bot, Amazon Lex sets the status
	// response element to BUILDING. After Amazon Lex builds the bot, it sets status
	// to READY. If Amazon Lex can't build the bot, it sets status to FAILED. Amazon
	// Lex returns the reason for the failure in the failureReason response element.
	Status Status `locationName:"status" type:"string" enum:"true"`

	// The version of the bot.
	Version *string `locationName:"version" min:"1" type:"string"`

	// The Amazon Polly voice ID that Amazon Lex uses for voice interactions with
	// the user.
	VoiceId *string `locationName:"voiceId" type:"string"`
}

// String returns the string representation
func (s CreateBotVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBotVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateBotVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBotVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AbortStatement != nil {
		v := s.AbortStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "abortStatement", v, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChildDirected != nil {
		v := *s.ChildDirected

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "childDirected", protocol.BoolValue(v), metadata)
	}
	if s.ClarificationPrompt != nil {
		v := s.ClarificationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "clarificationPrompt", v, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FailureReason != nil {
		v := *s.FailureReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "failureReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdleSessionTTLInSeconds != nil {
		v := *s.IdleSessionTTLInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "idleSessionTTLInSeconds", protocol.Int64Value(v), metadata)
	}
	if len(s.Intents) > 0 {
		v := s.Intents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "intents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Locale) > 0 {
		v := s.Locale

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "locale", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VoiceId != nil {
		v := *s.VoiceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "voiceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateIntentVersionRequest
type CreateIntentVersionInput struct {
	_ struct{} `type:"structure"`

	// Checksum of the $LATEST version of the intent that should be used to create
	// the new version. If you specify a checksum and the $LATEST version of the
	// intent has a different checksum, Amazon Lex returns a PreconditionFailedException
	// exception and doesn't publish a new version. If you don't specify a checksum,
	// Amazon Lex publishes the $LATEST version.
	Checksum *string `locationName:"checksum" type:"string"`

	// The name of the intent that you want to create a new version of. The name
	// is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateIntentVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateIntentVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateIntentVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateIntentVersionInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateIntentVersionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateIntentVersionResponse
type CreateIntentVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Checksum of the intent version created.
	Checksum *string `locationName:"checksum" type:"string"`

	// After the Lambda function specified in the fulfillmentActivity field fulfills
	// the intent, Amazon Lex conveys this statement to the user.
	ConclusionStatement *Statement `locationName:"conclusionStatement" type:"structure"`

	// If defined, the prompt that Amazon Lex uses to confirm the user's intent
	// before fulfilling it.
	ConfirmationPrompt *Prompt `locationName:"confirmationPrompt" type:"structure"`

	// The date that the intent was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the intent.
	Description *string `locationName:"description" type:"string"`

	// If defined, Amazon Lex invokes this Lambda function for each user input.
	DialogCodeHook *CodeHook `locationName:"dialogCodeHook" type:"structure"`

	// If defined, Amazon Lex uses this prompt to solicit additional user activity
	// after the intent is fulfilled.
	FollowUpPrompt *FollowUpPrompt `locationName:"followUpPrompt" type:"structure"`

	// Describes how the intent is fulfilled.
	FulfillmentActivity *FulfillmentActivity `locationName:"fulfillmentActivity" type:"structure"`

	// The date that the intent was updated.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the intent.
	Name *string `locationName:"name" min:"1" type:"string"`

	// A unique identifier for a built-in intent.
	ParentIntentSignature *string `locationName:"parentIntentSignature" type:"string"`

	// If the user answers "no" to the question defined in confirmationPrompt, Amazon
	// Lex responds with this statement to acknowledge that the intent was canceled.
	RejectionStatement *Statement `locationName:"rejectionStatement" type:"structure"`

	// An array of sample utterances configured for the intent.
	SampleUtterances []string `locationName:"sampleUtterances" type:"list"`

	// An array of slot types that defines the information required to fulfill the
	// intent.
	Slots []Slot `locationName:"slots" type:"list"`

	// The version number assigned to the new version of the intent.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateIntentVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateIntentVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateIntentVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateIntentVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConclusionStatement != nil {
		v := s.ConclusionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "conclusionStatement", v, metadata)
	}
	if s.ConfirmationPrompt != nil {
		v := s.ConfirmationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "confirmationPrompt", v, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DialogCodeHook != nil {
		v := s.DialogCodeHook

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dialogCodeHook", v, metadata)
	}
	if s.FollowUpPrompt != nil {
		v := s.FollowUpPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "followUpPrompt", v, metadata)
	}
	if s.FulfillmentActivity != nil {
		v := s.FulfillmentActivity

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "fulfillmentActivity", v, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentIntentSignature != nil {
		v := *s.ParentIntentSignature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "parentIntentSignature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RejectionStatement != nil {
		v := s.RejectionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "rejectionStatement", v, metadata)
	}
	if len(s.SampleUtterances) > 0 {
		v := s.SampleUtterances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "sampleUtterances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Slots) > 0 {
		v := s.Slots

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "slots", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateSlotTypeVersionRequest
type CreateSlotTypeVersionInput struct {
	_ struct{} `type:"structure"`

	// Checksum for the $LATEST version of the slot type that you want to publish.
	// If you specify a checksum and the $LATEST version of the slot type has a
	// different checksum, Amazon Lex returns a PreconditionFailedException exception
	// and doesn't publish the new version. If you don't specify a checksum, Amazon
	// Lex publishes the $LATEST version.
	Checksum *string `locationName:"checksum" type:"string"`

	// The name of the slot type that you want to create a new version for. The
	// name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateSlotTypeVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateSlotTypeVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateSlotTypeVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateSlotTypeVersionInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateSlotTypeVersionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/CreateSlotTypeVersionResponse
type CreateSlotTypeVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Checksum of the $LATEST version of the slot type.
	Checksum *string `locationName:"checksum" type:"string"`

	// The date that the slot type was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the slot type.
	Description *string `locationName:"description" type:"string"`

	// A list of EnumerationValue objects that defines the values that the slot
	// type can take.
	EnumerationValues []EnumerationValue `locationName:"enumerationValues" min:"1" type:"list"`

	// The date that the slot type was updated. When you create a resource, the
	// creation date and last update date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the slot type.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The strategy that Amazon Lex uses to determine the value of the slot. For
	// more information, see PutSlotType.
	ValueSelectionStrategy SlotValueSelectionStrategy `locationName:"valueSelectionStrategy" type:"string" enum:"true"`

	// The version assigned to the new slot type version.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateSlotTypeVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateSlotTypeVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateSlotTypeVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateSlotTypeVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EnumerationValues) > 0 {
		v := s.EnumerationValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "enumerationValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ValueSelectionStrategy) > 0 {
		v := s.ValueSelectionStrategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "valueSelectionStrategy", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotAliasRequest
type DeleteBotAliasInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot that the alias points to.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botName" min:"2" type:"string" required:"true"`

	// The name of the alias to delete. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBotAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBotAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBotAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBotAliasInput"}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBotAliasInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotAliasOutput
type DeleteBotAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBotAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBotAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBotAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBotAliasOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotChannelAssociationRequest
type DeleteBotChannelAssociationInput struct {
	_ struct{} `type:"structure"`

	// An alias that points to the specific version of the Amazon Lex bot to which
	// this association is being made.
	//
	// BotAlias is a required field
	BotAlias *string `location:"uri" locationName:"aliasName" min:"1" type:"string" required:"true"`

	// The name of the Amazon Lex bot.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botName" min:"2" type:"string" required:"true"`

	// The name of the association. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBotChannelAssociationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBotChannelAssociationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBotChannelAssociationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBotChannelAssociationInput"}

	if s.BotAlias == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotAlias"))
	}
	if s.BotAlias != nil && len(*s.BotAlias) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BotAlias", 1))
	}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBotChannelAssociationInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotAlias != nil {
		v := *s.BotAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "aliasName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotChannelAssociationOutput
type DeleteBotChannelAssociationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBotChannelAssociationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBotChannelAssociationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBotChannelAssociationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBotChannelAssociationOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotRequest
type DeleteBotInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"2" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBotInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBotInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBotInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBotInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 2))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBotInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotOutput
type DeleteBotOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBotOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBotOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBotOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBotOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotVersionRequest
type DeleteBotVersionInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"2" type:"string" required:"true"`

	// The version of the bot to delete. You cannot delete the $LATEST version of
	// the bot. To delete the $LATEST version, use the DeleteBot operation.
	//
	// Version is a required field
	Version *string `location:"uri" locationName:"version" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBotVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBotVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBotVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBotVersionInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 2))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBotVersionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteBotVersionOutput
type DeleteBotVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBotVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBotVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBotVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBotVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteIntentRequest
type DeleteIntentInput struct {
	_ struct{} `type:"structure"`

	// The name of the intent. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteIntentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteIntentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteIntentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteIntentInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteIntentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteIntentOutput
type DeleteIntentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteIntentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteIntentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteIntentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteIntentOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteIntentVersionRequest
type DeleteIntentVersionInput struct {
	_ struct{} `type:"structure"`

	// The name of the intent.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`

	// The version of the intent to delete. You cannot delete the $LATEST version
	// of the intent. To delete the $LATEST version, use the DeleteIntent operation.
	//
	// Version is a required field
	Version *string `location:"uri" locationName:"version" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteIntentVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteIntentVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteIntentVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteIntentVersionInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteIntentVersionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteIntentVersionOutput
type DeleteIntentVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteIntentVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteIntentVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteIntentVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteIntentVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteSlotTypeRequest
type DeleteSlotTypeInput struct {
	_ struct{} `type:"structure"`

	// The name of the slot type. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteSlotTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSlotTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteSlotTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteSlotTypeInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteSlotTypeInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteSlotTypeOutput
type DeleteSlotTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteSlotTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSlotTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteSlotTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteSlotTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteSlotTypeVersionRequest
type DeleteSlotTypeVersionInput struct {
	_ struct{} `type:"structure"`

	// The name of the slot type.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`

	// The version of the slot type to delete. You cannot delete the $LATEST version
	// of the slot type. To delete the $LATEST version, use the DeleteSlotType operation.
	//
	// Version is a required field
	Version *string `location:"uri" locationName:"version" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteSlotTypeVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSlotTypeVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteSlotTypeVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteSlotTypeVersionInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteSlotTypeVersionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteSlotTypeVersionOutput
type DeleteSlotTypeVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteSlotTypeVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSlotTypeVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteSlotTypeVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteSlotTypeVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteUtterancesRequest
type DeleteUtterancesInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot that stored the utterances.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botName" min:"2" type:"string" required:"true"`

	// The unique identifier for the user that made the utterances. This is the
	// user ID that was sent in the PostContent (http://docs.aws.amazon.com/lex/latest/dg/API_runtime_PostContent.html)
	// or PostText (http://docs.aws.amazon.com/lex/latest/dg/API_runtime_PostText.html)
	// operation request that contained the utterance.
	//
	// UserId is a required field
	UserId *string `location:"uri" locationName:"userId" min:"2" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteUtterancesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUtterancesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteUtterancesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteUtterancesInput"}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}

	if s.UserId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UserId"))
	}
	if s.UserId != nil && len(*s.UserId) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("UserId", 2))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUtterancesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserId != nil {
		v := *s.UserId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "userId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/DeleteUtterancesOutput
type DeleteUtterancesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteUtterancesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUtterancesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteUtterancesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUtterancesOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Each slot type can have a set of values. Each enumeration value represents
// a value the slot type can take.
//
// For example, a pizza ordering bot could have a slot type that specifies the
// type of crust that the pizza should have. The slot type could include the
// values
//
//    * thick
//
//    * thin
//
//    * stuffed
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/EnumerationValue
type EnumerationValue struct {
	_ struct{} `type:"structure"`

	// Additional values related to the slot type value.
	Synonyms []string `locationName:"synonyms" type:"list"`

	// The value of the slot type.
	//
	// Value is a required field
	Value *string `locationName:"value" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s EnumerationValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EnumerationValue) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *EnumerationValue) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "EnumerationValue"}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}
	if s.Value != nil && len(*s.Value) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Value", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EnumerationValue) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Synonyms) > 0 {
		v := s.Synonyms

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "synonyms", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A prompt for additional activity after an intent is fulfilled. For example,
// after the OrderPizza intent is fulfilled, you might prompt the user to find
// out whether the user wants to order drinks.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/FollowUpPrompt
type FollowUpPrompt struct {
	_ struct{} `type:"structure"`

	// Prompts for information from the user.
	//
	// Prompt is a required field
	Prompt *Prompt `locationName:"prompt" type:"structure" required:"true"`

	// If the user answers "no" to the question defined in the prompt field, Amazon
	// Lex responds with this statement to acknowledge that the intent was canceled.
	//
	// RejectionStatement is a required field
	RejectionStatement *Statement `locationName:"rejectionStatement" type:"structure" required:"true"`
}

// String returns the string representation
func (s FollowUpPrompt) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FollowUpPrompt) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FollowUpPrompt) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FollowUpPrompt"}

	if s.Prompt == nil {
		invalidParams.Add(aws.NewErrParamRequired("Prompt"))
	}

	if s.RejectionStatement == nil {
		invalidParams.Add(aws.NewErrParamRequired("RejectionStatement"))
	}
	if s.Prompt != nil {
		if err := s.Prompt.Validate(); err != nil {
			invalidParams.AddNested("Prompt", err.(aws.ErrInvalidParams))
		}
	}
	if s.RejectionStatement != nil {
		if err := s.RejectionStatement.Validate(); err != nil {
			invalidParams.AddNested("RejectionStatement", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FollowUpPrompt) MarshalFields(e protocol.FieldEncoder) error {
	if s.Prompt != nil {
		v := s.Prompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "prompt", v, metadata)
	}
	if s.RejectionStatement != nil {
		v := s.RejectionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "rejectionStatement", v, metadata)
	}
	return nil
}

// Describes how the intent is fulfilled after the user provides all of the
// information required for the intent. You can provide a Lambda function to
// process the intent, or you can return the intent information to the client
// application. We recommend that you use a Lambda function so that the relevant
// logic lives in the Cloud and limit the client-side code primarily to presentation.
// If you need to update the logic, you only update the Lambda function; you
// don't need to upgrade your client application.
//
// Consider the following examples:
//
//    * In a pizza ordering application, after the user provides all of the
//    information for placing an order, you use a Lambda function to place an
//    order with a pizzeria.
//
//    * In a gaming application, when a user says "pick up a rock," this information
//    must go back to the client application so that it can perform the operation
//    and update the graphics. In this case, you want Amazon Lex to return the
//    intent data to the client.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/FulfillmentActivity
type FulfillmentActivity struct {
	_ struct{} `type:"structure"`

	// A description of the Lambda function that is run to fulfill the intent.
	CodeHook *CodeHook `locationName:"codeHook" type:"structure"`

	// How the intent should be fulfilled, either by running a Lambda function or
	// by returning the slot data to the client application.
	//
	// Type is a required field
	Type FulfillmentActivityType `locationName:"type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s FulfillmentActivity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FulfillmentActivity) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FulfillmentActivity) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FulfillmentActivity"}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}
	if s.CodeHook != nil {
		if err := s.CodeHook.Validate(); err != nil {
			invalidParams.AddNested("CodeHook", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FulfillmentActivity) MarshalFields(e protocol.FieldEncoder) error {
	if s.CodeHook != nil {
		v := s.CodeHook

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "codeHook", v, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotAliasRequest
type GetBotAliasInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botName" min:"2" type:"string" required:"true"`

	// The name of the bot alias. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBotAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBotAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBotAliasInput"}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotAliasInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotAliasResponse
type GetBotAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The name of the bot that the alias points to.
	BotName *string `locationName:"botName" min:"2" type:"string"`

	// The version of the bot that the alias points to.
	BotVersion *string `locationName:"botVersion" min:"1" type:"string"`

	// Checksum of the bot alias.
	Checksum *string `locationName:"checksum" type:"string"`

	// The date that the bot alias was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the bot alias.
	Description *string `locationName:"description" type:"string"`

	// The date that the bot alias was updated. When you create a resource, the
	// creation date and the last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the bot alias.
	Name *string `locationName:"name" min:"1" type:"string"`
}

// String returns the string representation
func (s GetBotAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBotAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotAliasOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BotVersion != nil {
		v := *s.BotVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotAliasesRequest
type GetBotAliasesInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botName" min:"2" type:"string" required:"true"`

	// The maximum number of aliases to return in the response. The default is 50.
	// .
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// Substring to match in bot alias names. An alias will be returned if any part
	// of its name matches the substring. For example, "xyz" matches both "xyzabc"
	// and "abcxyz."
	NameContains *string `location:"querystring" locationName:"nameContains" min:"1" type:"string"`

	// A pagination token for fetching the next page of aliases. If the response
	// to this call is truncated, Amazon Lex returns a pagination token in the response.
	// To fetch the next page of aliases, specify the pagination token in the next
	// request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBotAliasesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotAliasesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBotAliasesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBotAliasesInput"}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.NameContains != nil && len(*s.NameContains) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NameContains", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotAliasesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NameContains != nil {
		v := *s.NameContains

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nameContains", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotAliasesResponse
type GetBotAliasesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of BotAliasMetadata objects, each describing a bot alias.
	BotAliases []BotAliasMetadata `type:"list"`

	// A pagination token for fetching next page of aliases. If the response to
	// this call is truncated, Amazon Lex returns a pagination token in the response.
	// To fetch the next page of aliases, specify the pagination token in the next
	// request.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBotAliasesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotAliasesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBotAliasesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotAliasesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BotAliases) > 0 {
		v := s.BotAliases

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BotAliases", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotChannelAssociationRequest
type GetBotChannelAssociationInput struct {
	_ struct{} `type:"structure"`

	// An alias pointing to the specific version of the Amazon Lex bot to which
	// this association is being made.
	//
	// BotAlias is a required field
	BotAlias *string `location:"uri" locationName:"aliasName" min:"1" type:"string" required:"true"`

	// The name of the Amazon Lex bot.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botName" min:"2" type:"string" required:"true"`

	// The name of the association between the bot and the channel. The name is
	// case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBotChannelAssociationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotChannelAssociationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBotChannelAssociationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBotChannelAssociationInput"}

	if s.BotAlias == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotAlias"))
	}
	if s.BotAlias != nil && len(*s.BotAlias) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BotAlias", 1))
	}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotChannelAssociationInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotAlias != nil {
		v := *s.BotAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "aliasName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotChannelAssociationResponse
type GetBotChannelAssociationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An alias pointing to the specific version of the Amazon Lex bot to which
	// this association is being made.
	BotAlias *string `locationName:"botAlias" min:"1" type:"string"`

	// Provides information that the messaging platform needs to communicate with
	// the Amazon Lex bot.
	BotConfiguration map[string]string `locationName:"botConfiguration" min:"1" type:"map"`

	// The name of the Amazon Lex bot.
	BotName *string `locationName:"botName" min:"2" type:"string"`

	// The date that the association between the bot and the channel was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the association between the bot and the channel.
	Description *string `locationName:"description" type:"string"`

	// If status is FAILED, Amazon Lex provides the reason that it failed to create
	// the association.
	FailureReason *string `locationName:"failureReason" type:"string"`

	// The name of the association between the bot and the channel.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The status of the bot channel.
	//
	//    * CREATED - The channel has been created and is ready for use.
	//
	//    * IN_PROGRESS - Channel creation is in progress.
	//
	//    * FAILED - There was an error creating the channel. For information about
	//    the reason for the failure, see the failureReason field.
	Status ChannelStatus `locationName:"status" type:"string" enum:"true"`

	// The type of the messaging platform.
	Type ChannelType `locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s GetBotChannelAssociationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotChannelAssociationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBotChannelAssociationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotChannelAssociationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BotAlias != nil {
		v := *s.BotAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.BotConfiguration) > 0 {
		v := s.BotConfiguration

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "botConfiguration", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FailureReason != nil {
		v := *s.FailureReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "failureReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotChannelAssociationsRequest
type GetBotChannelAssociationsInput struct {
	_ struct{} `type:"structure"`

	// An alias pointing to the specific version of the Amazon Lex bot to which
	// this association is being made.
	//
	// BotAlias is a required field
	BotAlias *string `location:"uri" locationName:"aliasName" min:"1" type:"string" required:"true"`

	// The name of the Amazon Lex bot in the association.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botName" min:"2" type:"string" required:"true"`

	// The maximum number of associations to return in the response. The default
	// is 50.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// Substring to match in channel association names. An association will be returned
	// if any part of its name matches the substring. For example, "xyz" matches
	// both "xyzabc" and "abcxyz." To return all bot channel associations, use a
	// hyphen ("-") as the nameContains parameter.
	NameContains *string `location:"querystring" locationName:"nameContains" min:"1" type:"string"`

	// A pagination token for fetching the next page of associations. If the response
	// to this call is truncated, Amazon Lex returns a pagination token in the response.
	// To fetch the next page of associations, specify the pagination token in the
	// next request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBotChannelAssociationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotChannelAssociationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBotChannelAssociationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBotChannelAssociationsInput"}

	if s.BotAlias == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotAlias"))
	}
	if s.BotAlias != nil && len(*s.BotAlias) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BotAlias", 1))
	}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.NameContains != nil && len(*s.NameContains) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NameContains", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotChannelAssociationsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotAlias != nil {
		v := *s.BotAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "aliasName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NameContains != nil {
		v := *s.NameContains

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nameContains", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotChannelAssociationsResponse
type GetBotChannelAssociationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of objects, one for each association, that provides information
	// about the Amazon Lex bot and its association with the channel.
	BotChannelAssociations []BotChannelAssociation `locationName:"botChannelAssociations" type:"list"`

	// A pagination token that fetches the next page of associations. If the response
	// to this call is truncated, Amazon Lex returns a pagination token in the response.
	// To fetch the next page of associations, specify the pagination token in the
	// next request.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBotChannelAssociationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotChannelAssociationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBotChannelAssociationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotChannelAssociationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BotChannelAssociations) > 0 {
		v := s.BotChannelAssociations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "botChannelAssociations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotRequest
type GetBotInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"2" type:"string" required:"true"`

	// The version or alias of the bot.
	//
	// VersionOrAlias is a required field
	VersionOrAlias *string `location:"uri" locationName:"versionoralias" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBotInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBotInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBotInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 2))
	}

	if s.VersionOrAlias == nil {
		invalidParams.Add(aws.NewErrParamRequired("VersionOrAlias"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionOrAlias != nil {
		v := *s.VersionOrAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "versionoralias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotResponse
type GetBotOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The message that Amazon Lex returns when the user elects to end the conversation
	// without completing it. For more information, see PutBot.
	AbortStatement *Statement `locationName:"abortStatement" type:"structure"`

	// Checksum of the bot used to identify a specific revision of the bot's $LATEST
	// version.
	Checksum *string `locationName:"checksum" type:"string"`

	// For each Amazon Lex bot created with the Amazon Lex Model Building Service,
	// you must specify whether your use of Amazon Lex is related to a website,
	// program, or other application that is directed or targeted, in whole or in
	// part, to children under age 13 and subject to the Children's Online Privacy
	// Protection Act (COPPA) by specifying true or false in the childDirected field.
	// By specifying true in the childDirected field, you confirm that your use
	// of Amazon Lex is related to a website, program, or other application that
	// is directed or targeted, in whole or in part, to children under age 13 and
	// subject to COPPA. By specifying false in the childDirected field, you confirm
	// that your use of Amazon Lex is not related to a website, program, or other
	// application that is directed or targeted, in whole or in part, to children
	// under age 13 and subject to COPPA. You may not specify a default value for
	// the childDirected field that does not accurately reflect whether your use
	// of Amazon Lex is related to a website, program, or other application that
	// is directed or targeted, in whole or in part, to children under age 13 and
	// subject to COPPA.
	//
	// If your use of Amazon Lex relates to a website, program, or other application
	// that is directed in whole or in part, to children under age 13, you must
	// obtain any required verifiable parental consent under COPPA. For information
	// regarding the use of Amazon Lex in connection with websites, programs, or
	// other applications that are directed or targeted, in whole or in part, to
	// children under age 13, see the Amazon Lex FAQ. (https://aws.amazon.com/lex/faqs#data-security)
	ChildDirected *bool `locationName:"childDirected" type:"boolean"`

	// The message Amazon Lex uses when it doesn't understand the user's request.
	// For more information, see PutBot.
	ClarificationPrompt *Prompt `locationName:"clarificationPrompt" type:"structure"`

	// The date that the bot was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the bot.
	Description *string `locationName:"description" type:"string"`

	// If status is FAILED, Amazon Lex explains why it failed to build the bot.
	FailureReason *string `locationName:"failureReason" type:"string"`

	// The maximum time in seconds that Amazon Lex retains the data gathered in
	// a conversation. For more information, see PutBot.
	IdleSessionTTLInSeconds *int64 `locationName:"idleSessionTTLInSeconds" min:"60" type:"integer"`

	// An array of intent objects. For more information, see PutBot.
	Intents []Intent `locationName:"intents" type:"list"`

	// The date that the bot was updated. When you create a resource, the creation
	// date and last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The target locale for the bot.
	Locale Locale `locationName:"locale" type:"string" enum:"true"`

	// The name of the bot.
	Name *string `locationName:"name" min:"2" type:"string"`

	// The status of the bot. If the bot is ready to run, the status is READY. If
	// there was a problem with building the bot, the status is FAILED and the failureReason
	// explains why the bot did not build. If the bot was saved but not built, the
	// status is NOT BUILT.
	Status Status `locationName:"status" type:"string" enum:"true"`

	// The version of the bot. For a new bot, the version is always $LATEST.
	Version *string `locationName:"version" min:"1" type:"string"`

	// The Amazon Polly voice ID that Amazon Lex uses for voice interaction with
	// the user. For more information, see PutBot.
	VoiceId *string `locationName:"voiceId" type:"string"`
}

// String returns the string representation
func (s GetBotOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBotOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AbortStatement != nil {
		v := s.AbortStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "abortStatement", v, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChildDirected != nil {
		v := *s.ChildDirected

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "childDirected", protocol.BoolValue(v), metadata)
	}
	if s.ClarificationPrompt != nil {
		v := s.ClarificationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "clarificationPrompt", v, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FailureReason != nil {
		v := *s.FailureReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "failureReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdleSessionTTLInSeconds != nil {
		v := *s.IdleSessionTTLInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "idleSessionTTLInSeconds", protocol.Int64Value(v), metadata)
	}
	if len(s.Intents) > 0 {
		v := s.Intents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "intents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Locale) > 0 {
		v := s.Locale

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "locale", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VoiceId != nil {
		v := *s.VoiceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "voiceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotVersionsRequest
type GetBotVersionsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of bot versions to return in the response. The default
	// is 10.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The name of the bot for which versions should be returned.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"2" type:"string" required:"true"`

	// A pagination token for fetching the next page of bot versions. If the response
	// to this call is truncated, Amazon Lex returns a pagination token in the response.
	// To fetch the next page of versions, specify the pagination token in the next
	// request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBotVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBotVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBotVersionsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 2))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotVersionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotVersionsResponse
type GetBotVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of BotMetadata objects, one for each numbered version of the bot
	// plus one for the $LATEST version.
	Bots []BotMetadata `locationName:"bots" type:"list"`

	// A pagination token for fetching the next page of bot versions. If the response
	// to this call is truncated, Amazon Lex returns a pagination token in the response.
	// To fetch the next page of versions, specify the pagination token in the next
	// request.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBotVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBotVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Bots) > 0 {
		v := s.Bots

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "bots", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotsRequest
type GetBotsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of bots to return in the response that the request will
	// return. The default is 10.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// Substring to match in bot names. A bot will be returned if any part of its
	// name matches the substring. For example, "xyz" matches both "xyzabc" and
	// "abcxyz."
	NameContains *string `location:"querystring" locationName:"nameContains" min:"2" type:"string"`

	// A pagination token that fetches the next page of bots. If the response to
	// this call is truncated, Amazon Lex returns a pagination token in the response.
	// To fetch the next page of bots, specify the pagination token in the next
	// request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBotsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBotsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBotsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.NameContains != nil && len(*s.NameContains) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("NameContains", 2))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NameContains != nil {
		v := *s.NameContains

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nameContains", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBotsResponse
type GetBotsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of botMetadata objects, with one entry for each bot.
	Bots []BotMetadata `locationName:"bots" type:"list"`

	// If the response is truncated, it includes a pagination token that you can
	// specify in your next request to fetch the next page of bots.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBotsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBotsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBotsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBotsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Bots) > 0 {
		v := s.Bots

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "bots", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinIntentRequest
type GetBuiltinIntentInput struct {
	_ struct{} `type:"structure"`

	// The unique identifier for a built-in intent. To find the signature for an
	// intent, see Standard Built-in Intents (https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/standard-intents)
	// in the Alexa Skills Kit.
	//
	// Signature is a required field
	Signature *string `location:"uri" locationName:"signature" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBuiltinIntentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBuiltinIntentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBuiltinIntentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBuiltinIntentInput"}

	if s.Signature == nil {
		invalidParams.Add(aws.NewErrParamRequired("Signature"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBuiltinIntentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Signature != nil {
		v := *s.Signature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "signature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinIntentResponse
type GetBuiltinIntentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The unique identifier for a built-in intent.
	Signature *string `locationName:"signature" type:"string"`

	// An array of BuiltinIntentSlot objects, one entry for each slot type in the
	// intent.
	Slots []BuiltinIntentSlot `locationName:"slots" type:"list"`

	// A list of locales that the intent supports.
	SupportedLocales []Locale `locationName:"supportedLocales" type:"list"`
}

// String returns the string representation
func (s GetBuiltinIntentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBuiltinIntentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBuiltinIntentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBuiltinIntentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Signature != nil {
		v := *s.Signature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "signature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Slots) > 0 {
		v := s.Slots

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "slots", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.SupportedLocales) > 0 {
		v := s.SupportedLocales

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "supportedLocales", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinIntentsRequest
type GetBuiltinIntentsInput struct {
	_ struct{} `type:"structure"`

	// A list of locales that the intent supports.
	Locale Locale `location:"querystring" locationName:"locale" type:"string" enum:"true"`

	// The maximum number of intents to return in the response. The default is 10.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// A pagination token that fetches the next page of intents. If this API call
	// is truncated, Amazon Lex returns a pagination token in the response. To fetch
	// the next page of intents, use the pagination token in the next request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// Substring to match in built-in intent signatures. An intent will be returned
	// if any part of its signature matches the substring. For example, "xyz" matches
	// both "xyzabc" and "abcxyz." To find the signature for an intent, see Standard
	// Built-in Intents (https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/standard-intents)
	// in the Alexa Skills Kit.
	SignatureContains *string `location:"querystring" locationName:"signatureContains" type:"string"`
}

// String returns the string representation
func (s GetBuiltinIntentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBuiltinIntentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBuiltinIntentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBuiltinIntentsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBuiltinIntentsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.Locale) > 0 {
		v := s.Locale

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "locale", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SignatureContains != nil {
		v := *s.SignatureContains

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "signatureContains", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinIntentsResponse
type GetBuiltinIntentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of builtinIntentMetadata objects, one for each intent in the response.
	Intents []BuiltinIntentMetadata `locationName:"intents" type:"list"`

	// A pagination token that fetches the next page of intents. If the response
	// to this API call is truncated, Amazon Lex returns a pagination token in the
	// response. To fetch the next page of intents, specify the pagination token
	// in the next request.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetBuiltinIntentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBuiltinIntentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBuiltinIntentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBuiltinIntentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Intents) > 0 {
		v := s.Intents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "intents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinSlotTypesRequest
type GetBuiltinSlotTypesInput struct {
	_ struct{} `type:"structure"`

	// A list of locales that the slot type supports.
	Locale Locale `location:"querystring" locationName:"locale" type:"string" enum:"true"`

	// The maximum number of slot types to return in the response. The default is
	// 10.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// A pagination token that fetches the next page of slot types. If the response
	// to this API call is truncated, Amazon Lex returns a pagination token in the
	// response. To fetch the next page of slot types, specify the pagination token
	// in the next request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// Substring to match in built-in slot type signatures. A slot type will be
	// returned if any part of its signature matches the substring. For example,
	// "xyz" matches both "xyzabc" and "abcxyz."
	SignatureContains *string `location:"querystring" locationName:"signatureContains" type:"string"`
}

// String returns the string representation
func (s GetBuiltinSlotTypesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBuiltinSlotTypesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBuiltinSlotTypesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBuiltinSlotTypesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBuiltinSlotTypesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.Locale) > 0 {
		v := s.Locale

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "locale", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SignatureContains != nil {
		v := *s.SignatureContains

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "signatureContains", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetBuiltinSlotTypesResponse
type GetBuiltinSlotTypesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If the response is truncated, the response includes a pagination token that
	// you can use in your next request to fetch the next page of slot types.
	NextToken *string `locationName:"nextToken" type:"string"`

	// An array of BuiltInSlotTypeMetadata objects, one entry for each slot type
	// returned.
	SlotTypes []BuiltinSlotTypeMetadata `locationName:"slotTypes" type:"list"`
}

// String returns the string representation
func (s GetBuiltinSlotTypesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBuiltinSlotTypesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBuiltinSlotTypesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBuiltinSlotTypesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SlotTypes) > 0 {
		v := s.SlotTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "slotTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetExportRequest
type GetExportInput struct {
	_ struct{} `type:"structure"`

	// The format of the exported data.
	//
	// ExportType is a required field
	ExportType ExportType `location:"querystring" locationName:"exportType" type:"string" required:"true" enum:"true"`

	// The name of the bot to export.
	//
	// Name is a required field
	Name *string `location:"querystring" locationName:"name" min:"1" type:"string" required:"true"`

	// The type of resource to export.
	//
	// ResourceType is a required field
	ResourceType ResourceType `location:"querystring" locationName:"resourceType" type:"string" required:"true" enum:"true"`

	// The version of the bot to export.
	//
	// Version is a required field
	Version *string `location:"querystring" locationName:"version" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetExportInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetExportInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetExportInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetExportInput"}
	if len(s.ExportType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ExportType"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if len(s.ResourceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResourceType"))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetExportInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.ExportType) > 0 {
		v := s.ExportType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "exportType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "resourceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetExportResponse
type GetExportOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The status of the export.
	//
	//    * IN_PROGRESS - The export is in progress.
	//
	//    * READY - The export is complete.
	//
	//    * FAILED - The export could not be completed.
	ExportStatus ExportStatus `locationName:"exportStatus" type:"string" enum:"true"`

	// The format of the exported data.
	ExportType ExportType `locationName:"exportType" type:"string" enum:"true"`

	// If status is FAILED, Amazon Lex provides the reason that it failed to export
	// the resource.
	FailureReason *string `locationName:"failureReason" type:"string"`

	// The name of the bot being exported.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The type of the exported resource.
	ResourceType ResourceType `locationName:"resourceType" type:"string" enum:"true"`

	// An S3 pre-signed URL that provides the location of the exported resource.
	// The exported resource is a ZIP archive that contains the exported resource
	// in JSON format. The structure of the archive may change. Your code should
	// not rely on the archive structure.
	Url *string `locationName:"url" type:"string"`

	// The version of the bot being exported.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s GetExportOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetExportOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetExportOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetExportOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ExportStatus) > 0 {
		v := s.ExportStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "exportStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.ExportType) > 0 {
		v := s.ExportType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "exportType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.FailureReason != nil {
		v := *s.FailureReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "failureReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "resourceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetImportRequest
type GetImportInput struct {
	_ struct{} `type:"structure"`

	// The identifier of the import job information to return.
	//
	// ImportId is a required field
	ImportId *string `location:"uri" locationName:"importId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetImportInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetImportInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetImportInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetImportInput"}

	if s.ImportId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ImportId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetImportInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ImportId != nil {
		v := *s.ImportId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "importId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetImportResponse
type GetImportOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A timestamp for the date and time that the import job was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A string that describes why an import job failed to complete.
	FailureReason []string `locationName:"failureReason" type:"list"`

	// The identifier for the specific import job.
	ImportId *string `locationName:"importId" type:"string"`

	// The status of the import job. If the status is FAILED, you can get the reason
	// for the failure from the failureReason field.
	ImportStatus ImportStatus `locationName:"importStatus" type:"string" enum:"true"`

	// The action taken when there was a conflict between an existing resource and
	// a resource in the import file.
	MergeStrategy MergeStrategy `locationName:"mergeStrategy" type:"string" enum:"true"`

	// The name given to the import job.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The type of resource imported.
	ResourceType ResourceType `locationName:"resourceType" type:"string" enum:"true"`
}

// String returns the string representation
func (s GetImportOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetImportOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetImportOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetImportOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.FailureReason) > 0 {
		v := s.FailureReason

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "failureReason", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ImportId != nil {
		v := *s.ImportId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "importId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ImportStatus) > 0 {
		v := s.ImportStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "importStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.MergeStrategy) > 0 {
		v := s.MergeStrategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "mergeStrategy", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "resourceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntentRequest
type GetIntentInput struct {
	_ struct{} `type:"structure"`

	// The name of the intent. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`

	// The version of the intent.
	//
	// Version is a required field
	Version *string `location:"uri" locationName:"version" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetIntentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetIntentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetIntentInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntentResponse
type GetIntentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Checksum of the intent.
	Checksum *string `locationName:"checksum" type:"string"`

	// After the Lambda function specified in the fulfillmentActivity element fulfills
	// the intent, Amazon Lex conveys this statement to the user.
	ConclusionStatement *Statement `locationName:"conclusionStatement" type:"structure"`

	// If defined in the bot, Amazon Lex uses prompt to confirm the intent before
	// fulfilling the user's request. For more information, see PutIntent.
	ConfirmationPrompt *Prompt `locationName:"confirmationPrompt" type:"structure"`

	// The date that the intent was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the intent.
	Description *string `locationName:"description" type:"string"`

	// If defined in the bot, Amazon Amazon Lex invokes this Lambda function for
	// each user input. For more information, see PutIntent.
	DialogCodeHook *CodeHook `locationName:"dialogCodeHook" type:"structure"`

	// If defined in the bot, Amazon Lex uses this prompt to solicit additional
	// user activity after the intent is fulfilled. For more information, see PutIntent.
	FollowUpPrompt *FollowUpPrompt `locationName:"followUpPrompt" type:"structure"`

	// Describes how the intent is fulfilled. For more information, see PutIntent.
	FulfillmentActivity *FulfillmentActivity `locationName:"fulfillmentActivity" type:"structure"`

	// The date that the intent was updated. When you create a resource, the creation
	// date and the last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the intent.
	Name *string `locationName:"name" min:"1" type:"string"`

	// A unique identifier for a built-in intent.
	ParentIntentSignature *string `locationName:"parentIntentSignature" type:"string"`

	// If the user answers "no" to the question defined in confirmationPrompt, Amazon
	// Lex responds with this statement to acknowledge that the intent was canceled.
	RejectionStatement *Statement `locationName:"rejectionStatement" type:"structure"`

	// An array of sample utterances configured for the intent.
	SampleUtterances []string `locationName:"sampleUtterances" type:"list"`

	// An array of intent slots configured for the intent.
	Slots []Slot `locationName:"slots" type:"list"`

	// The version of the intent.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s GetIntentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetIntentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConclusionStatement != nil {
		v := s.ConclusionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "conclusionStatement", v, metadata)
	}
	if s.ConfirmationPrompt != nil {
		v := s.ConfirmationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "confirmationPrompt", v, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DialogCodeHook != nil {
		v := s.DialogCodeHook

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dialogCodeHook", v, metadata)
	}
	if s.FollowUpPrompt != nil {
		v := s.FollowUpPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "followUpPrompt", v, metadata)
	}
	if s.FulfillmentActivity != nil {
		v := s.FulfillmentActivity

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "fulfillmentActivity", v, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentIntentSignature != nil {
		v := *s.ParentIntentSignature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "parentIntentSignature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RejectionStatement != nil {
		v := s.RejectionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "rejectionStatement", v, metadata)
	}
	if len(s.SampleUtterances) > 0 {
		v := s.SampleUtterances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "sampleUtterances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Slots) > 0 {
		v := s.Slots

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "slots", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntentVersionsRequest
type GetIntentVersionsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of intent versions to return in the response. The default
	// is 10.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The name of the intent for which versions should be returned.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`

	// A pagination token for fetching the next page of intent versions. If the
	// response to this call is truncated, Amazon Lex returns a pagination token
	// in the response. To fetch the next page of versions, specify the pagination
	// token in the next request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetIntentVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntentVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetIntentVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetIntentVersionsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntentVersionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntentVersionsResponse
type GetIntentVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of IntentMetadata objects, one for each numbered version of the
	// intent plus one for the $LATEST version.
	Intents []IntentMetadata `locationName:"intents" type:"list"`

	// A pagination token for fetching the next page of intent versions. If the
	// response to this call is truncated, Amazon Lex returns a pagination token
	// in the response. To fetch the next page of versions, specify the pagination
	// token in the next request.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetIntentVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntentVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetIntentVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntentVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Intents) > 0 {
		v := s.Intents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "intents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntentsRequest
type GetIntentsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of intents to return in the response. The default is 10.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// Substring to match in intent names. An intent will be returned if any part
	// of its name matches the substring. For example, "xyz" matches both "xyzabc"
	// and "abcxyz."
	NameContains *string `location:"querystring" locationName:"nameContains" min:"1" type:"string"`

	// A pagination token that fetches the next page of intents. If the response
	// to this API call is truncated, Amazon Lex returns a pagination token in the
	// response. To fetch the next page of intents, specify the pagination token
	// in the next request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetIntentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetIntentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetIntentsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.NameContains != nil && len(*s.NameContains) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NameContains", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntentsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NameContains != nil {
		v := *s.NameContains

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nameContains", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetIntentsResponse
type GetIntentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of Intent objects. For more information, see PutBot.
	Intents []IntentMetadata `locationName:"intents" type:"list"`

	// If the response is truncated, the response includes a pagination token that
	// you can specify in your next request to fetch the next page of intents.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetIntentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetIntentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Intents) > 0 {
		v := s.Intents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "intents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotTypeRequest
type GetSlotTypeInput struct {
	_ struct{} `type:"structure"`

	// The name of the slot type. The name is case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`

	// The version of the slot type.
	//
	// Version is a required field
	Version *string `location:"uri" locationName:"version" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetSlotTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSlotTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSlotTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSlotTypeInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSlotTypeInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotTypeResponse
type GetSlotTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Checksum of the $LATEST version of the slot type.
	Checksum *string `locationName:"checksum" type:"string"`

	// The date that the slot type was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the slot type.
	Description *string `locationName:"description" type:"string"`

	// A list of EnumerationValue objects that defines the values that the slot
	// type can take.
	EnumerationValues []EnumerationValue `locationName:"enumerationValues" min:"1" type:"list"`

	// The date that the slot type was updated. When you create a resource, the
	// creation date and last update date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the slot type.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The strategy that Amazon Lex uses to determine the value of the slot. For
	// more information, see PutSlotType.
	ValueSelectionStrategy SlotValueSelectionStrategy `locationName:"valueSelectionStrategy" type:"string" enum:"true"`

	// The version of the slot type.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s GetSlotTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSlotTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSlotTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSlotTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EnumerationValues) > 0 {
		v := s.EnumerationValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "enumerationValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ValueSelectionStrategy) > 0 {
		v := s.ValueSelectionStrategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "valueSelectionStrategy", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotTypeVersionsRequest
type GetSlotTypeVersionsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of slot type versions to return in the response. The default
	// is 10.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The name of the slot type for which versions should be returned.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`

	// A pagination token for fetching the next page of slot type versions. If the
	// response to this call is truncated, Amazon Lex returns a pagination token
	// in the response. To fetch the next page of versions, specify the pagination
	// token in the next request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetSlotTypeVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSlotTypeVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSlotTypeVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSlotTypeVersionsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSlotTypeVersionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotTypeVersionsResponse
type GetSlotTypeVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A pagination token for fetching the next page of slot type versions. If the
	// response to this call is truncated, Amazon Lex returns a pagination token
	// in the response. To fetch the next page of versions, specify the pagination
	// token in the next request.
	NextToken *string `locationName:"nextToken" type:"string"`

	// An array of SlotTypeMetadata objects, one for each numbered version of the
	// slot type plus one for the $LATEST version.
	SlotTypes []SlotTypeMetadata `locationName:"slotTypes" type:"list"`
}

// String returns the string representation
func (s GetSlotTypeVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSlotTypeVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSlotTypeVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSlotTypeVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SlotTypes) > 0 {
		v := s.SlotTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "slotTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotTypesRequest
type GetSlotTypesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of slot types to return in the response. The default is
	// 10.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// Substring to match in slot type names. A slot type will be returned if any
	// part of its name matches the substring. For example, "xyz" matches both "xyzabc"
	// and "abcxyz."
	NameContains *string `location:"querystring" locationName:"nameContains" min:"1" type:"string"`

	// A pagination token that fetches the next page of slot types. If the response
	// to this API call is truncated, Amazon Lex returns a pagination token in the
	// response. To fetch next page of slot types, specify the pagination token
	// in the next request.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetSlotTypesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSlotTypesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSlotTypesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSlotTypesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.NameContains != nil && len(*s.NameContains) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NameContains", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSlotTypesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NameContains != nil {
		v := *s.NameContains

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nameContains", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetSlotTypesResponse
type GetSlotTypesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If the response is truncated, it includes a pagination token that you can
	// specify in your next request to fetch the next page of slot types.
	NextToken *string `locationName:"nextToken" type:"string"`

	// An array of objects, one for each slot type, that provides information such
	// as the name of the slot type, the version, and a description.
	SlotTypes []SlotTypeMetadata `locationName:"slotTypes" type:"list"`
}

// String returns the string representation
func (s GetSlotTypesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSlotTypesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSlotTypesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSlotTypesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SlotTypes) > 0 {
		v := s.SlotTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "slotTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetUtterancesViewRequest
type GetUtterancesViewInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot for which utterance information should be returned.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botname" min:"2" type:"string" required:"true"`

	// An array of bot versions for which utterance information should be returned.
	// The limit is 5 versions per request.
	//
	// BotVersions is a required field
	BotVersions []string `location:"querystring" locationName:"bot_versions" min:"1" type:"list" required:"true"`

	// To return utterances that were recognized and handled, useDetected. To return
	// utterances that were not recognized, use Missed.
	//
	// StatusType is a required field
	StatusType StatusType `location:"querystring" locationName:"status_type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s GetUtterancesViewInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUtterancesViewInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetUtterancesViewInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetUtterancesViewInput"}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}

	if s.BotVersions == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotVersions"))
	}
	if s.BotVersions != nil && len(s.BotVersions) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BotVersions", 1))
	}
	if len(s.StatusType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("StatusType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUtterancesViewInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botname", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.BotVersions) > 0 {
		v := s.BotVersions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.QueryTarget, "bot_versions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.StatusType) > 0 {
		v := s.StatusType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "status_type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/GetUtterancesViewResponse
type GetUtterancesViewOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The name of the bot for which utterance information was returned.
	BotName *string `locationName:"botName" min:"2" type:"string"`

	// An array of UtteranceList objects, each containing a list of UtteranceData
	// objects describing the utterances that were processed by your bot. The response
	// contains a maximum of 100 UtteranceData objects for each version.
	Utterances []UtteranceList `locationName:"utterances" type:"list"`
}

// String returns the string representation
func (s GetUtterancesViewOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUtterancesViewOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetUtterancesViewOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUtterancesViewOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Utterances) > 0 {
		v := s.Utterances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "utterances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Identifies the specific version of an intent.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/Intent
type Intent struct {
	_ struct{} `type:"structure"`

	// The name of the intent.
	//
	// IntentName is a required field
	IntentName *string `locationName:"intentName" min:"1" type:"string" required:"true"`

	// The version of the intent.
	//
	// IntentVersion is a required field
	IntentVersion *string `locationName:"intentVersion" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s Intent) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Intent) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Intent) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Intent"}

	if s.IntentName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IntentName"))
	}
	if s.IntentName != nil && len(*s.IntentName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("IntentName", 1))
	}

	if s.IntentVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("IntentVersion"))
	}
	if s.IntentVersion != nil && len(*s.IntentVersion) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("IntentVersion", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Intent) MarshalFields(e protocol.FieldEncoder) error {
	if s.IntentName != nil {
		v := *s.IntentName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "intentName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IntentVersion != nil {
		v := *s.IntentVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "intentVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides information about an intent.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/IntentMetadata
type IntentMetadata struct {
	_ struct{} `type:"structure"`

	// The date that the intent was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the intent.
	Description *string `locationName:"description" type:"string"`

	// The date that the intent was updated. When you create an intent, the creation
	// date and last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the intent.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The version of the intent.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s IntentMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s IntentMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s IntentMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The message object that provides the message text and its type.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/Message
type Message struct {
	_ struct{} `type:"structure"`

	// The text of the message.
	//
	// Content is a required field
	Content *string `locationName:"content" min:"1" type:"string" required:"true"`

	// The content type of the message string.
	//
	// ContentType is a required field
	ContentType ContentType `locationName:"contentType" type:"string" required:"true" enum:"true"`

	// Identifies the message group that the message belongs to. When a group is
	// assigned to a message, Amazon Lex returns one message from each group in
	// the response.
	GroupNumber *int64 `locationName:"groupNumber" min:"1" type:"integer"`
}

// String returns the string representation
func (s Message) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Message) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Message) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Message"}

	if s.Content == nil {
		invalidParams.Add(aws.NewErrParamRequired("Content"))
	}
	if s.Content != nil && len(*s.Content) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Content", 1))
	}
	if len(s.ContentType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ContentType"))
	}
	if s.GroupNumber != nil && *s.GroupNumber < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("GroupNumber", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Message) MarshalFields(e protocol.FieldEncoder) error {
	if s.Content != nil {
		v := *s.Content

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "content", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ContentType) > 0 {
		v := s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "contentType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.GroupNumber != nil {
		v := *s.GroupNumber

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "groupNumber", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Obtains information from the user. To define a prompt, provide one or more
// messages and specify the number of attempts to get information from the user.
// If you provide more than one message, Amazon Lex chooses one of the messages
// to use to prompt the user. For more information, see how-it-works.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/Prompt
type Prompt struct {
	_ struct{} `type:"structure"`

	// The number of times to prompt the user for information.
	//
	// MaxAttempts is a required field
	MaxAttempts *int64 `locationName:"maxAttempts" min:"1" type:"integer" required:"true"`

	// An array of objects, each of which provides a message string and its type.
	// You can specify the message string in plain text or in Speech Synthesis Markup
	// Language (SSML).
	//
	// Messages is a required field
	Messages []Message `locationName:"messages" min:"1" type:"list" required:"true"`

	// A response card. Amazon Lex uses this prompt at runtime, in the PostText
	// API response. It substitutes session attributes and slot values for placeholders
	// in the response card. For more information, see ex-resp-card.
	ResponseCard *string `locationName:"responseCard" min:"1" type:"string"`
}

// String returns the string representation
func (s Prompt) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Prompt) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Prompt) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Prompt"}

	if s.MaxAttempts == nil {
		invalidParams.Add(aws.NewErrParamRequired("MaxAttempts"))
	}
	if s.MaxAttempts != nil && *s.MaxAttempts < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxAttempts", 1))
	}

	if s.Messages == nil {
		invalidParams.Add(aws.NewErrParamRequired("Messages"))
	}
	if s.Messages != nil && len(s.Messages) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Messages", 1))
	}
	if s.ResponseCard != nil && len(*s.ResponseCard) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResponseCard", 1))
	}
	if s.Messages != nil {
		for i, v := range s.Messages {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Messages", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Prompt) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaxAttempts != nil {
		v := *s.MaxAttempts

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxAttempts", protocol.Int64Value(v), metadata)
	}
	if len(s.Messages) > 0 {
		v := s.Messages

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "messages", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResponseCard != nil {
		v := *s.ResponseCard

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "responseCard", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutBotAliasRequest
type PutBotAliasInput struct {
	_ struct{} `type:"structure"`

	// The name of the bot.
	//
	// BotName is a required field
	BotName *string `location:"uri" locationName:"botName" min:"2" type:"string" required:"true"`

	// The version of the bot.
	//
	// BotVersion is a required field
	BotVersion *string `locationName:"botVersion" min:"1" type:"string" required:"true"`

	// Identifies a specific revision of the $LATEST version.
	//
	// When you create a new bot alias, leave the checksum field blank. If you specify
	// a checksum you get a BadRequestException exception.
	//
	// When you want to update a bot alias, set the checksum field to the checksum
	// of the most recent revision of the $LATEST version. If you don't specify
	// the  checksum field, or if the checksum does not match the $LATEST version,
	// you get a PreconditionFailedException exception.
	Checksum *string `locationName:"checksum" type:"string"`

	// A description of the alias.
	Description *string `locationName:"description" type:"string"`

	// The name of the alias. The name is not case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s PutBotAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutBotAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutBotAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutBotAliasInput"}

	if s.BotName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotName"))
	}
	if s.BotName != nil && len(*s.BotName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("BotName", 2))
	}

	if s.BotVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("BotVersion"))
	}
	if s.BotVersion != nil && len(*s.BotVersion) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BotVersion", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutBotAliasInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BotVersion != nil {
		v := *s.BotVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutBotAliasResponse
type PutBotAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The name of the bot that the alias points to.
	BotName *string `locationName:"botName" min:"2" type:"string"`

	// The version of the bot that the alias points to.
	BotVersion *string `locationName:"botVersion" min:"1" type:"string"`

	// The checksum for the current version of the alias.
	Checksum *string `locationName:"checksum" type:"string"`

	// The date that the bot alias was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the alias.
	Description *string `locationName:"description" type:"string"`

	// The date that the bot alias was updated. When you create a resource, the
	// creation date and the last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the alias.
	Name *string `locationName:"name" min:"1" type:"string"`
}

// String returns the string representation
func (s PutBotAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutBotAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutBotAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutBotAliasOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BotName != nil {
		v := *s.BotName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BotVersion != nil {
		v := *s.BotVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutBotRequest
type PutBotInput struct {
	_ struct{} `type:"structure"`

	// When Amazon Lex can't understand the user's input in context, it tries to
	// elicit the information a few times. After that, Amazon Lex sends the message
	// defined in abortStatement to the user, and then aborts the conversation.
	// To set the number of retries, use the valueElicitationPrompt field for the
	// slot type.
	//
	// For example, in a pizza ordering bot, Amazon Lex might ask a user "What type
	// of crust would you like?" If the user's response is not one of the expected
	// responses (for example, "thin crust, "deep dish," etc.), Amazon Lex tries
	// to elicit a correct response a few more times.
	//
	// For example, in a pizza ordering application, OrderPizza might be one of
	// the intents. This intent might require the CrustType slot. You specify the
	// valueElicitationPrompt field when you create the CrustType slot.
	AbortStatement *Statement `locationName:"abortStatement" type:"structure"`

	// Identifies a specific revision of the $LATEST version.
	//
	// When you create a new bot, leave the checksum field blank. If you specify
	// a checksum you get a BadRequestException exception.
	//
	// When you want to update a bot, set the checksum field to the checksum of
	// the most recent revision of the $LATEST version. If you don't specify the
	//  checksum field, or if the checksum does not match the $LATEST version, you
	// get a PreconditionFailedException exception.
	Checksum *string `locationName:"checksum" type:"string"`

	// For each Amazon Lex bot created with the Amazon Lex Model Building Service,
	// you must specify whether your use of Amazon Lex is related to a website,
	// program, or other application that is directed or targeted, in whole or in
	// part, to children under age 13 and subject to the Children's Online Privacy
	// Protection Act (COPPA) by specifying true or false in the childDirected field.
	// By specifying true in the childDirected field, you confirm that your use
	// of Amazon Lex is related to a website, program, or other application that
	// is directed or targeted, in whole or in part, to children under age 13 and
	// subject to COPPA. By specifying false in the childDirected field, you confirm
	// that your use of Amazon Lex is not related to a website, program, or other
	// application that is directed or targeted, in whole or in part, to children
	// under age 13 and subject to COPPA. You may not specify a default value for
	// the childDirected field that does not accurately reflect whether your use
	// of Amazon Lex is related to a website, program, or other application that
	// is directed or targeted, in whole or in part, to children under age 13 and
	// subject to COPPA.
	//
	// If your use of Amazon Lex relates to a website, program, or other application
	// that is directed in whole or in part, to children under age 13, you must
	// obtain any required verifiable parental consent under COPPA. For information
	// regarding the use of Amazon Lex in connection with websites, programs, or
	// other applications that are directed or targeted, in whole or in part, to
	// children under age 13, see the Amazon Lex FAQ. (https://aws.amazon.com/lex/faqs#data-security)
	//
	// ChildDirected is a required field
	ChildDirected *bool `locationName:"childDirected" type:"boolean" required:"true"`

	// When Amazon Lex doesn't understand the user's intent, it uses this message
	// to get clarification. To specify how many times Amazon Lex should repeate
	// the clarification prompt, use the maxAttempts field. If Amazon Lex still
	// doesn't understand, it sends the message in the abortStatement field.
	//
	// When you create a clarification prompt, make sure that it suggests the correct
	// response from the user. for example, for a bot that orders pizza and drinks,
	// you might create this clarification prompt: "What would you like to do? You
	// can say 'Order a pizza' or 'Order a drink.'"
	ClarificationPrompt *Prompt `locationName:"clarificationPrompt" type:"structure"`

	CreateVersion *bool `locationName:"createVersion" type:"boolean"`

	// A description of the bot.
	Description *string `locationName:"description" type:"string"`

	// The maximum time in seconds that Amazon Lex retains the data gathered in
	// a conversation.
	//
	// A user interaction session remains active for the amount of time specified.
	// If no conversation occurs during this time, the session expires and Amazon
	// Lex deletes any data provided before the timeout.
	//
	// For example, suppose that a user chooses the OrderPizza intent, but gets
	// sidetracked halfway through placing an order. If the user doesn't complete
	// the order within the specified time, Amazon Lex discards the slot information
	// that it gathered, and the user must start over.
	//
	// If you don't include the idleSessionTTLInSeconds element in a PutBot operation
	// request, Amazon Lex uses the default value. This is also true if the request
	// replaces an existing bot.
	//
	// The default is 300 seconds (5 minutes).
	IdleSessionTTLInSeconds *int64 `locationName:"idleSessionTTLInSeconds" min:"60" type:"integer"`

	// An array of Intent objects. Each intent represents a command that a user
	// can express. For example, a pizza ordering bot might support an OrderPizza
	// intent. For more information, see how-it-works.
	Intents []Intent `locationName:"intents" type:"list"`

	// Specifies the target locale for the bot. Any intent used in the bot must
	// be compatible with the locale of the bot.
	//
	// The default is en-US.
	//
	// Locale is a required field
	Locale Locale `locationName:"locale" type:"string" required:"true" enum:"true"`

	// The name of the bot. The name is not case sensitive.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"2" type:"string" required:"true"`

	// If you set the processBehavior element to BUILD, Amazon Lex builds the bot
	// so that it can be run. If you set the element to SAVE Amazon Lex saves the
	// bot, but doesn't build it.
	//
	// If you don't specify this value, the default value is BUILD.
	ProcessBehavior ProcessBehavior `locationName:"processBehavior" type:"string" enum:"true"`

	// The Amazon Polly voice ID that you want Amazon Lex to use for voice interactions
	// with the user. The locale configured for the voice must match the locale
	// of the bot. For more information, see Available Voices (http://docs.aws.amazon.com/polly/latest/dg/voicelist.html)
	// in the Amazon Polly Developer Guide.
	VoiceId *string `locationName:"voiceId" type:"string"`
}

// String returns the string representation
func (s PutBotInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutBotInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutBotInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutBotInput"}

	if s.ChildDirected == nil {
		invalidParams.Add(aws.NewErrParamRequired("ChildDirected"))
	}
	if s.IdleSessionTTLInSeconds != nil && *s.IdleSessionTTLInSeconds < 60 {
		invalidParams.Add(aws.NewErrParamMinValue("IdleSessionTTLInSeconds", 60))
	}
	if len(s.Locale) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Locale"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 2))
	}
	if s.AbortStatement != nil {
		if err := s.AbortStatement.Validate(); err != nil {
			invalidParams.AddNested("AbortStatement", err.(aws.ErrInvalidParams))
		}
	}
	if s.ClarificationPrompt != nil {
		if err := s.ClarificationPrompt.Validate(); err != nil {
			invalidParams.AddNested("ClarificationPrompt", err.(aws.ErrInvalidParams))
		}
	}
	if s.Intents != nil {
		for i, v := range s.Intents {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Intents", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutBotInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AbortStatement != nil {
		v := s.AbortStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "abortStatement", v, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChildDirected != nil {
		v := *s.ChildDirected

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "childDirected", protocol.BoolValue(v), metadata)
	}
	if s.ClarificationPrompt != nil {
		v := s.ClarificationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "clarificationPrompt", v, metadata)
	}
	if s.CreateVersion != nil {
		v := *s.CreateVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createVersion", protocol.BoolValue(v), metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdleSessionTTLInSeconds != nil {
		v := *s.IdleSessionTTLInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "idleSessionTTLInSeconds", protocol.Int64Value(v), metadata)
	}
	if len(s.Intents) > 0 {
		v := s.Intents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "intents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Locale) > 0 {
		v := s.Locale

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "locale", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.ProcessBehavior) > 0 {
		v := s.ProcessBehavior

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "processBehavior", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.VoiceId != nil {
		v := *s.VoiceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "voiceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutBotResponse
type PutBotOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The message that Amazon Lex uses to abort a conversation. For more information,
	// see PutBot.
	AbortStatement *Statement `locationName:"abortStatement" type:"structure"`

	// Checksum of the bot that you created.
	Checksum *string `locationName:"checksum" type:"string"`

	// For each Amazon Lex bot created with the Amazon Lex Model Building Service,
	// you must specify whether your use of Amazon Lex is related to a website,
	// program, or other application that is directed or targeted, in whole or in
	// part, to children under age 13 and subject to the Children's Online Privacy
	// Protection Act (COPPA) by specifying true or false in the childDirected field.
	// By specifying true in the childDirected field, you confirm that your use
	// of Amazon Lex is related to a website, program, or other application that
	// is directed or targeted, in whole or in part, to children under age 13 and
	// subject to COPPA. By specifying false in the childDirected field, you confirm
	// that your use of Amazon Lex is not related to a website, program, or other
	// application that is directed or targeted, in whole or in part, to children
	// under age 13 and subject to COPPA. You may not specify a default value for
	// the childDirected field that does not accurately reflect whether your use
	// of Amazon Lex is related to a website, program, or other application that
	// is directed or targeted, in whole or in part, to children under age 13 and
	// subject to COPPA.
	//
	// If your use of Amazon Lex relates to a website, program, or other application
	// that is directed in whole or in part, to children under age 13, you must
	// obtain any required verifiable parental consent under COPPA. For information
	// regarding the use of Amazon Lex in connection with websites, programs, or
	// other applications that are directed or targeted, in whole or in part, to
	// children under age 13, see the Amazon Lex FAQ. (https://aws.amazon.com/lex/faqs#data-security)
	ChildDirected *bool `locationName:"childDirected" type:"boolean"`

	// The prompts that Amazon Lex uses when it doesn't understand the user's intent.
	// For more information, see PutBot.
	ClarificationPrompt *Prompt `locationName:"clarificationPrompt" type:"structure"`

	CreateVersion *bool `locationName:"createVersion" type:"boolean"`

	// The date that the bot was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the bot.
	Description *string `locationName:"description" type:"string"`

	// If status is FAILED, Amazon Lex provides the reason that it failed to build
	// the bot.
	FailureReason *string `locationName:"failureReason" type:"string"`

	// The maximum length of time that Amazon Lex retains the data gathered in a
	// conversation. For more information, see PutBot.
	IdleSessionTTLInSeconds *int64 `locationName:"idleSessionTTLInSeconds" min:"60" type:"integer"`

	// An array of Intent objects. For more information, see PutBot.
	Intents []Intent `locationName:"intents" type:"list"`

	// The date that the bot was updated. When you create a resource, the creation
	// date and last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The target locale for the bot.
	Locale Locale `locationName:"locale" type:"string" enum:"true"`

	// The name of the bot.
	Name *string `locationName:"name" min:"2" type:"string"`

	// When you send a request to create a bot with processBehavior set to BUILD,
	// Amazon Lex sets the status response element to BUILDING. After Amazon Lex
	// builds the bot, it sets status to READY. If Amazon Lex can't build the bot,
	// Amazon Lex sets status to FAILED. Amazon Lex returns the reason for the failure
	// in the failureReason response element.
	//
	// When you set processBehaviorto SAVE, Amazon Lex sets the status code to NOT
	// BUILT.
	Status Status `locationName:"status" type:"string" enum:"true"`

	// The version of the bot. For a new bot, the version is always $LATEST.
	Version *string `locationName:"version" min:"1" type:"string"`

	// The Amazon Polly voice ID that Amazon Lex uses for voice interaction with
	// the user. For more information, see PutBot.
	VoiceId *string `locationName:"voiceId" type:"string"`
}

// String returns the string representation
func (s PutBotOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutBotOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutBotOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutBotOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AbortStatement != nil {
		v := s.AbortStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "abortStatement", v, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChildDirected != nil {
		v := *s.ChildDirected

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "childDirected", protocol.BoolValue(v), metadata)
	}
	if s.ClarificationPrompt != nil {
		v := s.ClarificationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "clarificationPrompt", v, metadata)
	}
	if s.CreateVersion != nil {
		v := *s.CreateVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createVersion", protocol.BoolValue(v), metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FailureReason != nil {
		v := *s.FailureReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "failureReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdleSessionTTLInSeconds != nil {
		v := *s.IdleSessionTTLInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "idleSessionTTLInSeconds", protocol.Int64Value(v), metadata)
	}
	if len(s.Intents) > 0 {
		v := s.Intents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "intents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Locale) > 0 {
		v := s.Locale

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "locale", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VoiceId != nil {
		v := *s.VoiceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "voiceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutIntentRequest
type PutIntentInput struct {
	_ struct{} `type:"structure"`

	// Identifies a specific revision of the $LATEST version.
	//
	// When you create a new intent, leave the checksum field blank. If you specify
	// a checksum you get a BadRequestException exception.
	//
	// When you want to update a intent, set the checksum field to the checksum
	// of the most recent revision of the $LATEST version. If you don't specify
	// the  checksum field, or if the checksum does not match the $LATEST version,
	// you get a PreconditionFailedException exception.
	Checksum *string `locationName:"checksum" type:"string"`

	// The statement that you want Amazon Lex to convey to the user after the intent
	// is successfully fulfilled by the Lambda function.
	//
	// This element is relevant only if you provide a Lambda function in the fulfillmentActivity.
	// If you return the intent to the client application, you can't specify this
	// element.
	//
	// The followUpPrompt and conclusionStatement are mutually exclusive. You can
	// specify only one.
	ConclusionStatement *Statement `locationName:"conclusionStatement" type:"structure"`

	// Prompts the user to confirm the intent. This question should have a yes or
	// no answer.
	//
	// Amazon Lex uses this prompt to ensure that the user acknowledges that the
	// intent is ready for fulfillment. For example, with the OrderPizza intent,
	// you might want to confirm that the order is correct before placing it. For
	// other intents, such as intents that simply respond to user questions, you
	// might not need to ask the user for confirmation before providing the information.
	//
	// You you must provide both the rejectionStatement and the confirmationPrompt,
	// or neither.
	ConfirmationPrompt *Prompt `locationName:"confirmationPrompt" type:"structure"`

	CreateVersion *bool `locationName:"createVersion" type:"boolean"`

	// A description of the intent.
	Description *string `locationName:"description" type:"string"`

	// Specifies a Lambda function to invoke for each user input. You can invoke
	// this Lambda function to personalize user interaction.
	//
	// For example, suppose your bot determines that the user is John. Your Lambda
	// function might retrieve John's information from a backend database and prepopulate
	// some of the values. For example, if you find that John is gluten intolerant,
	// you might set the corresponding intent slot, GlutenIntolerant, to true. You
	// might find John's phone number and set the corresponding session attribute.
	DialogCodeHook *CodeHook `locationName:"dialogCodeHook" type:"structure"`

	// Amazon Lex uses this prompt to solicit additional activity after fulfilling
	// an intent. For example, after the OrderPizza intent is fulfilled, you might
	// prompt the user to order a drink.
	//
	// The action that Amazon Lex takes depends on the user's response, as follows:
	//
	//    * If the user says "Yes" it responds with the clarification prompt that
	//    is configured for the bot.
	//
	//    * if the user says "Yes" and continues with an utterance that triggers
	//    an intent it starts a conversation for the intent.
	//
	//    * If the user says "No" it responds with the rejection statement configured
	//    for the the follow-up prompt.
	//
	//    * If it doesn't recognize the utterance it repeats the follow-up prompt
	//    again.
	//
	// The followUpPrompt field and the conclusionStatement field are mutually exclusive.
	// You can specify only one.
	FollowUpPrompt *FollowUpPrompt `locationName:"followUpPrompt" type:"structure"`

	// Required. Describes how the intent is fulfilled. For example, after a user
	// provides all of the information for a pizza order, fulfillmentActivity defines
	// how the bot places an order with a local pizza store.
	//
	// You might configure Amazon Lex to return all of the intent information to
	// the client application, or direct it to invoke a Lambda function that can
	// process the intent (for example, place an order with a pizzeria).
	FulfillmentActivity *FulfillmentActivity `locationName:"fulfillmentActivity" type:"structure"`

	// The name of the intent. The name is not case sensitive.
	//
	// The name can't match a built-in intent name, or a built-in intent name with
	// "AMAZON." removed. For example, because there is a built-in intent called
	// AMAZON.HelpIntent, you can't create a custom intent called HelpIntent.
	//
	// For a list of built-in intents, see Standard Built-in Intents (https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/standard-intents)
	// in the Alexa Skills Kit.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`

	// A unique identifier for the built-in intent to base this intent on. To find
	// the signature for an intent, see Standard Built-in Intents (https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/standard-intents)
	// in the Alexa Skills Kit.
	ParentIntentSignature *string `locationName:"parentIntentSignature" type:"string"`

	// When the user answers "no" to the question defined in confirmationPrompt,
	// Amazon Lex responds with this statement to acknowledge that the intent was
	// canceled.
	//
	// You must provide both the rejectionStatement and the confirmationPrompt,
	// or neither.
	RejectionStatement *Statement `locationName:"rejectionStatement" type:"structure"`

	// An array of utterances (strings) that a user might say to signal the intent.
	// For example, "I want {PizzaSize} pizza", "Order {Quantity} {PizzaSize} pizzas".
	//
	// In each utterance, a slot name is enclosed in curly braces.
	SampleUtterances []string `locationName:"sampleUtterances" type:"list"`

	// An array of intent slots. At runtime, Amazon Lex elicits required slot values
	// from the user using prompts defined in the slots. For more information, see
	// how-it-works.
	Slots []Slot `locationName:"slots" type:"list"`
}

// String returns the string representation
func (s PutIntentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutIntentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutIntentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutIntentInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.ConclusionStatement != nil {
		if err := s.ConclusionStatement.Validate(); err != nil {
			invalidParams.AddNested("ConclusionStatement", err.(aws.ErrInvalidParams))
		}
	}
	if s.ConfirmationPrompt != nil {
		if err := s.ConfirmationPrompt.Validate(); err != nil {
			invalidParams.AddNested("ConfirmationPrompt", err.(aws.ErrInvalidParams))
		}
	}
	if s.DialogCodeHook != nil {
		if err := s.DialogCodeHook.Validate(); err != nil {
			invalidParams.AddNested("DialogCodeHook", err.(aws.ErrInvalidParams))
		}
	}
	if s.FollowUpPrompt != nil {
		if err := s.FollowUpPrompt.Validate(); err != nil {
			invalidParams.AddNested("FollowUpPrompt", err.(aws.ErrInvalidParams))
		}
	}
	if s.FulfillmentActivity != nil {
		if err := s.FulfillmentActivity.Validate(); err != nil {
			invalidParams.AddNested("FulfillmentActivity", err.(aws.ErrInvalidParams))
		}
	}
	if s.RejectionStatement != nil {
		if err := s.RejectionStatement.Validate(); err != nil {
			invalidParams.AddNested("RejectionStatement", err.(aws.ErrInvalidParams))
		}
	}
	if s.Slots != nil {
		for i, v := range s.Slots {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Slots", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutIntentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConclusionStatement != nil {
		v := s.ConclusionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "conclusionStatement", v, metadata)
	}
	if s.ConfirmationPrompt != nil {
		v := s.ConfirmationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "confirmationPrompt", v, metadata)
	}
	if s.CreateVersion != nil {
		v := *s.CreateVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createVersion", protocol.BoolValue(v), metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DialogCodeHook != nil {
		v := s.DialogCodeHook

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dialogCodeHook", v, metadata)
	}
	if s.FollowUpPrompt != nil {
		v := s.FollowUpPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "followUpPrompt", v, metadata)
	}
	if s.FulfillmentActivity != nil {
		v := s.FulfillmentActivity

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "fulfillmentActivity", v, metadata)
	}
	if s.ParentIntentSignature != nil {
		v := *s.ParentIntentSignature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "parentIntentSignature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RejectionStatement != nil {
		v := s.RejectionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "rejectionStatement", v, metadata)
	}
	if len(s.SampleUtterances) > 0 {
		v := s.SampleUtterances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "sampleUtterances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Slots) > 0 {
		v := s.Slots

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "slots", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutIntentResponse
type PutIntentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Checksum of the $LATESTversion of the intent created or updated.
	Checksum *string `locationName:"checksum" type:"string"`

	// After the Lambda function specified in thefulfillmentActivityintent fulfills
	// the intent, Amazon Lex conveys this statement to the user.
	ConclusionStatement *Statement `locationName:"conclusionStatement" type:"structure"`

	// If defined in the intent, Amazon Lex prompts the user to confirm the intent
	// before fulfilling it.
	ConfirmationPrompt *Prompt `locationName:"confirmationPrompt" type:"structure"`

	CreateVersion *bool `locationName:"createVersion" type:"boolean"`

	// The date that the intent was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the intent.
	Description *string `locationName:"description" type:"string"`

	// If defined in the intent, Amazon Lex invokes this Lambda function for each
	// user input.
	DialogCodeHook *CodeHook `locationName:"dialogCodeHook" type:"structure"`

	// If defined in the intent, Amazon Lex uses this prompt to solicit additional
	// user activity after the intent is fulfilled.
	FollowUpPrompt *FollowUpPrompt `locationName:"followUpPrompt" type:"structure"`

	// If defined in the intent, Amazon Lex invokes this Lambda function to fulfill
	// the intent after the user provides all of the information required by the
	// intent.
	FulfillmentActivity *FulfillmentActivity `locationName:"fulfillmentActivity" type:"structure"`

	// The date that the intent was updated. When you create a resource, the creation
	// date and last update dates are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the intent.
	Name *string `locationName:"name" min:"1" type:"string"`

	// A unique identifier for the built-in intent that this intent is based on.
	ParentIntentSignature *string `locationName:"parentIntentSignature" type:"string"`

	// If the user answers "no" to the question defined in confirmationPrompt Amazon
	// Lex responds with this statement to acknowledge that the intent was canceled.
	RejectionStatement *Statement `locationName:"rejectionStatement" type:"structure"`

	// An array of sample utterances that are configured for the intent.
	SampleUtterances []string `locationName:"sampleUtterances" type:"list"`

	// An array of intent slots that are configured for the intent.
	Slots []Slot `locationName:"slots" type:"list"`

	// The version of the intent. For a new intent, the version is always $LATEST.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s PutIntentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutIntentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutIntentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutIntentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConclusionStatement != nil {
		v := s.ConclusionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "conclusionStatement", v, metadata)
	}
	if s.ConfirmationPrompt != nil {
		v := s.ConfirmationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "confirmationPrompt", v, metadata)
	}
	if s.CreateVersion != nil {
		v := *s.CreateVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createVersion", protocol.BoolValue(v), metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DialogCodeHook != nil {
		v := s.DialogCodeHook

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dialogCodeHook", v, metadata)
	}
	if s.FollowUpPrompt != nil {
		v := s.FollowUpPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "followUpPrompt", v, metadata)
	}
	if s.FulfillmentActivity != nil {
		v := s.FulfillmentActivity

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "fulfillmentActivity", v, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentIntentSignature != nil {
		v := *s.ParentIntentSignature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "parentIntentSignature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RejectionStatement != nil {
		v := s.RejectionStatement

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "rejectionStatement", v, metadata)
	}
	if len(s.SampleUtterances) > 0 {
		v := s.SampleUtterances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "sampleUtterances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Slots) > 0 {
		v := s.Slots

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "slots", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutSlotTypeRequest
type PutSlotTypeInput struct {
	_ struct{} `type:"structure"`

	// Identifies a specific revision of the $LATEST version.
	//
	// When you create a new slot type, leave the checksum field blank. If you specify
	// a checksum you get a BadRequestException exception.
	//
	// When you want to update a slot type, set the checksum field to the checksum
	// of the most recent revision of the $LATEST version. If you don't specify
	// the  checksum field, or if the checksum does not match the $LATEST version,
	// you get a PreconditionFailedException exception.
	Checksum *string `locationName:"checksum" type:"string"`

	CreateVersion *bool `locationName:"createVersion" type:"boolean"`

	// A description of the slot type.
	Description *string `locationName:"description" type:"string"`

	// A list of EnumerationValue objects that defines the values that the slot
	// type can take. Each value can have a list of synonyms, which are additional
	// values that help train the machine learning model about the values that it
	// resolves for a slot.
	//
	// When Amazon Lex resolves a slot value, it generates a resolution list that
	// contains up to five possible values for the slot. If you are using a Lambda
	// function, this resolution list is passed to the function. If you are not
	// using a Lambda function you can choose to return the value that the user
	// entered or the first value in the resolution list as the slot value. The
	// valueSelectionStrategy field indicates the option to use.
	EnumerationValues []EnumerationValue `locationName:"enumerationValues" min:"1" type:"list"`

	// The name of the slot type. The name is not case sensitive.
	//
	// The name can't match a built-in slot type name, or a built-in slot type name
	// with "AMAZON." removed. For example, because there is a built-in slot type
	// called AMAZON.DATE, you can't create a custom slot type called DATE.
	//
	// For a list of built-in slot types, see Slot Type Reference (https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/slot-type-reference)
	// in the Alexa Skills Kit.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" min:"1" type:"string" required:"true"`

	// Determines the slot resolution strategy that Amazon Lex uses to return slot
	// type values. The field can be set to one of the following values:
	//
	//    * ORIGINAL_VALUE - Returns the value entered by the user, if the user
	//    value is similar to the slot value.
	//
	//    * TOP_RESOLUTION - If there is a resolution list for the slot, return
	//    the first value in the resolution list as the slot type value. If there
	//    is no resolution list, null is returned.
	//
	// If you don't specify the valueSelectionStrategy, the default is ORIGINAL_VALUE.
	ValueSelectionStrategy SlotValueSelectionStrategy `locationName:"valueSelectionStrategy" type:"string" enum:"true"`
}

// String returns the string representation
func (s PutSlotTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutSlotTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutSlotTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutSlotTypeInput"}
	if s.EnumerationValues != nil && len(s.EnumerationValues) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("EnumerationValues", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.EnumerationValues != nil {
		for i, v := range s.EnumerationValues {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "EnumerationValues", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutSlotTypeInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreateVersion != nil {
		v := *s.CreateVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createVersion", protocol.BoolValue(v), metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EnumerationValues) > 0 {
		v := s.EnumerationValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "enumerationValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.ValueSelectionStrategy) > 0 {
		v := s.ValueSelectionStrategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "valueSelectionStrategy", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/PutSlotTypeResponse
type PutSlotTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Checksum of the $LATEST version of the slot type.
	Checksum *string `locationName:"checksum" type:"string"`

	CreateVersion *bool `locationName:"createVersion" type:"boolean"`

	// The date that the slot type was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the slot type.
	Description *string `locationName:"description" type:"string"`

	// A list of EnumerationValue objects that defines the values that the slot
	// type can take.
	EnumerationValues []EnumerationValue `locationName:"enumerationValues" min:"1" type:"list"`

	// The date that the slot type was updated. When you create a slot type, the
	// creation date and last update date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the slot type.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The slot resolution strategy that Amazon Lex uses to determine the value
	// of the slot. For more information, see PutSlotType.
	ValueSelectionStrategy SlotValueSelectionStrategy `locationName:"valueSelectionStrategy" type:"string" enum:"true"`

	// The version of the slot type. For a new slot type, the version is always
	// $LATEST.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s PutSlotTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutSlotTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutSlotTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutSlotTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "checksum", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreateVersion != nil {
		v := *s.CreateVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createVersion", protocol.BoolValue(v), metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EnumerationValues) > 0 {
		v := s.EnumerationValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "enumerationValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ValueSelectionStrategy) > 0 {
		v := s.ValueSelectionStrategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "valueSelectionStrategy", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes the resource that refers to the resource that you are attempting
// to delete. This object is returned as part of the ResourceInUseException
// exception.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/ResourceReference
type ResourceReference struct {
	_ struct{} `type:"structure"`

	// The name of the resource that is using the resource that you are trying to
	// delete.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The version of the resource that is using the resource that you are trying
	// to delete.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s ResourceReference) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourceReference) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourceReference) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Identifies the version of a specific slot.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/Slot
type Slot struct {
	_ struct{} `type:"structure"`

	// A description of the slot.
	Description *string `locationName:"description" type:"string"`

	// The name of the slot.
	//
	// Name is a required field
	Name *string `locationName:"name" min:"1" type:"string" required:"true"`

	// Directs Lex the order in which to elicit this slot value from the user. For
	// example, if the intent has two slots with priorities 1 and 2, AWS Lex first
	// elicits a value for the slot with priority 1.
	//
	// If multiple slots share the same priority, the order in which Lex elicits
	// values is arbitrary.
	Priority *int64 `locationName:"priority" type:"integer"`

	// A set of possible responses for the slot type used by text-based clients.
	// A user chooses an option from the response card, instead of using text to
	// reply.
	ResponseCard *string `locationName:"responseCard" min:"1" type:"string"`

	// If you know a specific pattern with which users might respond to an Amazon
	// Lex request for a slot value, you can provide those utterances to improve
	// accuracy. This is optional. In most cases, Amazon Lex is capable of understanding
	// user utterances.
	SampleUtterances []string `locationName:"sampleUtterances" type:"list"`

	// Specifies whether the slot is required or optional.
	//
	// SlotConstraint is a required field
	SlotConstraint SlotConstraint `locationName:"slotConstraint" type:"string" required:"true" enum:"true"`

	// The type of the slot, either a custom slot type that you defined or one of
	// the built-in slot types.
	SlotType *string `locationName:"slotType" min:"1" type:"string"`

	// The version of the slot type.
	SlotTypeVersion *string `locationName:"slotTypeVersion" min:"1" type:"string"`

	// The prompt that Amazon Lex uses to elicit the slot value from the user.
	ValueElicitationPrompt *Prompt `locationName:"valueElicitationPrompt" type:"structure"`
}

// String returns the string representation
func (s Slot) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Slot) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Slot) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Slot"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.ResponseCard != nil && len(*s.ResponseCard) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResponseCard", 1))
	}
	if len(s.SlotConstraint) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("SlotConstraint"))
	}
	if s.SlotType != nil && len(*s.SlotType) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SlotType", 1))
	}
	if s.SlotTypeVersion != nil && len(*s.SlotTypeVersion) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SlotTypeVersion", 1))
	}
	if s.ValueElicitationPrompt != nil {
		if err := s.ValueElicitationPrompt.Validate(); err != nil {
			invalidParams.AddNested("ValueElicitationPrompt", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Slot) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "priority", protocol.Int64Value(v), metadata)
	}
	if s.ResponseCard != nil {
		v := *s.ResponseCard

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "responseCard", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SampleUtterances) > 0 {
		v := s.SampleUtterances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "sampleUtterances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.SlotConstraint) > 0 {
		v := s.SlotConstraint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "slotConstraint", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SlotType != nil {
		v := *s.SlotType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "slotType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SlotTypeVersion != nil {
		v := *s.SlotTypeVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "slotTypeVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ValueElicitationPrompt != nil {
		v := s.ValueElicitationPrompt

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "valueElicitationPrompt", v, metadata)
	}
	return nil
}

// Provides information about a slot type..
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/SlotTypeMetadata
type SlotTypeMetadata struct {
	_ struct{} `type:"structure"`

	// The date that the slot type was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the slot type.
	Description *string `locationName:"description" type:"string"`

	// The date that the slot type was updated. When you create a resource, the
	// creation date and last updated date are the same.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the slot type.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The version of the slot type.
	Version *string `locationName:"version" min:"1" type:"string"`
}

// String returns the string representation
func (s SlotTypeMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SlotTypeMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SlotTypeMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/StartImportRequest
type StartImportInput struct {
	_ struct{} `type:"structure"`

	// Specifies the action that the StartImport operation should take when there
	// is an existing resource with the same name.
	//
	//    * FAIL_ON_CONFLICT - The import operation is stopped on the first conflict
	//    between a resource in the import file and an existing resource. The name
	//    of the resource causing the conflict is in the failureReason field of
	//    the response to the GetImport operation.
	//
	// OVERWRITE_LATEST - The import operation proceeds even if there is a conflict
	//    with an existing resource. The $LASTEST version of the existing resource
	//    is overwritten with the data from the import file.
	//
	// MergeStrategy is a required field
	MergeStrategy MergeStrategy `locationName:"mergeStrategy" type:"string" required:"true" enum:"true"`

	// A zip archive in binary format. The archive should contain one file, a JSON
	// file containing the resource to import. The resource should match the type
	// specified in the resourceType field.
	//
	// Payload is automatically base64 encoded/decoded by the SDK.
	//
	// Payload is a required field
	Payload []byte `locationName:"payload" type:"blob" required:"true"`

	// Specifies the type of resource to export. Each resource also exports any
	// resources that it depends on.
	//
	//    * A bot exports dependent intents.
	//
	//    * An intent exports dependent slot types.
	//
	// ResourceType is a required field
	ResourceType ResourceType `locationName:"resourceType" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s StartImportInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartImportInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartImportInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartImportInput"}
	if len(s.MergeStrategy) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("MergeStrategy"))
	}

	if s.Payload == nil {
		invalidParams.Add(aws.NewErrParamRequired("Payload"))
	}
	if len(s.ResourceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResourceType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartImportInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.MergeStrategy) > 0 {
		v := s.MergeStrategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "mergeStrategy", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Payload != nil {
		v := s.Payload

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "payload", protocol.QuotedValue{ValueMarshaler: protocol.BytesValue(v)}, metadata)
	}
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "resourceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/StartImportResponse
type StartImportOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A timestamp for the date and time that the import job was requested.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// The identifier for the specific import job.
	ImportId *string `locationName:"importId" type:"string"`

	// The status of the import job. If the status is FAILED, you can get the reason
	// for the failure using the GetImport operation.
	ImportStatus ImportStatus `locationName:"importStatus" type:"string" enum:"true"`

	// The action to take when there is a merge conflict.
	MergeStrategy MergeStrategy `locationName:"mergeStrategy" type:"string" enum:"true"`

	// The name given to the import job.
	Name *string `locationName:"name" min:"1" type:"string"`

	// The type of resource to import.
	ResourceType ResourceType `locationName:"resourceType" type:"string" enum:"true"`
}

// String returns the string representation
func (s StartImportOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartImportOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartImportOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartImportOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ImportId != nil {
		v := *s.ImportId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "importId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ImportStatus) > 0 {
		v := s.ImportStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "importStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.MergeStrategy) > 0 {
		v := s.MergeStrategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "mergeStrategy", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "resourceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// A collection of messages that convey information to the user. At runtime,
// Amazon Lex selects the message to convey.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/Statement
type Statement struct {
	_ struct{} `type:"structure"`

	// A collection of message objects.
	//
	// Messages is a required field
	Messages []Message `locationName:"messages" min:"1" type:"list" required:"true"`

	// At runtime, if the client is using the PostText (http://docs.aws.amazon.com/lex/latest/dg/API_runtime_PostText.html)
	// API, Amazon Lex includes the response card in the response. It substitutes
	// all of the session attributes and slot values for placeholders in the response
	// card.
	ResponseCard *string `locationName:"responseCard" min:"1" type:"string"`
}

// String returns the string representation
func (s Statement) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Statement) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Statement) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Statement"}

	if s.Messages == nil {
		invalidParams.Add(aws.NewErrParamRequired("Messages"))
	}
	if s.Messages != nil && len(s.Messages) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Messages", 1))
	}
	if s.ResponseCard != nil && len(*s.ResponseCard) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResponseCard", 1))
	}
	if s.Messages != nil {
		for i, v := range s.Messages {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Messages", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Statement) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Messages) > 0 {
		v := s.Messages

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "messages", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResponseCard != nil {
		v := *s.ResponseCard

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "responseCard", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides information about a single utterance that was made to your bot.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/UtteranceData
type UtteranceData struct {
	_ struct{} `type:"structure"`

	// The number of times that the utterance was processed.
	Count *int64 `locationName:"count" type:"integer"`

	// The total number of individuals that used the utterance.
	DistinctUsers *int64 `locationName:"distinctUsers" type:"integer"`

	// The date that the utterance was first recorded.
	FirstUtteredDate *time.Time `locationName:"firstUtteredDate" type:"timestamp" timestampFormat:"unix"`

	// The date that the utterance was last recorded.
	LastUtteredDate *time.Time `locationName:"lastUtteredDate" type:"timestamp" timestampFormat:"unix"`

	// The text that was entered by the user or the text representation of an audio
	// clip.
	UtteranceString *string `locationName:"utteranceString" min:"1" type:"string"`
}

// String returns the string representation
func (s UtteranceData) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UtteranceData) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UtteranceData) MarshalFields(e protocol.FieldEncoder) error {
	if s.Count != nil {
		v := *s.Count

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "count", protocol.Int64Value(v), metadata)
	}
	if s.DistinctUsers != nil {
		v := *s.DistinctUsers

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "distinctUsers", protocol.Int64Value(v), metadata)
	}
	if s.FirstUtteredDate != nil {
		v := *s.FirstUtteredDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "firstUtteredDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.LastUtteredDate != nil {
		v := *s.LastUtteredDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUtteredDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.UtteranceString != nil {
		v := *s.UtteranceString

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "utteranceString", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides a list of utterances that have been made to a specific version of
// your bot. The list contains a maximum of 100 utterances.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lex-models-2017-04-19/UtteranceList
type UtteranceList struct {
	_ struct{} `type:"structure"`

	// The version of the bot that processed the list.
	BotVersion *string `locationName:"botVersion" min:"1" type:"string"`

	// One or more UtteranceData objects that contain information about the utterances
	// that have been made to a bot. The maximum number of object is 100.
	Utterances []UtteranceData `locationName:"utterances" type:"list"`
}

// String returns the string representation
func (s UtteranceList) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UtteranceList) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UtteranceList) MarshalFields(e protocol.FieldEncoder) error {
	if s.BotVersion != nil {
		v := *s.BotVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "botVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Utterances) > 0 {
		v := s.Utterances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "utterances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type ChannelStatus string

// Enum values for ChannelStatus
const (
	ChannelStatusInProgress ChannelStatus = "IN_PROGRESS"
	ChannelStatusCreated    ChannelStatus = "CREATED"
	ChannelStatusFailed     ChannelStatus = "FAILED"
)

func (enum ChannelStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ChannelStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ChannelType string

// Enum values for ChannelType
const (
	ChannelTypeFacebook  ChannelType = "Facebook"
	ChannelTypeSlack     ChannelType = "Slack"
	ChannelTypeTwilioSms ChannelType = "Twilio-Sms"
	ChannelTypeKik       ChannelType = "Kik"
)

func (enum ChannelType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ChannelType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ContentType string

// Enum values for ContentType
const (
	ContentTypePlainText     ContentType = "PlainText"
	ContentTypeSsml          ContentType = "SSML"
	ContentTypeCustomPayload ContentType = "CustomPayload"
)

func (enum ContentType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ContentType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ExportStatus string

// Enum values for ExportStatus
const (
	ExportStatusInProgress ExportStatus = "IN_PROGRESS"
	ExportStatusReady      ExportStatus = "READY"
	ExportStatusFailed     ExportStatus = "FAILED"
)

func (enum ExportStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ExportStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ExportType string

// Enum values for ExportType
const (
	ExportTypeAlexaSkillsKit ExportType = "ALEXA_SKILLS_KIT"
	ExportTypeLex            ExportType = "LEX"
)

func (enum ExportType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ExportType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type FulfillmentActivityType string

// Enum values for FulfillmentActivityType
const (
	FulfillmentActivityTypeReturnIntent FulfillmentActivityType = "ReturnIntent"
	FulfillmentActivityTypeCodeHook     FulfillmentActivityType = "CodeHook"
)

func (enum FulfillmentActivityType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum FulfillmentActivityType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ImportStatus string

// Enum values for ImportStatus
const (
	ImportStatusInProgress ImportStatus = "IN_PROGRESS"
	ImportStatusComplete   ImportStatus = "COMPLETE"
	ImportStatusFailed     ImportStatus = "FAILED"
)

func (enum ImportStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ImportStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Locale string

// Enum values for Locale
const (
	LocaleEnUs Locale = "en-US"
	LocaleEnGb Locale = "en-GB"
	LocaleDeDe Locale = "de-DE"
)

func (enum Locale) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Locale) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type MergeStrategy string

// Enum values for MergeStrategy
const (
	MergeStrategyOverwriteLatest MergeStrategy = "OVERWRITE_LATEST"
	MergeStrategyFailOnConflict  MergeStrategy = "FAIL_ON_CONFLICT"
)

func (enum MergeStrategy) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum MergeStrategy) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ProcessBehavior string

// Enum values for ProcessBehavior
const (
	ProcessBehaviorSave  ProcessBehavior = "SAVE"
	ProcessBehaviorBuild ProcessBehavior = "BUILD"
)

func (enum ProcessBehavior) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ProcessBehavior) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ReferenceType string

// Enum values for ReferenceType
const (
	ReferenceTypeIntent     ReferenceType = "Intent"
	ReferenceTypeBot        ReferenceType = "Bot"
	ReferenceTypeBotAlias   ReferenceType = "BotAlias"
	ReferenceTypeBotChannel ReferenceType = "BotChannel"
)

func (enum ReferenceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReferenceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ResourceType string

// Enum values for ResourceType
const (
	ResourceTypeBot      ResourceType = "BOT"
	ResourceTypeIntent   ResourceType = "INTENT"
	ResourceTypeSlotType ResourceType = "SLOT_TYPE"
)

func (enum ResourceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ResourceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SlotConstraint string

// Enum values for SlotConstraint
const (
	SlotConstraintRequired SlotConstraint = "Required"
	SlotConstraintOptional SlotConstraint = "Optional"
)

func (enum SlotConstraint) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SlotConstraint) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SlotValueSelectionStrategy string

// Enum values for SlotValueSelectionStrategy
const (
	SlotValueSelectionStrategyOriginalValue SlotValueSelectionStrategy = "ORIGINAL_VALUE"
	SlotValueSelectionStrategyTopResolution SlotValueSelectionStrategy = "TOP_RESOLUTION"
)

func (enum SlotValueSelectionStrategy) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SlotValueSelectionStrategy) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Status string

// Enum values for Status
const (
	StatusBuilding Status = "BUILDING"
	StatusReady    Status = "READY"
	StatusFailed   Status = "FAILED"
	StatusNotBuilt Status = "NOT_BUILT"
)

func (enum Status) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Status) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type StatusType string

// Enum values for StatusType
const (
	StatusTypeDetected StatusType = "Detected"
	StatusTypeMissed   StatusType = "Missed"
)

func (enum StatusType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum StatusType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
