// Code generated by smithy-go-codegen DO NOT EDIT.

package types

import (
	"time"
)

// Describes the timestamp range and timestamp origin of a range of fragments.
// Fragments that have duplicate producer timestamps are deduplicated. This means
// that if producers are producing a stream of fragments with producer timestamps
// that are approximately equal to the true clock time, the clip will contain all
// of the fragments within the requested timestamp range. If some fragments are
// ingested within the same time range and very different points in time, only the
// oldest ingested collection of fragments are returned.
type ClipFragmentSelector struct {
	// The range of timestamps to return.
	TimestampRange *ClipTimestampRange
	// The origin of the timestamps to use (Server or Producer).
	FragmentSelectorType ClipFragmentSelectorType
}

// The range of timestamps for which to return fragments. The values in the
// ClipTimestampRange are inclusive. Fragments that begin before the start time but
// continue past it, or fragments that begin before the end time but continue past
// it, are included in the session.
type ClipTimestampRange struct {
	// The starting timestamp in the range of timestamps for which to return fragments.
	// This value is inclusive. Fragments that start before the StartTimestamp and
	// continue past it are included in the session. If FragmentSelectorType is
	// SERVER_TIMESTAMP, the StartTimestamp must be later than the stream head.
	StartTimestamp *time.Time
	// The end of the timestamp range for the requested media. This value must be
	// within 3 hours of the specified StartTimestamp, and it must be later than the
	// StartTimestamp value. If FragmentSelectorType for the request is
	// SERVER_TIMESTAMP, this value must be in the past. This value is inclusive. The
	// EndTimestamp is compared to the (starting) timestamp of the fragment. Fragments
	// that start before the EndTimestamp value and continue past it are included in
	// the session.
	EndTimestamp *time.Time
}

// Contains the range of timestamps for the requested media, and the source of the
// timestamps.
type DASHFragmentSelector struct {
	// The start and end of the timestamp range for the requested media. This value
	// should not be present if PlaybackType is LIVE.
	TimestampRange *DASHTimestampRange
	// The source of the timestamps for the requested media. When FragmentSelectorType
	// is set to PRODUCER_TIMESTAMP and GetDASHStreamingSessionURLInput$PlaybackMode ()
	// is ON_DEMAND or LIVE_REPLAY, the first fragment ingested with a producer
	// timestamp within the specified FragmentSelector$TimestampRange () is included in
	// the media playlist. In addition, the fragments with producer timestamps within
	// the TimestampRange ingested immediately following the first fragment (up to the
	// GetDASHStreamingSessionURLInput$MaxManifestFragmentResults () value) are
	// included. Fragments that have duplicate producer timestamps are deduplicated.
	// This means that if producers are producing a stream of fragments with producer
	// timestamps that are approximately equal to the true clock time, the MPEG-DASH
	// manifest will contain all of the fragments within the requested timestamp range.
	// If some fragments are ingested within the same time range and very different
	// points in time, only the oldest ingested collection of fragments are returned.
	// When FragmentSelectorType is set to PRODUCER_TIMESTAMP and
	// GetDASHStreamingSessionURLInput$PlaybackMode () is LIVE, the producer timestamps
	// are used in the MP4 fragments and for deduplication. But the most recently
	// ingested fragments based on server timestamps are included in the MPEG-DASH
	// manifest. This means that even if fragments ingested in the past have producer
	// timestamps with values now, they are not included in the HLS media playlist. The
	// default is SERVER_TIMESTAMP.
	FragmentSelectorType DASHFragmentSelectorType
}

// The start and end of the timestamp range for the requested media. This value
// should not be present if PlaybackType is LIVE. The values in the
// DASHimestampRange are inclusive. Fragments that begin before the start time but
// continue past it, or fragments that begin before the end time but continue past
// it, are included in the session.
type DASHTimestampRange struct {
	// The start of the timestamp range for the requested media. If the
	// DASHTimestampRange value is specified, the StartTimestamp value is required.
	// This value is inclusive. Fragments that start before the StartTimestamp and
	// continue past it are included in the session. If FragmentSelectorType is
	// SERVER_TIMESTAMP, the StartTimestamp must be later than the stream head.
	StartTimestamp *time.Time
	// The end of the timestamp range for the requested media. This value must be
	// within 3 hours of the specified StartTimestamp, and it must be later than the
	// StartTimestamp value. If FragmentSelectorType for the request is
	// SERVER_TIMESTAMP, this value must be in the past.  <p>The
	// <code>EndTimestamp</code> value is required for <code>ON_DEMAND</code> mode, but
	// optional for <code>LIVE_REPLAY</code> mode. If the <code>EndTimestamp</code> is
	// not set for <code>LIVE_REPLAY</code> mode then the session will continue to
	// include newly ingested fragments until the session expires.</p> <note> <p>This
	// value is inclusive. The <code>EndTimestamp</code> is compared to the (starting)
	// timestamp of the fragment. Fragments that start before the
	// <code>EndTimestamp</code> value and continue past it are included in the
	// session.</p> </note>
	EndTimestamp *time.Time
}

// Represents a segment of video or other time-delimited data.
type Fragment struct {
	// The timestamp from the AWS server corresponding to the fragment.
	ServerTimestamp *time.Time
	// The playback duration or other time value associated with the fragment.
	FragmentLengthInMilliseconds *int64
	// The total fragment size, including information about the fragment and contained
	// media data.
	FragmentSizeInBytes *int64
	// The unique identifier of the fragment. This value monotonically increases based
	// on the ingestion order.
	FragmentNumber *string
	// The timestamp from the producer corresponding to the fragment.
	ProducerTimestamp *time.Time
}

// Describes the timestamp range and timestamp origin of a range of fragments. Only
// fragments with a start timestamp greater than or equal to the given start time
// and less than or equal to the end time are returned. For example, if a stream
// contains fragments with the following start timestamps:
//
//     * 00:00:00
//
//     *
// 00:00:02
//
//     * 00:00:04
//
//     * 00:00:06
//
// A fragment selector range with a start
// time of 00:00:01 and end time of 00:00:04 would return the fragments with start
// times of 00:00:02 and 00:00:04.
type FragmentSelector struct {
	// The origin of the timestamps to use (Server or Producer).
	FragmentSelectorType FragmentSelectorType
	// The range of timestamps to return.
	TimestampRange *TimestampRange
}

// Contains the range of timestamps for the requested media, and the source of the
// timestamps.
type HLSFragmentSelector struct {
	// The start and end of the timestamp range for the requested media. This value
	// should not be present if PlaybackType is LIVE.
	TimestampRange *HLSTimestampRange
	// The source of the timestamps for the requested media. When FragmentSelectorType
	// is set to PRODUCER_TIMESTAMP and GetHLSStreamingSessionURLInput$PlaybackMode ()
	// is ON_DEMAND or LIVE_REPLAY, the first fragment ingested with a producer
	// timestamp within the specified FragmentSelector$TimestampRange () is included in
	// the media playlist. In addition, the fragments with producer timestamps within
	// the TimestampRange ingested immediately following the first fragment (up to the
	// GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults () value) are
	// included. Fragments that have duplicate producer timestamps are deduplicated.
	// This means that if producers are producing a stream of fragments with producer
	// timestamps that are approximately equal to the true clock time, the HLS media
	// playlists will contain all of the fragments within the requested timestamp
	// range. If some fragments are ingested within the same time range and very
	// different points in time, only the oldest ingested collection of fragments are
	// returned. When FragmentSelectorType is set to PRODUCER_TIMESTAMP and
	// GetHLSStreamingSessionURLInput$PlaybackMode () is LIVE, the producer timestamps
	// are used in the MP4 fragments and for deduplication. But the most recently
	// ingested fragments based on server timestamps are included in the HLS media
	// playlist. This means that even if fragments ingested in the past have producer
	// timestamps with values now, they are not included in the HLS media playlist. The
	// default is SERVER_TIMESTAMP.
	FragmentSelectorType HLSFragmentSelectorType
}

// The start and end of the timestamp range for the requested media. This value
// should not be present if PlaybackType is LIVE. The values in the
// HLSTimestampRange are inclusive. Fragments that begin before the start time but
// continue past it, or fragments that begin before the end time but continue past
// it, are included in the session.
type HLSTimestampRange struct {
	// The start of the timestamp range for the requested media. If the
	// HLSTimestampRange value is specified, the StartTimestamp value is required. This
	// value is inclusive. Fragments that start before the StartTimestamp and continue
	// past it are included in the session. If FragmentSelectorType is
	// SERVER_TIMESTAMP, the StartTimestamp must be later than the stream head.
	StartTimestamp *time.Time
	// The end of the timestamp range for the requested media. This value must be
	// within 3 hours of the specified StartTimestamp, and it must be later than the
	// StartTimestamp value. If FragmentSelectorType for the request is
	// SERVER_TIMESTAMP, this value must be in the past. The EndTimestamp value is
	// required for ON_DEMAND mode, but optional for LIVE_REPLAY mode. If the
	// EndTimestamp is not set for LIVE_REPLAY mode then the session will continue to
	// include newly ingested fragments until the session expires. This value is
	// inclusive. The EndTimestamp is compared to the (starting) timestamp of the
	// fragment. Fragments that start before the EndTimestamp value and continue past
	// it are included in the session.
	EndTimestamp *time.Time
}

// The range of timestamps for which to return fragments.
type TimestampRange struct {
	// The starting timestamp in the range of timestamps for which to return fragments.
	StartTimestamp *time.Time
	// The ending timestamp in the range of timestamps for which to return fragments.
	EndTimestamp *time.Time
}
