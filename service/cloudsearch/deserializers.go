// Code generated by smithy-go-codegen DO NOT EDIT.

package cloudsearch

import (
	"bytes"
	"context"
	"encoding/xml"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/cloudsearch/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithytime "github.com/awslabs/smithy-go/time"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	smithyxml "github.com/awslabs/smithy-go/xml"
	"io"
	"strconv"
	"strings"
)

type awsAwsquery_deserializeOpBuildSuggesters struct {
}

func (*awsAwsquery_deserializeOpBuildSuggesters) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpBuildSuggesters) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorBuildSuggesters(response)
	}
	output := &BuildSuggestersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentBuildSuggestersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorBuildSuggesters(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpCreateDomain struct {
}

func (*awsAwsquery_deserializeOpCreateDomain) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpCreateDomain) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorCreateDomain(response)
	}
	output := &CreateDomainOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentCreateDomainOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorCreateDomain(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDefineAnalysisScheme struct {
}

func (*awsAwsquery_deserializeOpDefineAnalysisScheme) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDefineAnalysisScheme) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDefineAnalysisScheme(response)
	}
	output := &DefineAnalysisSchemeOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDefineAnalysisSchemeOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDefineAnalysisScheme(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDefineExpression struct {
}

func (*awsAwsquery_deserializeOpDefineExpression) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDefineExpression) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDefineExpression(response)
	}
	output := &DefineExpressionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDefineExpressionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDefineExpression(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDefineIndexField struct {
}

func (*awsAwsquery_deserializeOpDefineIndexField) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDefineIndexField) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDefineIndexField(response)
	}
	output := &DefineIndexFieldOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDefineIndexFieldOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDefineIndexField(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDefineSuggester struct {
}

func (*awsAwsquery_deserializeOpDefineSuggester) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDefineSuggester) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDefineSuggester(response)
	}
	output := &DefineSuggesterOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDefineSuggesterOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDefineSuggester(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteAnalysisScheme struct {
}

func (*awsAwsquery_deserializeOpDeleteAnalysisScheme) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteAnalysisScheme) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteAnalysisScheme(response)
	}
	output := &DeleteAnalysisSchemeOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDeleteAnalysisSchemeOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteAnalysisScheme(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteDomain struct {
}

func (*awsAwsquery_deserializeOpDeleteDomain) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteDomain) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteDomain(response)
	}
	output := &DeleteDomainOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDeleteDomainOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteDomain(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteExpression struct {
}

func (*awsAwsquery_deserializeOpDeleteExpression) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteExpression) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteExpression(response)
	}
	output := &DeleteExpressionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDeleteExpressionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteExpression(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteIndexField struct {
}

func (*awsAwsquery_deserializeOpDeleteIndexField) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteIndexField) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteIndexField(response)
	}
	output := &DeleteIndexFieldOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDeleteIndexFieldOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteIndexField(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteSuggester struct {
}

func (*awsAwsquery_deserializeOpDeleteSuggester) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteSuggester) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteSuggester(response)
	}
	output := &DeleteSuggesterOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDeleteSuggesterOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteSuggester(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeAnalysisSchemes struct {
}

func (*awsAwsquery_deserializeOpDescribeAnalysisSchemes) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeAnalysisSchemes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeAnalysisSchemes(response)
	}
	output := &DescribeAnalysisSchemesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeAnalysisSchemesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeAnalysisSchemes(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeAvailabilityOptions struct {
}

func (*awsAwsquery_deserializeOpDescribeAvailabilityOptions) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeAvailabilityOptions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeAvailabilityOptions(response)
	}
	output := &DescribeAvailabilityOptionsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeAvailabilityOptionsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeAvailabilityOptions(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("DisabledOperationException", errorCode):
		return awsAwsquery_deserializeErrorDisabledOperationException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeDomainEndpointOptions struct {
}

func (*awsAwsquery_deserializeOpDescribeDomainEndpointOptions) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeDomainEndpointOptions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeDomainEndpointOptions(response)
	}
	output := &DescribeDomainEndpointOptionsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeDomainEndpointOptionsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeDomainEndpointOptions(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("DisabledOperationException", errorCode):
		return awsAwsquery_deserializeErrorDisabledOperationException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeDomains struct {
}

func (*awsAwsquery_deserializeOpDescribeDomains) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeDomains) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeDomains(response)
	}
	output := &DescribeDomainsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeDomainsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeDomains(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeExpressions struct {
}

func (*awsAwsquery_deserializeOpDescribeExpressions) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeExpressions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeExpressions(response)
	}
	output := &DescribeExpressionsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeExpressionsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeExpressions(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeIndexFields struct {
}

func (*awsAwsquery_deserializeOpDescribeIndexFields) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeIndexFields) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeIndexFields(response)
	}
	output := &DescribeIndexFieldsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeIndexFieldsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeIndexFields(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeScalingParameters struct {
}

func (*awsAwsquery_deserializeOpDescribeScalingParameters) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeScalingParameters) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeScalingParameters(response)
	}
	output := &DescribeScalingParametersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeScalingParametersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeScalingParameters(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeServiceAccessPolicies struct {
}

func (*awsAwsquery_deserializeOpDescribeServiceAccessPolicies) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeServiceAccessPolicies) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeServiceAccessPolicies(response)
	}
	output := &DescribeServiceAccessPoliciesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeServiceAccessPoliciesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeServiceAccessPolicies(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeSuggesters struct {
}

func (*awsAwsquery_deserializeOpDescribeSuggesters) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeSuggesters) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeSuggesters(response)
	}
	output := &DescribeSuggestersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDescribeSuggestersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeSuggesters(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpIndexDocuments struct {
}

func (*awsAwsquery_deserializeOpIndexDocuments) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpIndexDocuments) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorIndexDocuments(response)
	}
	output := &IndexDocumentsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentIndexDocumentsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorIndexDocuments(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpListDomainNames struct {
}

func (*awsAwsquery_deserializeOpListDomainNames) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpListDomainNames) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorListDomainNames(response)
	}
	output := &ListDomainNamesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentListDomainNamesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorListDomainNames(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpUpdateAvailabilityOptions struct {
}

func (*awsAwsquery_deserializeOpUpdateAvailabilityOptions) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpUpdateAvailabilityOptions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorUpdateAvailabilityOptions(response)
	}
	output := &UpdateAvailabilityOptionsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentUpdateAvailabilityOptionsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorUpdateAvailabilityOptions(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("DisabledOperationException", errorCode):
		return awsAwsquery_deserializeErrorDisabledOperationException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	case strings.EqualFold("ValidationException", errorCode):
		return awsAwsquery_deserializeErrorValidationException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpUpdateDomainEndpointOptions struct {
}

func (*awsAwsquery_deserializeOpUpdateDomainEndpointOptions) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpUpdateDomainEndpointOptions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorUpdateDomainEndpointOptions(response)
	}
	output := &UpdateDomainEndpointOptionsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentUpdateDomainEndpointOptionsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorUpdateDomainEndpointOptions(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("DisabledOperationException", errorCode):
		return awsAwsquery_deserializeErrorDisabledOperationException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	case strings.EqualFold("ValidationException", errorCode):
		return awsAwsquery_deserializeErrorValidationException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpUpdateScalingParameters struct {
}

func (*awsAwsquery_deserializeOpUpdateScalingParameters) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpUpdateScalingParameters) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorUpdateScalingParameters(response)
	}
	output := &UpdateScalingParametersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentUpdateScalingParametersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorUpdateScalingParameters(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpUpdateServiceAccessPolicies struct {
}

func (*awsAwsquery_deserializeOpUpdateServiceAccessPolicies) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpUpdateServiceAccessPolicies) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorUpdateServiceAccessPolicies(response)
	}
	output := &UpdateServiceAccessPoliciesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentUpdateServiceAccessPoliciesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorUpdateServiceAccessPolicies(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("BaseException", errorCode):
		return awsAwsquery_deserializeErrorBaseException(response, errorBody)

	case strings.EqualFold("InternalException", errorCode):
		return awsAwsquery_deserializeErrorInternalException(response, errorBody)

	case strings.EqualFold("InvalidTypeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTypeException(response, errorBody)

	case strings.EqualFold("LimitExceededException", errorCode):
		return awsAwsquery_deserializeErrorLimitExceededException(response, errorBody)

	case strings.EqualFold("ResourceNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorResourceNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsAwsquery_deserializeErrorBaseException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.BaseException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentBaseException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorDisabledOperationException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DisabledOperationException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDisabledOperationException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorInternalException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InternalException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentInternalException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorInvalidTypeException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidTypeException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentInvalidTypeException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorLimitExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.LimitExceededException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentLimitExceededException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorResourceNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ResourceNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentResourceNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorValidationException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ValidationException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentValidationException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeDocumentAccessPoliciesStatus(v **types.AccessPoliciesStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AccessPoliciesStatus
	if *v == nil {
		sv = &types.AccessPoliciesStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Options", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Options = &xtv
			}

		case strings.EqualFold("Status", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentOptionStatus(&sv.Status, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAnalysisOptions(v **types.AnalysisOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AnalysisOptions
	if *v == nil {
		sv = &types.AnalysisOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AlgorithmicStemming", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.AlgorithmicStemming = types.AlgorithmicStemming(xtv)
			}

		case strings.EqualFold("JapaneseTokenizationDictionary", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.JapaneseTokenizationDictionary = &xtv
			}

		case strings.EqualFold("StemmingDictionary", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.StemmingDictionary = &xtv
			}

		case strings.EqualFold("Stopwords", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Stopwords = &xtv
			}

		case strings.EqualFold("Synonyms", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Synonyms = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAnalysisScheme(v **types.AnalysisScheme, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AnalysisScheme
	if *v == nil {
		sv = &types.AnalysisScheme{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AnalysisOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAnalysisOptions(&sv.AnalysisOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("AnalysisSchemeLanguage", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.AnalysisSchemeLanguage = types.AnalysisSchemeLanguage(xtv)
			}

		case strings.EqualFold("AnalysisSchemeName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.AnalysisSchemeName = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAnalysisSchemeStatus(v **types.AnalysisSchemeStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AnalysisSchemeStatus
	if *v == nil {
		sv = &types.AnalysisSchemeStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Options", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAnalysisScheme(&sv.Options, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Status", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentOptionStatus(&sv.Status, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAnalysisSchemeStatusList(v *[]*types.AnalysisSchemeStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.AnalysisSchemeStatus
	if *v == nil {
		sv = make([]*types.AnalysisSchemeStatus, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.AnalysisSchemeStatus
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentAnalysisSchemeStatus(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAnalysisSchemeStatusListUnwrapped(v *[]*types.AnalysisSchemeStatus, decoder smithyxml.NodeDecoder) error {
	var sv []*types.AnalysisSchemeStatus
	if *v == nil {
		sv = make([]*types.AnalysisSchemeStatus, 0)
	} else {
		sv = *v
	}

	for {
		var mv *types.AnalysisSchemeStatus
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentAnalysisSchemeStatus(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentAvailabilityOptionsStatus(v **types.AvailabilityOptionsStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AvailabilityOptionsStatus
	if *v == nil {
		sv = &types.AvailabilityOptionsStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Options", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected MultiAZ to be of type *bool, got %T instead", val)
				}
				sv.Options = &xtv
			}

		case strings.EqualFold("Status", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentOptionStatus(&sv.Status, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentBaseException(v **types.BaseException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.BaseException
	if *v == nil {
		sv = &types.BaseException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Code", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Code = &xtv
			}

		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDateArrayOptions(v **types.DateArrayOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DateArrayOptions
	if *v == nil {
		sv = &types.DateArrayOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DefaultValue = &xtv
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SourceFields", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceFields = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDateOptions(v **types.DateOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DateOptions
	if *v == nil {
		sv = &types.DateOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DefaultValue = &xtv
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SortEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SortEnabled = &xtv
			}

		case strings.EqualFold("SourceField", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceField = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDisabledOperationException(v **types.DisabledOperationException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DisabledOperationException
	if *v == nil {
		sv = &types.DisabledOperationException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Code", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Code = &xtv
			}

		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDocumentSuggesterOptions(v **types.DocumentSuggesterOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DocumentSuggesterOptions
	if *v == nil {
		sv = &types.DocumentSuggesterOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("FuzzyMatching", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.FuzzyMatching = types.SuggesterFuzzyMatching(xtv)
			}

		case strings.EqualFold("SortExpression", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SortExpression = &xtv
			}

		case strings.EqualFold("SourceField", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceField = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDomainEndpointOptions(v **types.DomainEndpointOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DomainEndpointOptions
	if *v == nil {
		sv = &types.DomainEndpointOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("EnforceHTTPS", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.EnforceHTTPS = &xtv
			}

		case strings.EqualFold("TLSSecurityPolicy", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TLSSecurityPolicy = types.TLSSecurityPolicy(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDomainEndpointOptionsStatus(v **types.DomainEndpointOptionsStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DomainEndpointOptionsStatus
	if *v == nil {
		sv = &types.DomainEndpointOptionsStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Options", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDomainEndpointOptions(&sv.Options, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Status", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentOptionStatus(&sv.Status, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDomainNameMap(v *map[string]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv map[string]*string
	if *v == nil {
		sv = make(map[string]*string, 0)
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if strings.EqualFold("entry", t.Name.Local) {
			entryDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDomainNameMapUnwrapped(&sv, entryDecoder); err != nil {
				return err
			}
		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDomainNameMapUnwrapped(v *map[string]*string, decoder smithyxml.NodeDecoder) error {
	var sv map[string]*string
	if *v == nil {
		sv = make(map[string]*string, 0)
	} else {
		sv = *v
	}

	var ek *string
	var ev *string
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			sv[*ek] = ev
			break
		}
		switch {
		case strings.EqualFold("key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				ek = &xtv
			}

		case strings.EqualFold("value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				ev = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentDomainStatus(v **types.DomainStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DomainStatus
	if *v == nil {
		sv = &types.DomainStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("ARN", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ARN = &xtv
			}

		case strings.EqualFold("Created", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.Created = &xtv
			}

		case strings.EqualFold("Deleted", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.Deleted = &xtv
			}

		case strings.EqualFold("DocService", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentServiceEndpoint(&sv.DocService, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("DomainId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DomainId = &xtv
			}

		case strings.EqualFold("DomainName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DomainName = &xtv
			}

		case strings.EqualFold("Limits", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLimits(&sv.Limits, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Processing", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.Processing = &xtv
			}

		case strings.EqualFold("RequiresIndexDocuments", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.RequiresIndexDocuments = &xtv
			}

		case strings.EqualFold("SearchInstanceCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.SearchInstanceCount = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("SearchInstanceType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SearchInstanceType = &xtv
			}

		case strings.EqualFold("SearchPartitionCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.SearchPartitionCount = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("SearchService", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentServiceEndpoint(&sv.SearchService, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDomainStatusList(v *[]*types.DomainStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.DomainStatus
	if *v == nil {
		sv = make([]*types.DomainStatus, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.DomainStatus
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentDomainStatus(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDomainStatusListUnwrapped(v *[]*types.DomainStatus, decoder smithyxml.NodeDecoder) error {
	var sv []*types.DomainStatus
	if *v == nil {
		sv = make([]*types.DomainStatus, 0)
	} else {
		sv = *v
	}

	for {
		var mv *types.DomainStatus
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentDomainStatus(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentDoubleArrayOptions(v **types.DoubleArrayOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DoubleArrayOptions
	if *v == nil {
		sv = &types.DoubleArrayOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				f64, err := strconv.ParseFloat(xtv, 64)
				if err != nil {
					return err
				}
				sv.DefaultValue = &f64
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SourceFields", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceFields = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDoubleOptions(v **types.DoubleOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DoubleOptions
	if *v == nil {
		sv = &types.DoubleOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				f64, err := strconv.ParseFloat(xtv, 64)
				if err != nil {
					return err
				}
				sv.DefaultValue = &f64
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SortEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SortEnabled = &xtv
			}

		case strings.EqualFold("SourceField", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceField = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentExpression(v **types.Expression, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Expression
	if *v == nil {
		sv = &types.Expression{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("ExpressionName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ExpressionName = &xtv
			}

		case strings.EqualFold("ExpressionValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ExpressionValue = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentExpressionStatus(v **types.ExpressionStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ExpressionStatus
	if *v == nil {
		sv = &types.ExpressionStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Options", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentExpression(&sv.Options, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Status", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentOptionStatus(&sv.Status, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentExpressionStatusList(v *[]*types.ExpressionStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.ExpressionStatus
	if *v == nil {
		sv = make([]*types.ExpressionStatus, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.ExpressionStatus
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentExpressionStatus(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentExpressionStatusListUnwrapped(v *[]*types.ExpressionStatus, decoder smithyxml.NodeDecoder) error {
	var sv []*types.ExpressionStatus
	if *v == nil {
		sv = make([]*types.ExpressionStatus, 0)
	} else {
		sv = *v
	}

	for {
		var mv *types.ExpressionStatus
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentExpressionStatus(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentFieldNameList(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentFieldNameListUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	for {
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentIndexField(v **types.IndexField, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.IndexField
	if *v == nil {
		sv = &types.IndexField{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DateArrayOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDateArrayOptions(&sv.DateArrayOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("DateOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDateOptions(&sv.DateOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("DoubleArrayOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDoubleArrayOptions(&sv.DoubleArrayOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("DoubleOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDoubleOptions(&sv.DoubleOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("IndexFieldName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.IndexFieldName = &xtv
			}

		case strings.EqualFold("IndexFieldType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.IndexFieldType = types.IndexFieldType(xtv)
			}

		case strings.EqualFold("IntArrayOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentIntArrayOptions(&sv.IntArrayOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("IntOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentIntOptions(&sv.IntOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("LatLonOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLatLonOptions(&sv.LatLonOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("LiteralArrayOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLiteralArrayOptions(&sv.LiteralArrayOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("LiteralOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLiteralOptions(&sv.LiteralOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TextArrayOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTextArrayOptions(&sv.TextArrayOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TextOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTextOptions(&sv.TextOptions, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentIndexFieldStatus(v **types.IndexFieldStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.IndexFieldStatus
	if *v == nil {
		sv = &types.IndexFieldStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Options", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentIndexField(&sv.Options, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Status", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentOptionStatus(&sv.Status, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentIndexFieldStatusList(v *[]*types.IndexFieldStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.IndexFieldStatus
	if *v == nil {
		sv = make([]*types.IndexFieldStatus, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.IndexFieldStatus
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentIndexFieldStatus(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentIndexFieldStatusListUnwrapped(v *[]*types.IndexFieldStatus, decoder smithyxml.NodeDecoder) error {
	var sv []*types.IndexFieldStatus
	if *v == nil {
		sv = make([]*types.IndexFieldStatus, 0)
	} else {
		sv = *v
	}

	for {
		var mv *types.IndexFieldStatus
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentIndexFieldStatus(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentIntArrayOptions(v **types.IntArrayOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.IntArrayOptions
	if *v == nil {
		sv = &types.IntArrayOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.DefaultValue = &i64
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SourceFields", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceFields = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentInternalException(v **types.InternalException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InternalException
	if *v == nil {
		sv = &types.InternalException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Code", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Code = &xtv
			}

		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentIntOptions(v **types.IntOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.IntOptions
	if *v == nil {
		sv = &types.IntOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.DefaultValue = &i64
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SortEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SortEnabled = &xtv
			}

		case strings.EqualFold("SourceField", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceField = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentInvalidTypeException(v **types.InvalidTypeException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidTypeException
	if *v == nil {
		sv = &types.InvalidTypeException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Code", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Code = &xtv
			}

		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLatLonOptions(v **types.LatLonOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LatLonOptions
	if *v == nil {
		sv = &types.LatLonOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DefaultValue = &xtv
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SortEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SortEnabled = &xtv
			}

		case strings.EqualFold("SourceField", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceField = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLimitExceededException(v **types.LimitExceededException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LimitExceededException
	if *v == nil {
		sv = &types.LimitExceededException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Code", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Code = &xtv
			}

		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLimits(v **types.Limits, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Limits
	if *v == nil {
		sv = &types.Limits{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("MaximumPartitionCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.MaximumPartitionCount = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("MaximumReplicationCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.MaximumReplicationCount = ptr.Int32(int32(i64))
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLiteralArrayOptions(v **types.LiteralArrayOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LiteralArrayOptions
	if *v == nil {
		sv = &types.LiteralArrayOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DefaultValue = &xtv
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SourceFields", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceFields = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLiteralOptions(v **types.LiteralOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LiteralOptions
	if *v == nil {
		sv = &types.LiteralOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DefaultValue = &xtv
			}

		case strings.EqualFold("FacetEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.FacetEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SearchEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SearchEnabled = &xtv
			}

		case strings.EqualFold("SortEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SortEnabled = &xtv
			}

		case strings.EqualFold("SourceField", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceField = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentOptionStatus(v **types.OptionStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.OptionStatus
	if *v == nil {
		sv = &types.OptionStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("CreationDate", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				t, err := smithytime.ParseDateTime(xtv)
				if err != nil {
					return err
				}
				sv.CreationDate = &t
			}

		case strings.EqualFold("PendingDeletion", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.PendingDeletion = &xtv
			}

		case strings.EqualFold("State", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.State = types.OptionState(xtv)
			}

		case strings.EqualFold("UpdateDate", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				t, err := smithytime.ParseDateTime(xtv)
				if err != nil {
					return err
				}
				sv.UpdateDate = &t
			}

		case strings.EqualFold("UpdateVersion", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.UpdateVersion = ptr.Int32(int32(i64))
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentResourceNotFoundException(v **types.ResourceNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ResourceNotFoundException
	if *v == nil {
		sv = &types.ResourceNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Code", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Code = &xtv
			}

		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentScalingParameters(v **types.ScalingParameters, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ScalingParameters
	if *v == nil {
		sv = &types.ScalingParameters{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DesiredInstanceType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DesiredInstanceType = types.PartitionInstanceType(xtv)
			}

		case strings.EqualFold("DesiredPartitionCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.DesiredPartitionCount = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("DesiredReplicationCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.DesiredReplicationCount = ptr.Int32(int32(i64))
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentScalingParametersStatus(v **types.ScalingParametersStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ScalingParametersStatus
	if *v == nil {
		sv = &types.ScalingParametersStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Options", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentScalingParameters(&sv.Options, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Status", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentOptionStatus(&sv.Status, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentServiceEndpoint(v **types.ServiceEndpoint, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ServiceEndpoint
	if *v == nil {
		sv = &types.ServiceEndpoint{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Endpoint", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Endpoint = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSuggester(v **types.Suggester, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Suggester
	if *v == nil {
		sv = &types.Suggester{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DocumentSuggesterOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDocumentSuggesterOptions(&sv.DocumentSuggesterOptions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("SuggesterName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SuggesterName = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSuggesterStatus(v **types.SuggesterStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.SuggesterStatus
	if *v == nil {
		sv = &types.SuggesterStatus{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Options", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSuggester(&sv.Options, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Status", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentOptionStatus(&sv.Status, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSuggesterStatusList(v *[]*types.SuggesterStatus, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.SuggesterStatus
	if *v == nil {
		sv = make([]*types.SuggesterStatus, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.SuggesterStatus
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentSuggesterStatus(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSuggesterStatusListUnwrapped(v *[]*types.SuggesterStatus, decoder smithyxml.NodeDecoder) error {
	var sv []*types.SuggesterStatus
	if *v == nil {
		sv = make([]*types.SuggesterStatus, 0)
	} else {
		sv = *v
	}

	for {
		var mv *types.SuggesterStatus
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentSuggesterStatus(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentTextArrayOptions(v **types.TextArrayOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TextArrayOptions
	if *v == nil {
		sv = &types.TextArrayOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AnalysisScheme", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.AnalysisScheme = &xtv
			}

		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DefaultValue = &xtv
			}

		case strings.EqualFold("HighlightEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.HighlightEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SourceFields", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceFields = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTextOptions(v **types.TextOptions, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TextOptions
	if *v == nil {
		sv = &types.TextOptions{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AnalysisScheme", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.AnalysisScheme = &xtv
			}

		case strings.EqualFold("DefaultValue", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DefaultValue = &xtv
			}

		case strings.EqualFold("HighlightEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.HighlightEnabled = &xtv
			}

		case strings.EqualFold("ReturnEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.ReturnEnabled = &xtv
			}

		case strings.EqualFold("SortEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
				}
				sv.SortEnabled = &xtv
			}

		case strings.EqualFold("SourceField", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SourceField = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentValidationException(v **types.ValidationException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ValidationException
	if *v == nil {
		sv = &types.ValidationException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Code", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Code = &xtv
			}

		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentBuildSuggestersOutput(v **BuildSuggestersOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *BuildSuggestersOutput
	if *v == nil {
		sv = &BuildSuggestersOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("FieldNames", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentFieldNameList(&sv.FieldNames, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentCreateDomainOutput(v **CreateDomainOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateDomainOutput
	if *v == nil {
		sv = &CreateDomainOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DomainStatus", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDomainStatus(&sv.DomainStatus, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDefineAnalysisSchemeOutput(v **DefineAnalysisSchemeOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DefineAnalysisSchemeOutput
	if *v == nil {
		sv = &DefineAnalysisSchemeOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AnalysisScheme", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAnalysisSchemeStatus(&sv.AnalysisScheme, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDefineExpressionOutput(v **DefineExpressionOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DefineExpressionOutput
	if *v == nil {
		sv = &DefineExpressionOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Expression", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentExpressionStatus(&sv.Expression, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDefineIndexFieldOutput(v **DefineIndexFieldOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DefineIndexFieldOutput
	if *v == nil {
		sv = &DefineIndexFieldOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("IndexField", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentIndexFieldStatus(&sv.IndexField, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDefineSuggesterOutput(v **DefineSuggesterOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DefineSuggesterOutput
	if *v == nil {
		sv = &DefineSuggesterOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Suggester", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSuggesterStatus(&sv.Suggester, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDeleteAnalysisSchemeOutput(v **DeleteAnalysisSchemeOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteAnalysisSchemeOutput
	if *v == nil {
		sv = &DeleteAnalysisSchemeOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AnalysisScheme", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAnalysisSchemeStatus(&sv.AnalysisScheme, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDeleteDomainOutput(v **DeleteDomainOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteDomainOutput
	if *v == nil {
		sv = &DeleteDomainOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DomainStatus", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDomainStatus(&sv.DomainStatus, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDeleteExpressionOutput(v **DeleteExpressionOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteExpressionOutput
	if *v == nil {
		sv = &DeleteExpressionOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Expression", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentExpressionStatus(&sv.Expression, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDeleteIndexFieldOutput(v **DeleteIndexFieldOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteIndexFieldOutput
	if *v == nil {
		sv = &DeleteIndexFieldOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("IndexField", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentIndexFieldStatus(&sv.IndexField, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDeleteSuggesterOutput(v **DeleteSuggesterOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteSuggesterOutput
	if *v == nil {
		sv = &DeleteSuggesterOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Suggester", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSuggesterStatus(&sv.Suggester, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeAnalysisSchemesOutput(v **DescribeAnalysisSchemesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeAnalysisSchemesOutput
	if *v == nil {
		sv = &DescribeAnalysisSchemesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AnalysisSchemes", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAnalysisSchemeStatusList(&sv.AnalysisSchemes, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeAvailabilityOptionsOutput(v **DescribeAvailabilityOptionsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeAvailabilityOptionsOutput
	if *v == nil {
		sv = &DescribeAvailabilityOptionsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AvailabilityOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAvailabilityOptionsStatus(&sv.AvailabilityOptions, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeDomainEndpointOptionsOutput(v **DescribeDomainEndpointOptionsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeDomainEndpointOptionsOutput
	if *v == nil {
		sv = &DescribeDomainEndpointOptionsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DomainEndpointOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDomainEndpointOptionsStatus(&sv.DomainEndpointOptions, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeDomainsOutput(v **DescribeDomainsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeDomainsOutput
	if *v == nil {
		sv = &DescribeDomainsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DomainStatusList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDomainStatusList(&sv.DomainStatusList, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeExpressionsOutput(v **DescribeExpressionsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeExpressionsOutput
	if *v == nil {
		sv = &DescribeExpressionsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Expressions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentExpressionStatusList(&sv.Expressions, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeIndexFieldsOutput(v **DescribeIndexFieldsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeIndexFieldsOutput
	if *v == nil {
		sv = &DescribeIndexFieldsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("IndexFields", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentIndexFieldStatusList(&sv.IndexFields, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeScalingParametersOutput(v **DescribeScalingParametersOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeScalingParametersOutput
	if *v == nil {
		sv = &DescribeScalingParametersOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("ScalingParameters", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentScalingParametersStatus(&sv.ScalingParameters, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeServiceAccessPoliciesOutput(v **DescribeServiceAccessPoliciesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeServiceAccessPoliciesOutput
	if *v == nil {
		sv = &DescribeServiceAccessPoliciesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AccessPolicies", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAccessPoliciesStatus(&sv.AccessPolicies, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDescribeSuggestersOutput(v **DescribeSuggestersOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeSuggestersOutput
	if *v == nil {
		sv = &DescribeSuggestersOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("Suggesters", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSuggesterStatusList(&sv.Suggesters, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentIndexDocumentsOutput(v **IndexDocumentsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *IndexDocumentsOutput
	if *v == nil {
		sv = &IndexDocumentsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("FieldNames", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentFieldNameList(&sv.FieldNames, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListDomainNamesOutput(v **ListDomainNamesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListDomainNamesOutput
	if *v == nil {
		sv = &ListDomainNamesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DomainNames", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDomainNameMap(&sv.DomainNames, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentUpdateAvailabilityOptionsOutput(v **UpdateAvailabilityOptionsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *UpdateAvailabilityOptionsOutput
	if *v == nil {
		sv = &UpdateAvailabilityOptionsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AvailabilityOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAvailabilityOptionsStatus(&sv.AvailabilityOptions, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentUpdateDomainEndpointOptionsOutput(v **UpdateDomainEndpointOptionsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *UpdateDomainEndpointOptionsOutput
	if *v == nil {
		sv = &UpdateDomainEndpointOptionsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("DomainEndpointOptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentDomainEndpointOptionsStatus(&sv.DomainEndpointOptions, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentUpdateScalingParametersOutput(v **UpdateScalingParametersOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *UpdateScalingParametersOutput
	if *v == nil {
		sv = &UpdateScalingParametersOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("ScalingParameters", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentScalingParametersStatus(&sv.ScalingParameters, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentUpdateServiceAccessPoliciesOutput(v **UpdateServiceAccessPoliciesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *UpdateServiceAccessPoliciesOutput
	if *v == nil {
		sv = &UpdateServiceAccessPoliciesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		_ = t
		switch {
		case strings.EqualFold("AccessPolicies", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAccessPoliciesStatus(&sv.AccessPolicies, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}
