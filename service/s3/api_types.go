// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package s3

import (
	"encoding/xml"
	"fmt"
	"strconv"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

var _ aws.Config
var _ = awsutil.Prettify

// Specifies the days since the initiation of an incomplete multipart upload
// that Amazon S3 will wait before permanently removing all parts of the upload.
// For more information, see Aborting Incomplete Multipart Uploads Using a Bucket
// Lifecycle Policy (https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config)
// in the Amazon Simple Storage Service Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AbortIncompleteMultipartUpload
type AbortIncompleteMultipartUpload struct {
	_ struct{} `type:"structure"`

	// Specifies the number of days after which Amazon S3 aborts an incomplete multipart
	// upload.
	DaysAfterInitiation *int64 `type:"integer"`
}

// String returns the string representation
func (s AbortIncompleteMultipartUpload) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AbortIncompleteMultipartUpload) MarshalFields(e protocol.FieldEncoder) error {
	if s.DaysAfterInitiation != nil {
		v := *s.DaysAfterInitiation

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DaysAfterInitiation", protocol.Int64Value(v), metadata)
	}
	return nil
}
func (s *AbortIncompleteMultipartUpload) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AbortIncompleteMultipartUpload{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AbortIncompleteMultipartUpload.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DaysAfterInitiation":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AbortIncompleteMultipartUpload.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.DaysAfterInitiation = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AbortIncompleteMultipartUpload.%s, %s", name, err)
				}
			}
		}
	}
}

// Configures the transfer acceleration state for an Amazon S3 bucket. For more
// information, see Amazon S3 Transfer Acceleration (https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html)
// in the Amazon Simple Storage Service Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AccelerateConfiguration
type AccelerateConfiguration struct {
	_ struct{} `type:"structure"`

	// Specifies the transfer acceleration status of the bucket.
	Status BucketAccelerateStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s AccelerateConfiguration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AccelerateConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}
func (s *AccelerateConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AccelerateConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AccelerateConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AccelerateConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := BucketAccelerateStatus(v)
				s.Status = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AccelerateConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Contains the elements that set the ACL permissions for an object per grantee.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AccessControlPolicy
type AccessControlPolicy struct {
	_ struct{} `type:"structure"`

	// A list of grants.
	Grants []Grant `locationName:"AccessControlList" locationNameList:"Grant" type:"list"`

	// Container for the bucket owner's display name and ID.
	Owner *Owner `type:"structure"`
}

// String returns the string representation
func (s AccessControlPolicy) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AccessControlPolicy) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AccessControlPolicy"}
	if s.Grants != nil {
		for i, v := range s.Grants {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Grants", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AccessControlPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.Grants != nil {
		v := s.Grants

		metadata := protocol.Metadata{ListLocationName: "Grant"}
		ls0 := e.List(protocol.BodyTarget, "AccessControlList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Owner != nil {
		v := s.Owner

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Owner", v, metadata)
	}
	return nil
}
func (s *AccessControlPolicy) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AccessControlPolicy{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AccessControlPolicy.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AccessControlList":
				if s.Grants == nil {
					s.Grants = make([]Grant, 0)
				}
				err := unmarshalAWSXMLListGrants(&s.Grants, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AccessControlPolicy.%s, %s", name, err)
				}
			case "Owner":
				value := Owner{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AccessControlPolicy.%s, %s", name, err)
				}
				s.Owner = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AccessControlPolicy.%s, %s", name, err)
				}
			}
		}
	}
}

// A container for information about access control for replicas.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AccessControlTranslation
type AccessControlTranslation struct {
	_ struct{} `type:"structure"`

	// Specifies the replica ownership. For default and valid values, see PUT bucket
	// replication (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html)
	// in the Amazon Simple Storage Service API Reference.
	//
	// Owner is a required field
	Owner OwnerOverride `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s AccessControlTranslation) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AccessControlTranslation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AccessControlTranslation"}
	if len(s.Owner) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Owner"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AccessControlTranslation) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Owner) > 0 {
		v := s.Owner

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Owner", v, metadata)
	}
	return nil
}
func (s *AccessControlTranslation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AccessControlTranslation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AccessControlTranslation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Owner":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AccessControlTranslation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := OwnerOverride(v)
				s.Owner = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AccessControlTranslation.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListAllowedHeaders(s *[]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]string, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []string.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListAllowedHeaders(s *[]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]string, 0)
		}
	}()
	return nil
}

func unmarshalAWSXMLListAllowedMethods(s *[]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]string, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []string.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListAllowedMethods(s *[]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]string, 0)
		}
	}()
	return nil
}

func unmarshalAWSXMLListAllowedOrigins(s *[]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]string, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []string.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListAllowedOrigins(s *[]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]string, 0)
		}
	}()
	return nil
}

// A conjunction (logical AND) of predicates, which is used in evaluating a
// metrics filter. The operator must have at least two predicates in any combination,
// and an object must match all of the predicates for the filter to apply.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AnalyticsAndOperator
type AnalyticsAndOperator struct {
	_ struct{} `type:"structure"`

	// The prefix to use when evaluating an AND predicate: The prefix that an object
	// must have to be included in the metrics results.
	Prefix *string `type:"string"`

	// The list of tags to use when evaluating an AND predicate.
	Tags []Tag `locationName:"Tag" locationNameList:"Tag" type:"list" flattened:"true"`
}

// String returns the string representation
func (s AnalyticsAndOperator) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AnalyticsAndOperator) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AnalyticsAndOperator"}
	if s.Tags != nil {
		for i, v := range s.Tags {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Tags", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AnalyticsAndOperator) MarshalFields(e protocol.FieldEncoder) error {
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Tags != nil {
		v := s.Tags

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Tag", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *AnalyticsAndOperator) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AnalyticsAndOperator{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsAndOperator.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsAndOperator.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Tag":
				if s.Tags == nil {
					s.Tags = make([]Tag, 0)
				}
				err := unmarshalAWSXMLFlattenedListTagSet(&s.Tags, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsAndOperator.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsAndOperator.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the configuration and any analyses for the analytics filter of
// an Amazon S3 bucket.
//
// For more information, see GET Bucket analytics (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETAnalyticsConfig.html)
// in the Amazon Simple Storage Service API Reference.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AnalyticsConfiguration
type AnalyticsConfiguration struct {
	_ struct{} `type:"structure"`

	// The filter used to describe a set of objects for analyses. A filter must
	// have exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator).
	// If no filter is provided, all objects will be considered in any analysis.
	Filter *AnalyticsFilter `type:"structure"`

	// The ID that identifies the analytics configuration.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`

	// Contains data related to access patterns to be collected and made available
	// to analyze the tradeoffs between different storage classes.
	//
	// StorageClassAnalysis is a required field
	StorageClassAnalysis *StorageClassAnalysis `type:"structure" required:"true"`
}

// String returns the string representation
func (s AnalyticsConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AnalyticsConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AnalyticsConfiguration"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if s.StorageClassAnalysis == nil {
		invalidParams.Add(aws.NewErrParamRequired("StorageClassAnalysis"))
	}
	if s.Filter != nil {
		if err := s.Filter.Validate(); err != nil {
			invalidParams.AddNested("Filter", err.(aws.ErrInvalidParams))
		}
	}
	if s.StorageClassAnalysis != nil {
		if err := s.StorageClassAnalysis.Validate(); err != nil {
			invalidParams.AddNested("StorageClassAnalysis", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AnalyticsConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Filter != nil {
		v := s.Filter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filter", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.StorageClassAnalysis != nil {
		v := s.StorageClassAnalysis

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "StorageClassAnalysis", v, metadata)
	}
	return nil
}
func (s *AnalyticsConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AnalyticsConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Filter":
				value := AnalyticsFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsConfiguration.%s, %s", name, err)
				}
				s.Filter = &value
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			case "StorageClassAnalysis":
				value := StorageClassAnalysis{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsConfiguration.%s, %s", name, err)
				}
				s.StorageClassAnalysis = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListAnalyticsConfigurationList(s *[]AnalyticsConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]AnalyticsConfiguration, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := AnalyticsConfiguration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []AnalyticsConfiguration.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []AnalyticsConfiguration.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListAnalyticsConfigurationList(s *[]AnalyticsConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]AnalyticsConfiguration, 0)
		}
	}()
	value := AnalyticsConfiguration{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Where to publish the analytics results.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AnalyticsExportDestination
type AnalyticsExportDestination struct {
	_ struct{} `type:"structure"`

	// A destination signifying output to an S3 bucket.
	//
	// S3BucketDestination is a required field
	S3BucketDestination *AnalyticsS3BucketDestination `type:"structure" required:"true"`
}

// String returns the string representation
func (s AnalyticsExportDestination) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AnalyticsExportDestination) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AnalyticsExportDestination"}

	if s.S3BucketDestination == nil {
		invalidParams.Add(aws.NewErrParamRequired("S3BucketDestination"))
	}
	if s.S3BucketDestination != nil {
		if err := s.S3BucketDestination.Validate(); err != nil {
			invalidParams.AddNested("S3BucketDestination", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AnalyticsExportDestination) MarshalFields(e protocol.FieldEncoder) error {
	if s.S3BucketDestination != nil {
		v := s.S3BucketDestination

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3BucketDestination", v, metadata)
	}
	return nil
}
func (s *AnalyticsExportDestination) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AnalyticsExportDestination{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsExportDestination.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "S3BucketDestination":
				value := AnalyticsS3BucketDestination{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsExportDestination.%s, %s", name, err)
				}
				s.S3BucketDestination = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsExportDestination.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AnalyticsFilter
type AnalyticsFilter struct {
	_ struct{} `type:"structure"`

	// A conjunction (logical AND) of predicates, which is used in evaluating an
	// analytics filter. The operator must have at least two predicates.
	And *AnalyticsAndOperator `type:"structure"`

	// The prefix to use when evaluating an analytics filter.
	Prefix *string `type:"string"`

	// The tag to use when evaluating an analytics filter.
	Tag *Tag `type:"structure"`
}

// String returns the string representation
func (s AnalyticsFilter) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AnalyticsFilter) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AnalyticsFilter"}
	if s.And != nil {
		if err := s.And.Validate(); err != nil {
			invalidParams.AddNested("And", err.(aws.ErrInvalidParams))
		}
	}
	if s.Tag != nil {
		if err := s.Tag.Validate(); err != nil {
			invalidParams.AddNested("Tag", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AnalyticsFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.And != nil {
		v := s.And

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "And", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Tag != nil {
		v := s.Tag

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Tag", v, metadata)
	}
	return nil
}
func (s *AnalyticsFilter) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AnalyticsFilter{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsFilter.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "And":
				value := AnalyticsAndOperator{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsFilter.%s, %s", name, err)
				}
				s.And = &value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsFilter.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Tag":
				value := Tag{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsFilter.%s, %s", name, err)
				}
				s.Tag = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsFilter.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/AnalyticsS3BucketDestination
type AnalyticsS3BucketDestination struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the bucket to which data is exported.
	//
	// Bucket is a required field
	Bucket *string `type:"string" required:"true"`

	// The account ID that owns the destination bucket. If no account ID is provided,
	// the owner will not be validated prior to exporting data.
	BucketAccountId *string `type:"string"`

	// Specifies the file format used when exporting data to Amazon S3.
	//
	// Format is a required field
	Format AnalyticsS3ExportFileFormat `type:"string" required:"true" enum:"true"`

	// The prefix to use when exporting data. The prefix is prepended to all results.
	Prefix *string `type:"string"`
}

// String returns the string representation
func (s AnalyticsS3BucketDestination) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AnalyticsS3BucketDestination) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AnalyticsS3BucketDestination"}

	if s.Bucket == nil {
		invalidParams.Add(aws.NewErrParamRequired("Bucket"))
	}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

func (s *AnalyticsS3BucketDestination) getBucket() (v string) {
	if s.Bucket == nil {
		return v
	}
	return *s.Bucket
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AnalyticsS3BucketDestination) MarshalFields(e protocol.FieldEncoder) error {
	if s.Bucket != nil {
		v := *s.Bucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Bucket", protocol.StringValue(v), metadata)
	}
	if s.BucketAccountId != nil {
		v := *s.BucketAccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BucketAccountId", protocol.StringValue(v), metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Format", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *AnalyticsS3BucketDestination) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = AnalyticsS3BucketDestination{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsS3BucketDestination.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Bucket":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsS3BucketDestination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Bucket = &value
			case "BucketAccountId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsS3BucketDestination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.BucketAccountId = &value
			case "Format":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsS3BucketDestination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := AnalyticsS3ExportFileFormat(v)
				s.Format = value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsS3BucketDestination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML AnalyticsS3BucketDestination.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Bucket
type Bucket struct {
	_ struct{} `type:"structure"`

	// Date the bucket was created.
	CreationDate *time.Time `type:"timestamp"`

	// The name of the bucket.
	Name *string `type:"string"`
}

// String returns the string representation
func (s Bucket) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Bucket) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Bucket) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Bucket{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Bucket.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CreationDate":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Bucket.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.CreationDate = &value
			case "Name":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Bucket.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Name = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Bucket.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the lifecycle configuration for objects in an Amazon S3 bucket.
// For more information, see Object Lifecycle Management (https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html)
// in the Amazon Simple Storage Service Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/BucketLifecycleConfiguration
type BucketLifecycleConfiguration struct {
	_ struct{} `type:"structure"`

	// A lifecycle rule for individual objects in an Amazon S3 bucket.
	//
	// Rules is a required field
	Rules []LifecycleRule `locationName:"Rule" type:"list" flattened:"true" required:"true"`
}

// String returns the string representation
func (s BucketLifecycleConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BucketLifecycleConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BucketLifecycleConfiguration"}

	if s.Rules == nil {
		invalidParams.Add(aws.NewErrParamRequired("Rules"))
	}
	if s.Rules != nil {
		for i, v := range s.Rules {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Rules", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BucketLifecycleConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Rules != nil {
		v := s.Rules

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Rule", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *BucketLifecycleConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = BucketLifecycleConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML BucketLifecycleConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Rule":
				if s.Rules == nil {
					s.Rules = make([]LifecycleRule, 0)
				}
				err := unmarshalAWSXMLFlattenedListLifecycleRules(&s.Rules, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML BucketLifecycleConfiguration.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML BucketLifecycleConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/BucketLoggingStatus
type BucketLoggingStatus struct {
	_ struct{} `type:"structure"`

	// Describes where logs are stored and the prefix that Amazon S3 assigns to
	// all log object keys for a bucket. For more information, see PUT Bucket logging
	// (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html)
	// in the Amazon Simple Storage Service API Reference.
	LoggingEnabled *LoggingEnabled `type:"structure"`
}

// String returns the string representation
func (s BucketLoggingStatus) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BucketLoggingStatus) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BucketLoggingStatus"}
	if s.LoggingEnabled != nil {
		if err := s.LoggingEnabled.Validate(); err != nil {
			invalidParams.AddNested("LoggingEnabled", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BucketLoggingStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.LoggingEnabled != nil {
		v := s.LoggingEnabled

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LoggingEnabled", v, metadata)
	}
	return nil
}
func (s *BucketLoggingStatus) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = BucketLoggingStatus{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML BucketLoggingStatus.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "LoggingEnabled":
				value := LoggingEnabled{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML BucketLoggingStatus.%s, %s", name, err)
				}
				s.LoggingEnabled = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML BucketLoggingStatus.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListBuckets(s *[]Bucket, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Bucket, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Bucket":
				value := Bucket{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Bucket.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Bucket.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListBuckets(s *[]Bucket, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Bucket, 0)
		}
	}()
	value := Bucket{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Describes the cross-origin access configuration for objects in an Amazon
// S3 bucket. For more information, see Enabling Cross-Origin Resource Sharing
// (https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the Amazon
// Simple Storage Service Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CORSConfiguration
type CORSConfiguration struct {
	_ struct{} `type:"structure"`

	// A set of allowed origins and methods.
	//
	// CORSRules is a required field
	CORSRules []CORSRule `locationName:"CORSRule" type:"list" flattened:"true" required:"true"`
}

// String returns the string representation
func (s CORSConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CORSConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CORSConfiguration"}

	if s.CORSRules == nil {
		invalidParams.Add(aws.NewErrParamRequired("CORSRules"))
	}
	if s.CORSRules != nil {
		for i, v := range s.CORSRules {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "CORSRules", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CORSConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.CORSRules != nil {
		v := s.CORSRules

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "CORSRule", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *CORSConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CORSConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CORSConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CORSRule":
				if s.CORSRules == nil {
					s.CORSRules = make([]CORSRule, 0)
				}
				err := unmarshalAWSXMLFlattenedListCORSRules(&s.CORSRules, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CORSConfiguration.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CORSConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies a cross-origin access rule for an Amazon S3 bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CORSRule
type CORSRule struct {
	_ struct{} `type:"structure"`

	// Headers that are specified in the Access-Control-Request-Headers header.
	// These headers are allowed in a preflight OPTIONS request. In response to
	// any preflight OPTIONS request, Amazon S3 returns any requested headers that
	// are allowed.
	AllowedHeaders []string `locationName:"AllowedHeader" type:"list" flattened:"true"`

	// An HTTP method that you allow the origin to execute. Valid values are GET,
	// PUT, HEAD, POST, and DELETE.
	//
	// AllowedMethods is a required field
	AllowedMethods []string `locationName:"AllowedMethod" type:"list" flattened:"true" required:"true"`

	// One or more origins you want customers to be able to access the bucket from.
	//
	// AllowedOrigins is a required field
	AllowedOrigins []string `locationName:"AllowedOrigin" type:"list" flattened:"true" required:"true"`

	// One or more headers in the response that you want customers to be able to
	// access from their applications (for example, from a JavaScript XMLHttpRequest
	// object).
	ExposeHeaders []string `locationName:"ExposeHeader" type:"list" flattened:"true"`

	// The time in seconds that your browser is to cache the preflight response
	// for the specified resource.
	MaxAgeSeconds *int64 `type:"integer"`
}

// String returns the string representation
func (s CORSRule) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CORSRule) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CORSRule"}

	if s.AllowedMethods == nil {
		invalidParams.Add(aws.NewErrParamRequired("AllowedMethods"))
	}

	if s.AllowedOrigins == nil {
		invalidParams.Add(aws.NewErrParamRequired("AllowedOrigins"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CORSRule) MarshalFields(e protocol.FieldEncoder) error {
	if s.AllowedHeaders != nil {
		v := s.AllowedHeaders

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "AllowedHeader", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.AllowedMethods != nil {
		v := s.AllowedMethods

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "AllowedMethod", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.AllowedOrigins != nil {
		v := s.AllowedOrigins

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "AllowedOrigin", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.ExposeHeaders != nil {
		v := s.ExposeHeaders

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "ExposeHeader", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.MaxAgeSeconds != nil {
		v := *s.MaxAgeSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxAgeSeconds", protocol.Int64Value(v), metadata)
	}
	return nil
}
func (s *CORSRule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CORSRule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CORSRule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AllowedHeader":
				if s.AllowedHeaders == nil {
					s.AllowedHeaders = make([]string, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CORSRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.AllowedHeaders = append(s.AllowedHeaders, value)
			case "AllowedMethod":
				if s.AllowedMethods == nil {
					s.AllowedMethods = make([]string, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CORSRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.AllowedMethods = append(s.AllowedMethods, value)
			case "AllowedOrigin":
				if s.AllowedOrigins == nil {
					s.AllowedOrigins = make([]string, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CORSRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.AllowedOrigins = append(s.AllowedOrigins, value)
			case "ExposeHeader":
				if s.ExposeHeaders == nil {
					s.ExposeHeaders = make([]string, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CORSRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ExposeHeaders = append(s.ExposeHeaders, value)
			case "MaxAgeSeconds":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CORSRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.MaxAgeSeconds = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CORSRule.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListCORSRules(s *[]CORSRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]CORSRule, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := CORSRule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []CORSRule.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []CORSRule.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListCORSRules(s *[]CORSRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]CORSRule, 0)
		}
	}()
	value := CORSRule{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Describes how a CSV-formatted input object is formatted.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CSVInput
type CSVInput struct {
	_ struct{} `type:"structure"`

	// Specifies that CSV field values may contain quoted record delimiters and
	// such records should be allowed. Default value is FALSE. Setting this value
	// to TRUE may lower performance.
	AllowQuotedRecordDelimiter *bool `type:"boolean"`

	// The single character used to indicate a row should be ignored when present
	// at the start of a row.
	Comments *string `type:"string"`

	// The value used to separate individual fields in a record.
	FieldDelimiter *string `type:"string"`

	// Describes the first line of input. Valid values: None, Ignore, Use.
	FileHeaderInfo FileHeaderInfo `type:"string" enum:"true"`

	// Value used for escaping where the field delimiter is part of the value.
	QuoteCharacter *string `type:"string"`

	// The single character used for escaping the quote character inside an already
	// escaped value.
	QuoteEscapeCharacter *string `type:"string"`

	// The value used to separate individual records.
	RecordDelimiter *string `type:"string"`
}

// String returns the string representation
func (s CSVInput) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CSVInput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AllowQuotedRecordDelimiter != nil {
		v := *s.AllowQuotedRecordDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AllowQuotedRecordDelimiter", protocol.BoolValue(v), metadata)
	}
	if s.Comments != nil {
		v := *s.Comments

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Comments", protocol.StringValue(v), metadata)
	}
	if s.FieldDelimiter != nil {
		v := *s.FieldDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FieldDelimiter", protocol.StringValue(v), metadata)
	}
	if len(s.FileHeaderInfo) > 0 {
		v := s.FileHeaderInfo

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FileHeaderInfo", v, metadata)
	}
	if s.QuoteCharacter != nil {
		v := *s.QuoteCharacter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteCharacter", protocol.StringValue(v), metadata)
	}
	if s.QuoteEscapeCharacter != nil {
		v := *s.QuoteEscapeCharacter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteEscapeCharacter", protocol.StringValue(v), metadata)
	}
	if s.RecordDelimiter != nil {
		v := *s.RecordDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecordDelimiter", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *CSVInput) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CSVInput{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AllowQuotedRecordDelimiter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.AllowQuotedRecordDelimiter = &value
			case "Comments":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Comments = &value
			case "FieldDelimiter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.FieldDelimiter = &value
			case "FileHeaderInfo":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := FileHeaderInfo(v)
				s.FileHeaderInfo = value
			case "QuoteCharacter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.QuoteCharacter = &value
			case "QuoteEscapeCharacter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.QuoteEscapeCharacter = &value
			case "RecordDelimiter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.RecordDelimiter = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVInput.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes how CSV-formatted results are formatted.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CSVOutput
type CSVOutput struct {
	_ struct{} `type:"structure"`

	// The value used to separate individual fields in a record.
	FieldDelimiter *string `type:"string"`

	// The value used for escaping where the field delimiter is part of the value.
	QuoteCharacter *string `type:"string"`

	// Th single character used for escaping the quote character inside an already
	// escaped value.
	QuoteEscapeCharacter *string `type:"string"`

	// Indicates whether or not all output fields should be quoted.
	QuoteFields QuoteFields `type:"string" enum:"true"`

	// The value used to separate individual records.
	RecordDelimiter *string `type:"string"`
}

// String returns the string representation
func (s CSVOutput) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CSVOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.FieldDelimiter != nil {
		v := *s.FieldDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FieldDelimiter", protocol.StringValue(v), metadata)
	}
	if s.QuoteCharacter != nil {
		v := *s.QuoteCharacter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteCharacter", protocol.StringValue(v), metadata)
	}
	if s.QuoteEscapeCharacter != nil {
		v := *s.QuoteEscapeCharacter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteEscapeCharacter", protocol.StringValue(v), metadata)
	}
	if len(s.QuoteFields) > 0 {
		v := s.QuoteFields

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteFields", v, metadata)
	}
	if s.RecordDelimiter != nil {
		v := *s.RecordDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecordDelimiter", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *CSVOutput) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CSVOutput{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CSVOutput.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "FieldDelimiter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVOutput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.FieldDelimiter = &value
			case "QuoteCharacter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVOutput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.QuoteCharacter = &value
			case "QuoteEscapeCharacter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVOutput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.QuoteEscapeCharacter = &value
			case "QuoteFields":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVOutput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := QuoteFields(v)
				s.QuoteFields = value
			case "RecordDelimiter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVOutput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.RecordDelimiter = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CSVOutput.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CloudFunctionConfiguration
type CloudFunctionConfiguration struct {
	_ struct{} `type:"structure"`

	CloudFunction *string `type:"string"`

	// The bucket event for which to send notifications.
	Event Event `deprecated:"true" type:"string" enum:"true"`

	Events []Event `locationName:"Event" type:"list" flattened:"true"`

	// An optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	Id *string `type:"string"`

	InvocationRole *string `type:"string"`
}

// String returns the string representation
func (s CloudFunctionConfiguration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CloudFunctionConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.CloudFunction != nil {
		v := *s.CloudFunction

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CloudFunction", protocol.StringValue(v), metadata)
	}
	if len(s.Event) > 0 {
		v := s.Event

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Event", v, metadata)
	}
	if s.Events != nil {
		v := s.Events

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Event", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.InvocationRole != nil {
		v := *s.InvocationRole

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InvocationRole", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *CloudFunctionConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CloudFunctionConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CloudFunctionConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CloudFunction":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CloudFunctionConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.CloudFunction = &value
			case "Event":
				if s.Events == nil {
					s.Events = make([]Event, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CloudFunctionConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Event(v)
				s.Events = append(s.Events, value)
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CloudFunctionConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			case "InvocationRole":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CloudFunctionConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.InvocationRole = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CloudFunctionConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CommonPrefix
type CommonPrefix struct {
	_ struct{} `type:"structure"`

	Prefix *string `type:"string"`
}

// String returns the string representation
func (s CommonPrefix) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CommonPrefix) MarshalFields(e protocol.FieldEncoder) error {
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *CommonPrefix) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CommonPrefix{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CommonPrefix.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CommonPrefix.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CommonPrefix.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListCommonPrefixList(s *[]CommonPrefix, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]CommonPrefix, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := CommonPrefix{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []CommonPrefix.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []CommonPrefix.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListCommonPrefixList(s *[]CommonPrefix, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]CommonPrefix, 0)
		}
	}()
	value := CommonPrefix{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CompletedMultipartUpload
type CompletedMultipartUpload struct {
	_ struct{} `type:"structure"`

	Parts []CompletedPart `locationName:"Part" type:"list" flattened:"true"`
}

// String returns the string representation
func (s CompletedMultipartUpload) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CompletedMultipartUpload) MarshalFields(e protocol.FieldEncoder) error {
	if s.Parts != nil {
		v := s.Parts

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Part", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *CompletedMultipartUpload) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CompletedMultipartUpload{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CompletedMultipartUpload.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Part":
				if s.Parts == nil {
					s.Parts = make([]CompletedPart, 0)
				}
				err := unmarshalAWSXMLFlattenedListCompletedPartList(&s.Parts, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CompletedMultipartUpload.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CompletedMultipartUpload.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CompletedPart
type CompletedPart struct {
	_ struct{} `type:"structure"`

	// Entity tag returned when the part was uploaded.
	ETag *string `type:"string"`

	// Part number that identifies the part. This is a positive integer between
	// 1 and 10,000.
	PartNumber *int64 `type:"integer"`
}

// String returns the string representation
func (s CompletedPart) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CompletedPart) MarshalFields(e protocol.FieldEncoder) error {
	if s.ETag != nil {
		v := *s.ETag

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ETag", protocol.StringValue(v), metadata)
	}
	if s.PartNumber != nil {
		v := *s.PartNumber

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PartNumber", protocol.Int64Value(v), metadata)
	}
	return nil
}
func (s *CompletedPart) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CompletedPart{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CompletedPart.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ETag":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CompletedPart.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ETag = &value
			case "PartNumber":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CompletedPart.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.PartNumber = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CompletedPart.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListCompletedPartList(s *[]CompletedPart, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]CompletedPart, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := CompletedPart{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []CompletedPart.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []CompletedPart.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListCompletedPartList(s *[]CompletedPart, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]CompletedPart, 0)
		}
	}()
	value := CompletedPart{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Specifies a condition that must be met for a redirect to apply.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Condition
type Condition struct {
	_ struct{} `type:"structure"`

	// The HTTP error code when the redirect is applied. In the event of an error,
	// if the error code equals this value, then the specified redirect is applied.
	// Required when parent element Condition is specified and sibling KeyPrefixEquals
	// is not specified. If both are specified, then both must be true for the redirect
	// to be applied.
	HttpErrorCodeReturnedEquals *string `type:"string"`

	// The object key name prefix when the redirect is applied. For example, to
	// redirect requests for ExamplePage.html, the key prefix will be ExamplePage.html.
	// To redirect request for all pages with the prefix docs/, the key prefix will
	// be /docs, which identifies all objects in the docs/ folder. Required when
	// the parent element Condition is specified and sibling HttpErrorCodeReturnedEquals
	// is not specified. If both conditions are specified, both must be true for
	// the redirect to be applied.
	KeyPrefixEquals *string `type:"string"`
}

// String returns the string representation
func (s Condition) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Condition) MarshalFields(e protocol.FieldEncoder) error {
	if s.HttpErrorCodeReturnedEquals != nil {
		v := *s.HttpErrorCodeReturnedEquals

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpErrorCodeReturnedEquals", protocol.StringValue(v), metadata)
	}
	if s.KeyPrefixEquals != nil {
		v := *s.KeyPrefixEquals

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyPrefixEquals", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Condition) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Condition{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Condition.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "HttpErrorCodeReturnedEquals":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Condition.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.HttpErrorCodeReturnedEquals = &value
			case "KeyPrefixEquals":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Condition.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.KeyPrefixEquals = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Condition.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CopyObjectResult
type CopyObjectResult struct {
	_ struct{} `type:"structure"`

	ETag *string `type:"string"`

	LastModified *time.Time `type:"timestamp"`
}

// String returns the string representation
func (s CopyObjectResult) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CopyObjectResult) MarshalFields(e protocol.FieldEncoder) error {
	if s.ETag != nil {
		v := *s.ETag

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ETag", protocol.StringValue(v), metadata)
	}
	if s.LastModified != nil {
		v := *s.LastModified

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModified",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	return nil
}
func (s *CopyObjectResult) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CopyObjectResult{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CopyObjectResult.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ETag":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CopyObjectResult.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ETag = &value
			case "LastModified":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CopyObjectResult.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.LastModified = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CopyObjectResult.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CopyPartResult
type CopyPartResult struct {
	_ struct{} `type:"structure"`

	// Entity tag of the object.
	ETag *string `type:"string"`

	// Date and time at which the object was uploaded.
	LastModified *time.Time `type:"timestamp"`
}

// String returns the string representation
func (s CopyPartResult) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CopyPartResult) MarshalFields(e protocol.FieldEncoder) error {
	if s.ETag != nil {
		v := *s.ETag

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ETag", protocol.StringValue(v), metadata)
	}
	if s.LastModified != nil {
		v := *s.LastModified

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModified",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	return nil
}
func (s *CopyPartResult) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CopyPartResult{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CopyPartResult.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ETag":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CopyPartResult.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ETag = &value
			case "LastModified":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CopyPartResult.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.LastModified = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CopyPartResult.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/CreateBucketConfiguration
type CreateBucketConfiguration struct {
	_ struct{} `type:"structure"`

	// Specifies the region where the bucket will be created. If you don't specify
	// a region, the bucket is created in US East (N. Virginia) Region (us-east-1).
	LocationConstraint BucketLocationConstraint `type:"string" enum:"true"`
}

// String returns the string representation
func (s CreateBucketConfiguration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBucketConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.LocationConstraint) > 0 {
		v := s.LocationConstraint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LocationConstraint", v, metadata)
	}
	return nil
}
func (s *CreateBucketConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = CreateBucketConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML CreateBucketConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "LocationConstraint":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CreateBucketConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := BucketLocationConstraint(v)
				s.LocationConstraint = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML CreateBucketConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// The container element for specifying the default object lock retention settings
// for new objects placed in the specified bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/DefaultRetention
type DefaultRetention struct {
	_ struct{} `type:"structure"`

	// The number of days that you want to specify for the default retention period.
	Days *int64 `type:"integer"`

	// The default object lock retention mode you want to apply to new objects placed
	// in the specified bucket.
	Mode ObjectLockRetentionMode `type:"string" enum:"true"`

	// The number of years that you want to specify for the default retention period.
	Years *int64 `type:"integer"`
}

// String returns the string representation
func (s DefaultRetention) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DefaultRetention) MarshalFields(e protocol.FieldEncoder) error {
	if s.Days != nil {
		v := *s.Days

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Days", protocol.Int64Value(v), metadata)
	}
	if len(s.Mode) > 0 {
		v := s.Mode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Mode", v, metadata)
	}
	if s.Years != nil {
		v := *s.Years

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Years", protocol.Int64Value(v), metadata)
	}
	return nil
}
func (s *DefaultRetention) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = DefaultRetention{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML DefaultRetention.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Days":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DefaultRetention.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Days = &value
			case "Mode":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DefaultRetention.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ObjectLockRetentionMode(v)
				s.Mode = value
			case "Years":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DefaultRetention.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Years = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DefaultRetention.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Delete
type Delete struct {
	_ struct{} `type:"structure"`

	// Objects is a required field
	Objects []ObjectIdentifier `locationName:"Object" type:"list" flattened:"true" required:"true"`

	// Element to enable quiet mode for the request. When you add this element,
	// you must set its value to true.
	Quiet *bool `type:"boolean"`
}

// String returns the string representation
func (s Delete) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Delete) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Delete"}

	if s.Objects == nil {
		invalidParams.Add(aws.NewErrParamRequired("Objects"))
	}
	if s.Objects != nil {
		for i, v := range s.Objects {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Objects", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Delete) MarshalFields(e protocol.FieldEncoder) error {
	if s.Objects != nil {
		v := s.Objects

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Object", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Quiet != nil {
		v := *s.Quiet

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Quiet", protocol.BoolValue(v), metadata)
	}
	return nil
}
func (s *Delete) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Delete{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Delete.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Object":
				if s.Objects == nil {
					s.Objects = make([]ObjectIdentifier, 0)
				}
				err := unmarshalAWSXMLFlattenedListObjectIdentifierList(&s.Objects, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Delete.%s, %s", name, err)
				}
			case "Quiet":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Delete.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.Quiet = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Delete.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/DeleteMarkerEntry
type DeleteMarkerEntry struct {
	_ struct{} `type:"structure"`

	// Specifies whether the object is (true) or is not (false) the latest version
	// of an object.
	IsLatest *bool `type:"boolean"`

	// The object key.
	Key *string `min:"1" type:"string"`

	// Date and time the object was last modified.
	LastModified *time.Time `type:"timestamp"`

	Owner *Owner `type:"structure"`

	// Version ID of an object.
	VersionId *string `type:"string"`
}

// String returns the string representation
func (s DeleteMarkerEntry) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteMarkerEntry) MarshalFields(e protocol.FieldEncoder) error {
	if s.IsLatest != nil {
		v := *s.IsLatest

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsLatest", protocol.BoolValue(v), metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.LastModified != nil {
		v := *s.LastModified

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModified",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.Owner != nil {
		v := s.Owner

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Owner", v, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *DeleteMarkerEntry) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = DeleteMarkerEntry{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerEntry.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "IsLatest":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerEntry.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.IsLatest = &value
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerEntry.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "LastModified":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerEntry.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.LastModified = &value
			case "Owner":
				value := Owner{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerEntry.%s, %s", name, err)
				}
				s.Owner = &value
			case "VersionId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerEntry.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.VersionId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerEntry.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies whether Amazon S3 should replicate delete makers.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/DeleteMarkerReplication
type DeleteMarkerReplication struct {
	_ struct{} `type:"structure"`

	// The status of the delete marker replication.
	//
	// In the current implementation, Amazon S3 doesn't replicate the delete markers.
	// The status must be Disabled.
	Status DeleteMarkerReplicationStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s DeleteMarkerReplication) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteMarkerReplication) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}
func (s *DeleteMarkerReplication) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = DeleteMarkerReplication{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerReplication.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerReplication.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := DeleteMarkerReplicationStatus(v)
				s.Status = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeleteMarkerReplication.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListDeleteMarkers(s *[]DeleteMarkerEntry, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]DeleteMarkerEntry, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := DeleteMarkerEntry{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []DeleteMarkerEntry.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []DeleteMarkerEntry.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListDeleteMarkers(s *[]DeleteMarkerEntry, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]DeleteMarkerEntry, 0)
		}
	}()
	value := DeleteMarkerEntry{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/DeletedObject
type DeletedObject struct {
	_ struct{} `type:"structure"`

	DeleteMarker *bool `type:"boolean"`

	DeleteMarkerVersionId *string `type:"string"`

	Key *string `min:"1" type:"string"`

	VersionId *string `type:"string"`
}

// String returns the string representation
func (s DeletedObject) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeletedObject) MarshalFields(e protocol.FieldEncoder) error {
	if s.DeleteMarker != nil {
		v := *s.DeleteMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DeleteMarker", protocol.BoolValue(v), metadata)
	}
	if s.DeleteMarkerVersionId != nil {
		v := *s.DeleteMarkerVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DeleteMarkerVersionId", protocol.StringValue(v), metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *DeletedObject) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = DeletedObject{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML DeletedObject.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DeleteMarker":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeletedObject.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.DeleteMarker = &value
			case "DeleteMarkerVersionId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeletedObject.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.DeleteMarkerVersionId = &value
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeletedObject.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "VersionId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeletedObject.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.VersionId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML DeletedObject.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListDeletedObjects(s *[]DeletedObject, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]DeletedObject, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := DeletedObject{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []DeletedObject.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []DeletedObject.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListDeletedObjects(s *[]DeletedObject, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]DeletedObject, 0)
		}
	}()
	value := DeletedObject{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Specifies information about where to publish analysis or configuration results
// for an Amazon S3 bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Destination
type Destination struct {
	_ struct{} `type:"structure"`

	// Specify this only in a cross-account scenario (where source and destination
	// bucket owners are not the same), and you want to change replica ownership
	// to the AWS account that owns the destination bucket. If this is not specified
	// in the replication configuration, the replicas are owned by same AWS account
	// that owns the source object.
	AccessControlTranslation *AccessControlTranslation `type:"structure"`

	// Destination bucket owner account ID. In a cross-account scenario, if you
	// direct Amazon S3 to change replica ownership to the AWS account that owns
	// the destination bucket by specifying the AccessControlTranslation property,
	// this is the account ID of the destination bucket owner. For more information,
	// see Cross-Region Replication Additional Configuration: Change Replica Owner
	// (https://docs.aws.amazon.com/AmazonS3/latest/dev/crr-change-owner.html) in
	// the Amazon Simple Storage Service Developer Guide.
	Account *string `type:"string"`

	// The Amazon Resource Name (ARN) of the bucket where you want Amazon S3 to
	// store replicas of the object identified by the rule.
	//
	// A replication configuration can replicate objects to only one destination
	// bucket. If there are multiple rules in your replication configuration, all
	// rules must specify the same destination bucket.
	//
	// Bucket is a required field
	Bucket *string `type:"string" required:"true"`

	// A container that provides information about encryption. If SourceSelectionCriteria
	// is specified, you must specify this element.
	EncryptionConfiguration *EncryptionConfiguration `type:"structure"`

	// The storage class to use when replicating objects, such as standard or reduced
	// redundancy. By default, Amazon S3 uses the storage class of the source object
	// to create the object replica.
	//
	// For valid values, see the StorageClass element of the PUT Bucket replication
	// (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html)
	// action in the Amazon Simple Storage Service API Reference.
	StorageClass StorageClass `type:"string" enum:"true"`
}

// String returns the string representation
func (s Destination) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Destination) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Destination"}

	if s.Bucket == nil {
		invalidParams.Add(aws.NewErrParamRequired("Bucket"))
	}
	if s.AccessControlTranslation != nil {
		if err := s.AccessControlTranslation.Validate(); err != nil {
			invalidParams.AddNested("AccessControlTranslation", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

func (s *Destination) getBucket() (v string) {
	if s.Bucket == nil {
		return v
	}
	return *s.Bucket
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Destination) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccessControlTranslation != nil {
		v := s.AccessControlTranslation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AccessControlTranslation", v, metadata)
	}
	if s.Account != nil {
		v := *s.Account

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Account", protocol.StringValue(v), metadata)
	}
	if s.Bucket != nil {
		v := *s.Bucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Bucket", protocol.StringValue(v), metadata)
	}
	if s.EncryptionConfiguration != nil {
		v := s.EncryptionConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EncryptionConfiguration", v, metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", v, metadata)
	}
	return nil
}
func (s *Destination) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Destination{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Destination.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AccessControlTranslation":
				value := AccessControlTranslation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Destination.%s, %s", name, err)
				}
				s.AccessControlTranslation = &value
			case "Account":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Destination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Account = &value
			case "Bucket":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Destination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Bucket = &value
			case "EncryptionConfiguration":
				value := EncryptionConfiguration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Destination.%s, %s", name, err)
				}
				s.EncryptionConfiguration = &value
			case "StorageClass":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Destination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := StorageClass(v)
				s.StorageClass = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Destination.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes the server-side encryption that will be applied to the restore
// results.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Encryption
type Encryption struct {
	_ struct{} `type:"structure"`

	// The server-side encryption algorithm used when storing job results in Amazon
	// S3 (e.g., AES256, aws:kms).
	//
	// EncryptionType is a required field
	EncryptionType ServerSideEncryption `type:"string" required:"true" enum:"true"`

	// If the encryption type is aws:kms, this optional value can be used to specify
	// the encryption context for the restore results.
	KMSContext *string `type:"string"`

	// If the encryption type is aws:kms, this optional value specifies the AWS
	// KMS key ID to use for encryption of job results.
	KMSKeyId *string `type:"string"`
}

// String returns the string representation
func (s Encryption) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Encryption) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Encryption"}
	if len(s.EncryptionType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("EncryptionType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Encryption) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.EncryptionType) > 0 {
		v := s.EncryptionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EncryptionType", v, metadata)
	}
	if s.KMSContext != nil {
		v := *s.KMSContext

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KMSContext", protocol.StringValue(v), metadata)
	}
	if s.KMSKeyId != nil {
		v := *s.KMSKeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KMSKeyId", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Encryption) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Encryption{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Encryption.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "EncryptionType":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Encryption.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ServerSideEncryption(v)
				s.EncryptionType = value
			case "KMSContext":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Encryption.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.KMSContext = &value
			case "KMSKeyId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Encryption.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.KMSKeyId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Encryption.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies encryption-related information for an Amazon S3 bucket that is
// a destination for replicated objects.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/EncryptionConfiguration
type EncryptionConfiguration struct {
	_ struct{} `type:"structure"`

	// Specifies the AWS KMS Key ID (Key ARN or Alias ARN) for the destination bucket.
	// Amazon S3 uses this key to encrypt replica objects.
	ReplicaKmsKeyID *string `type:"string"`
}

// String returns the string representation
func (s EncryptionConfiguration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EncryptionConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.ReplicaKmsKeyID != nil {
		v := *s.ReplicaKmsKeyID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReplicaKmsKeyID", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *EncryptionConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = EncryptionConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML EncryptionConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ReplicaKmsKeyID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML EncryptionConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ReplicaKmsKeyID = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML EncryptionConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Error
type Error struct {
	_ struct{} `type:"structure"`

	Code *string `type:"string"`

	Key *string `min:"1" type:"string"`

	Message *string `type:"string"`

	VersionId *string `type:"string"`
}

// String returns the string representation
func (s Error) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Error) MarshalFields(e protocol.FieldEncoder) error {
	if s.Code != nil {
		v := *s.Code

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Code", protocol.StringValue(v), metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Message", protocol.StringValue(v), metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Error) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Error{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Error.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Code":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Error.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Code = &value
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Error.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "Message":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Error.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Message = &value
			case "VersionId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Error.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.VersionId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Error.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ErrorDocument
type ErrorDocument struct {
	_ struct{} `type:"structure"`

	// The object key name to use when a 4XX class error occurs.
	//
	// Key is a required field
	Key *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ErrorDocument) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ErrorDocument) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ErrorDocument"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ErrorDocument) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *ErrorDocument) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ErrorDocument{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ErrorDocument.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ErrorDocument.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ErrorDocument.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListErrors(s *[]Error, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Error, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := Error{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Error.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Error.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListErrors(s *[]Error, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Error, 0)
		}
	}()
	value := Error{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

func unmarshalAWSXMLListEventList(s *[]Event, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Event, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Event.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Event(v)
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Event.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListEventList(s *[]Event, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Event, 0)
		}
	}()
	return nil
}

func unmarshalAWSXMLListExposeHeaders(s *[]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]string, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []string.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListExposeHeaders(s *[]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]string, 0)
		}
	}()
	return nil
}

// Specifies the Amazon S3 object key name to filter on and whether to filter
// on the suffix or prefix of the key name.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/FilterRule
type FilterRule struct {
	_ struct{} `type:"structure"`

	// The object key name prefix or suffix identifying one or more objects to which
	// the filtering rule applies. The maximum length is 1,024 characters. Overlapping
	// prefixes and suffixes are not supported. For more information, see Configuring
	// Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html)
	// in the Amazon Simple Storage Service Developer Guide.
	Name FilterRuleName `type:"string" enum:"true"`

	// The value that the filter searches for in object key names.
	Value *string `type:"string"`
}

// String returns the string representation
func (s FilterRule) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FilterRule) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Name) > 0 {
		v := s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", v, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *FilterRule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = FilterRule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML FilterRule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Name":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML FilterRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := FilterRuleName(v)
				s.Name = value
			case "Value":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML FilterRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Value = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML FilterRule.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListFilterRuleList(s *[]FilterRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]FilterRule, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := FilterRule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []FilterRule.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []FilterRule.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListFilterRuleList(s *[]FilterRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]FilterRule, 0)
		}
	}()
	value := FilterRule{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/GlacierJobParameters
type GlacierJobParameters struct {
	_ struct{} `type:"structure"`

	// Glacier retrieval tier at which the restore will be processed.
	//
	// Tier is a required field
	Tier Tier `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s GlacierJobParameters) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GlacierJobParameters) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GlacierJobParameters"}
	if len(s.Tier) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Tier"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GlacierJobParameters) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Tier) > 0 {
		v := s.Tier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Tier", v, metadata)
	}
	return nil
}
func (s *GlacierJobParameters) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = GlacierJobParameters{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML GlacierJobParameters.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Tier":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML GlacierJobParameters.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Tier(v)
				s.Tier = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML GlacierJobParameters.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Grant
type Grant struct {
	_ struct{} `type:"structure"`

	Grantee *Grantee `type:"structure" xmlPrefix:"xsi" xmlURI:"http://www.w3.org/2001/XMLSchema-instance"`

	// Specifies the permission given to the grantee.
	Permission Permission `type:"string" enum:"true"`
}

// String returns the string representation
func (s Grant) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Grant) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Grant"}
	if s.Grantee != nil {
		if err := s.Grantee.Validate(); err != nil {
			invalidParams.AddNested("Grantee", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Grant) MarshalFields(e protocol.FieldEncoder) error {
	if s.Grantee != nil {
		v := s.Grantee
		attrs := make([]protocol.Attribute, 0, 1)

		if len(s.Grantee.Type) > 0 {

			v := s.Grantee.Type
			attrs = append(attrs, protocol.Attribute{Name: "xsi:type", Value: v, Meta: protocol.Metadata{}})
		}
		metadata := protocol.Metadata{Attributes: attrs, XMLNamespacePrefix: "xsi", XMLNamespaceURI: "http://www.w3.org/2001/XMLSchema-instance"}
		e.SetFields(protocol.BodyTarget, "Grantee", v, metadata)
	}
	if len(s.Permission) > 0 {
		v := s.Permission

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Permission", v, metadata)
	}
	return nil
}
func (s *Grant) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Grant{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Grant.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Grantee":
				value := Grantee{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Grant.%s, %s", name, err)
				}
				s.Grantee = &value
			case "Permission":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Grant.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Permission(v)
				s.Permission = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Grant.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Grantee
type Grantee struct {
	_ struct{} `type:"structure" xmlPrefix:"xsi" xmlURI:"http://www.w3.org/2001/XMLSchema-instance"`

	// Screen name of the grantee.
	DisplayName *string `type:"string"`

	// Email address of the grantee.
	EmailAddress *string `type:"string"`

	// The canonical user ID of the grantee.
	ID *string `type:"string"`

	// Type of grantee
	//
	// Type is a required field
	Type Type `locationName:"xsi:type" type:"string" xmlAttribute:"true" required:"true" enum:"true"`

	// URI of the grantee group.
	URI *string `type:"string"`
}

// String returns the string representation
func (s Grantee) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Grantee) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Grantee"}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Grantee) MarshalFields(e protocol.FieldEncoder) error {
	if s.DisplayName != nil {
		v := *s.DisplayName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DisplayName", protocol.StringValue(v), metadata)
	}
	if s.EmailAddress != nil {
		v := *s.EmailAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EmailAddress", protocol.StringValue(v), metadata)
	}
	if s.ID != nil {
		v := *s.ID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ID", protocol.StringValue(v), metadata)
	}
	// Skipping Type XML Attribute.
	if s.URI != nil {
		v := *s.URI

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "URI", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Grantee) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Grantee{}
		}
	}()
	for index, attr := range head.Attr {
		if attr.Name.Local == "type" {
			v := head.Attr[index].Value
			value := Type(v)
			s.Type = value
		}
	}
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Grantee.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DisplayName":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Grantee.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.DisplayName = &value
			case "EmailAddress":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Grantee.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.EmailAddress = &value
			case "ID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Grantee.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ID = &value
			case "URI":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Grantee.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.URI = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Grantee.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListGrants(s *[]Grant, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Grant, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Grant":
				value := Grant{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Grant.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Grant.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListGrants(s *[]Grant, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Grant, 0)
		}
	}()
	value := Grant{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/IndexDocument
type IndexDocument struct {
	_ struct{} `type:"structure"`

	// A suffix that is appended to a request that is for a directory on the website
	// endpoint (e.g. if the suffix is index.html and you make a request to samplebucket/images/
	// the data that is returned will be for the object with the key name images/index.html)
	// The suffix must not be empty and must not include a slash character.
	//
	// Suffix is a required field
	Suffix *string `type:"string" required:"true"`
}

// String returns the string representation
func (s IndexDocument) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *IndexDocument) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "IndexDocument"}

	if s.Suffix == nil {
		invalidParams.Add(aws.NewErrParamRequired("Suffix"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s IndexDocument) MarshalFields(e protocol.FieldEncoder) error {
	if s.Suffix != nil {
		v := *s.Suffix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Suffix", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *IndexDocument) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = IndexDocument{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML IndexDocument.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Suffix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML IndexDocument.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Suffix = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML IndexDocument.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Initiator
type Initiator struct {
	_ struct{} `type:"structure"`

	// Name of the Principal.
	DisplayName *string `type:"string"`

	// If the principal is an AWS account, it provides the Canonical User ID. If
	// the principal is an IAM User, it provides a user ARN value.
	ID *string `type:"string"`
}

// String returns the string representation
func (s Initiator) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Initiator) MarshalFields(e protocol.FieldEncoder) error {
	if s.DisplayName != nil {
		v := *s.DisplayName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DisplayName", protocol.StringValue(v), metadata)
	}
	if s.ID != nil {
		v := *s.ID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ID", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Initiator) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Initiator{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Initiator.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DisplayName":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Initiator.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.DisplayName = &value
			case "ID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Initiator.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ID = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Initiator.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes the serialization format of the object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/InputSerialization
type InputSerialization struct {
	_ struct{} `type:"structure"`

	// Describes the serialization of a CSV-encoded object.
	CSV *CSVInput `type:"structure"`

	// Specifies object's compression format. Valid values: NONE, GZIP, BZIP2. Default
	// Value: NONE.
	CompressionType CompressionType `type:"string" enum:"true"`

	// Specifies JSON as object's input serialization format.
	JSON *JSONInput `type:"structure"`

	// Specifies Parquet as object's input serialization format.
	Parquet *ParquetInput `type:"structure"`
}

// String returns the string representation
func (s InputSerialization) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InputSerialization) MarshalFields(e protocol.FieldEncoder) error {
	if s.CSV != nil {
		v := s.CSV

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CSV", v, metadata)
	}
	if len(s.CompressionType) > 0 {
		v := s.CompressionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompressionType", v, metadata)
	}
	if s.JSON != nil {
		v := s.JSON

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "JSON", v, metadata)
	}
	if s.Parquet != nil {
		v := s.Parquet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Parquet", v, metadata)
	}
	return nil
}
func (s *InputSerialization) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = InputSerialization{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML InputSerialization.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CSV":
				value := CSVInput{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InputSerialization.%s, %s", name, err)
				}
				s.CSV = &value
			case "CompressionType":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InputSerialization.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := CompressionType(v)
				s.CompressionType = value
			case "JSON":
				value := JSONInput{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InputSerialization.%s, %s", name, err)
				}
				s.JSON = &value
			case "Parquet":
				value := ParquetInput{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InputSerialization.%s, %s", name, err)
				}
				s.Parquet = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InputSerialization.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the inventory configuration for an Amazon S3 bucket. For more information,
// see GET Bucket inventory (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html)
// in the Amazon Simple Storage Service API Reference.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/InventoryConfiguration
type InventoryConfiguration struct {
	_ struct{} `type:"structure"`

	// Contains information about where to publish the inventory results.
	//
	// Destination is a required field
	Destination *InventoryDestination `type:"structure" required:"true"`

	// Specifies an inventory filter. The inventory only includes objects that meet
	// the filter's criteria.
	Filter *InventoryFilter `type:"structure"`

	// The ID used to identify the inventory configuration.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`

	// Object versions to include in the inventory list. If set to All, the list
	// includes all the object versions, which adds the version-related fields VersionId,
	// IsLatest, and DeleteMarker to the list. If set to Current, the list does
	// not contain these version-related fields.
	//
	// IncludedObjectVersions is a required field
	IncludedObjectVersions InventoryIncludedObjectVersions `type:"string" required:"true" enum:"true"`

	// Specifies whether the inventory is enabled or disabled. If set to True, an
	// inventory list is generated. If set to False, no inventory list is generated.
	//
	// IsEnabled is a required field
	IsEnabled *bool `type:"boolean" required:"true"`

	// Contains the optional fields that are included in the inventory results.
	OptionalFields []InventoryOptionalField `locationNameList:"Field" type:"list"`

	// Specifies the schedule for generating inventory results.
	//
	// Schedule is a required field
	Schedule *InventorySchedule `type:"structure" required:"true"`
}

// String returns the string representation
func (s InventoryConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InventoryConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InventoryConfiguration"}

	if s.Destination == nil {
		invalidParams.Add(aws.NewErrParamRequired("Destination"))
	}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if len(s.IncludedObjectVersions) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("IncludedObjectVersions"))
	}

	if s.IsEnabled == nil {
		invalidParams.Add(aws.NewErrParamRequired("IsEnabled"))
	}

	if s.Schedule == nil {
		invalidParams.Add(aws.NewErrParamRequired("Schedule"))
	}
	if s.Destination != nil {
		if err := s.Destination.Validate(); err != nil {
			invalidParams.AddNested("Destination", err.(aws.ErrInvalidParams))
		}
	}
	if s.Filter != nil {
		if err := s.Filter.Validate(); err != nil {
			invalidParams.AddNested("Filter", err.(aws.ErrInvalidParams))
		}
	}
	if s.Schedule != nil {
		if err := s.Schedule.Validate(); err != nil {
			invalidParams.AddNested("Schedule", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InventoryConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Destination != nil {
		v := s.Destination

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Destination", v, metadata)
	}
	if s.Filter != nil {
		v := s.Filter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filter", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if len(s.IncludedObjectVersions) > 0 {
		v := s.IncludedObjectVersions

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IncludedObjectVersions", v, metadata)
	}
	if s.IsEnabled != nil {
		v := *s.IsEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsEnabled", protocol.BoolValue(v), metadata)
	}
	if s.OptionalFields != nil {
		v := s.OptionalFields

		metadata := protocol.Metadata{ListLocationName: "Field"}
		ls0 := e.List(protocol.BodyTarget, "OptionalFields", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.Schedule != nil {
		v := s.Schedule

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Schedule", v, metadata)
	}
	return nil
}
func (s *InventoryConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = InventoryConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Destination":
				value := InventoryDestination{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
				}
				s.Destination = &value
			case "Filter":
				value := InventoryFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
				}
				s.Filter = &value
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			case "IncludedObjectVersions":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := InventoryIncludedObjectVersions(v)
				s.IncludedObjectVersions = value
			case "IsEnabled":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.IsEnabled = &value
			case "OptionalFields":
				if s.OptionalFields == nil {
					s.OptionalFields = make([]InventoryOptionalField, 0)
				}
				for {
					tok, err = d.Token()
					if tok == nil || err != nil {
						return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
					}
					if end, ok := tok.(xml.EndElement); ok {
						name := end.Name.Local
						if name == "OptionalFields" {
							break
						}
					}
					if start, ok := tok.(xml.StartElement); ok {
						switch name = start.Name.Local; name {
						case "Field":
							tok, err = d.Token()
							if tok == nil || err != nil {
								return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
							}
							v, _ := tok.(xml.CharData)
							value := InventoryOptionalField(v)
							s.OptionalFields = append(s.OptionalFields, value)
						default:
							err := d.Skip()
							if err != nil {
								return err
							}
						}
					}
				}
			case "Schedule":
				value := InventorySchedule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
				}
				s.Schedule = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListInventoryConfigurationList(s *[]InventoryConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]InventoryConfiguration, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := InventoryConfiguration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []InventoryConfiguration.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []InventoryConfiguration.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListInventoryConfigurationList(s *[]InventoryConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]InventoryConfiguration, 0)
		}
	}()
	value := InventoryConfiguration{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/InventoryDestination
type InventoryDestination struct {
	_ struct{} `type:"structure"`

	// Contains the bucket name, file format, bucket owner (optional), and prefix
	// (optional) where inventory results are published.
	//
	// S3BucketDestination is a required field
	S3BucketDestination *InventoryS3BucketDestination `type:"structure" required:"true"`
}

// String returns the string representation
func (s InventoryDestination) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InventoryDestination) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InventoryDestination"}

	if s.S3BucketDestination == nil {
		invalidParams.Add(aws.NewErrParamRequired("S3BucketDestination"))
	}
	if s.S3BucketDestination != nil {
		if err := s.S3BucketDestination.Validate(); err != nil {
			invalidParams.AddNested("S3BucketDestination", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InventoryDestination) MarshalFields(e protocol.FieldEncoder) error {
	if s.S3BucketDestination != nil {
		v := s.S3BucketDestination

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3BucketDestination", v, metadata)
	}
	return nil
}
func (s *InventoryDestination) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = InventoryDestination{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML InventoryDestination.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "S3BucketDestination":
				value := InventoryS3BucketDestination{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryDestination.%s, %s", name, err)
				}
				s.S3BucketDestination = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryDestination.%s, %s", name, err)
				}
			}
		}
	}
}

// Contains the type of server-side encryption used to encrypt the inventory
// results.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/InventoryEncryption
type InventoryEncryption struct {
	_ struct{} `type:"structure"`

	// Specifies the use of SSE-KMS to encrypt delivered Inventory reports.
	SSEKMS *SSEKMS `locationName:"SSE-KMS" type:"structure"`

	// Specifies the use of SSE-S3 to encrypt delivered Inventory reports.
	SSES3 *SSES3 `locationName:"SSE-S3" type:"structure"`
}

// String returns the string representation
func (s InventoryEncryption) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InventoryEncryption) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InventoryEncryption"}
	if s.SSEKMS != nil {
		if err := s.SSEKMS.Validate(); err != nil {
			invalidParams.AddNested("SSEKMS", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InventoryEncryption) MarshalFields(e protocol.FieldEncoder) error {
	if s.SSEKMS != nil {
		v := s.SSEKMS

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SSE-KMS", v, metadata)
	}
	if s.SSES3 != nil {
		v := s.SSES3

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SSE-S3", v, metadata)
	}
	return nil
}
func (s *InventoryEncryption) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = InventoryEncryption{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML InventoryEncryption.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "SSE-KMS":
				value := SSEKMS{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryEncryption.%s, %s", name, err)
				}
				s.SSEKMS = &value
			case "SSE-S3":
				value := SSES3{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryEncryption.%s, %s", name, err)
				}
				s.SSES3 = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryEncryption.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/InventoryFilter
type InventoryFilter struct {
	_ struct{} `type:"structure"`

	// The prefix that an object must have to be included in the inventory results.
	//
	// Prefix is a required field
	Prefix *string `type:"string" required:"true"`
}

// String returns the string representation
func (s InventoryFilter) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InventoryFilter) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InventoryFilter"}

	if s.Prefix == nil {
		invalidParams.Add(aws.NewErrParamRequired("Prefix"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InventoryFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *InventoryFilter) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = InventoryFilter{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML InventoryFilter.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryFilter.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryFilter.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListInventoryOptionalFields(s *[]InventoryOptionalField, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]InventoryOptionalField, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Field":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []InventoryOptionalField.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := InventoryOptionalField(v)
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []InventoryOptionalField.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListInventoryOptionalFields(s *[]InventoryOptionalField, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]InventoryOptionalField, 0)
		}
	}()
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/InventoryS3BucketDestination
type InventoryS3BucketDestination struct {
	_ struct{} `type:"structure"`

	// The ID of the account that owns the destination bucket.
	AccountId *string `type:"string"`

	// The Amazon resource name (ARN) of the bucket where inventory results will
	// be published.
	//
	// Bucket is a required field
	Bucket *string `type:"string" required:"true"`

	// Contains the type of server-side encryption used to encrypt the inventory
	// results.
	Encryption *InventoryEncryption `type:"structure"`

	// Specifies the output format of the inventory results.
	//
	// Format is a required field
	Format InventoryFormat `type:"string" required:"true" enum:"true"`

	// The prefix that is prepended to all inventory results.
	Prefix *string `type:"string"`
}

// String returns the string representation
func (s InventoryS3BucketDestination) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InventoryS3BucketDestination) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InventoryS3BucketDestination"}

	if s.Bucket == nil {
		invalidParams.Add(aws.NewErrParamRequired("Bucket"))
	}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}
	if s.Encryption != nil {
		if err := s.Encryption.Validate(); err != nil {
			invalidParams.AddNested("Encryption", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

func (s *InventoryS3BucketDestination) getBucket() (v string) {
	if s.Bucket == nil {
		return v
	}
	return *s.Bucket
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InventoryS3BucketDestination) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.StringValue(v), metadata)
	}
	if s.Bucket != nil {
		v := *s.Bucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Bucket", protocol.StringValue(v), metadata)
	}
	if s.Encryption != nil {
		v := s.Encryption

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Encryption", v, metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Format", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *InventoryS3BucketDestination) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = InventoryS3BucketDestination{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML InventoryS3BucketDestination.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AccountId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryS3BucketDestination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.AccountId = &value
			case "Bucket":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryS3BucketDestination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Bucket = &value
			case "Encryption":
				value := InventoryEncryption{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryS3BucketDestination.%s, %s", name, err)
				}
				s.Encryption = &value
			case "Format":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryS3BucketDestination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := InventoryFormat(v)
				s.Format = value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryS3BucketDestination.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventoryS3BucketDestination.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/InventorySchedule
type InventorySchedule struct {
	_ struct{} `type:"structure"`

	// Specifies how frequently inventory results are produced.
	//
	// Frequency is a required field
	Frequency InventoryFrequency `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s InventorySchedule) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InventorySchedule) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InventorySchedule"}
	if len(s.Frequency) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Frequency"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InventorySchedule) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Frequency) > 0 {
		v := s.Frequency

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Frequency", v, metadata)
	}
	return nil
}
func (s *InventorySchedule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = InventorySchedule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML InventorySchedule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Frequency":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventorySchedule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := InventoryFrequency(v)
				s.Frequency = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML InventorySchedule.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/JSONInput
type JSONInput struct {
	_ struct{} `type:"structure"`

	// The type of JSON. Valid values: Document, Lines.
	Type JSONType `type:"string" enum:"true"`
}

// String returns the string representation
func (s JSONInput) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JSONInput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	return nil
}
func (s *JSONInput) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JSONInput{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JSONInput.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Type":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JSONInput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := JSONType(v)
				s.Type = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JSONInput.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/JSONOutput
type JSONOutput struct {
	_ struct{} `type:"structure"`

	// The value used to separate individual records in the output.
	RecordDelimiter *string `type:"string"`
}

// String returns the string representation
func (s JSONOutput) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JSONOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.RecordDelimiter != nil {
		v := *s.RecordDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecordDelimiter", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *JSONOutput) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JSONOutput{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JSONOutput.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "RecordDelimiter":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JSONOutput.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.RecordDelimiter = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JSONOutput.%s, %s", name, err)
				}
			}
		}
	}
}

// A container for specifying the configuration for AWS Lambda notifications.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/LambdaFunctionConfiguration
type LambdaFunctionConfiguration struct {
	_ struct{} `type:"structure"`

	// The Amazon S3 bucket event for which to invoke the AWS Lambda function. For
	// more information, see Supported Event Types (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html)
	// in the Amazon Simple Storage Service Developer Guide.
	//
	// Events is a required field
	Events []Event `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Specifies object key name filtering rules. For information about key name
	// filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html)
	// in the Amazon Simple Storage Service Developer Guide.
	Filter *NotificationConfigurationFilter `type:"structure"`

	// An optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	Id *string `type:"string"`

	// The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3
	// invokes when the specified event type occurs.
	//
	// LambdaFunctionArn is a required field
	LambdaFunctionArn *string `locationName:"CloudFunction" type:"string" required:"true"`
}

// String returns the string representation
func (s LambdaFunctionConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LambdaFunctionConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LambdaFunctionConfiguration"}

	if s.Events == nil {
		invalidParams.Add(aws.NewErrParamRequired("Events"))
	}

	if s.LambdaFunctionArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("LambdaFunctionArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LambdaFunctionConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Events != nil {
		v := s.Events

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Event", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.Filter != nil {
		v := s.Filter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filter", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.LambdaFunctionArn != nil {
		v := *s.LambdaFunctionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CloudFunction", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *LambdaFunctionConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = LambdaFunctionConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML LambdaFunctionConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Event":
				if s.Events == nil {
					s.Events = make([]Event, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LambdaFunctionConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Event(v)
				s.Events = append(s.Events, value)
			case "Filter":
				value := NotificationConfigurationFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LambdaFunctionConfiguration.%s, %s", name, err)
				}
				s.Filter = &value
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LambdaFunctionConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			case "CloudFunction":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LambdaFunctionConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.LambdaFunctionArn = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LambdaFunctionConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListLambdaFunctionConfigurationList(s *[]LambdaFunctionConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]LambdaFunctionConfiguration, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := LambdaFunctionConfiguration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []LambdaFunctionConfiguration.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []LambdaFunctionConfiguration.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListLambdaFunctionConfigurationList(s *[]LambdaFunctionConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]LambdaFunctionConfiguration, 0)
		}
	}()
	value := LambdaFunctionConfiguration{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/LifecycleConfiguration
type LifecycleConfiguration struct {
	_ struct{} `type:"structure"`

	// Rules is a required field
	Rules []Rule `locationName:"Rule" type:"list" flattened:"true" required:"true"`
}

// String returns the string representation
func (s LifecycleConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LifecycleConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LifecycleConfiguration"}

	if s.Rules == nil {
		invalidParams.Add(aws.NewErrParamRequired("Rules"))
	}
	if s.Rules != nil {
		for i, v := range s.Rules {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Rules", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LifecycleConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Rules != nil {
		v := s.Rules

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Rule", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *LifecycleConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = LifecycleConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML LifecycleConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Rule":
				if s.Rules == nil {
					s.Rules = make([]Rule, 0)
				}
				err := unmarshalAWSXMLFlattenedListRules(&s.Rules, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleConfiguration.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/LifecycleExpiration
type LifecycleExpiration struct {
	_ struct{} `type:"structure"`

	// Indicates at what date the object is to be moved or deleted. Should be in
	// GMT ISO 8601 Format.
	Date *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Indicates the lifetime, in days, of the objects that are subject to the rule.
	// The value must be a non-zero positive integer.
	Days *int64 `type:"integer"`

	// Indicates whether Amazon S3 will remove a delete marker with no noncurrent
	// versions. If set to true, the delete marker will be expired; if set to false
	// the policy takes no action. This cannot be specified with Days or Date in
	// a Lifecycle Expiration Policy.
	ExpiredObjectDeleteMarker *bool `type:"boolean"`
}

// String returns the string representation
func (s LifecycleExpiration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LifecycleExpiration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Date != nil {
		v := *s.Date

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Date",
			protocol.TimeValue{V: v, Format: "iso8601", QuotedFormatTime: false}, metadata)
	}
	if s.Days != nil {
		v := *s.Days

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Days", protocol.Int64Value(v), metadata)
	}
	if s.ExpiredObjectDeleteMarker != nil {
		v := *s.ExpiredObjectDeleteMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpiredObjectDeleteMarker", protocol.BoolValue(v), metadata)
	}
	return nil
}
func (s *LifecycleExpiration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = LifecycleExpiration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML LifecycleExpiration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Date":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleExpiration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.Date = &value
			case "Days":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleExpiration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Days = &value
			case "ExpiredObjectDeleteMarker":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleExpiration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.ExpiredObjectDeleteMarker = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleExpiration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/LifecycleRule
type LifecycleRule struct {
	_ struct{} `type:"structure"`

	// Specifies the days since the initiation of an incomplete multipart upload
	// that Amazon S3 will wait before permanently removing all parts of the upload.
	// For more information, see Aborting Incomplete Multipart Uploads Using a Bucket
	// Lifecycle Policy (https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config)
	// in the Amazon Simple Storage Service Developer Guide.
	AbortIncompleteMultipartUpload *AbortIncompleteMultipartUpload `type:"structure"`

	Expiration *LifecycleExpiration `type:"structure"`

	// The Filter is used to identify objects that a Lifecycle Rule applies to.
	// A Filter must have exactly one of Prefix, Tag, or And specified.
	Filter *LifecycleRuleFilter `type:"structure"`

	// Unique identifier for the rule. The value cannot be longer than 255 characters.
	ID *string `type:"string"`

	// Specifies when noncurrent object versions expire. Upon expiration, Amazon
	// S3 permanently deletes the noncurrent object versions. You set this lifecycle
	// configuration action on a bucket that has versioning enabled (or suspended)
	// to request that Amazon S3 delete noncurrent object versions at a specific
	// period in the object's lifetime.
	NoncurrentVersionExpiration *NoncurrentVersionExpiration `type:"structure"`

	NoncurrentVersionTransitions []NoncurrentVersionTransition `locationName:"NoncurrentVersionTransition" type:"list" flattened:"true"`

	// Prefix identifying one or more objects to which the rule applies. This is
	// No longer used; use Filter instead.
	Prefix *string `deprecated:"true" type:"string"`

	// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule
	// is not currently being applied.
	//
	// Status is a required field
	Status ExpirationStatus `type:"string" required:"true" enum:"true"`

	Transitions []Transition `locationName:"Transition" type:"list" flattened:"true"`
}

// String returns the string representation
func (s LifecycleRule) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LifecycleRule) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LifecycleRule"}
	if len(s.Status) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Status"))
	}
	if s.Filter != nil {
		if err := s.Filter.Validate(); err != nil {
			invalidParams.AddNested("Filter", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LifecycleRule) MarshalFields(e protocol.FieldEncoder) error {
	if s.AbortIncompleteMultipartUpload != nil {
		v := s.AbortIncompleteMultipartUpload

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AbortIncompleteMultipartUpload", v, metadata)
	}
	if s.Expiration != nil {
		v := s.Expiration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Expiration", v, metadata)
	}
	if s.Filter != nil {
		v := s.Filter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filter", v, metadata)
	}
	if s.ID != nil {
		v := *s.ID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ID", protocol.StringValue(v), metadata)
	}
	if s.NoncurrentVersionExpiration != nil {
		v := s.NoncurrentVersionExpiration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "NoncurrentVersionExpiration", v, metadata)
	}
	if s.NoncurrentVersionTransitions != nil {
		v := s.NoncurrentVersionTransitions

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "NoncurrentVersionTransition", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	if s.Transitions != nil {
		v := s.Transitions

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Transition", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *LifecycleRule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = LifecycleRule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AbortIncompleteMultipartUpload":
				value := AbortIncompleteMultipartUpload{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
				s.AbortIncompleteMultipartUpload = &value
			case "Expiration":
				value := LifecycleExpiration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
				s.Expiration = &value
			case "Filter":
				value := LifecycleRuleFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
				s.Filter = &value
			case "ID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ID = &value
			case "NoncurrentVersionExpiration":
				value := NoncurrentVersionExpiration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
				s.NoncurrentVersionExpiration = &value
			case "NoncurrentVersionTransition":
				if s.NoncurrentVersionTransitions == nil {
					s.NoncurrentVersionTransitions = make([]NoncurrentVersionTransition, 0)
				}
				err := unmarshalAWSXMLFlattenedListNoncurrentVersionTransitionList(&s.NoncurrentVersionTransitions, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ExpirationStatus(v)
				s.Status = value
			case "Transition":
				if s.Transitions == nil {
					s.Transitions = make([]Transition, 0)
				}
				err := unmarshalAWSXMLFlattenedListTransitionList(&s.Transitions, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRule.%s, %s", name, err)
				}
			}
		}
	}
}

// This is used in a Lifecycle Rule Filter to apply a logical AND to two or
// more predicates. The Lifecycle Rule will apply to any object matching all
// of the predicates configured inside the And operator.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/LifecycleRuleAndOperator
type LifecycleRuleAndOperator struct {
	_ struct{} `type:"structure"`

	Prefix *string `type:"string"`

	// All of these tags must exist in the object's tag set in order for the rule
	// to apply.
	Tags []Tag `locationName:"Tag" locationNameList:"Tag" type:"list" flattened:"true"`
}

// String returns the string representation
func (s LifecycleRuleAndOperator) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LifecycleRuleAndOperator) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LifecycleRuleAndOperator"}
	if s.Tags != nil {
		for i, v := range s.Tags {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Tags", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LifecycleRuleAndOperator) MarshalFields(e protocol.FieldEncoder) error {
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Tags != nil {
		v := s.Tags

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Tag", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *LifecycleRuleAndOperator) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = LifecycleRuleAndOperator{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleAndOperator.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleAndOperator.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Tag":
				if s.Tags == nil {
					s.Tags = make([]Tag, 0)
				}
				err := unmarshalAWSXMLFlattenedListTagSet(&s.Tags, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleAndOperator.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleAndOperator.%s, %s", name, err)
				}
			}
		}
	}
}

// The Filter is used to identify objects that a Lifecycle Rule applies to.
// A Filter must have exactly one of Prefix, Tag, or And specified.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/LifecycleRuleFilter
type LifecycleRuleFilter struct {
	_ struct{} `type:"structure"`

	// This is used in a Lifecycle Rule Filter to apply a logical AND to two or
	// more predicates. The Lifecycle Rule will apply to any object matching all
	// of the predicates configured inside the And operator.
	And *LifecycleRuleAndOperator `type:"structure"`

	// Prefix identifying one or more objects to which the rule applies.
	Prefix *string `type:"string"`

	// This tag must exist in the object's tag set in order for the rule to apply.
	Tag *Tag `type:"structure"`
}

// String returns the string representation
func (s LifecycleRuleFilter) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LifecycleRuleFilter) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LifecycleRuleFilter"}
	if s.And != nil {
		if err := s.And.Validate(); err != nil {
			invalidParams.AddNested("And", err.(aws.ErrInvalidParams))
		}
	}
	if s.Tag != nil {
		if err := s.Tag.Validate(); err != nil {
			invalidParams.AddNested("Tag", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LifecycleRuleFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.And != nil {
		v := s.And

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "And", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Tag != nil {
		v := s.Tag

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Tag", v, metadata)
	}
	return nil
}
func (s *LifecycleRuleFilter) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = LifecycleRuleFilter{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleFilter.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "And":
				value := LifecycleRuleAndOperator{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleFilter.%s, %s", name, err)
				}
				s.And = &value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleFilter.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Tag":
				value := Tag{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleFilter.%s, %s", name, err)
				}
				s.Tag = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LifecycleRuleFilter.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListLifecycleRules(s *[]LifecycleRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]LifecycleRule, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := LifecycleRule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []LifecycleRule.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []LifecycleRule.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListLifecycleRules(s *[]LifecycleRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]LifecycleRule, 0)
		}
	}()
	value := LifecycleRule{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Describes where logs are stored and the prefix that Amazon S3 assigns to
// all log object keys for a bucket. For more information, see PUT Bucket logging
// (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html)
// in the Amazon Simple Storage Service API Reference.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/LoggingEnabled
type LoggingEnabled struct {
	_ struct{} `type:"structure"`

	// Specifies the bucket where you want Amazon S3 to store server access logs.
	// You can have your logs delivered to any bucket that you own, including the
	// same bucket that is being logged. You can also configure multiple buckets
	// to deliver their logs to the same target bucket. In this case you should
	// choose a different TargetPrefix for each source bucket so that the delivered
	// log files can be distinguished by key.
	//
	// TargetBucket is a required field
	TargetBucket *string `type:"string" required:"true"`

	TargetGrants []TargetGrant `locationNameList:"Grant" type:"list"`

	// A prefix for all log object keys. If you store log files from multiple Amazon
	// S3 buckets in a single bucket, you can use a prefix to distinguish which
	// log files came from which bucket.
	//
	// TargetPrefix is a required field
	TargetPrefix *string `type:"string" required:"true"`
}

// String returns the string representation
func (s LoggingEnabled) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LoggingEnabled) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LoggingEnabled"}

	if s.TargetBucket == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetBucket"))
	}

	if s.TargetPrefix == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetPrefix"))
	}
	if s.TargetGrants != nil {
		for i, v := range s.TargetGrants {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TargetGrants", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LoggingEnabled) MarshalFields(e protocol.FieldEncoder) error {
	if s.TargetBucket != nil {
		v := *s.TargetBucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetBucket", protocol.StringValue(v), metadata)
	}
	if s.TargetGrants != nil {
		v := s.TargetGrants

		metadata := protocol.Metadata{ListLocationName: "Grant"}
		ls0 := e.List(protocol.BodyTarget, "TargetGrants", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.TargetPrefix != nil {
		v := *s.TargetPrefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetPrefix", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *LoggingEnabled) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = LoggingEnabled{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML LoggingEnabled.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "TargetBucket":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LoggingEnabled.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.TargetBucket = &value
			case "TargetGrants":
				if s.TargetGrants == nil {
					s.TargetGrants = make([]TargetGrant, 0)
				}
				err := unmarshalAWSXMLListTargetGrants(&s.TargetGrants, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LoggingEnabled.%s, %s", name, err)
				}
			case "TargetPrefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LoggingEnabled.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.TargetPrefix = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LoggingEnabled.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLMapMetadata(s *map[string]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make(map[string]string)
		}
	}()
	name := ""
	curKey := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "key":
				tok, err := d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				curKey = string(v)
			case "value":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				(*s)[curKey] = value
			case "entry":
				continue
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedMapMetadata(s *map[string]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make(map[string]string)
		}
	}()
	name := ""
	curKey := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "key":
				tok, err := d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				curKey = string(v)
			case "value":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				(*s)[curKey] = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

// A metadata key-value pair to store with an object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/MetadataEntry
type MetadataEntry struct {
	_ struct{} `type:"structure"`

	Name *string `type:"string"`

	Value *string `type:"string"`
}

// String returns the string representation
func (s MetadataEntry) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MetadataEntry) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *MetadataEntry) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = MetadataEntry{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML MetadataEntry.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Name":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetadataEntry.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Name = &value
			case "Value":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetadataEntry.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Value = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetadataEntry.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/MetricsAndOperator
type MetricsAndOperator struct {
	_ struct{} `type:"structure"`

	// The prefix used when evaluating an AND predicate.
	Prefix *string `type:"string"`

	// The list of tags used when evaluating an AND predicate.
	Tags []Tag `locationName:"Tag" locationNameList:"Tag" type:"list" flattened:"true"`
}

// String returns the string representation
func (s MetricsAndOperator) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MetricsAndOperator) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "MetricsAndOperator"}
	if s.Tags != nil {
		for i, v := range s.Tags {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Tags", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MetricsAndOperator) MarshalFields(e protocol.FieldEncoder) error {
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Tags != nil {
		v := s.Tags

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Tag", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *MetricsAndOperator) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = MetricsAndOperator{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML MetricsAndOperator.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsAndOperator.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Tag":
				if s.Tags == nil {
					s.Tags = make([]Tag, 0)
				}
				err := unmarshalAWSXMLFlattenedListTagSet(&s.Tags, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsAndOperator.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsAndOperator.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies a metrics configuration for the CloudWatch request metrics (specified
// by the metrics configuration ID) from an Amazon S3 bucket. If you're updating
// an existing metrics configuration, note that this is a full replacement of
// the existing metrics configuration. If you don't include the elements you
// want to keep, they are erased. For more information, see PUT Bucket metrics
// (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html)
// in the Amazon Simple Storage Service API Reference.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/MetricsConfiguration
type MetricsConfiguration struct {
	_ struct{} `type:"structure"`

	// Specifies a metrics configuration filter. The metrics configuration will
	// only include objects that meet the filter's criteria. A filter must be a
	// prefix, a tag, or a conjunction (MetricsAndOperator).
	Filter *MetricsFilter `type:"structure"`

	// The ID used to identify the metrics configuration.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`
}

// String returns the string representation
func (s MetricsConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MetricsConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "MetricsConfiguration"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Filter != nil {
		if err := s.Filter.Validate(); err != nil {
			invalidParams.AddNested("Filter", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MetricsConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Filter != nil {
		v := s.Filter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filter", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *MetricsConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = MetricsConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML MetricsConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Filter":
				value := MetricsFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsConfiguration.%s, %s", name, err)
				}
				s.Filter = &value
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListMetricsConfigurationList(s *[]MetricsConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]MetricsConfiguration, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := MetricsConfiguration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []MetricsConfiguration.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []MetricsConfiguration.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListMetricsConfigurationList(s *[]MetricsConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]MetricsConfiguration, 0)
		}
	}()
	value := MetricsConfiguration{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/MetricsFilter
type MetricsFilter struct {
	_ struct{} `type:"structure"`

	// A conjunction (logical AND) of predicates, which is used in evaluating a
	// metrics filter. The operator must have at least two predicates, and an object
	// must match all of the predicates in order for the filter to apply.
	And *MetricsAndOperator `type:"structure"`

	// The prefix used when evaluating a metrics filter.
	Prefix *string `type:"string"`

	// The tag used when evaluating a metrics filter.
	Tag *Tag `type:"structure"`
}

// String returns the string representation
func (s MetricsFilter) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MetricsFilter) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "MetricsFilter"}
	if s.And != nil {
		if err := s.And.Validate(); err != nil {
			invalidParams.AddNested("And", err.(aws.ErrInvalidParams))
		}
	}
	if s.Tag != nil {
		if err := s.Tag.Validate(); err != nil {
			invalidParams.AddNested("Tag", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MetricsFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.And != nil {
		v := s.And

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "And", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Tag != nil {
		v := s.Tag

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Tag", v, metadata)
	}
	return nil
}
func (s *MetricsFilter) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = MetricsFilter{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML MetricsFilter.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "And":
				value := MetricsAndOperator{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsFilter.%s, %s", name, err)
				}
				s.And = &value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsFilter.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Tag":
				value := Tag{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsFilter.%s, %s", name, err)
				}
				s.Tag = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MetricsFilter.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/MultipartUpload
type MultipartUpload struct {
	_ struct{} `type:"structure"`

	// Date and time at which the multipart upload was initiated.
	Initiated *time.Time `type:"timestamp"`

	// Identifies who initiated the multipart upload.
	Initiator *Initiator `type:"structure"`

	// Key of the object for which the multipart upload was initiated.
	Key *string `min:"1" type:"string"`

	Owner *Owner `type:"structure"`

	// The class of storage used to store the object.
	StorageClass StorageClass `type:"string" enum:"true"`

	// Upload ID that identifies the multipart upload.
	UploadId *string `type:"string"`
}

// String returns the string representation
func (s MultipartUpload) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MultipartUpload) MarshalFields(e protocol.FieldEncoder) error {
	if s.Initiated != nil {
		v := *s.Initiated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Initiated",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.Initiator != nil {
		v := s.Initiator

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Initiator", v, metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.Owner != nil {
		v := s.Owner

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Owner", v, metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", v, metadata)
	}
	if s.UploadId != nil {
		v := *s.UploadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UploadId", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *MultipartUpload) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = MultipartUpload{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML MultipartUpload.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Initiated":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MultipartUpload.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.Initiated = &value
			case "Initiator":
				value := Initiator{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MultipartUpload.%s, %s", name, err)
				}
				s.Initiator = &value
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MultipartUpload.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "Owner":
				value := Owner{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MultipartUpload.%s, %s", name, err)
				}
				s.Owner = &value
			case "StorageClass":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MultipartUpload.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := StorageClass(v)
				s.StorageClass = value
			case "UploadId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MultipartUpload.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.UploadId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML MultipartUpload.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListMultipartUploadList(s *[]MultipartUpload, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]MultipartUpload, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := MultipartUpload{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []MultipartUpload.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []MultipartUpload.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListMultipartUploadList(s *[]MultipartUpload, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]MultipartUpload, 0)
		}
	}()
	value := MultipartUpload{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Specifies when noncurrent object versions expire. Upon expiration, Amazon
// S3 permanently deletes the noncurrent object versions. You set this lifecycle
// configuration action on a bucket that has versioning enabled (or suspended)
// to request that Amazon S3 delete noncurrent object versions at a specific
// period in the object's lifetime.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/NoncurrentVersionExpiration
type NoncurrentVersionExpiration struct {
	_ struct{} `type:"structure"`

	// Specifies the number of days an object is noncurrent before Amazon S3 can
	// perform the associated action. For information about the noncurrent days
	// calculations, see How Amazon S3 Calculates When an Object Became Noncurrent
	// (https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations)
	// in the Amazon Simple Storage Service Developer Guide.
	NoncurrentDays *int64 `type:"integer"`
}

// String returns the string representation
func (s NoncurrentVersionExpiration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NoncurrentVersionExpiration) MarshalFields(e protocol.FieldEncoder) error {
	if s.NoncurrentDays != nil {
		v := *s.NoncurrentDays

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NoncurrentDays", protocol.Int64Value(v), metadata)
	}
	return nil
}
func (s *NoncurrentVersionExpiration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = NoncurrentVersionExpiration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML NoncurrentVersionExpiration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "NoncurrentDays":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NoncurrentVersionExpiration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.NoncurrentDays = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NoncurrentVersionExpiration.%s, %s", name, err)
				}
			}
		}
	}
}

// Container for the transition rule that describes when noncurrent objects
// transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER,
// or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning
// is suspended), you can set this action to request that Amazon S3 transition
// noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING,
// GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's
// lifetime.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/NoncurrentVersionTransition
type NoncurrentVersionTransition struct {
	_ struct{} `type:"structure"`

	// Specifies the number of days an object is noncurrent before Amazon S3 can
	// perform the associated action. For information about the noncurrent days
	// calculations, see How Amazon S3 Calculates When an Object Became Noncurrent
	// (https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-access-control.html)
	// in the Amazon Simple Storage Service Developer Guide.
	NoncurrentDays *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass TransitionStorageClass `type:"string" enum:"true"`
}

// String returns the string representation
func (s NoncurrentVersionTransition) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NoncurrentVersionTransition) MarshalFields(e protocol.FieldEncoder) error {
	if s.NoncurrentDays != nil {
		v := *s.NoncurrentDays

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NoncurrentDays", protocol.Int64Value(v), metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", v, metadata)
	}
	return nil
}
func (s *NoncurrentVersionTransition) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = NoncurrentVersionTransition{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML NoncurrentVersionTransition.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "NoncurrentDays":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NoncurrentVersionTransition.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.NoncurrentDays = &value
			case "StorageClass":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NoncurrentVersionTransition.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := TransitionStorageClass(v)
				s.StorageClass = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NoncurrentVersionTransition.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListNoncurrentVersionTransitionList(s *[]NoncurrentVersionTransition, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]NoncurrentVersionTransition, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := NoncurrentVersionTransition{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []NoncurrentVersionTransition.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []NoncurrentVersionTransition.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListNoncurrentVersionTransitionList(s *[]NoncurrentVersionTransition, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]NoncurrentVersionTransition, 0)
		}
	}()
	value := NoncurrentVersionTransition{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// A container for specifying the notification configuration of the bucket.
// If this element is empty, notifications are turned off for the bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/NotificationConfiguration
type NotificationConfiguration struct {
	_ struct{} `type:"structure"`

	// Describes the AWS Lambda functions to invoke and the events for which to
	// invoke them.
	LambdaFunctionConfigurations []LambdaFunctionConfiguration `locationName:"CloudFunctionConfiguration" type:"list" flattened:"true"`

	// The Amazon Simple Queue Service queues to publish messages to and the events
	// for which to publish messages.
	QueueConfigurations []QueueConfiguration `locationName:"QueueConfiguration" type:"list" flattened:"true"`

	// The topic to which notifications are sent and the events for which notifications
	// are generated.
	TopicConfigurations []TopicConfiguration `locationName:"TopicConfiguration" type:"list" flattened:"true"`
}

// String returns the string representation
func (s NotificationConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *NotificationConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "NotificationConfiguration"}
	if s.LambdaFunctionConfigurations != nil {
		for i, v := range s.LambdaFunctionConfigurations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "LambdaFunctionConfigurations", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.QueueConfigurations != nil {
		for i, v := range s.QueueConfigurations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "QueueConfigurations", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.TopicConfigurations != nil {
		for i, v := range s.TopicConfigurations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TopicConfigurations", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NotificationConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.LambdaFunctionConfigurations != nil {
		v := s.LambdaFunctionConfigurations

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "CloudFunctionConfiguration", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.QueueConfigurations != nil {
		v := s.QueueConfigurations

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "QueueConfiguration", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.TopicConfigurations != nil {
		v := s.TopicConfigurations

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "TopicConfiguration", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *NotificationConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = NotificationConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CloudFunctionConfiguration":
				if s.LambdaFunctionConfigurations == nil {
					s.LambdaFunctionConfigurations = make([]LambdaFunctionConfiguration, 0)
				}
				err := unmarshalAWSXMLFlattenedListLambdaFunctionConfigurationList(&s.LambdaFunctionConfigurations, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfiguration.%s, %s", name, err)
				}
			case "QueueConfiguration":
				if s.QueueConfigurations == nil {
					s.QueueConfigurations = make([]QueueConfiguration, 0)
				}
				err := unmarshalAWSXMLFlattenedListQueueConfigurationList(&s.QueueConfigurations, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfiguration.%s, %s", name, err)
				}
			case "TopicConfiguration":
				if s.TopicConfigurations == nil {
					s.TopicConfigurations = make([]TopicConfiguration, 0)
				}
				err := unmarshalAWSXMLFlattenedListTopicConfigurationList(&s.TopicConfigurations, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfiguration.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/NotificationConfigurationDeprecated
type NotificationConfigurationDeprecated struct {
	_ struct{} `type:"structure"`

	CloudFunctionConfiguration *CloudFunctionConfiguration `type:"structure"`

	QueueConfiguration *QueueConfigurationDeprecated `type:"structure"`

	TopicConfiguration *TopicConfigurationDeprecated `type:"structure"`
}

// String returns the string representation
func (s NotificationConfigurationDeprecated) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NotificationConfigurationDeprecated) MarshalFields(e protocol.FieldEncoder) error {
	if s.CloudFunctionConfiguration != nil {
		v := s.CloudFunctionConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CloudFunctionConfiguration", v, metadata)
	}
	if s.QueueConfiguration != nil {
		v := s.QueueConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "QueueConfiguration", v, metadata)
	}
	if s.TopicConfiguration != nil {
		v := s.TopicConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TopicConfiguration", v, metadata)
	}
	return nil
}
func (s *NotificationConfigurationDeprecated) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = NotificationConfigurationDeprecated{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfigurationDeprecated.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CloudFunctionConfiguration":
				value := CloudFunctionConfiguration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfigurationDeprecated.%s, %s", name, err)
				}
				s.CloudFunctionConfiguration = &value
			case "QueueConfiguration":
				value := QueueConfigurationDeprecated{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfigurationDeprecated.%s, %s", name, err)
				}
				s.QueueConfiguration = &value
			case "TopicConfiguration":
				value := TopicConfigurationDeprecated{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfigurationDeprecated.%s, %s", name, err)
				}
				s.TopicConfiguration = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfigurationDeprecated.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies object key name filtering rules. For information about key name
// filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html)
// in the Amazon Simple Storage Service Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/NotificationConfigurationFilter
type NotificationConfigurationFilter struct {
	_ struct{} `type:"structure"`

	// A container for object key name prefix and suffix filtering rules.
	Key *S3KeyFilter `locationName:"S3Key" type:"structure"`
}

// String returns the string representation
func (s NotificationConfigurationFilter) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NotificationConfigurationFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := s.Key

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3Key", v, metadata)
	}
	return nil
}
func (s *NotificationConfigurationFilter) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = NotificationConfigurationFilter{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfigurationFilter.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "S3Key":
				value := S3KeyFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfigurationFilter.%s, %s", name, err)
				}
				s.Key = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML NotificationConfigurationFilter.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Object
type Object struct {
	_ struct{} `type:"structure"`

	ETag *string `type:"string"`

	Key *string `min:"1" type:"string"`

	LastModified *time.Time `type:"timestamp"`

	Owner *Owner `type:"structure"`

	Size *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass ObjectStorageClass `type:"string" enum:"true"`
}

// String returns the string representation
func (s Object) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Object) MarshalFields(e protocol.FieldEncoder) error {
	if s.ETag != nil {
		v := *s.ETag

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ETag", protocol.StringValue(v), metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.LastModified != nil {
		v := *s.LastModified

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModified",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.Owner != nil {
		v := s.Owner

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Owner", v, metadata)
	}
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Size", protocol.Int64Value(v), metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", v, metadata)
	}
	return nil
}
func (s *Object) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Object{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Object.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ETag":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Object.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ETag = &value
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Object.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "LastModified":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Object.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.LastModified = &value
			case "Owner":
				value := Owner{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Object.%s, %s", name, err)
				}
				s.Owner = &value
			case "Size":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Object.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Size = &value
			case "StorageClass":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Object.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ObjectStorageClass(v)
				s.StorageClass = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Object.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ObjectIdentifier
type ObjectIdentifier struct {
	_ struct{} `type:"structure"`

	// Key name of the object to delete.
	//
	// Key is a required field
	Key *string `min:"1" type:"string" required:"true"`

	// VersionId for the specific version of the object to delete.
	VersionId *string `type:"string"`
}

// String returns the string representation
func (s ObjectIdentifier) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ObjectIdentifier) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ObjectIdentifier"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectIdentifier) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *ObjectIdentifier) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ObjectIdentifier{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ObjectIdentifier.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectIdentifier.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "VersionId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectIdentifier.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.VersionId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectIdentifier.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListObjectIdentifierList(s *[]ObjectIdentifier, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]ObjectIdentifier, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := ObjectIdentifier{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []ObjectIdentifier.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []ObjectIdentifier.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListObjectIdentifierList(s *[]ObjectIdentifier, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]ObjectIdentifier, 0)
		}
	}()
	value := ObjectIdentifier{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

func unmarshalAWSXMLListObjectList(s *[]Object, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Object, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := Object{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Object.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Object.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListObjectList(s *[]Object, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Object, 0)
		}
	}()
	value := Object{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// The container element for object lock configuration parameters.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ObjectLockConfiguration
type ObjectLockConfiguration struct {
	_ struct{} `type:"structure"`

	// Indicates whether this bucket has an object lock configuration enabled.
	ObjectLockEnabled ObjectLockEnabled `type:"string" enum:"true"`

	// The object lock rule in place for the specified object.
	Rule *ObjectLockRule `type:"structure"`
}

// String returns the string representation
func (s ObjectLockConfiguration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectLockConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ObjectLockEnabled) > 0 {
		v := s.ObjectLockEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectLockEnabled", v, metadata)
	}
	if s.Rule != nil {
		v := s.Rule

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Rule", v, metadata)
	}
	return nil
}
func (s *ObjectLockConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ObjectLockConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ObjectLockEnabled":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ObjectLockEnabled(v)
				s.ObjectLockEnabled = value
			case "Rule":
				value := ObjectLockRule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockConfiguration.%s, %s", name, err)
				}
				s.Rule = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// A Legal Hold configuration for an object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ObjectLockLegalHold
type ObjectLockLegalHold struct {
	_ struct{} `type:"structure"`

	// Indicates whether the specified object has a Legal Hold in place.
	Status ObjectLockLegalHoldStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s ObjectLockLegalHold) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectLockLegalHold) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}
func (s *ObjectLockLegalHold) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ObjectLockLegalHold{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockLegalHold.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockLegalHold.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ObjectLockLegalHoldStatus(v)
				s.Status = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockLegalHold.%s, %s", name, err)
				}
			}
		}
	}
}

// A Retention configuration for an object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ObjectLockRetention
type ObjectLockRetention struct {
	_ struct{} `type:"structure"`

	// Indicates the Retention mode for the specified object.
	Mode ObjectLockRetentionMode `type:"string" enum:"true"`

	// The date on which this object lock retention expires.
	RetainUntilDate *time.Time `type:"timestamp" timestampFormat:"iso8601"`
}

// String returns the string representation
func (s ObjectLockRetention) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectLockRetention) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Mode) > 0 {
		v := s.Mode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Mode", v, metadata)
	}
	if s.RetainUntilDate != nil {
		v := *s.RetainUntilDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RetainUntilDate",
			protocol.TimeValue{V: v, Format: "iso8601", QuotedFormatTime: false}, metadata)
	}
	return nil
}
func (s *ObjectLockRetention) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ObjectLockRetention{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockRetention.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Mode":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockRetention.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ObjectLockRetentionMode(v)
				s.Mode = value
			case "RetainUntilDate":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockRetention.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.RetainUntilDate = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockRetention.%s, %s", name, err)
				}
			}
		}
	}
}

// The container element for an object lock rule.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ObjectLockRule
type ObjectLockRule struct {
	_ struct{} `type:"structure"`

	// The default retention period that you want to apply to new objects placed
	// in the specified bucket.
	DefaultRetention *DefaultRetention `type:"structure"`
}

// String returns the string representation
func (s ObjectLockRule) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectLockRule) MarshalFields(e protocol.FieldEncoder) error {
	if s.DefaultRetention != nil {
		v := s.DefaultRetention

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DefaultRetention", v, metadata)
	}
	return nil
}
func (s *ObjectLockRule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ObjectLockRule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockRule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DefaultRetention":
				value := DefaultRetention{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockRule.%s, %s", name, err)
				}
				s.DefaultRetention = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectLockRule.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ObjectVersion
type ObjectVersion struct {
	_ struct{} `type:"structure"`

	ETag *string `type:"string"`

	// Specifies whether the object is (true) or is not (false) the latest version
	// of an object.
	IsLatest *bool `type:"boolean"`

	// The object key.
	Key *string `min:"1" type:"string"`

	// Date and time the object was last modified.
	LastModified *time.Time `type:"timestamp"`

	Owner *Owner `type:"structure"`

	// Size in bytes of the object.
	Size *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass ObjectVersionStorageClass `type:"string" enum:"true"`

	// Version ID of an object.
	VersionId *string `type:"string"`
}

// String returns the string representation
func (s ObjectVersion) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectVersion) MarshalFields(e protocol.FieldEncoder) error {
	if s.ETag != nil {
		v := *s.ETag

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ETag", protocol.StringValue(v), metadata)
	}
	if s.IsLatest != nil {
		v := *s.IsLatest

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsLatest", protocol.BoolValue(v), metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.LastModified != nil {
		v := *s.LastModified

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModified",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.Owner != nil {
		v := s.Owner

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Owner", v, metadata)
	}
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Size", protocol.Int64Value(v), metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", v, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *ObjectVersion) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ObjectVersion{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ETag":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ETag = &value
			case "IsLatest":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.IsLatest = &value
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "LastModified":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.LastModified = &value
			case "Owner":
				value := Owner{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
				s.Owner = &value
			case "Size":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Size = &value
			case "StorageClass":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ObjectVersionStorageClass(v)
				s.StorageClass = value
			case "VersionId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.VersionId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ObjectVersion.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListObjectVersionList(s *[]ObjectVersion, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]ObjectVersion, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := ObjectVersion{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []ObjectVersion.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []ObjectVersion.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListObjectVersionList(s *[]ObjectVersion, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]ObjectVersion, 0)
		}
	}()
	value := ObjectVersion{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Describes the location where the restore job's output is stored.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/OutputLocation
type OutputLocation struct {
	_ struct{} `type:"structure"`

	// Describes an S3 location that will receive the results of the restore request.
	S3 *S3Location `type:"structure"`
}

// String returns the string representation
func (s OutputLocation) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *OutputLocation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "OutputLocation"}
	if s.S3 != nil {
		if err := s.S3.Validate(); err != nil {
			invalidParams.AddNested("S3", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OutputLocation) MarshalFields(e protocol.FieldEncoder) error {
	if s.S3 != nil {
		v := s.S3

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3", v, metadata)
	}
	return nil
}
func (s *OutputLocation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = OutputLocation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML OutputLocation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "S3":
				value := S3Location{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML OutputLocation.%s, %s", name, err)
				}
				s.S3 = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML OutputLocation.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes how results of the Select job are serialized.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/OutputSerialization
type OutputSerialization struct {
	_ struct{} `type:"structure"`

	// Describes the serialization of CSV-encoded Select results.
	CSV *CSVOutput `type:"structure"`

	// Specifies JSON as request's output serialization format.
	JSON *JSONOutput `type:"structure"`
}

// String returns the string representation
func (s OutputSerialization) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OutputSerialization) MarshalFields(e protocol.FieldEncoder) error {
	if s.CSV != nil {
		v := s.CSV

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CSV", v, metadata)
	}
	if s.JSON != nil {
		v := s.JSON

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "JSON", v, metadata)
	}
	return nil
}
func (s *OutputSerialization) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = OutputSerialization{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML OutputSerialization.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CSV":
				value := CSVOutput{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML OutputSerialization.%s, %s", name, err)
				}
				s.CSV = &value
			case "JSON":
				value := JSONOutput{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML OutputSerialization.%s, %s", name, err)
				}
				s.JSON = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML OutputSerialization.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Owner
type Owner struct {
	_ struct{} `type:"structure"`

	DisplayName *string `type:"string"`

	ID *string `type:"string"`
}

// String returns the string representation
func (s Owner) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Owner) MarshalFields(e protocol.FieldEncoder) error {
	if s.DisplayName != nil {
		v := *s.DisplayName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DisplayName", protocol.StringValue(v), metadata)
	}
	if s.ID != nil {
		v := *s.ID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ID", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Owner) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Owner{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Owner.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DisplayName":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Owner.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.DisplayName = &value
			case "ID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Owner.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ID = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Owner.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ParquetInput
type ParquetInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s ParquetInput) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ParquetInput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}
func (s *ParquetInput) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ParquetInput{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ParquetInput.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ParquetInput.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Part
type Part struct {
	_ struct{} `type:"structure"`

	// Entity tag returned when the part was uploaded.
	ETag *string `type:"string"`

	// Date and time at which the part was uploaded.
	LastModified *time.Time `type:"timestamp"`

	// Part number identifying the part. This is a positive integer between 1 and
	// 10,000.
	PartNumber *int64 `type:"integer"`

	// Size in bytes of the uploaded part data.
	Size *int64 `type:"integer"`
}

// String returns the string representation
func (s Part) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Part) MarshalFields(e protocol.FieldEncoder) error {
	if s.ETag != nil {
		v := *s.ETag

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ETag", protocol.StringValue(v), metadata)
	}
	if s.LastModified != nil {
		v := *s.LastModified

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModified",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.PartNumber != nil {
		v := *s.PartNumber

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PartNumber", protocol.Int64Value(v), metadata)
	}
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Size", protocol.Int64Value(v), metadata)
	}
	return nil
}
func (s *Part) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Part{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Part.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ETag":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Part.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ETag = &value
			case "LastModified":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Part.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.LastModified = &value
			case "PartNumber":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Part.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.PartNumber = &value
			case "Size":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Part.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Size = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Part.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListParts(s *[]Part, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Part, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := Part{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Part.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Part.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListParts(s *[]Part, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Part, 0)
		}
	}()
	value := Part{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// The container element for a bucket's policy status.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/PolicyStatus
type PolicyStatus struct {
	_ struct{} `type:"structure"`

	// The policy status for this bucket. TRUE indicates that this bucket is public.
	// FALSE indicates that the bucket is not public.
	IsPublic *bool `locationName:"IsPublic" type:"boolean"`
}

// String returns the string representation
func (s PolicyStatus) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PolicyStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.IsPublic != nil {
		v := *s.IsPublic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsPublic", protocol.BoolValue(v), metadata)
	}
	return nil
}
func (s *PolicyStatus) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = PolicyStatus{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML PolicyStatus.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "IsPublic":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PolicyStatus.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.IsPublic = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PolicyStatus.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the Block Public Access configuration for an Amazon S3 bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/PublicAccessBlockConfiguration
type PublicAccessBlockConfiguration struct {
	_ struct{} `type:"structure"`

	// Specifies whether Amazon S3 should block public access control lists (ACLs)
	// for this bucket and objects in this bucket. Setting this element to TRUE
	// causes the following behavior:
	//
	//    * PUT Bucket acl and PUT Object acl calls fail if the specified ACL is
	//    public.
	//
	//    * PUT Object calls fail if the request includes a public ACL.
	//
	// Enabling this setting doesn't affect existing policies or ACLs.
	BlockPublicAcls *bool `locationName:"BlockPublicAcls" type:"boolean"`

	// Specifies whether Amazon S3 should block public bucket policies for this
	// bucket. Setting this element to TRUE causes Amazon S3 to reject calls to
	// PUT Bucket policy if the specified bucket policy allows public access.
	//
	// Enabling this setting doesn't affect existing bucket policies.
	BlockPublicPolicy *bool `locationName:"BlockPublicPolicy" type:"boolean"`

	// Specifies whether Amazon S3 should ignore public ACLs for this bucket and
	// objects in this bucket. Setting this element to TRUE causes Amazon S3 to
	// ignore all public ACLs on this bucket and objects in this bucket.
	//
	// Enabling this setting doesn't affect the persistence of any existing ACLs
	// and doesn't prevent new public ACLs from being set.
	IgnorePublicAcls *bool `locationName:"IgnorePublicAcls" type:"boolean"`

	// Specifies whether Amazon S3 should restrict public bucket policies for this
	// bucket. Setting this element to TRUE restricts access to this bucket to only
	// AWS services and authorized users within this account if the bucket has a
	// public policy.
	//
	// Enabling this setting doesn't affect previously stored bucket policies, except
	// that public and cross-account access within any public bucket policy, including
	// non-public delegation to specific accounts, is blocked.
	RestrictPublicBuckets *bool `locationName:"RestrictPublicBuckets" type:"boolean"`
}

// String returns the string representation
func (s PublicAccessBlockConfiguration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PublicAccessBlockConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.BlockPublicAcls != nil {
		v := *s.BlockPublicAcls

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BlockPublicAcls", protocol.BoolValue(v), metadata)
	}
	if s.BlockPublicPolicy != nil {
		v := *s.BlockPublicPolicy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BlockPublicPolicy", protocol.BoolValue(v), metadata)
	}
	if s.IgnorePublicAcls != nil {
		v := *s.IgnorePublicAcls

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IgnorePublicAcls", protocol.BoolValue(v), metadata)
	}
	if s.RestrictPublicBuckets != nil {
		v := *s.RestrictPublicBuckets

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RestrictPublicBuckets", protocol.BoolValue(v), metadata)
	}
	return nil
}
func (s *PublicAccessBlockConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = PublicAccessBlockConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "BlockPublicAcls":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.BlockPublicAcls = &value
			case "BlockPublicPolicy":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.BlockPublicPolicy = &value
			case "IgnorePublicAcls":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.IgnorePublicAcls = &value
			case "RestrictPublicBuckets":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.RestrictPublicBuckets = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the configuration for publishing messages to an Amazon Simple Queue
// Service (Amazon SQS) queue when Amazon S3 detects specified events.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/QueueConfiguration
type QueueConfiguration struct {
	_ struct{} `type:"structure"`

	// Events is a required field
	Events []Event `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Specifies object key name filtering rules. For information about key name
	// filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html)
	// in the Amazon Simple Storage Service Developer Guide.
	Filter *NotificationConfigurationFilter `type:"structure"`

	// An optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	Id *string `type:"string"`

	// The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3
	// publishes a message when it detects events of the specified type.
	//
	// QueueArn is a required field
	QueueArn *string `locationName:"Queue" type:"string" required:"true"`
}

// String returns the string representation
func (s QueueConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *QueueConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "QueueConfiguration"}

	if s.Events == nil {
		invalidParams.Add(aws.NewErrParamRequired("Events"))
	}

	if s.QueueArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("QueueArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s QueueConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Events != nil {
		v := s.Events

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Event", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.Filter != nil {
		v := s.Filter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filter", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.QueueArn != nil {
		v := *s.QueueArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Queue", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *QueueConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = QueueConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML QueueConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Event":
				if s.Events == nil {
					s.Events = make([]Event, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Event(v)
				s.Events = append(s.Events, value)
			case "Filter":
				value := NotificationConfigurationFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfiguration.%s, %s", name, err)
				}
				s.Filter = &value
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			case "Queue":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.QueueArn = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/QueueConfigurationDeprecated
type QueueConfigurationDeprecated struct {
	_ struct{} `type:"structure"`

	// The bucket event for which to send notifications.
	Event Event `deprecated:"true" type:"string" enum:"true"`

	Events []Event `locationName:"Event" type:"list" flattened:"true"`

	// An optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	Id *string `type:"string"`

	Queue *string `type:"string"`
}

// String returns the string representation
func (s QueueConfigurationDeprecated) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s QueueConfigurationDeprecated) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Event) > 0 {
		v := s.Event

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Event", v, metadata)
	}
	if s.Events != nil {
		v := s.Events

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Event", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.Queue != nil {
		v := *s.Queue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Queue", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *QueueConfigurationDeprecated) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = QueueConfigurationDeprecated{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML QueueConfigurationDeprecated.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Event":
				if s.Events == nil {
					s.Events = make([]Event, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfigurationDeprecated.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Event(v)
				s.Events = append(s.Events, value)
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfigurationDeprecated.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			case "Queue":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfigurationDeprecated.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Queue = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML QueueConfigurationDeprecated.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListQueueConfigurationList(s *[]QueueConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]QueueConfiguration, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := QueueConfiguration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []QueueConfiguration.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []QueueConfiguration.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListQueueConfigurationList(s *[]QueueConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]QueueConfiguration, 0)
		}
	}()
	value := QueueConfiguration{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Specifies how requests are redirected. In the event of an error, you can
// specify a different error code to return.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Redirect
type Redirect struct {
	_ struct{} `type:"structure"`

	// The host name to use in the redirect request.
	HostName *string `type:"string"`

	// The HTTP redirect code to use on the response. Not required if one of the
	// siblings is present.
	HttpRedirectCode *string `type:"string"`

	// Protocol to use when redirecting requests. The default is the protocol that
	// is used in the original request.
	Protocol Protocol `type:"string" enum:"true"`

	// The object key prefix to use in the redirect request. For example, to redirect
	// requests for all pages with prefix docs/ (objects in the docs/ folder) to
	// documents/, you can set a condition block with KeyPrefixEquals set to docs/
	// and in the Redirect set ReplaceKeyPrefixWith to /documents. Not required
	// if one of the siblings is present. Can be present only if ReplaceKeyWith
	// is not provided.
	ReplaceKeyPrefixWith *string `type:"string"`

	// The specific object key to use in the redirect request. For example, redirect
	// request to error.html. Not required if one of the siblings is present. Can
	// be present only if ReplaceKeyPrefixWith is not provided.
	ReplaceKeyWith *string `type:"string"`
}

// String returns the string representation
func (s Redirect) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Redirect) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostName != nil {
		v := *s.HostName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostName", protocol.StringValue(v), metadata)
	}
	if s.HttpRedirectCode != nil {
		v := *s.HttpRedirectCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpRedirectCode", protocol.StringValue(v), metadata)
	}
	if len(s.Protocol) > 0 {
		v := s.Protocol

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Protocol", v, metadata)
	}
	if s.ReplaceKeyPrefixWith != nil {
		v := *s.ReplaceKeyPrefixWith

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReplaceKeyPrefixWith", protocol.StringValue(v), metadata)
	}
	if s.ReplaceKeyWith != nil {
		v := *s.ReplaceKeyWith

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReplaceKeyWith", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Redirect) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Redirect{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Redirect.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "HostName":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Redirect.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.HostName = &value
			case "HttpRedirectCode":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Redirect.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.HttpRedirectCode = &value
			case "Protocol":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Redirect.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Protocol(v)
				s.Protocol = value
			case "ReplaceKeyPrefixWith":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Redirect.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ReplaceKeyPrefixWith = &value
			case "ReplaceKeyWith":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Redirect.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ReplaceKeyWith = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Redirect.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the redirect behavior of all requests to a website endpoint of
// an Amazon S3 bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/RedirectAllRequestsTo
type RedirectAllRequestsTo struct {
	_ struct{} `type:"structure"`

	// Name of the host where requests are redirected.
	//
	// HostName is a required field
	HostName *string `type:"string" required:"true"`

	// Protocol to use when redirecting requests. The default is the protocol that
	// is used in the original request.
	Protocol Protocol `type:"string" enum:"true"`
}

// String returns the string representation
func (s RedirectAllRequestsTo) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RedirectAllRequestsTo) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RedirectAllRequestsTo"}

	if s.HostName == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RedirectAllRequestsTo) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostName != nil {
		v := *s.HostName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostName", protocol.StringValue(v), metadata)
	}
	if len(s.Protocol) > 0 {
		v := s.Protocol

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Protocol", v, metadata)
	}
	return nil
}
func (s *RedirectAllRequestsTo) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = RedirectAllRequestsTo{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML RedirectAllRequestsTo.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "HostName":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RedirectAllRequestsTo.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.HostName = &value
			case "Protocol":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RedirectAllRequestsTo.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Protocol(v)
				s.Protocol = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RedirectAllRequestsTo.%s, %s", name, err)
				}
			}
		}
	}
}

// A container for replication rules. You can add up to 1,000 rules. The maximum
// size of a replication configuration is 2 MB.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ReplicationConfiguration
type ReplicationConfiguration struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the AWS Identity and Access Management
	// (IAM) role that Amazon S3 assumes when replicating objects. For more information,
	// see How to Set Up Cross-Region Replication (https://docs.aws.amazon.com/AmazonS3/latest/dev/crr-how-setup.html)
	// in the Amazon Simple Storage Service Developer Guide.
	//
	// Role is a required field
	Role *string `type:"string" required:"true"`

	// A container for one or more replication rules. A replication configuration
	// must have at least one rule and can contain a maximum of 1,000 rules.
	//
	// Rules is a required field
	Rules []ReplicationRule `locationName:"Rule" type:"list" flattened:"true" required:"true"`
}

// String returns the string representation
func (s ReplicationConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplicationConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ReplicationConfiguration"}

	if s.Role == nil {
		invalidParams.Add(aws.NewErrParamRequired("Role"))
	}

	if s.Rules == nil {
		invalidParams.Add(aws.NewErrParamRequired("Rules"))
	}
	if s.Rules != nil {
		for i, v := range s.Rules {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Rules", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReplicationConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Role != nil {
		v := *s.Role

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Role", protocol.StringValue(v), metadata)
	}
	if s.Rules != nil {
		v := s.Rules

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Rule", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *ReplicationConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ReplicationConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ReplicationConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Role":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Role = &value
			case "Rule":
				if s.Rules == nil {
					s.Rules = make([]ReplicationRule, 0)
				}
				err := unmarshalAWSXMLFlattenedListReplicationRules(&s.Rules, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationConfiguration.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies which Amazon S3 objects to replicate and where to store the replicas.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ReplicationRule
type ReplicationRule struct {
	_ struct{} `type:"structure"`

	// Specifies whether Amazon S3 should replicate delete makers.
	DeleteMarkerReplication *DeleteMarkerReplication `type:"structure"`

	// A container for information about the replication destination.
	//
	// Destination is a required field
	Destination *Destination `type:"structure" required:"true"`

	// A filter that identifies the subset of objects to which the replication rule
	// applies. A Filter must specify exactly one Prefix, Tag, or an And child element.
	Filter *ReplicationRuleFilter `type:"structure"`

	// A unique identifier for the rule. The maximum value is 255 characters.
	ID *string `type:"string"`

	// An object keyname prefix that identifies the object or objects to which the
	// rule applies. The maximum prefix length is 1,024 characters. To include all
	// objects in a bucket, specify an empty string.
	Prefix *string `deprecated:"true" type:"string"`

	// The priority associated with the rule. If you specify multiple rules in a
	// replication configuration, Amazon S3 prioritizes the rules to prevent conflicts
	// when filtering. If two or more rules identify the same object based on a
	// specified filter, the rule with higher priority takes precedence. For example:
	//
	//    * Same object quality prefix based filter criteria If prefixes you specified
	//    in multiple rules overlap
	//
	//    * Same object qualify tag based filter criteria specified in multiple
	//    rules
	//
	// For more information, see Cross-Region Replication (CRR) (https://docs.aws.amazon.com/AmazonS3/latest/dev/crr.html)
	// in the Amazon S3 Developer Guide.
	Priority *int64 `type:"integer"`

	// A container that describes additional filters for identifying the source
	// objects that you want to replicate. You can choose to enable or disable the
	// replication of these objects. Currently, Amazon S3 supports only the filter
	// that you can specify for objects created with server-side encryption using
	// an AWS KMS-Managed Key (SSE-KMS).
	SourceSelectionCriteria *SourceSelectionCriteria `type:"structure"`

	// Specifies whether the rule is enabled.
	//
	// Status is a required field
	Status ReplicationRuleStatus `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s ReplicationRule) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplicationRule) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ReplicationRule"}

	if s.Destination == nil {
		invalidParams.Add(aws.NewErrParamRequired("Destination"))
	}
	if len(s.Status) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Status"))
	}
	if s.Destination != nil {
		if err := s.Destination.Validate(); err != nil {
			invalidParams.AddNested("Destination", err.(aws.ErrInvalidParams))
		}
	}
	if s.Filter != nil {
		if err := s.Filter.Validate(); err != nil {
			invalidParams.AddNested("Filter", err.(aws.ErrInvalidParams))
		}
	}
	if s.SourceSelectionCriteria != nil {
		if err := s.SourceSelectionCriteria.Validate(); err != nil {
			invalidParams.AddNested("SourceSelectionCriteria", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReplicationRule) MarshalFields(e protocol.FieldEncoder) error {
	if s.DeleteMarkerReplication != nil {
		v := s.DeleteMarkerReplication

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DeleteMarkerReplication", v, metadata)
	}
	if s.Destination != nil {
		v := s.Destination

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Destination", v, metadata)
	}
	if s.Filter != nil {
		v := s.Filter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filter", v, metadata)
	}
	if s.ID != nil {
		v := *s.ID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ID", protocol.StringValue(v), metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Priority", protocol.Int64Value(v), metadata)
	}
	if s.SourceSelectionCriteria != nil {
		v := s.SourceSelectionCriteria

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SourceSelectionCriteria", v, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}
func (s *ReplicationRule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ReplicationRule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DeleteMarkerReplication":
				value := DeleteMarkerReplication{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
				}
				s.DeleteMarkerReplication = &value
			case "Destination":
				value := Destination{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
				}
				s.Destination = &value
			case "Filter":
				value := ReplicationRuleFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
				}
				s.Filter = &value
			case "ID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ID = &value
			case "Priority":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Priority = &value
			case "SourceSelectionCriteria":
				value := SourceSelectionCriteria{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
				}
				s.SourceSelectionCriteria = &value
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ReplicationRuleStatus(v)
				s.Status = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRule.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ReplicationRuleAndOperator
type ReplicationRuleAndOperator struct {
	_ struct{} `type:"structure"`

	Prefix *string `type:"string"`

	Tags []Tag `locationName:"Tag" locationNameList:"Tag" type:"list" flattened:"true"`
}

// String returns the string representation
func (s ReplicationRuleAndOperator) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplicationRuleAndOperator) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ReplicationRuleAndOperator"}
	if s.Tags != nil {
		for i, v := range s.Tags {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Tags", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReplicationRuleAndOperator) MarshalFields(e protocol.FieldEncoder) error {
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Tags != nil {
		v := s.Tags

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Tag", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *ReplicationRuleAndOperator) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ReplicationRuleAndOperator{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleAndOperator.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleAndOperator.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Tag":
				if s.Tags == nil {
					s.Tags = make([]Tag, 0)
				}
				err := unmarshalAWSXMLFlattenedListTagSet(&s.Tags, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleAndOperator.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleAndOperator.%s, %s", name, err)
				}
			}
		}
	}
}

// A filter that identifies the subset of objects to which the replication rule
// applies. A Filter must specify exactly one Prefix, Tag, or an And child element.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ReplicationRuleFilter
type ReplicationRuleFilter struct {
	_ struct{} `type:"structure"`

	// A container for specifying rule filters. The filters determine the subset
	// of objects to which the rule applies. This element is required only if you
	// specify more than one filter. For example:
	//
	//    * If you specify both a Prefix and a Tag filter, wrap these filters in
	//    an And tag.
	//
	//    * If you specify a filter based on multiple tags, wrap the Tag elements
	//    in an And tag.
	And *ReplicationRuleAndOperator `type:"structure"`

	// An object keyname prefix that identifies the subset of objects to which the
	// rule applies.
	Prefix *string `type:"string"`

	// A container for specifying a tag key and value.
	//
	// The rule applies only to objects that have the tag in their tag set.
	Tag *Tag `type:"structure"`
}

// String returns the string representation
func (s ReplicationRuleFilter) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplicationRuleFilter) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ReplicationRuleFilter"}
	if s.And != nil {
		if err := s.And.Validate(); err != nil {
			invalidParams.AddNested("And", err.(aws.ErrInvalidParams))
		}
	}
	if s.Tag != nil {
		if err := s.Tag.Validate(); err != nil {
			invalidParams.AddNested("Tag", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReplicationRuleFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.And != nil {
		v := s.And

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "And", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if s.Tag != nil {
		v := s.Tag

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Tag", v, metadata)
	}
	return nil
}
func (s *ReplicationRuleFilter) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ReplicationRuleFilter{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleFilter.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "And":
				value := ReplicationRuleAndOperator{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleFilter.%s, %s", name, err)
				}
				s.And = &value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleFilter.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Tag":
				value := Tag{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleFilter.%s, %s", name, err)
				}
				s.Tag = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ReplicationRuleFilter.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListReplicationRules(s *[]ReplicationRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]ReplicationRule, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := ReplicationRule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []ReplicationRule.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []ReplicationRule.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListReplicationRules(s *[]ReplicationRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]ReplicationRule, 0)
		}
	}()
	value := ReplicationRule{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/RequestPaymentConfiguration
type RequestPaymentConfiguration struct {
	_ struct{} `type:"structure"`

	// Specifies who pays for the download and request fees.
	//
	// Payer is a required field
	Payer Payer `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s RequestPaymentConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RequestPaymentConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RequestPaymentConfiguration"}
	if len(s.Payer) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Payer"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RequestPaymentConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Payer) > 0 {
		v := s.Payer

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Payer", v, metadata)
	}
	return nil
}
func (s *RequestPaymentConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = RequestPaymentConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML RequestPaymentConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Payer":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RequestPaymentConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Payer(v)
				s.Payer = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RequestPaymentConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Container for restore job parameters.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/RestoreRequest
type RestoreRequest struct {
	_ struct{} `type:"structure"`

	// Lifetime of the active copy in days. Do not use with restores that specify
	// OutputLocation.
	Days *int64 `type:"integer"`

	// The optional description for the job.
	Description *string `type:"string"`

	// Glacier related parameters pertaining to this job. Do not use with restores
	// that specify OutputLocation.
	GlacierJobParameters *GlacierJobParameters `type:"structure"`

	// Describes the location where the restore job's output is stored.
	OutputLocation *OutputLocation `type:"structure"`

	// Describes the parameters for Select job types.
	SelectParameters *SelectParameters `type:"structure"`

	// Glacier retrieval tier at which the restore will be processed.
	Tier Tier `type:"string" enum:"true"`

	// Type of restore request.
	Type RestoreRequestType `type:"string" enum:"true"`
}

// String returns the string representation
func (s RestoreRequest) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RestoreRequest) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RestoreRequest"}
	if s.GlacierJobParameters != nil {
		if err := s.GlacierJobParameters.Validate(); err != nil {
			invalidParams.AddNested("GlacierJobParameters", err.(aws.ErrInvalidParams))
		}
	}
	if s.OutputLocation != nil {
		if err := s.OutputLocation.Validate(); err != nil {
			invalidParams.AddNested("OutputLocation", err.(aws.ErrInvalidParams))
		}
	}
	if s.SelectParameters != nil {
		if err := s.SelectParameters.Validate(); err != nil {
			invalidParams.AddNested("SelectParameters", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RestoreRequest) MarshalFields(e protocol.FieldEncoder) error {
	if s.Days != nil {
		v := *s.Days

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Days", protocol.Int64Value(v), metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.StringValue(v), metadata)
	}
	if s.GlacierJobParameters != nil {
		v := s.GlacierJobParameters

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "GlacierJobParameters", v, metadata)
	}
	if s.OutputLocation != nil {
		v := s.OutputLocation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "OutputLocation", v, metadata)
	}
	if s.SelectParameters != nil {
		v := s.SelectParameters

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SelectParameters", v, metadata)
	}
	if len(s.Tier) > 0 {
		v := s.Tier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Tier", v, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	return nil
}
func (s *RestoreRequest) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = RestoreRequest{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Days":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Days = &value
			case "Description":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Description = &value
			case "GlacierJobParameters":
				value := GlacierJobParameters{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
				}
				s.GlacierJobParameters = &value
			case "OutputLocation":
				value := OutputLocation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
				}
				s.OutputLocation = &value
			case "SelectParameters":
				value := SelectParameters{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
				}
				s.SelectParameters = &value
			case "Tier":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Tier(v)
				s.Tier = value
			case "Type":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := RestoreRequestType(v)
				s.Type = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RestoreRequest.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the redirect behavior and when a redirect is applied.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/RoutingRule
type RoutingRule struct {
	_ struct{} `type:"structure"`

	// A container for describing a condition that must be met for the specified
	// redirect to apply. For example, 1. If request is for pages in the /docs folder,
	// redirect to the /documents folder. 2. If request results in HTTP error 4xx,
	// redirect request to another host where you might process the error.
	Condition *Condition `type:"structure"`

	// Container for redirect information. You can redirect requests to another
	// host, to another page, or with another protocol. In the event of an error,
	// you can specify a different error code to return.
	//
	// Redirect is a required field
	Redirect *Redirect `type:"structure" required:"true"`
}

// String returns the string representation
func (s RoutingRule) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RoutingRule) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RoutingRule"}

	if s.Redirect == nil {
		invalidParams.Add(aws.NewErrParamRequired("Redirect"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RoutingRule) MarshalFields(e protocol.FieldEncoder) error {
	if s.Condition != nil {
		v := s.Condition

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Condition", v, metadata)
	}
	if s.Redirect != nil {
		v := s.Redirect

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Redirect", v, metadata)
	}
	return nil
}
func (s *RoutingRule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = RoutingRule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML RoutingRule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Condition":
				value := Condition{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RoutingRule.%s, %s", name, err)
				}
				s.Condition = &value
			case "Redirect":
				value := Redirect{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RoutingRule.%s, %s", name, err)
				}
				s.Redirect = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML RoutingRule.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListRoutingRules(s *[]RoutingRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]RoutingRule, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "RoutingRule":
				value := RoutingRule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []RoutingRule.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []RoutingRule.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListRoutingRules(s *[]RoutingRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]RoutingRule, 0)
		}
	}()
	value := RoutingRule{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Specifies lifecycle rules for an Amazon S3 bucket. For more information,
// see PUT Bucket lifecycle (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlifecycle.html)
// in the Amazon Simple Storage Service API Reference.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Rule
type Rule struct {
	_ struct{} `type:"structure"`

	// Specifies the days since the initiation of an incomplete multipart upload
	// that Amazon S3 will wait before permanently removing all parts of the upload.
	// For more information, see Aborting Incomplete Multipart Uploads Using a Bucket
	// Lifecycle Policy (https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config)
	// in the Amazon Simple Storage Service Developer Guide.
	AbortIncompleteMultipartUpload *AbortIncompleteMultipartUpload `type:"structure"`

	Expiration *LifecycleExpiration `type:"structure"`

	// Unique identifier for the rule. The value can't be longer than 255 characters.
	ID *string `type:"string"`

	// Specifies when noncurrent object versions expire. Upon expiration, Amazon
	// S3 permanently deletes the noncurrent object versions. You set this lifecycle
	// configuration action on a bucket that has versioning enabled (or suspended)
	// to request that Amazon S3 delete noncurrent object versions at a specific
	// period in the object's lifetime.
	NoncurrentVersionExpiration *NoncurrentVersionExpiration `type:"structure"`

	// Container for the transition rule that describes when noncurrent objects
	// transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER,
	// or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning
	// is suspended), you can set this action to request that Amazon S3 transition
	// noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING,
	// GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's
	// lifetime.
	NoncurrentVersionTransition *NoncurrentVersionTransition `type:"structure"`

	// Object key prefix that identifies one or more objects to which this rule
	// applies.
	//
	// Prefix is a required field
	Prefix *string `type:"string" required:"true"`

	// If Enabled, the rule is currently being applied. If Disabled, the rule is
	// not currently being applied.
	//
	// Status is a required field
	Status ExpirationStatus `type:"string" required:"true" enum:"true"`

	// Specifies when an object transitions to a specified storage class.
	Transition *Transition `type:"structure"`
}

// String returns the string representation
func (s Rule) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Rule) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Rule"}

	if s.Prefix == nil {
		invalidParams.Add(aws.NewErrParamRequired("Prefix"))
	}
	if len(s.Status) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Status"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Rule) MarshalFields(e protocol.FieldEncoder) error {
	if s.AbortIncompleteMultipartUpload != nil {
		v := s.AbortIncompleteMultipartUpload

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AbortIncompleteMultipartUpload", v, metadata)
	}
	if s.Expiration != nil {
		v := s.Expiration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Expiration", v, metadata)
	}
	if s.ID != nil {
		v := *s.ID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ID", protocol.StringValue(v), metadata)
	}
	if s.NoncurrentVersionExpiration != nil {
		v := s.NoncurrentVersionExpiration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "NoncurrentVersionExpiration", v, metadata)
	}
	if s.NoncurrentVersionTransition != nil {
		v := s.NoncurrentVersionTransition

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "NoncurrentVersionTransition", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	if s.Transition != nil {
		v := s.Transition

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Transition", v, metadata)
	}
	return nil
}
func (s *Rule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Rule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AbortIncompleteMultipartUpload":
				value := AbortIncompleteMultipartUpload{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
				s.AbortIncompleteMultipartUpload = &value
			case "Expiration":
				value := LifecycleExpiration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
				s.Expiration = &value
			case "ID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ID = &value
			case "NoncurrentVersionExpiration":
				value := NoncurrentVersionExpiration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
				s.NoncurrentVersionExpiration = &value
			case "NoncurrentVersionTransition":
				value := NoncurrentVersionTransition{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
				s.NoncurrentVersionTransition = &value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ExpirationStatus(v)
				s.Status = value
			case "Transition":
				value := Transition{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
				s.Transition = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Rule.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListRules(s *[]Rule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Rule, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := Rule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Rule.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Rule.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListRules(s *[]Rule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Rule, 0)
		}
	}()
	value := Rule{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// A container for object key name prefix and suffix filtering rules.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/S3KeyFilter
type S3KeyFilter struct {
	_ struct{} `type:"structure"`

	// A list of containers for the key value pair that defines the criteria for
	// the filter rule.
	FilterRules []FilterRule `locationName:"FilterRule" type:"list" flattened:"true"`
}

// String returns the string representation
func (s S3KeyFilter) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3KeyFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.FilterRules != nil {
		v := s.FilterRules

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "FilterRule", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *S3KeyFilter) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3KeyFilter{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3KeyFilter.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "FilterRule":
				if s.FilterRules == nil {
					s.FilterRules = make([]FilterRule, 0)
				}
				err := unmarshalAWSXMLFlattenedListFilterRuleList(&s.FilterRules, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3KeyFilter.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3KeyFilter.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes an S3 location that will receive the results of the restore request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/S3Location
type S3Location struct {
	_ struct{} `type:"structure"`

	// A list of grants that control access to the staged results.
	AccessControlList []Grant `locationNameList:"Grant" type:"list"`

	// The name of the bucket where the restore results will be placed.
	//
	// BucketName is a required field
	BucketName *string `type:"string" required:"true"`

	// The canned ACL to apply to the restore results.
	CannedACL ObjectCannedACL `type:"string" enum:"true"`

	// Describes the server-side encryption that will be applied to the restore
	// results.
	Encryption *Encryption `type:"structure"`

	// The prefix that is prepended to the restore results for this request.
	//
	// Prefix is a required field
	Prefix *string `type:"string" required:"true"`

	// The class of storage used to store the restore results.
	StorageClass StorageClass `type:"string" enum:"true"`

	// The tag-set that is applied to the restore results.
	Tagging *Tagging `type:"structure"`

	// A list of metadata to store with the restore results in S3.
	UserMetadata []MetadataEntry `locationNameList:"MetadataEntry" type:"list"`
}

// String returns the string representation
func (s S3Location) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Location) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Location"}

	if s.BucketName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BucketName"))
	}

	if s.Prefix == nil {
		invalidParams.Add(aws.NewErrParamRequired("Prefix"))
	}
	if s.AccessControlList != nil {
		for i, v := range s.AccessControlList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AccessControlList", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.Encryption != nil {
		if err := s.Encryption.Validate(); err != nil {
			invalidParams.AddNested("Encryption", err.(aws.ErrInvalidParams))
		}
	}
	if s.Tagging != nil {
		if err := s.Tagging.Validate(); err != nil {
			invalidParams.AddNested("Tagging", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Location) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccessControlList != nil {
		v := s.AccessControlList

		metadata := protocol.Metadata{ListLocationName: "Grant"}
		ls0 := e.List(protocol.BodyTarget, "AccessControlList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.BucketName != nil {
		v := *s.BucketName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BucketName", protocol.StringValue(v), metadata)
	}
	if len(s.CannedACL) > 0 {
		v := s.CannedACL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CannedACL", v, metadata)
	}
	if s.Encryption != nil {
		v := s.Encryption

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Encryption", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", v, metadata)
	}
	if s.Tagging != nil {
		v := s.Tagging

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Tagging", v, metadata)
	}
	if s.UserMetadata != nil {
		v := s.UserMetadata

		metadata := protocol.Metadata{ListLocationName: "MetadataEntry"}
		ls0 := e.List(protocol.BodyTarget, "UserMetadata", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *S3Location) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3Location{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AccessControlList":
				if s.AccessControlList == nil {
					s.AccessControlList = make([]Grant, 0)
				}
				err := unmarshalAWSXMLListGrants(&s.AccessControlList, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
			case "BucketName":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.BucketName = &value
			case "CannedACL":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ObjectCannedACL(v)
				s.CannedACL = value
			case "Encryption":
				value := Encryption{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
				s.Encryption = &value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "StorageClass":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := StorageClass(v)
				s.StorageClass = value
			case "Tagging":
				value := Tagging{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
				s.Tagging = &value
			case "UserMetadata":
				if s.UserMetadata == nil {
					s.UserMetadata = make([]MetadataEntry, 0)
				}
				err := unmarshalAWSXMLListUserMetadata(&s.UserMetadata, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Location.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the use of SSE-KMS to encrypt delivered Inventory reports.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/SSEKMS
type SSEKMS struct {
	_ struct{} `locationName:"SSE-KMS" type:"structure"`

	// Specifies the ID of the AWS Key Management Service (KMS) master encryption
	// key to use for encrypting Inventory reports.
	//
	// KeyId is a required field
	KeyId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s SSEKMS) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SSEKMS) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SSEKMS"}

	if s.KeyId == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeyId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SSEKMS) MarshalFields(e protocol.FieldEncoder) error {
	e.SetFields(protocol.BodyTarget, "SSE-KMS", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.KeyId != nil {
			v := *s.KeyId

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "KeyId", protocol.StringValue(v), metadata)
		}
		return nil
	}), protocol.Metadata{})
	return nil
}
func (s *SSEKMS) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = SSEKMS{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML SSEKMS.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "KeyId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SSEKMS.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.KeyId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SSEKMS.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the use of SSE-S3 to encrypt delivered Inventory reports.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/SSES3
type SSES3 struct {
	_ struct{} `locationName:"SSE-S3" type:"structure"`
}

// String returns the string representation
func (s SSES3) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SSES3) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}
func (s *SSES3) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = SSES3{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML SSES3.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SSES3.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes the parameters for Select job types.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/SelectParameters
type SelectParameters struct {
	_ struct{} `type:"structure"`

	// The expression that is used to query the object.
	//
	// Expression is a required field
	Expression *string `type:"string" required:"true"`

	// The type of the provided expression (e.g., SQL).
	//
	// ExpressionType is a required field
	ExpressionType ExpressionType `type:"string" required:"true" enum:"true"`

	// Describes the serialization format of the object.
	//
	// InputSerialization is a required field
	InputSerialization *InputSerialization `type:"structure" required:"true"`

	// Describes how the results of the Select job are serialized.
	//
	// OutputSerialization is a required field
	OutputSerialization *OutputSerialization `type:"structure" required:"true"`
}

// String returns the string representation
func (s SelectParameters) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SelectParameters) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SelectParameters"}

	if s.Expression == nil {
		invalidParams.Add(aws.NewErrParamRequired("Expression"))
	}
	if len(s.ExpressionType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ExpressionType"))
	}

	if s.InputSerialization == nil {
		invalidParams.Add(aws.NewErrParamRequired("InputSerialization"))
	}

	if s.OutputSerialization == nil {
		invalidParams.Add(aws.NewErrParamRequired("OutputSerialization"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SelectParameters) MarshalFields(e protocol.FieldEncoder) error {
	if s.Expression != nil {
		v := *s.Expression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Expression", protocol.StringValue(v), metadata)
	}
	if len(s.ExpressionType) > 0 {
		v := s.ExpressionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpressionType", v, metadata)
	}
	if s.InputSerialization != nil {
		v := s.InputSerialization

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "InputSerialization", v, metadata)
	}
	if s.OutputSerialization != nil {
		v := s.OutputSerialization

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "OutputSerialization", v, metadata)
	}
	return nil
}
func (s *SelectParameters) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = SelectParameters{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML SelectParameters.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Expression":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SelectParameters.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Expression = &value
			case "ExpressionType":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SelectParameters.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ExpressionType(v)
				s.ExpressionType = value
			case "InputSerialization":
				value := InputSerialization{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SelectParameters.%s, %s", name, err)
				}
				s.InputSerialization = &value
			case "OutputSerialization":
				value := OutputSerialization{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SelectParameters.%s, %s", name, err)
				}
				s.OutputSerialization = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SelectParameters.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes the default server-side encryption to apply to new objects in the
// bucket. If a PUT Object request doesn't specify any server-side encryption,
// this default encryption will be applied. For more information, see PUT Bucket
// encryption (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html)
// in the Amazon Simple Storage Service API Reference.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ServerSideEncryptionByDefault
type ServerSideEncryptionByDefault struct {
	_ struct{} `type:"structure"`

	// KMS master key ID to use for the default encryption. This parameter is allowed
	// if and only if SSEAlgorithm is set to aws:kms.
	KMSMasterKeyID *string `type:"string"`

	// Server-side encryption algorithm to use for the default encryption.
	//
	// SSEAlgorithm is a required field
	SSEAlgorithm ServerSideEncryption `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s ServerSideEncryptionByDefault) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ServerSideEncryptionByDefault) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ServerSideEncryptionByDefault"}
	if len(s.SSEAlgorithm) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("SSEAlgorithm"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ServerSideEncryptionByDefault) MarshalFields(e protocol.FieldEncoder) error {
	if s.KMSMasterKeyID != nil {
		v := *s.KMSMasterKeyID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KMSMasterKeyID", protocol.StringValue(v), metadata)
	}
	if len(s.SSEAlgorithm) > 0 {
		v := s.SSEAlgorithm

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SSEAlgorithm", v, metadata)
	}
	return nil
}
func (s *ServerSideEncryptionByDefault) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ServerSideEncryptionByDefault{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionByDefault.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "KMSMasterKeyID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionByDefault.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.KMSMasterKeyID = &value
			case "SSEAlgorithm":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionByDefault.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := ServerSideEncryption(v)
				s.SSEAlgorithm = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionByDefault.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the default server-side-encryption configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ServerSideEncryptionConfiguration
type ServerSideEncryptionConfiguration struct {
	_ struct{} `type:"structure"`

	// Container for information about a particular server-side encryption configuration
	// rule.
	//
	// Rules is a required field
	Rules []ServerSideEncryptionRule `locationName:"Rule" type:"list" flattened:"true" required:"true"`
}

// String returns the string representation
func (s ServerSideEncryptionConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ServerSideEncryptionConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ServerSideEncryptionConfiguration"}

	if s.Rules == nil {
		invalidParams.Add(aws.NewErrParamRequired("Rules"))
	}
	if s.Rules != nil {
		for i, v := range s.Rules {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Rules", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ServerSideEncryptionConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Rules != nil {
		v := s.Rules

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Rule", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *ServerSideEncryptionConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ServerSideEncryptionConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Rule":
				if s.Rules == nil {
					s.Rules = make([]ServerSideEncryptionRule, 0)
				}
				err := unmarshalAWSXMLFlattenedListServerSideEncryptionRules(&s.Rules, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionConfiguration.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies the default server-side encryption configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/ServerSideEncryptionRule
type ServerSideEncryptionRule struct {
	_ struct{} `type:"structure"`

	// Specifies the default server-side encryption to apply to new objects in the
	// bucket. If a PUT Object request doesn't specify any server-side encryption,
	// this default encryption will be applied.
	ApplyServerSideEncryptionByDefault *ServerSideEncryptionByDefault `type:"structure"`
}

// String returns the string representation
func (s ServerSideEncryptionRule) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ServerSideEncryptionRule) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ServerSideEncryptionRule"}
	if s.ApplyServerSideEncryptionByDefault != nil {
		if err := s.ApplyServerSideEncryptionByDefault.Validate(); err != nil {
			invalidParams.AddNested("ApplyServerSideEncryptionByDefault", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ServerSideEncryptionRule) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApplyServerSideEncryptionByDefault != nil {
		v := s.ApplyServerSideEncryptionByDefault

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ApplyServerSideEncryptionByDefault", v, metadata)
	}
	return nil
}
func (s *ServerSideEncryptionRule) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = ServerSideEncryptionRule{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionRule.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ApplyServerSideEncryptionByDefault":
				value := ServerSideEncryptionByDefault{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionRule.%s, %s", name, err)
				}
				s.ApplyServerSideEncryptionByDefault = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML ServerSideEncryptionRule.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListServerSideEncryptionRules(s *[]ServerSideEncryptionRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]ServerSideEncryptionRule, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := ServerSideEncryptionRule{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []ServerSideEncryptionRule.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []ServerSideEncryptionRule.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListServerSideEncryptionRules(s *[]ServerSideEncryptionRule, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]ServerSideEncryptionRule, 0)
		}
	}()
	value := ServerSideEncryptionRule{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// A container that describes additional filters for identifying the source
// objects that you want to replicate. You can choose to enable or disable the
// replication of these objects. Currently, Amazon S3 supports only the filter
// that you can specify for objects created with server-side encryption using
// an AWS KMS-Managed Key (SSE-KMS).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/SourceSelectionCriteria
type SourceSelectionCriteria struct {
	_ struct{} `type:"structure"`

	// A container for filter information for the selection of Amazon S3 objects
	// encrypted with AWS KMS. If you include SourceSelectionCriteria in the replication
	// configuration, this element is required.
	SseKmsEncryptedObjects *SseKmsEncryptedObjects `type:"structure"`
}

// String returns the string representation
func (s SourceSelectionCriteria) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SourceSelectionCriteria) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SourceSelectionCriteria"}
	if s.SseKmsEncryptedObjects != nil {
		if err := s.SseKmsEncryptedObjects.Validate(); err != nil {
			invalidParams.AddNested("SseKmsEncryptedObjects", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SourceSelectionCriteria) MarshalFields(e protocol.FieldEncoder) error {
	if s.SseKmsEncryptedObjects != nil {
		v := s.SseKmsEncryptedObjects

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SseKmsEncryptedObjects", v, metadata)
	}
	return nil
}
func (s *SourceSelectionCriteria) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = SourceSelectionCriteria{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML SourceSelectionCriteria.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "SseKmsEncryptedObjects":
				value := SseKmsEncryptedObjects{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SourceSelectionCriteria.%s, %s", name, err)
				}
				s.SseKmsEncryptedObjects = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SourceSelectionCriteria.%s, %s", name, err)
				}
			}
		}
	}
}

// A container for filter information for the selection of S3 objects encrypted
// with AWS KMS.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/SseKmsEncryptedObjects
type SseKmsEncryptedObjects struct {
	_ struct{} `type:"structure"`

	// Specifies whether Amazon S3 replicates objects created with server-side encryption
	// using an AWS KMS-managed key.
	//
	// Status is a required field
	Status SseKmsEncryptedObjectsStatus `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s SseKmsEncryptedObjects) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SseKmsEncryptedObjects) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SseKmsEncryptedObjects"}
	if len(s.Status) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Status"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SseKmsEncryptedObjects) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}
func (s *SseKmsEncryptedObjects) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = SseKmsEncryptedObjects{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML SseKmsEncryptedObjects.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SseKmsEncryptedObjects.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := SseKmsEncryptedObjectsStatus(v)
				s.Status = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML SseKmsEncryptedObjects.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies data related to access patterns to be collected and made available
// to analyze the tradeoffs between different storage classes for an Amazon
// S3 bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/StorageClassAnalysis
type StorageClassAnalysis struct {
	_ struct{} `type:"structure"`

	// Specifies how data related to the storage class analysis for an Amazon S3
	// bucket should be exported.
	DataExport *StorageClassAnalysisDataExport `type:"structure"`
}

// String returns the string representation
func (s StorageClassAnalysis) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StorageClassAnalysis) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StorageClassAnalysis"}
	if s.DataExport != nil {
		if err := s.DataExport.Validate(); err != nil {
			invalidParams.AddNested("DataExport", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StorageClassAnalysis) MarshalFields(e protocol.FieldEncoder) error {
	if s.DataExport != nil {
		v := s.DataExport

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DataExport", v, metadata)
	}
	return nil
}
func (s *StorageClassAnalysis) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = StorageClassAnalysis{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML StorageClassAnalysis.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DataExport":
				value := StorageClassAnalysisDataExport{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML StorageClassAnalysis.%s, %s", name, err)
				}
				s.DataExport = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML StorageClassAnalysis.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/StorageClassAnalysisDataExport
type StorageClassAnalysisDataExport struct {
	_ struct{} `type:"structure"`

	// The place to store the data for an analysis.
	//
	// Destination is a required field
	Destination *AnalyticsExportDestination `type:"structure" required:"true"`

	// The version of the output schema to use when exporting data. Must be V_1.
	//
	// OutputSchemaVersion is a required field
	OutputSchemaVersion StorageClassAnalysisSchemaVersion `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s StorageClassAnalysisDataExport) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StorageClassAnalysisDataExport) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StorageClassAnalysisDataExport"}

	if s.Destination == nil {
		invalidParams.Add(aws.NewErrParamRequired("Destination"))
	}
	if len(s.OutputSchemaVersion) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("OutputSchemaVersion"))
	}
	if s.Destination != nil {
		if err := s.Destination.Validate(); err != nil {
			invalidParams.AddNested("Destination", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StorageClassAnalysisDataExport) MarshalFields(e protocol.FieldEncoder) error {
	if s.Destination != nil {
		v := s.Destination

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Destination", v, metadata)
	}
	if len(s.OutputSchemaVersion) > 0 {
		v := s.OutputSchemaVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OutputSchemaVersion", v, metadata)
	}
	return nil
}
func (s *StorageClassAnalysisDataExport) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = StorageClassAnalysisDataExport{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML StorageClassAnalysisDataExport.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Destination":
				value := AnalyticsExportDestination{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML StorageClassAnalysisDataExport.%s, %s", name, err)
				}
				s.Destination = &value
			case "OutputSchemaVersion":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML StorageClassAnalysisDataExport.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := StorageClassAnalysisSchemaVersion(v)
				s.OutputSchemaVersion = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML StorageClassAnalysisDataExport.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Tag
type Tag struct {
	_ struct{} `type:"structure"`

	// Name of the tag.
	//
	// Key is a required field
	Key *string `min:"1" type:"string" required:"true"`

	// Value of the tag.
	//
	// Value is a required field
	Value *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Tag) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Tag) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Tag"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Tag) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *Tag) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Tag{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Tag.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Tag.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "Value":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Tag.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Value = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Tag.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListTagSet(s *[]Tag, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Tag, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Tag":
				value := Tag{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Tag.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Tag.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListTagSet(s *[]Tag, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Tag, 0)
		}
	}()
	value := Tag{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Tagging
type Tagging struct {
	_ struct{} `type:"structure"`

	// TagSet is a required field
	TagSet []Tag `locationNameList:"Tag" type:"list" required:"true"`
}

// String returns the string representation
func (s Tagging) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Tagging) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Tagging"}

	if s.TagSet == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagSet"))
	}
	if s.TagSet != nil {
		for i, v := range s.TagSet {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TagSet", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Tagging) MarshalFields(e protocol.FieldEncoder) error {
	if s.TagSet != nil {
		v := s.TagSet

		metadata := protocol.Metadata{ListLocationName: "Tag"}
		ls0 := e.List(protocol.BodyTarget, "TagSet", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *Tagging) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Tagging{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Tagging.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "TagSet":
				if s.TagSet == nil {
					s.TagSet = make([]Tag, 0)
				}
				err := unmarshalAWSXMLListTagSet(&s.TagSet, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Tagging.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Tagging.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/TargetGrant
type TargetGrant struct {
	_ struct{} `type:"structure"`

	Grantee *Grantee `type:"structure" xmlPrefix:"xsi" xmlURI:"http://www.w3.org/2001/XMLSchema-instance"`

	// Logging permissions assigned to the Grantee for the bucket.
	Permission BucketLogsPermission `type:"string" enum:"true"`
}

// String returns the string representation
func (s TargetGrant) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TargetGrant) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TargetGrant"}
	if s.Grantee != nil {
		if err := s.Grantee.Validate(); err != nil {
			invalidParams.AddNested("Grantee", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TargetGrant) MarshalFields(e protocol.FieldEncoder) error {
	if s.Grantee != nil {
		v := s.Grantee
		attrs := make([]protocol.Attribute, 0, 1)

		if len(s.Grantee.Type) > 0 {

			v := s.Grantee.Type
			attrs = append(attrs, protocol.Attribute{Name: "xsi:type", Value: v, Meta: protocol.Metadata{}})
		}
		metadata := protocol.Metadata{Attributes: attrs, XMLNamespacePrefix: "xsi", XMLNamespaceURI: "http://www.w3.org/2001/XMLSchema-instance"}
		e.SetFields(protocol.BodyTarget, "Grantee", v, metadata)
	}
	if len(s.Permission) > 0 {
		v := s.Permission

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Permission", v, metadata)
	}
	return nil
}
func (s *TargetGrant) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = TargetGrant{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML TargetGrant.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Grantee":
				value := Grantee{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TargetGrant.%s, %s", name, err)
				}
				s.Grantee = &value
			case "Permission":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TargetGrant.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := BucketLogsPermission(v)
				s.Permission = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TargetGrant.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListTargetGrants(s *[]TargetGrant, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]TargetGrant, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Grant":
				value := TargetGrant{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []TargetGrant.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []TargetGrant.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListTargetGrants(s *[]TargetGrant, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]TargetGrant, 0)
		}
	}()
	value := TargetGrant{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// A container for specifying the configuration for publication of messages
// to an Amazon Simple Notification Service (Amazon SNS) topic when Amazon S3
// detects specified events.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/TopicConfiguration
type TopicConfiguration struct {
	_ struct{} `type:"structure"`

	// The Amazon S3 bucket event about which to send notifications. For more information,
	// see Supported Event Types (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html)
	// in the Amazon Simple Storage Service Developer Guide.
	//
	// Events is a required field
	Events []Event `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Specifies object key name filtering rules. For information about key name
	// filtering, see Configuring Event Notifications (https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html)
	// in the Amazon Simple Storage Service Developer Guide.
	Filter *NotificationConfigurationFilter `type:"structure"`

	// An optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	Id *string `type:"string"`

	// The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3
	// publishes a message when it detects events of the specified type.
	//
	// TopicArn is a required field
	TopicArn *string `locationName:"Topic" type:"string" required:"true"`
}

// String returns the string representation
func (s TopicConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TopicConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TopicConfiguration"}

	if s.Events == nil {
		invalidParams.Add(aws.NewErrParamRequired("Events"))
	}

	if s.TopicArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("TopicArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TopicConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Events != nil {
		v := s.Events

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Event", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.Filter != nil {
		v := s.Filter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filter", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.TopicArn != nil {
		v := *s.TopicArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Topic", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *TopicConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = TopicConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML TopicConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Event":
				if s.Events == nil {
					s.Events = make([]Event, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Event(v)
				s.Events = append(s.Events, value)
			case "Filter":
				value := NotificationConfigurationFilter{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfiguration.%s, %s", name, err)
				}
				s.Filter = &value
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			case "Topic":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.TopicArn = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/TopicConfigurationDeprecated
type TopicConfigurationDeprecated struct {
	_ struct{} `type:"structure"`

	// Bucket event for which to send notifications.
	Event Event `deprecated:"true" type:"string" enum:"true"`

	Events []Event `locationName:"Event" type:"list" flattened:"true"`

	// An optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	Id *string `type:"string"`

	// Amazon SNS topic to which Amazon S3 will publish a message to report the
	// specified events for the bucket.
	Topic *string `type:"string"`
}

// String returns the string representation
func (s TopicConfigurationDeprecated) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TopicConfigurationDeprecated) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Event) > 0 {
		v := s.Event

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Event", v, metadata)
	}
	if s.Events != nil {
		v := s.Events

		metadata := protocol.Metadata{Flatten: true}
		ls0 := e.List(protocol.BodyTarget, "Event", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.Topic != nil {
		v := *s.Topic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Topic", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *TopicConfigurationDeprecated) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = TopicConfigurationDeprecated{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML TopicConfigurationDeprecated.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Event":
				if s.Events == nil {
					s.Events = make([]Event, 0)
				}
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfigurationDeprecated.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := Event(v)
				s.Events = append(s.Events, value)
			case "Id":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfigurationDeprecated.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Id = &value
			case "Topic":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfigurationDeprecated.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Topic = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML TopicConfigurationDeprecated.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListTopicConfigurationList(s *[]TopicConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]TopicConfiguration, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := TopicConfiguration{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []TopicConfiguration.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []TopicConfiguration.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListTopicConfigurationList(s *[]TopicConfiguration, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]TopicConfiguration, 0)
		}
	}()
	value := TopicConfiguration{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Specifies when an object transitions to a specified storage class.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/Transition
type Transition struct {
	_ struct{} `type:"structure"`

	// Indicates when objects are transitioned to the specified storage class. The
	// date value must be in ISO 8601 format. The time is always midnight UTC.
	Date *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Indicates the number of days after creation when objects are transitioned
	// to the specified storage class. The value must be a positive integer.
	Days *int64 `type:"integer"`

	// The storage class to which you want the object to transition.
	StorageClass TransitionStorageClass `type:"string" enum:"true"`
}

// String returns the string representation
func (s Transition) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Transition) MarshalFields(e protocol.FieldEncoder) error {
	if s.Date != nil {
		v := *s.Date

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Date",
			protocol.TimeValue{V: v, Format: "iso8601", QuotedFormatTime: false}, metadata)
	}
	if s.Days != nil {
		v := *s.Days

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Days", protocol.Int64Value(v), metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", v, metadata)
	}
	return nil
}
func (s *Transition) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = Transition{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML Transition.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Date":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Transition.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := time.Parse(protocol.ISO8601TimeFormat, string(v))
				s.Date = &value
			case "Days":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Transition.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Days = &value
			case "StorageClass":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Transition.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := TransitionStorageClass(v)
				s.StorageClass = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML Transition.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListTransitionList(s *[]Transition, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Transition, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := Transition{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Transition.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []Transition.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListTransitionList(s *[]Transition, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]Transition, 0)
		}
	}()
	value := Transition{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

func unmarshalAWSXMLListUserMetadata(s *[]MetadataEntry, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]MetadataEntry, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "MetadataEntry":
				value := MetadataEntry{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []MetadataEntry.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []MetadataEntry.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListUserMetadata(s *[]MetadataEntry, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]MetadataEntry, 0)
		}
	}()
	value := MetadataEntry{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Describes the versioning state of an Amazon S3 bucket. For more information,
// see PUT Bucket versioning (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html)
// in the Amazon Simple Storage Service API Reference.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/VersioningConfiguration
type VersioningConfiguration struct {
	_ struct{} `type:"structure"`

	// Specifies whether MFA delete is enabled in the bucket versioning configuration.
	// This element is only returned if the bucket has been configured with MFA
	// delete. If the bucket has never been so configured, this element is not returned.
	MFADelete MFADelete `locationName:"MfaDelete" type:"string" enum:"true"`

	// The versioning state of the bucket.
	Status BucketVersioningStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s VersioningConfiguration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VersioningConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.MFADelete) > 0 {
		v := s.MFADelete

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MfaDelete", v, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}
func (s *VersioningConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = VersioningConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML VersioningConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "MfaDelete":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML VersioningConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := MFADelete(v)
				s.MFADelete = value
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML VersioningConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := BucketVersioningStatus(v)
				s.Status = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML VersioningConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Specifies website configuration parameters for an Amazon S3 bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3-2006-03-01/WebsiteConfiguration
type WebsiteConfiguration struct {
	_ struct{} `type:"structure"`

	// The name of the error document for the website.
	ErrorDocument *ErrorDocument `type:"structure"`

	// The name of the index document for the website.
	IndexDocument *IndexDocument `type:"structure"`

	// The redirect behavior for every request to this bucket's website endpoint.
	//
	// If you specify this property, you can't specify any other property.
	RedirectAllRequestsTo *RedirectAllRequestsTo `type:"structure"`

	// Rules that define when a redirect is applied and the redirect behavior.
	RoutingRules []RoutingRule `locationNameList:"RoutingRule" type:"list"`
}

// String returns the string representation
func (s WebsiteConfiguration) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *WebsiteConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "WebsiteConfiguration"}
	if s.ErrorDocument != nil {
		if err := s.ErrorDocument.Validate(); err != nil {
			invalidParams.AddNested("ErrorDocument", err.(aws.ErrInvalidParams))
		}
	}
	if s.IndexDocument != nil {
		if err := s.IndexDocument.Validate(); err != nil {
			invalidParams.AddNested("IndexDocument", err.(aws.ErrInvalidParams))
		}
	}
	if s.RedirectAllRequestsTo != nil {
		if err := s.RedirectAllRequestsTo.Validate(); err != nil {
			invalidParams.AddNested("RedirectAllRequestsTo", err.(aws.ErrInvalidParams))
		}
	}
	if s.RoutingRules != nil {
		for i, v := range s.RoutingRules {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "RoutingRules", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s WebsiteConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorDocument != nil {
		v := s.ErrorDocument

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ErrorDocument", v, metadata)
	}
	if s.IndexDocument != nil {
		v := s.IndexDocument

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "IndexDocument", v, metadata)
	}
	if s.RedirectAllRequestsTo != nil {
		v := s.RedirectAllRequestsTo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "RedirectAllRequestsTo", v, metadata)
	}
	if s.RoutingRules != nil {
		v := s.RoutingRules

		metadata := protocol.Metadata{ListLocationName: "RoutingRule"}
		ls0 := e.List(protocol.BodyTarget, "RoutingRules", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *WebsiteConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = WebsiteConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML WebsiteConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ErrorDocument":
				value := ErrorDocument{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML WebsiteConfiguration.%s, %s", name, err)
				}
				s.ErrorDocument = &value
			case "IndexDocument":
				value := IndexDocument{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML WebsiteConfiguration.%s, %s", name, err)
				}
				s.IndexDocument = &value
			case "RedirectAllRequestsTo":
				value := RedirectAllRequestsTo{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML WebsiteConfiguration.%s, %s", name, err)
				}
				s.RedirectAllRequestsTo = &value
			case "RoutingRules":
				if s.RoutingRules == nil {
					s.RoutingRules = make([]RoutingRule, 0)
				}
				err := unmarshalAWSXMLListRoutingRules(&s.RoutingRules, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML WebsiteConfiguration.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML WebsiteConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}
