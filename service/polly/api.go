// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package polly

import (
	"io"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

const opDeleteLexicon = "DeleteLexicon"

// DeleteLexiconRequest is a API request type for the DeleteLexicon API operation.
type DeleteLexiconRequest struct {
	*aws.Request
	Input *DeleteLexiconInput
	Copy  func(*DeleteLexiconInput) DeleteLexiconRequest
}

// Send marshals and sends the DeleteLexicon API request.
func (r DeleteLexiconRequest) Send() (*DeleteLexiconOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteLexiconOutput), nil
}

// DeleteLexiconRequest returns a request value for making API operation for
// Amazon Polly.
//
// Deletes the specified pronunciation lexicon stored in an AWS Region. A lexicon
// which has been deleted is not available for speech synthesis, nor is it possible
// to retrieve it using either the GetLexicon or ListLexicon APIs.
//
// For more information, see Managing Lexicons (http://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html).
//
//    // Example sending a request using the DeleteLexiconRequest method.
//    req := client.DeleteLexiconRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/DeleteLexicon
func (c *Polly) DeleteLexiconRequest(input *DeleteLexiconInput) DeleteLexiconRequest {
	op := &aws.Operation{
		Name:       opDeleteLexicon,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/lexicons/{LexiconName}",
	}

	if input == nil {
		input = &DeleteLexiconInput{}
	}

	output := &DeleteLexiconOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteLexiconRequest{Request: req, Input: input, Copy: c.DeleteLexiconRequest}
}

const opDescribeVoices = "DescribeVoices"

// DescribeVoicesRequest is a API request type for the DescribeVoices API operation.
type DescribeVoicesRequest struct {
	*aws.Request
	Input *DescribeVoicesInput
	Copy  func(*DescribeVoicesInput) DescribeVoicesRequest
}

// Send marshals and sends the DescribeVoices API request.
func (r DescribeVoicesRequest) Send() (*DescribeVoicesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeVoicesOutput), nil
}

// DescribeVoicesRequest returns a request value for making API operation for
// Amazon Polly.
//
// Returns the list of voices that are available for use when requesting speech
// synthesis. Each voice speaks a specified language, is either male or female,
// and is identified by an ID, which is the ASCII version of the voice name.
//
// When synthesizing speech ( SynthesizeSpeech ), you provide the voice ID for
// the voice you want from the list of voices returned by DescribeVoices.
//
// For example, you want your news reader application to read news in a specific
// language, but giving a user the option to choose the voice. Using the DescribeVoices
// operation you can provide the user with a list of available voices to select
// from.
//
// You can optionally specify a language code to filter the available voices.
// For example, if you specify en-US, the operation returns a list of all available
// US English voices.
//
// This operation requires permissions to perform the polly:DescribeVoices action.
//
//    // Example sending a request using the DescribeVoicesRequest method.
//    req := client.DescribeVoicesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/DescribeVoices
func (c *Polly) DescribeVoicesRequest(input *DescribeVoicesInput) DescribeVoicesRequest {
	op := &aws.Operation{
		Name:       opDescribeVoices,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/voices",
	}

	if input == nil {
		input = &DescribeVoicesInput{}
	}

	output := &DescribeVoicesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeVoicesRequest{Request: req, Input: input, Copy: c.DescribeVoicesRequest}
}

const opGetLexicon = "GetLexicon"

// GetLexiconRequest is a API request type for the GetLexicon API operation.
type GetLexiconRequest struct {
	*aws.Request
	Input *GetLexiconInput
	Copy  func(*GetLexiconInput) GetLexiconRequest
}

// Send marshals and sends the GetLexicon API request.
func (r GetLexiconRequest) Send() (*GetLexiconOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetLexiconOutput), nil
}

// GetLexiconRequest returns a request value for making API operation for
// Amazon Polly.
//
// Returns the content of the specified pronunciation lexicon stored in an AWS
// Region. For more information, see Managing Lexicons (http://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html).
//
//    // Example sending a request using the GetLexiconRequest method.
//    req := client.GetLexiconRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/GetLexicon
func (c *Polly) GetLexiconRequest(input *GetLexiconInput) GetLexiconRequest {
	op := &aws.Operation{
		Name:       opGetLexicon,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/lexicons/{LexiconName}",
	}

	if input == nil {
		input = &GetLexiconInput{}
	}

	output := &GetLexiconOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetLexiconRequest{Request: req, Input: input, Copy: c.GetLexiconRequest}
}

const opGetSpeechSynthesisTask = "GetSpeechSynthesisTask"

// GetSpeechSynthesisTaskRequest is a API request type for the GetSpeechSynthesisTask API operation.
type GetSpeechSynthesisTaskRequest struct {
	*aws.Request
	Input *GetSpeechSynthesisTaskInput
	Copy  func(*GetSpeechSynthesisTaskInput) GetSpeechSynthesisTaskRequest
}

// Send marshals and sends the GetSpeechSynthesisTask API request.
func (r GetSpeechSynthesisTaskRequest) Send() (*GetSpeechSynthesisTaskOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSpeechSynthesisTaskOutput), nil
}

// GetSpeechSynthesisTaskRequest returns a request value for making API operation for
// Amazon Polly.
//
// Retrieves a specific SpeechSynthesisTask object based on its TaskID. This
// object contains information about the given speech synthesis task, including
// the status of the task, and a link to the S3 bucket containing the output
// of the task.
//
//    // Example sending a request using the GetSpeechSynthesisTaskRequest method.
//    req := client.GetSpeechSynthesisTaskRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/GetSpeechSynthesisTask
func (c *Polly) GetSpeechSynthesisTaskRequest(input *GetSpeechSynthesisTaskInput) GetSpeechSynthesisTaskRequest {
	op := &aws.Operation{
		Name:       opGetSpeechSynthesisTask,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/synthesisTasks/{TaskId}",
	}

	if input == nil {
		input = &GetSpeechSynthesisTaskInput{}
	}

	output := &GetSpeechSynthesisTaskOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSpeechSynthesisTaskRequest{Request: req, Input: input, Copy: c.GetSpeechSynthesisTaskRequest}
}

const opListLexicons = "ListLexicons"

// ListLexiconsRequest is a API request type for the ListLexicons API operation.
type ListLexiconsRequest struct {
	*aws.Request
	Input *ListLexiconsInput
	Copy  func(*ListLexiconsInput) ListLexiconsRequest
}

// Send marshals and sends the ListLexicons API request.
func (r ListLexiconsRequest) Send() (*ListLexiconsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListLexiconsOutput), nil
}

// ListLexiconsRequest returns a request value for making API operation for
// Amazon Polly.
//
// Returns a list of pronunciation lexicons stored in an AWS Region. For more
// information, see Managing Lexicons (http://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html).
//
//    // Example sending a request using the ListLexiconsRequest method.
//    req := client.ListLexiconsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/ListLexicons
func (c *Polly) ListLexiconsRequest(input *ListLexiconsInput) ListLexiconsRequest {
	op := &aws.Operation{
		Name:       opListLexicons,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/lexicons",
	}

	if input == nil {
		input = &ListLexiconsInput{}
	}

	output := &ListLexiconsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListLexiconsRequest{Request: req, Input: input, Copy: c.ListLexiconsRequest}
}

const opListSpeechSynthesisTasks = "ListSpeechSynthesisTasks"

// ListSpeechSynthesisTasksRequest is a API request type for the ListSpeechSynthesisTasks API operation.
type ListSpeechSynthesisTasksRequest struct {
	*aws.Request
	Input *ListSpeechSynthesisTasksInput
	Copy  func(*ListSpeechSynthesisTasksInput) ListSpeechSynthesisTasksRequest
}

// Send marshals and sends the ListSpeechSynthesisTasks API request.
func (r ListSpeechSynthesisTasksRequest) Send() (*ListSpeechSynthesisTasksOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListSpeechSynthesisTasksOutput), nil
}

// ListSpeechSynthesisTasksRequest returns a request value for making API operation for
// Amazon Polly.
//
// Returns a list of SpeechSynthesisTask objects ordered by their creation date.
// This operation can filter the tasks by their status, for example, allowing
// users to list only tasks that are completed.
//
//    // Example sending a request using the ListSpeechSynthesisTasksRequest method.
//    req := client.ListSpeechSynthesisTasksRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/ListSpeechSynthesisTasks
func (c *Polly) ListSpeechSynthesisTasksRequest(input *ListSpeechSynthesisTasksInput) ListSpeechSynthesisTasksRequest {
	op := &aws.Operation{
		Name:       opListSpeechSynthesisTasks,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/synthesisTasks",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListSpeechSynthesisTasksInput{}
	}

	output := &ListSpeechSynthesisTasksOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListSpeechSynthesisTasksRequest{Request: req, Input: input, Copy: c.ListSpeechSynthesisTasksRequest}
}

// Paginate pages iterates over the pages of a ListSpeechSynthesisTasksRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListSpeechSynthesisTasks operation.
//		req := client.ListSpeechSynthesisTasksRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListSpeechSynthesisTasksRequest) Paginate(opts ...aws.Option) ListSpeechSynthesisTasksPager {
	return ListSpeechSynthesisTasksPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListSpeechSynthesisTasksInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListSpeechSynthesisTasksPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListSpeechSynthesisTasksPager struct {
	aws.Pager
}

func (p *ListSpeechSynthesisTasksPager) CurrentPage() *ListSpeechSynthesisTasksOutput {
	return p.Pager.CurrentPage().(*ListSpeechSynthesisTasksOutput)
}

const opPutLexicon = "PutLexicon"

// PutLexiconRequest is a API request type for the PutLexicon API operation.
type PutLexiconRequest struct {
	*aws.Request
	Input *PutLexiconInput
	Copy  func(*PutLexiconInput) PutLexiconRequest
}

// Send marshals and sends the PutLexicon API request.
func (r PutLexiconRequest) Send() (*PutLexiconOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutLexiconOutput), nil
}

// PutLexiconRequest returns a request value for making API operation for
// Amazon Polly.
//
// Stores a pronunciation lexicon in an AWS Region. If a lexicon with the same
// name already exists in the region, it is overwritten by the new lexicon.
// Lexicon operations have eventual consistency, therefore, it might take some
// time before the lexicon is available to the SynthesizeSpeech operation.
//
// For more information, see Managing Lexicons (http://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html).
//
//    // Example sending a request using the PutLexiconRequest method.
//    req := client.PutLexiconRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/PutLexicon
func (c *Polly) PutLexiconRequest(input *PutLexiconInput) PutLexiconRequest {
	op := &aws.Operation{
		Name:       opPutLexicon,
		HTTPMethod: "PUT",
		HTTPPath:   "/v1/lexicons/{LexiconName}",
	}

	if input == nil {
		input = &PutLexiconInput{}
	}

	output := &PutLexiconOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutLexiconRequest{Request: req, Input: input, Copy: c.PutLexiconRequest}
}

const opStartSpeechSynthesisTask = "StartSpeechSynthesisTask"

// StartSpeechSynthesisTaskRequest is a API request type for the StartSpeechSynthesisTask API operation.
type StartSpeechSynthesisTaskRequest struct {
	*aws.Request
	Input *StartSpeechSynthesisTaskInput
	Copy  func(*StartSpeechSynthesisTaskInput) StartSpeechSynthesisTaskRequest
}

// Send marshals and sends the StartSpeechSynthesisTask API request.
func (r StartSpeechSynthesisTaskRequest) Send() (*StartSpeechSynthesisTaskOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartSpeechSynthesisTaskOutput), nil
}

// StartSpeechSynthesisTaskRequest returns a request value for making API operation for
// Amazon Polly.
//
// Allows the creation of an asynchronous synthesis task, by starting a new
// SpeechSynthesisTask. This operation requires all the standard information
// needed for speech synthesis, plus the name of an Amazon S3 bucket for the
// service to store the output of the synthesis task and two optional parameters
// (OutputS3KeyPrefix and SnsTopicArn). Once the synthesis task is created,
// this operation will return a SpeechSynthesisTask object, which will include
// an identifier of this task as well as the current status.
//
//    // Example sending a request using the StartSpeechSynthesisTaskRequest method.
//    req := client.StartSpeechSynthesisTaskRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/StartSpeechSynthesisTask
func (c *Polly) StartSpeechSynthesisTaskRequest(input *StartSpeechSynthesisTaskInput) StartSpeechSynthesisTaskRequest {
	op := &aws.Operation{
		Name:       opStartSpeechSynthesisTask,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/synthesisTasks",
	}

	if input == nil {
		input = &StartSpeechSynthesisTaskInput{}
	}

	output := &StartSpeechSynthesisTaskOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartSpeechSynthesisTaskRequest{Request: req, Input: input, Copy: c.StartSpeechSynthesisTaskRequest}
}

const opSynthesizeSpeech = "SynthesizeSpeech"

// SynthesizeSpeechRequest is a API request type for the SynthesizeSpeech API operation.
type SynthesizeSpeechRequest struct {
	*aws.Request
	Input *SynthesizeSpeechInput
	Copy  func(*SynthesizeSpeechInput) SynthesizeSpeechRequest
}

// Send marshals and sends the SynthesizeSpeech API request.
func (r SynthesizeSpeechRequest) Send() (*SynthesizeSpeechOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SynthesizeSpeechOutput), nil
}

// SynthesizeSpeechRequest returns a request value for making API operation for
// Amazon Polly.
//
// Synthesizes UTF-8 input, plain text or SSML, to a stream of bytes. SSML input
// must be valid, well-formed SSML. Some alphabets might not be available with
// all the voices (for example, Cyrillic might not be read at all by English
// voices) unless phoneme mapping is used. For more information, see How it
// Works (http://docs.aws.amazon.com/polly/latest/dg/how-text-to-speech-works.html).
//
//    // Example sending a request using the SynthesizeSpeechRequest method.
//    req := client.SynthesizeSpeechRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/SynthesizeSpeech
func (c *Polly) SynthesizeSpeechRequest(input *SynthesizeSpeechInput) SynthesizeSpeechRequest {
	op := &aws.Operation{
		Name:       opSynthesizeSpeech,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/speech",
	}

	if input == nil {
		input = &SynthesizeSpeechInput{}
	}

	output := &SynthesizeSpeechOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return SynthesizeSpeechRequest{Request: req, Input: input, Copy: c.SynthesizeSpeechRequest}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/DeleteLexiconInput
type DeleteLexiconInput struct {
	_ struct{} `type:"structure"`

	// The name of the lexicon to delete. Must be an existing lexicon in the region.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"LexiconName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteLexiconInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteLexiconInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteLexiconInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteLexiconInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteLexiconInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "LexiconName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/DeleteLexiconOutput
type DeleteLexiconOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteLexiconOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteLexiconOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteLexiconOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteLexiconOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/DescribeVoicesInput
type DescribeVoicesInput struct {
	_ struct{} `type:"structure"`

	// Boolean value indicating whether to return any bilingual voices that use
	// the specified language as an additional language. For instance, if you request
	// all languages that use US English (es-US), and there is an Italian voice
	// that speaks both Italian (it-IT) and US English, that voice will be included
	// if you specify yes but not if you specify no.
	IncludeAdditionalLanguageCodes *bool `location:"querystring" locationName:"IncludeAdditionalLanguageCodes" type:"boolean"`

	// The language identification tag (ISO 639 code for the language name-ISO 3166
	// country code) for filtering the list of voices returned. If you don't specify
	// this optional parameter, all available voices are returned.
	LanguageCode LanguageCode `location:"querystring" locationName:"LanguageCode" type:"string" enum:"true"`

	// An opaque pagination token returned from the previous DescribeVoices operation.
	// If present, this indicates where to continue the listing.
	NextToken *string `location:"querystring" locationName:"NextToken" type:"string"`
}

// String returns the string representation
func (s DescribeVoicesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeVoicesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeVoicesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.IncludeAdditionalLanguageCodes != nil {
		v := *s.IncludeAdditionalLanguageCodes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "IncludeAdditionalLanguageCodes", protocol.BoolValue(v), metadata)
	}
	if len(s.LanguageCode) > 0 {
		v := s.LanguageCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "LanguageCode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/DescribeVoicesOutput
type DescribeVoicesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token to use in the next request to continue the listing of
	// voices. NextToken is returned only if the response is truncated.
	NextToken *string `type:"string"`

	// A list of voices with their properties.
	Voices []Voice `type:"list"`
}

// String returns the string representation
func (s DescribeVoicesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeVoicesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeVoicesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeVoicesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Voices) > 0 {
		v := s.Voices

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Voices", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/GetLexiconInput
type GetLexiconInput struct {
	_ struct{} `type:"structure"`

	// Name of the lexicon.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"LexiconName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetLexiconInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetLexiconInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetLexiconInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetLexiconInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetLexiconInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "LexiconName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/GetLexiconOutput
type GetLexiconOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Lexicon object that provides name and the string content of the lexicon.
	Lexicon *Lexicon `type:"structure"`

	// Metadata of the lexicon, including phonetic alphabetic used, language code,
	// lexicon ARN, number of lexemes defined in the lexicon, and size of lexicon
	// in bytes.
	LexiconAttributes *LexiconAttributes `type:"structure"`
}

// String returns the string representation
func (s GetLexiconOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetLexiconOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetLexiconOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetLexiconOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Lexicon != nil {
		v := s.Lexicon

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Lexicon", v, metadata)
	}
	if s.LexiconAttributes != nil {
		v := s.LexiconAttributes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LexiconAttributes", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/GetSpeechSynthesisTaskInput
type GetSpeechSynthesisTaskInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Polly generated identifier for a speech synthesis task.
	//
	// TaskId is a required field
	TaskId *string `location:"uri" locationName:"TaskId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetSpeechSynthesisTaskInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSpeechSynthesisTaskInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSpeechSynthesisTaskInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSpeechSynthesisTaskInput"}

	if s.TaskId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TaskId"))
	}
	if s.TaskId != nil && len(*s.TaskId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TaskId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSpeechSynthesisTaskInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.TaskId != nil {
		v := *s.TaskId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "TaskId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/GetSpeechSynthesisTaskOutput
type GetSpeechSynthesisTaskOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// SynthesisTask object that provides information from the requested task, including
	// output format, creation time, task status, and so on.
	SynthesisTask *SynthesisTask `type:"structure"`
}

// String returns the string representation
func (s GetSpeechSynthesisTaskOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSpeechSynthesisTaskOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSpeechSynthesisTaskOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSpeechSynthesisTaskOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.SynthesisTask != nil {
		v := s.SynthesisTask

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SynthesisTask", v, metadata)
	}
	return nil
}

// Provides lexicon name and lexicon content in string format. For more information,
// see Pronunciation Lexicon Specification (PLS) Version 1.0 (https://www.w3.org/TR/pronunciation-lexicon/).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/Lexicon
type Lexicon struct {
	_ struct{} `type:"structure"`

	// Lexicon content in string format. The content of a lexicon must be in PLS
	// format.
	Content *string `type:"string"`

	// Name of the lexicon.
	Name *string `type:"string"`
}

// String returns the string representation
func (s Lexicon) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Lexicon) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Lexicon) MarshalFields(e protocol.FieldEncoder) error {
	if s.Content != nil {
		v := *s.Content

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Content", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains metadata describing the lexicon such as the number of lexemes, language
// code, and so on. For more information, see Managing Lexicons (http://docs.aws.amazon.com/polly/latest/dg/managing-lexicons.html).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/LexiconAttributes
type LexiconAttributes struct {
	_ struct{} `type:"structure"`

	// Phonetic alphabet used in the lexicon. Valid values are ipa and x-sampa.
	Alphabet *string `type:"string"`

	// Language code that the lexicon applies to. A lexicon with a language code
	// such as "en" would be applied to all English languages (en-GB, en-US, en-AUS,
	// en-WLS, and so on.
	LanguageCode LanguageCode `type:"string" enum:"true"`

	// Date lexicon was last modified (a timestamp value).
	LastModified *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Number of lexemes in the lexicon.
	LexemesCount *int64 `type:"integer"`

	// Amazon Resource Name (ARN) of the lexicon.
	LexiconArn *string `type:"string"`

	// Total size of the lexicon, in characters.
	Size *int64 `type:"integer"`
}

// String returns the string representation
func (s LexiconAttributes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LexiconAttributes) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LexiconAttributes) MarshalFields(e protocol.FieldEncoder) error {
	if s.Alphabet != nil {
		v := *s.Alphabet

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Alphabet", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.LanguageCode) > 0 {
		v := s.LanguageCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LanguageCode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.LastModified != nil {
		v := *s.LastModified

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModified", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.LexemesCount != nil {
		v := *s.LexemesCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LexemesCount", protocol.Int64Value(v), metadata)
	}
	if s.LexiconArn != nil {
		v := *s.LexiconArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LexiconArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Size", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Describes the content of the lexicon.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/LexiconDescription
type LexiconDescription struct {
	_ struct{} `type:"structure"`

	// Provides lexicon metadata.
	Attributes *LexiconAttributes `type:"structure"`

	// Name of the lexicon.
	Name *string `type:"string"`
}

// String returns the string representation
func (s LexiconDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LexiconDescription) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LexiconDescription) MarshalFields(e protocol.FieldEncoder) error {
	if s.Attributes != nil {
		v := s.Attributes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Attributes", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/ListLexiconsInput
type ListLexiconsInput struct {
	_ struct{} `type:"structure"`

	// An opaque pagination token returned from previous ListLexicons operation.
	// If present, indicates where to continue the list of lexicons.
	NextToken *string `location:"querystring" locationName:"NextToken" type:"string"`
}

// String returns the string representation
func (s ListLexiconsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListLexiconsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListLexiconsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/ListLexiconsOutput
type ListLexiconsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of lexicon names and attributes.
	Lexicons []LexiconDescription `type:"list"`

	// The pagination token to use in the next request to continue the listing of
	// lexicons. NextToken is returned only if the response is truncated.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListLexiconsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListLexiconsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListLexiconsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListLexiconsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Lexicons) > 0 {
		v := s.Lexicons

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Lexicons", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/ListSpeechSynthesisTasksInput
type ListSpeechSynthesisTasksInput struct {
	_ struct{} `type:"structure"`

	// Maximum number of speech synthesis tasks returned in a List operation.
	MaxResults *int64 `location:"querystring" locationName:"MaxResults" min:"1" type:"integer"`

	// The pagination token to use in the next request to continue the listing of
	// speech synthesis tasks.
	NextToken *string `location:"querystring" locationName:"NextToken" type:"string"`

	// Status of the speech synthesis tasks returned in a List operation
	Status TaskStatus `location:"querystring" locationName:"Status" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListSpeechSynthesisTasksInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListSpeechSynthesisTasksInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListSpeechSynthesisTasksInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListSpeechSynthesisTasksInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListSpeechSynthesisTasksInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/ListSpeechSynthesisTasksOutput
type ListSpeechSynthesisTasksOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An opaque pagination token returned from the previous List operation in this
	// request. If present, this indicates where to continue the listing.
	NextToken *string `type:"string"`

	// List of SynthesisTask objects that provides information from the specified
	// task in the list request, including output format, creation time, task status,
	// and so on.
	SynthesisTasks []SynthesisTask `type:"list"`
}

// String returns the string representation
func (s ListSpeechSynthesisTasksOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListSpeechSynthesisTasksOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListSpeechSynthesisTasksOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListSpeechSynthesisTasksOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SynthesisTasks) > 0 {
		v := s.SynthesisTasks

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SynthesisTasks", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/PutLexiconInput
type PutLexiconInput struct {
	_ struct{} `type:"structure"`

	// Content of the PLS lexicon as string data.
	//
	// Content is a required field
	Content *string `type:"string" required:"true"`

	// Name of the lexicon. The name must follow the regular express format [0-9A-Za-z]{1,20}.
	// That is, the name is a case-sensitive alphanumeric string up to 20 characters
	// long.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"LexiconName" type:"string" required:"true"`
}

// String returns the string representation
func (s PutLexiconInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutLexiconInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutLexiconInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutLexiconInput"}

	if s.Content == nil {
		invalidParams.Add(aws.NewErrParamRequired("Content"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutLexiconInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Content != nil {
		v := *s.Content

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Content", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "LexiconName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/PutLexiconOutput
type PutLexiconOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s PutLexiconOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutLexiconOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutLexiconOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutLexiconOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/StartSpeechSynthesisTaskInput
type StartSpeechSynthesisTaskInput struct {
	_ struct{} `type:"structure"`

	// Optional language code for the Speech Synthesis request. This is only necessary
	// if using a bilingual voice, such as Aditi, which can be used for either Indian
	// English (en-IN) or Hindi (hi-IN).
	//
	// If a bilingual voice is used and no language code is specified, Amazon Polly
	// will use the default language of the bilingual voice. The default language
	// for any voice is the one returned by the DescribeVoices (https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html)
	// operation for the LanguageCode parameter. For example, if no language code
	// is specified, Aditi will use Indian English rather than Hindi.
	LanguageCode LanguageCode `type:"string" enum:"true"`

	// List of one or more pronunciation lexicon names you want the service to apply
	// during synthesis. Lexicons are applied only if the language of the lexicon
	// is the same as the language of the voice.
	LexiconNames []string `type:"list"`

	// The format in which the returned output will be encoded. For audio stream,
	// this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
	//
	// OutputFormat is a required field
	OutputFormat OutputFormat `type:"string" required:"true" enum:"true"`

	// Amazon S3 bucket name to which the output file will be saved.
	//
	// OutputS3BucketName is a required field
	OutputS3BucketName *string `type:"string" required:"true"`

	// The Amazon S3 key prefix for the output speech file.
	OutputS3KeyPrefix *string `type:"string"`

	// The audio frequency specified in Hz.
	//
	// The valid values for mp3 and ogg_vorbis are "8000", "16000", and "22050".
	// The default value is "22050".
	//
	// Valid values for pcm are "8000" and "16000" The default value is "16000".
	SampleRate *string `type:"string"`

	// ARN for the SNS topic optionally used for providing status notification for
	// a speech synthesis task.
	SnsTopicArn *string `type:"string"`

	// The type of speech marks returned for the input text.
	SpeechMarkTypes []SpeechMarkType `type:"list"`

	// The input text to synthesize. If you specify ssml as the TextType, follow
	// the SSML format for the input text.
	//
	// Text is a required field
	Text *string `type:"string" required:"true"`

	// Specifies whether the input text is plain text or SSML. The default value
	// is plain text.
	TextType TextType `type:"string" enum:"true"`

	// Voice ID to use for the synthesis.
	//
	// VoiceId is a required field
	VoiceId VoiceId `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s StartSpeechSynthesisTaskInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartSpeechSynthesisTaskInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartSpeechSynthesisTaskInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartSpeechSynthesisTaskInput"}
	if len(s.OutputFormat) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("OutputFormat"))
	}

	if s.OutputS3BucketName == nil {
		invalidParams.Add(aws.NewErrParamRequired("OutputS3BucketName"))
	}

	if s.Text == nil {
		invalidParams.Add(aws.NewErrParamRequired("Text"))
	}
	if len(s.VoiceId) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("VoiceId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartSpeechSynthesisTaskInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.LanguageCode) > 0 {
		v := s.LanguageCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LanguageCode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.LexiconNames) > 0 {
		v := s.LexiconNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "LexiconNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.OutputFormat) > 0 {
		v := s.OutputFormat

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OutputFormat", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.OutputS3BucketName != nil {
		v := *s.OutputS3BucketName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OutputS3BucketName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OutputS3KeyPrefix != nil {
		v := *s.OutputS3KeyPrefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OutputS3KeyPrefix", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SampleRate != nil {
		v := *s.SampleRate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SampleRate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SnsTopicArn != nil {
		v := *s.SnsTopicArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SnsTopicArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SpeechMarkTypes) > 0 {
		v := s.SpeechMarkTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SpeechMarkTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Text != nil {
		v := *s.Text

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Text", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TextType) > 0 {
		v := s.TextType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TextType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.VoiceId) > 0 {
		v := s.VoiceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VoiceId", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/StartSpeechSynthesisTaskOutput
type StartSpeechSynthesisTaskOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// SynthesisTask object that provides information and attributes about a newly
	// submitted speech synthesis task.
	SynthesisTask *SynthesisTask `type:"structure"`
}

// String returns the string representation
func (s StartSpeechSynthesisTaskOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartSpeechSynthesisTaskOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartSpeechSynthesisTaskOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartSpeechSynthesisTaskOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.SynthesisTask != nil {
		v := s.SynthesisTask

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SynthesisTask", v, metadata)
	}
	return nil
}

// SynthesisTask object that provides information about a speech synthesis task.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/SynthesisTask
type SynthesisTask struct {
	_ struct{} `type:"structure"`

	// Timestamp for the time the synthesis task was started.
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Optional language code for a synthesis task. This is only necessary if using
	// a bilingual voice, such as Aditi, which can be used for either Indian English
	// (en-IN) or Hindi (hi-IN).
	//
	// If a bilingual voice is used and no language code is specified, Amazon Polly
	// will use the default language of the bilingual voice. The default language
	// for any voice is the one returned by the DescribeVoices (https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html)
	// operation for the LanguageCode parameter. For example, if no language code
	// is specified, Aditi will use Indian English rather than Hindi.
	LanguageCode LanguageCode `type:"string" enum:"true"`

	// List of one or more pronunciation lexicon names you want the service to apply
	// during synthesis. Lexicons are applied only if the language of the lexicon
	// is the same as the language of the voice.
	LexiconNames []string `type:"list"`

	// The format in which the returned output will be encoded. For audio stream,
	// this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
	OutputFormat OutputFormat `type:"string" enum:"true"`

	// Pathway for the output speech file.
	OutputUri *string `type:"string"`

	// Number of billable characters synthesized.
	RequestCharacters *int64 `type:"integer"`

	// The audio frequency specified in Hz.
	//
	// The valid values for mp3 and ogg_vorbis are "8000", "16000", and "22050".
	// The default value is "22050".
	//
	// Valid values for pcm are "8000" and "16000" The default value is "16000".
	SampleRate *string `type:"string"`

	// ARN for the SNS topic optionally used for providing status notification for
	// a speech synthesis task.
	SnsTopicArn *string `type:"string"`

	// The type of speech marks returned for the input text.
	SpeechMarkTypes []SpeechMarkType `type:"list"`

	// The Amazon Polly generated identifier for a speech synthesis task.
	TaskId *string `min:"1" type:"string"`

	// Current status of the individual speech synthesis task.
	TaskStatus TaskStatus `type:"string" enum:"true"`

	// Reason for the current status of a specific speech synthesis task, including
	// errors if the task has failed.
	TaskStatusReason *string `type:"string"`

	// Specifies whether the input text is plain text or SSML. The default value
	// is plain text.
	TextType TextType `type:"string" enum:"true"`

	// Voice ID to use for the synthesis.
	VoiceId VoiceId `type:"string" enum:"true"`
}

// String returns the string representation
func (s SynthesisTask) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SynthesisTask) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SynthesisTask) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationTime != nil {
		v := *s.CreationTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.LanguageCode) > 0 {
		v := s.LanguageCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LanguageCode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.LexiconNames) > 0 {
		v := s.LexiconNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "LexiconNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.OutputFormat) > 0 {
		v := s.OutputFormat

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OutputFormat", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.OutputUri != nil {
		v := *s.OutputUri

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OutputUri", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RequestCharacters != nil {
		v := *s.RequestCharacters

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RequestCharacters", protocol.Int64Value(v), metadata)
	}
	if s.SampleRate != nil {
		v := *s.SampleRate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SampleRate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SnsTopicArn != nil {
		v := *s.SnsTopicArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SnsTopicArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SpeechMarkTypes) > 0 {
		v := s.SpeechMarkTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SpeechMarkTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.TaskId != nil {
		v := *s.TaskId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TaskId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TaskStatus) > 0 {
		v := s.TaskStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TaskStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.TaskStatusReason != nil {
		v := *s.TaskStatusReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TaskStatusReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TextType) > 0 {
		v := s.TextType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TextType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.VoiceId) > 0 {
		v := s.VoiceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VoiceId", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/SynthesizeSpeechInput
type SynthesizeSpeechInput struct {
	_ struct{} `type:"structure"`

	// Optional language code for the Synthesize Speech request. This is only necessary
	// if using a bilingual voice, such as Aditi, which can be used for either Indian
	// English (en-IN) or Hindi (hi-IN).
	//
	// If a bilingual voice is used and no language code is specified, Amazon Polly
	// will use the default language of the bilingual voice. The default language
	// for any voice is the one returned by the DescribeVoices (https://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html)
	// operation for the LanguageCode parameter. For example, if no language code
	// is specified, Aditi will use Indian English rather than Hindi.
	LanguageCode LanguageCode `type:"string" enum:"true"`

	// List of one or more pronunciation lexicon names you want the service to apply
	// during synthesis. Lexicons are applied only if the language of the lexicon
	// is the same as the language of the voice. For information about storing lexicons,
	// see PutLexicon (http://docs.aws.amazon.com/polly/latest/dg/API_PutLexicon.html).
	LexiconNames []string `type:"list"`

	// The format in which the returned output will be encoded. For audio stream,
	// this will be mp3, ogg_vorbis, or pcm. For speech marks, this will be json.
	//
	// When pcm is used, the content returned is audio/pcm in a signed 16-bit, 1
	// channel (mono), little-endian format.
	//
	// OutputFormat is a required field
	OutputFormat OutputFormat `type:"string" required:"true" enum:"true"`

	// The audio frequency specified in Hz.
	//
	// The valid values for mp3 and ogg_vorbis are "8000", "16000", and "22050".
	// The default value is "22050".
	//
	// Valid values for pcm are "8000" and "16000" The default value is "16000".
	SampleRate *string `type:"string"`

	// The type of speech marks returned for the input text.
	SpeechMarkTypes []SpeechMarkType `type:"list"`

	// Input text to synthesize. If you specify ssml as the TextType, follow the
	// SSML format for the input text.
	//
	// Text is a required field
	Text *string `type:"string" required:"true"`

	// Specifies whether the input text is plain text or SSML. The default value
	// is plain text. For more information, see Using SSML (http://docs.aws.amazon.com/polly/latest/dg/ssml.html).
	TextType TextType `type:"string" enum:"true"`

	// Voice ID to use for the synthesis. You can get a list of available voice
	// IDs by calling the DescribeVoices (http://docs.aws.amazon.com/polly/latest/dg/API_DescribeVoices.html)
	// operation.
	//
	// VoiceId is a required field
	VoiceId VoiceId `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s SynthesizeSpeechInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SynthesizeSpeechInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SynthesizeSpeechInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SynthesizeSpeechInput"}
	if len(s.OutputFormat) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("OutputFormat"))
	}

	if s.Text == nil {
		invalidParams.Add(aws.NewErrParamRequired("Text"))
	}
	if len(s.VoiceId) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("VoiceId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SynthesizeSpeechInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.LanguageCode) > 0 {
		v := s.LanguageCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LanguageCode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.LexiconNames) > 0 {
		v := s.LexiconNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "LexiconNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.OutputFormat) > 0 {
		v := s.OutputFormat

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OutputFormat", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SampleRate != nil {
		v := *s.SampleRate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SampleRate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SpeechMarkTypes) > 0 {
		v := s.SpeechMarkTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SpeechMarkTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Text != nil {
		v := *s.Text

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Text", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TextType) > 0 {
		v := s.TextType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TextType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.VoiceId) > 0 {
		v := s.VoiceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VoiceId", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/SynthesizeSpeechOutput
type SynthesizeSpeechOutput struct {
	_ struct{} `type:"structure" payload:"AudioStream"`

	responseMetadata aws.Response

	// Stream containing the synthesized speech.
	AudioStream io.ReadCloser `type:"blob"`

	// Specifies the type audio stream. This should reflect the OutputFormat parameter
	// in your request.
	//
	//    *  If you request mp3 as the OutputFormat, the ContentType returned is
	//    audio/mpeg.
	//
	//    *  If you request ogg_vorbis as the OutputFormat, the ContentType returned
	//    is audio/ogg.
	//
	//    *  If you request pcm as the OutputFormat, the ContentType returned is
	//    audio/pcm in a signed 16-bit, 1 channel (mono), little-endian format.
	//
	//
	//    * If you request json as the OutputFormat, the ContentType returned is
	//    audio/json.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Number of characters synthesized.
	RequestCharacters *int64 `location:"header" locationName:"x-amzn-RequestCharacters" type:"integer"`
}

// String returns the string representation
func (s SynthesizeSpeechOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SynthesizeSpeechOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SynthesizeSpeechOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SynthesizeSpeechOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RequestCharacters != nil {
		v := *s.RequestCharacters

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amzn-RequestCharacters", protocol.Int64Value(v), metadata)
	}
	// Skipping AudioStream Output type's body not valid.
	return nil
}

// Description of the voice.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/polly-2016-06-10/Voice
type Voice struct {
	_ struct{} `type:"structure"`

	// Additional codes for languages available for the specified voice in addition
	// to its default language.
	//
	// For example, the default language for Aditi is Indian English (en-IN) because
	// it was first used for that language. Since Aditi is bilingual and fluent
	// in both Indian English and Hindi, this parameter would show the code hi-IN.
	AdditionalLanguageCodes []LanguageCode `type:"list"`

	// Gender of the voice.
	Gender Gender `type:"string" enum:"true"`

	// Amazon Polly assigned voice ID. This is the ID that you specify when calling
	// the SynthesizeSpeech operation.
	Id VoiceId `type:"string" enum:"true"`

	// Language code of the voice.
	LanguageCode LanguageCode `type:"string" enum:"true"`

	// Human readable name of the language in English.
	LanguageName *string `type:"string"`

	// Name of the voice (for example, Salli, Kendra, etc.). This provides a human
	// readable voice name that you might display in your application.
	Name *string `type:"string"`
}

// String returns the string representation
func (s Voice) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Voice) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Voice) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AdditionalLanguageCodes) > 0 {
		v := s.AdditionalLanguageCodes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AdditionalLanguageCodes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Gender) > 0 {
		v := s.Gender

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Gender", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Id) > 0 {
		v := s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.LanguageCode) > 0 {
		v := s.LanguageCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LanguageCode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.LanguageName != nil {
		v := *s.LanguageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LanguageName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type Gender string

// Enum values for Gender
const (
	GenderFemale Gender = "Female"
	GenderMale   Gender = "Male"
)

func (enum Gender) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Gender) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type LanguageCode string

// Enum values for LanguageCode
const (
	LanguageCodeCmnCn   LanguageCode = "cmn-CN"
	LanguageCodeCyGb    LanguageCode = "cy-GB"
	LanguageCodeDaDk    LanguageCode = "da-DK"
	LanguageCodeDeDe    LanguageCode = "de-DE"
	LanguageCodeEnAu    LanguageCode = "en-AU"
	LanguageCodeEnGb    LanguageCode = "en-GB"
	LanguageCodeEnGbWls LanguageCode = "en-GB-WLS"
	LanguageCodeEnIn    LanguageCode = "en-IN"
	LanguageCodeEnUs    LanguageCode = "en-US"
	LanguageCodeEsEs    LanguageCode = "es-ES"
	LanguageCodeEsMx    LanguageCode = "es-MX"
	LanguageCodeEsUs    LanguageCode = "es-US"
	LanguageCodeFrCa    LanguageCode = "fr-CA"
	LanguageCodeFrFr    LanguageCode = "fr-FR"
	LanguageCodeIsIs    LanguageCode = "is-IS"
	LanguageCodeItIt    LanguageCode = "it-IT"
	LanguageCodeJaJp    LanguageCode = "ja-JP"
	LanguageCodeHiIn    LanguageCode = "hi-IN"
	LanguageCodeKoKr    LanguageCode = "ko-KR"
	LanguageCodeNbNo    LanguageCode = "nb-NO"
	LanguageCodeNlNl    LanguageCode = "nl-NL"
	LanguageCodePlPl    LanguageCode = "pl-PL"
	LanguageCodePtBr    LanguageCode = "pt-BR"
	LanguageCodePtPt    LanguageCode = "pt-PT"
	LanguageCodeRoRo    LanguageCode = "ro-RO"
	LanguageCodeRuRu    LanguageCode = "ru-RU"
	LanguageCodeSvSe    LanguageCode = "sv-SE"
	LanguageCodeTrTr    LanguageCode = "tr-TR"
)

func (enum LanguageCode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum LanguageCode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type OutputFormat string

// Enum values for OutputFormat
const (
	OutputFormatJson      OutputFormat = "json"
	OutputFormatMp3       OutputFormat = "mp3"
	OutputFormatOggVorbis OutputFormat = "ogg_vorbis"
	OutputFormatPcm       OutputFormat = "pcm"
)

func (enum OutputFormat) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum OutputFormat) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SpeechMarkType string

// Enum values for SpeechMarkType
const (
	SpeechMarkTypeSentence SpeechMarkType = "sentence"
	SpeechMarkTypeSsml     SpeechMarkType = "ssml"
	SpeechMarkTypeViseme   SpeechMarkType = "viseme"
	SpeechMarkTypeWord     SpeechMarkType = "word"
)

func (enum SpeechMarkType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SpeechMarkType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type TaskStatus string

// Enum values for TaskStatus
const (
	TaskStatusScheduled  TaskStatus = "scheduled"
	TaskStatusInProgress TaskStatus = "inProgress"
	TaskStatusCompleted  TaskStatus = "completed"
	TaskStatusFailed     TaskStatus = "failed"
)

func (enum TaskStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum TaskStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type TextType string

// Enum values for TextType
const (
	TextTypeSsml TextType = "ssml"
	TextTypeText TextType = "text"
)

func (enum TextType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum TextType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type VoiceId string

// Enum values for VoiceId
const (
	VoiceIdGeraint   VoiceId = "Geraint"
	VoiceIdGwyneth   VoiceId = "Gwyneth"
	VoiceIdMads      VoiceId = "Mads"
	VoiceIdNaja      VoiceId = "Naja"
	VoiceIdHans      VoiceId = "Hans"
	VoiceIdMarlene   VoiceId = "Marlene"
	VoiceIdNicole    VoiceId = "Nicole"
	VoiceIdRussell   VoiceId = "Russell"
	VoiceIdAmy       VoiceId = "Amy"
	VoiceIdBrian     VoiceId = "Brian"
	VoiceIdEmma      VoiceId = "Emma"
	VoiceIdRaveena   VoiceId = "Raveena"
	VoiceIdIvy       VoiceId = "Ivy"
	VoiceIdJoanna    VoiceId = "Joanna"
	VoiceIdJoey      VoiceId = "Joey"
	VoiceIdJustin    VoiceId = "Justin"
	VoiceIdKendra    VoiceId = "Kendra"
	VoiceIdKimberly  VoiceId = "Kimberly"
	VoiceIdMatthew   VoiceId = "Matthew"
	VoiceIdSalli     VoiceId = "Salli"
	VoiceIdConchita  VoiceId = "Conchita"
	VoiceIdEnrique   VoiceId = "Enrique"
	VoiceIdMiguel    VoiceId = "Miguel"
	VoiceIdPenelope  VoiceId = "Penelope"
	VoiceIdChantal   VoiceId = "Chantal"
	VoiceIdCeline    VoiceId = "Celine"
	VoiceIdLea       VoiceId = "Lea"
	VoiceIdMathieu   VoiceId = "Mathieu"
	VoiceIdDora      VoiceId = "Dora"
	VoiceIdKarl      VoiceId = "Karl"
	VoiceIdCarla     VoiceId = "Carla"
	VoiceIdGiorgio   VoiceId = "Giorgio"
	VoiceIdMizuki    VoiceId = "Mizuki"
	VoiceIdLiv       VoiceId = "Liv"
	VoiceIdLotte     VoiceId = "Lotte"
	VoiceIdRuben     VoiceId = "Ruben"
	VoiceIdEwa       VoiceId = "Ewa"
	VoiceIdJacek     VoiceId = "Jacek"
	VoiceIdJan       VoiceId = "Jan"
	VoiceIdMaja      VoiceId = "Maja"
	VoiceIdRicardo   VoiceId = "Ricardo"
	VoiceIdVitoria   VoiceId = "Vitoria"
	VoiceIdCristiano VoiceId = "Cristiano"
	VoiceIdInes      VoiceId = "Ines"
	VoiceIdCarmen    VoiceId = "Carmen"
	VoiceIdMaxim     VoiceId = "Maxim"
	VoiceIdTatyana   VoiceId = "Tatyana"
	VoiceIdAstrid    VoiceId = "Astrid"
	VoiceIdFiliz     VoiceId = "Filiz"
	VoiceIdVicki     VoiceId = "Vicki"
	VoiceIdTakumi    VoiceId = "Takumi"
	VoiceIdSeoyeon   VoiceId = "Seoyeon"
	VoiceIdAditi     VoiceId = "Aditi"
	VoiceIdZhiyu     VoiceId = "Zhiyu"
	VoiceIdBianca    VoiceId = "Bianca"
	VoiceIdLucia     VoiceId = "Lucia"
	VoiceIdMia       VoiceId = "Mia"
)

func (enum VoiceId) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum VoiceId) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
