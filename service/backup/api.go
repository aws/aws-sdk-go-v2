// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package backup

import (
	"context"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opCreateBackupPlan = "CreateBackupPlan"

// CreateBackupPlanRequest is a API request type for the CreateBackupPlan API operation.
type CreateBackupPlanRequest struct {
	*aws.Request
	Input *CreateBackupPlanInput
	Copy  func(*CreateBackupPlanInput) CreateBackupPlanRequest
}

// Send marshals and sends the CreateBackupPlan API request.
func (r CreateBackupPlanRequest) Send(ctx context.Context) (*CreateBackupPlanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateBackupPlanOutput), nil
}

// CreateBackupPlanRequest returns a request value for making API operation for
// AWS Backup.
//
// Backup plans are documents that contain information that AWS Backup uses
// to schedule tasks that create recovery points of resources.
//
// If you call CreateBackupPlan with a plan that already exists, the existing
// backupPlanId is returned.
//
//    // Example sending a request using the CreateBackupPlanRequest method.
//    req := client.CreateBackupPlanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupPlan
func (c *Backup) CreateBackupPlanRequest(input *CreateBackupPlanInput) CreateBackupPlanRequest {
	op := &aws.Operation{
		Name:       opCreateBackupPlan,
		HTTPMethod: "PUT",
		HTTPPath:   "/backup/plans/",
	}

	if input == nil {
		input = &CreateBackupPlanInput{}
	}

	output := &CreateBackupPlanOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBackupPlanRequest{Request: req, Input: input, Copy: c.CreateBackupPlanRequest}
}

const opCreateBackupSelection = "CreateBackupSelection"

// CreateBackupSelectionRequest is a API request type for the CreateBackupSelection API operation.
type CreateBackupSelectionRequest struct {
	*aws.Request
	Input *CreateBackupSelectionInput
	Copy  func(*CreateBackupSelectionInput) CreateBackupSelectionRequest
}

// Send marshals and sends the CreateBackupSelection API request.
func (r CreateBackupSelectionRequest) Send(ctx context.Context) (*CreateBackupSelectionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateBackupSelectionOutput), nil
}

// CreateBackupSelectionRequest returns a request value for making API operation for
// AWS Backup.
//
// Creates a JSON document that specifies a set of resources to assign to a
// backup plan. Resources can be included by specifying patterns for a ListOfTags
// and selected Resources.
//
// For example, consider the following patterns:
//
//    * Resources: "arn:aws:ec2:region:account-id:volume/volume-id"
//
//    * ConditionKey:"department"
//
// ConditionValue:"finance"
//
// ConditionType:"StringEquals"
//
//    * ConditionKey:"importance"
//
// ConditionValue:"critical"
//
// ConditionType:"StringEquals"
//
// Using these patterns would back up all Amazon Elastic Block Store (Amazon
// EBS) volumes that are tagged as "department=finance", "importance=critical",
// in addition to an EBS volume with the specified volume Id.
//
// Resources and conditions are additive in that all resources that match the
// pattern are selected. This shouldn't be confused with a logical AND, where
// all conditions must match. The matching patterns are logically 'put together
// using the OR operator. In other words, all patterns that match are selected
// for backup.
//
//    // Example sending a request using the CreateBackupSelectionRequest method.
//    req := client.CreateBackupSelectionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupSelection
func (c *Backup) CreateBackupSelectionRequest(input *CreateBackupSelectionInput) CreateBackupSelectionRequest {
	op := &aws.Operation{
		Name:       opCreateBackupSelection,
		HTTPMethod: "PUT",
		HTTPPath:   "/backup/plans/{backupPlanId}/selections/",
	}

	if input == nil {
		input = &CreateBackupSelectionInput{}
	}

	output := &CreateBackupSelectionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBackupSelectionRequest{Request: req, Input: input, Copy: c.CreateBackupSelectionRequest}
}

const opCreateBackupVault = "CreateBackupVault"

// CreateBackupVaultRequest is a API request type for the CreateBackupVault API operation.
type CreateBackupVaultRequest struct {
	*aws.Request
	Input *CreateBackupVaultInput
	Copy  func(*CreateBackupVaultInput) CreateBackupVaultRequest
}

// Send marshals and sends the CreateBackupVault API request.
func (r CreateBackupVaultRequest) Send(ctx context.Context) (*CreateBackupVaultOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateBackupVaultOutput), nil
}

// CreateBackupVaultRequest returns a request value for making API operation for
// AWS Backup.
//
// Creates a logical container where backups are stored. A CreateBackupVault
// request includes a name, optionally one or more resource tags, an encryption
// key, and a request ID.
//
// Sensitive data, such as passport numbers, should not be included the name
// of a backup vault.
//
//    // Example sending a request using the CreateBackupVaultRequest method.
//    req := client.CreateBackupVaultRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupVault
func (c *Backup) CreateBackupVaultRequest(input *CreateBackupVaultInput) CreateBackupVaultRequest {
	op := &aws.Operation{
		Name:       opCreateBackupVault,
		HTTPMethod: "PUT",
		HTTPPath:   "/backup-vaults/{backupVaultName}",
	}

	if input == nil {
		input = &CreateBackupVaultInput{}
	}

	output := &CreateBackupVaultOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBackupVaultRequest{Request: req, Input: input, Copy: c.CreateBackupVaultRequest}
}

const opDeleteBackupPlan = "DeleteBackupPlan"

// DeleteBackupPlanRequest is a API request type for the DeleteBackupPlan API operation.
type DeleteBackupPlanRequest struct {
	*aws.Request
	Input *DeleteBackupPlanInput
	Copy  func(*DeleteBackupPlanInput) DeleteBackupPlanRequest
}

// Send marshals and sends the DeleteBackupPlan API request.
func (r DeleteBackupPlanRequest) Send(ctx context.Context) (*DeleteBackupPlanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBackupPlanOutput), nil
}

// DeleteBackupPlanRequest returns a request value for making API operation for
// AWS Backup.
//
// Deletes a backup plan. A backup plan can only be deleted after all associated
// selections of resources have been deleted. Deleting a backup plan deletes
// the current version of a backup plan. Previous versions, if any, will still
// exist.
//
//    // Example sending a request using the DeleteBackupPlanRequest method.
//    req := client.DeleteBackupPlanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupPlan
func (c *Backup) DeleteBackupPlanRequest(input *DeleteBackupPlanInput) DeleteBackupPlanRequest {
	op := &aws.Operation{
		Name:       opDeleteBackupPlan,
		HTTPMethod: "DELETE",
		HTTPPath:   "/backup/plans/{backupPlanId}",
	}

	if input == nil {
		input = &DeleteBackupPlanInput{}
	}

	output := &DeleteBackupPlanOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBackupPlanRequest{Request: req, Input: input, Copy: c.DeleteBackupPlanRequest}
}

const opDeleteBackupSelection = "DeleteBackupSelection"

// DeleteBackupSelectionRequest is a API request type for the DeleteBackupSelection API operation.
type DeleteBackupSelectionRequest struct {
	*aws.Request
	Input *DeleteBackupSelectionInput
	Copy  func(*DeleteBackupSelectionInput) DeleteBackupSelectionRequest
}

// Send marshals and sends the DeleteBackupSelection API request.
func (r DeleteBackupSelectionRequest) Send(ctx context.Context) (*DeleteBackupSelectionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBackupSelectionOutput), nil
}

// DeleteBackupSelectionRequest returns a request value for making API operation for
// AWS Backup.
//
// Deletes the resource selection associated with a backup plan that is specified
// by the SelectionId.
//
//    // Example sending a request using the DeleteBackupSelectionRequest method.
//    req := client.DeleteBackupSelectionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupSelection
func (c *Backup) DeleteBackupSelectionRequest(input *DeleteBackupSelectionInput) DeleteBackupSelectionRequest {
	op := &aws.Operation{
		Name:       opDeleteBackupSelection,
		HTTPMethod: "DELETE",
		HTTPPath:   "/backup/plans/{backupPlanId}/selections/{selectionId}",
	}

	if input == nil {
		input = &DeleteBackupSelectionInput{}
	}

	output := &DeleteBackupSelectionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBackupSelectionRequest{Request: req, Input: input, Copy: c.DeleteBackupSelectionRequest}
}

const opDeleteBackupVault = "DeleteBackupVault"

// DeleteBackupVaultRequest is a API request type for the DeleteBackupVault API operation.
type DeleteBackupVaultRequest struct {
	*aws.Request
	Input *DeleteBackupVaultInput
	Copy  func(*DeleteBackupVaultInput) DeleteBackupVaultRequest
}

// Send marshals and sends the DeleteBackupVault API request.
func (r DeleteBackupVaultRequest) Send(ctx context.Context) (*DeleteBackupVaultOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBackupVaultOutput), nil
}

// DeleteBackupVaultRequest returns a request value for making API operation for
// AWS Backup.
//
// Deletes the backup vault identified by its name. A vault can be deleted only
// if it is empty.
//
//    // Example sending a request using the DeleteBackupVaultRequest method.
//    req := client.DeleteBackupVaultRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVault
func (c *Backup) DeleteBackupVaultRequest(input *DeleteBackupVaultInput) DeleteBackupVaultRequest {
	op := &aws.Operation{
		Name:       opDeleteBackupVault,
		HTTPMethod: "DELETE",
		HTTPPath:   "/backup-vaults/{backupVaultName}",
	}

	if input == nil {
		input = &DeleteBackupVaultInput{}
	}

	output := &DeleteBackupVaultOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBackupVaultRequest{Request: req, Input: input, Copy: c.DeleteBackupVaultRequest}
}

const opDeleteBackupVaultAccessPolicy = "DeleteBackupVaultAccessPolicy"

// DeleteBackupVaultAccessPolicyRequest is a API request type for the DeleteBackupVaultAccessPolicy API operation.
type DeleteBackupVaultAccessPolicyRequest struct {
	*aws.Request
	Input *DeleteBackupVaultAccessPolicyInput
	Copy  func(*DeleteBackupVaultAccessPolicyInput) DeleteBackupVaultAccessPolicyRequest
}

// Send marshals and sends the DeleteBackupVaultAccessPolicy API request.
func (r DeleteBackupVaultAccessPolicyRequest) Send(ctx context.Context) (*DeleteBackupVaultAccessPolicyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBackupVaultAccessPolicyOutput), nil
}

// DeleteBackupVaultAccessPolicyRequest returns a request value for making API operation for
// AWS Backup.
//
// Deletes the policy document that manages permissions on a backup vault.
//
//    // Example sending a request using the DeleteBackupVaultAccessPolicyRequest method.
//    req := client.DeleteBackupVaultAccessPolicyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVaultAccessPolicy
func (c *Backup) DeleteBackupVaultAccessPolicyRequest(input *DeleteBackupVaultAccessPolicyInput) DeleteBackupVaultAccessPolicyRequest {
	op := &aws.Operation{
		Name:       opDeleteBackupVaultAccessPolicy,
		HTTPMethod: "DELETE",
		HTTPPath:   "/backup-vaults/{backupVaultName}/access-policy",
	}

	if input == nil {
		input = &DeleteBackupVaultAccessPolicyInput{}
	}

	output := &DeleteBackupVaultAccessPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBackupVaultAccessPolicyRequest{Request: req, Input: input, Copy: c.DeleteBackupVaultAccessPolicyRequest}
}

const opDeleteBackupVaultNotifications = "DeleteBackupVaultNotifications"

// DeleteBackupVaultNotificationsRequest is a API request type for the DeleteBackupVaultNotifications API operation.
type DeleteBackupVaultNotificationsRequest struct {
	*aws.Request
	Input *DeleteBackupVaultNotificationsInput
	Copy  func(*DeleteBackupVaultNotificationsInput) DeleteBackupVaultNotificationsRequest
}

// Send marshals and sends the DeleteBackupVaultNotifications API request.
func (r DeleteBackupVaultNotificationsRequest) Send(ctx context.Context) (*DeleteBackupVaultNotificationsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBackupVaultNotificationsOutput), nil
}

// DeleteBackupVaultNotificationsRequest returns a request value for making API operation for
// AWS Backup.
//
// Deletes event notifications for the specified backup vault.
//
//    // Example sending a request using the DeleteBackupVaultNotificationsRequest method.
//    req := client.DeleteBackupVaultNotificationsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVaultNotifications
func (c *Backup) DeleteBackupVaultNotificationsRequest(input *DeleteBackupVaultNotificationsInput) DeleteBackupVaultNotificationsRequest {
	op := &aws.Operation{
		Name:       opDeleteBackupVaultNotifications,
		HTTPMethod: "DELETE",
		HTTPPath:   "/backup-vaults/{backupVaultName}/notification-configuration",
	}

	if input == nil {
		input = &DeleteBackupVaultNotificationsInput{}
	}

	output := &DeleteBackupVaultNotificationsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBackupVaultNotificationsRequest{Request: req, Input: input, Copy: c.DeleteBackupVaultNotificationsRequest}
}

const opDeleteRecoveryPoint = "DeleteRecoveryPoint"

// DeleteRecoveryPointRequest is a API request type for the DeleteRecoveryPoint API operation.
type DeleteRecoveryPointRequest struct {
	*aws.Request
	Input *DeleteRecoveryPointInput
	Copy  func(*DeleteRecoveryPointInput) DeleteRecoveryPointRequest
}

// Send marshals and sends the DeleteRecoveryPoint API request.
func (r DeleteRecoveryPointRequest) Send(ctx context.Context) (*DeleteRecoveryPointOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteRecoveryPointOutput), nil
}

// DeleteRecoveryPointRequest returns a request value for making API operation for
// AWS Backup.
//
// Deletes the recovery point specified by a recovery point ID.
//
//    // Example sending a request using the DeleteRecoveryPointRequest method.
//    req := client.DeleteRecoveryPointRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteRecoveryPoint
func (c *Backup) DeleteRecoveryPointRequest(input *DeleteRecoveryPointInput) DeleteRecoveryPointRequest {
	op := &aws.Operation{
		Name:       opDeleteRecoveryPoint,
		HTTPMethod: "DELETE",
		HTTPPath:   "/backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}",
	}

	if input == nil {
		input = &DeleteRecoveryPointInput{}
	}

	output := &DeleteRecoveryPointOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteRecoveryPointRequest{Request: req, Input: input, Copy: c.DeleteRecoveryPointRequest}
}

const opDescribeBackupJob = "DescribeBackupJob"

// DescribeBackupJobRequest is a API request type for the DescribeBackupJob API operation.
type DescribeBackupJobRequest struct {
	*aws.Request
	Input *DescribeBackupJobInput
	Copy  func(*DescribeBackupJobInput) DescribeBackupJobRequest
}

// Send marshals and sends the DescribeBackupJob API request.
func (r DescribeBackupJobRequest) Send(ctx context.Context) (*DescribeBackupJobOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeBackupJobOutput), nil
}

// DescribeBackupJobRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns metadata associated with creating a backup of a resource.
//
//    // Example sending a request using the DescribeBackupJobRequest method.
//    req := client.DescribeBackupJobRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeBackupJob
func (c *Backup) DescribeBackupJobRequest(input *DescribeBackupJobInput) DescribeBackupJobRequest {
	op := &aws.Operation{
		Name:       opDescribeBackupJob,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-jobs/{backupJobId}",
	}

	if input == nil {
		input = &DescribeBackupJobInput{}
	}

	output := &DescribeBackupJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeBackupJobRequest{Request: req, Input: input, Copy: c.DescribeBackupJobRequest}
}

const opDescribeBackupVault = "DescribeBackupVault"

// DescribeBackupVaultRequest is a API request type for the DescribeBackupVault API operation.
type DescribeBackupVaultRequest struct {
	*aws.Request
	Input *DescribeBackupVaultInput
	Copy  func(*DescribeBackupVaultInput) DescribeBackupVaultRequest
}

// Send marshals and sends the DescribeBackupVault API request.
func (r DescribeBackupVaultRequest) Send(ctx context.Context) (*DescribeBackupVaultOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeBackupVaultOutput), nil
}

// DescribeBackupVaultRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns metadata about a backup vault specified by its name.
//
//    // Example sending a request using the DescribeBackupVaultRequest method.
//    req := client.DescribeBackupVaultRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeBackupVault
func (c *Backup) DescribeBackupVaultRequest(input *DescribeBackupVaultInput) DescribeBackupVaultRequest {
	op := &aws.Operation{
		Name:       opDescribeBackupVault,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-vaults/{backupVaultName}",
	}

	if input == nil {
		input = &DescribeBackupVaultInput{}
	}

	output := &DescribeBackupVaultOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeBackupVaultRequest{Request: req, Input: input, Copy: c.DescribeBackupVaultRequest}
}

const opDescribeProtectedResource = "DescribeProtectedResource"

// DescribeProtectedResourceRequest is a API request type for the DescribeProtectedResource API operation.
type DescribeProtectedResourceRequest struct {
	*aws.Request
	Input *DescribeProtectedResourceInput
	Copy  func(*DescribeProtectedResourceInput) DescribeProtectedResourceRequest
}

// Send marshals and sends the DescribeProtectedResource API request.
func (r DescribeProtectedResourceRequest) Send(ctx context.Context) (*DescribeProtectedResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeProtectedResourceOutput), nil
}

// DescribeProtectedResourceRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns information about a saved resource, including the last time it was
// backed-up, its Amazon Resource Name (ARN), and the AWS service type of the
// saved resource.
//
//    // Example sending a request using the DescribeProtectedResourceRequest method.
//    req := client.DescribeProtectedResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeProtectedResource
func (c *Backup) DescribeProtectedResourceRequest(input *DescribeProtectedResourceInput) DescribeProtectedResourceRequest {
	op := &aws.Operation{
		Name:       opDescribeProtectedResource,
		HTTPMethod: "GET",
		HTTPPath:   "/resources/{resourceArn}",
	}

	if input == nil {
		input = &DescribeProtectedResourceInput{}
	}

	output := &DescribeProtectedResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeProtectedResourceRequest{Request: req, Input: input, Copy: c.DescribeProtectedResourceRequest}
}

const opDescribeRecoveryPoint = "DescribeRecoveryPoint"

// DescribeRecoveryPointRequest is a API request type for the DescribeRecoveryPoint API operation.
type DescribeRecoveryPointRequest struct {
	*aws.Request
	Input *DescribeRecoveryPointInput
	Copy  func(*DescribeRecoveryPointInput) DescribeRecoveryPointRequest
}

// Send marshals and sends the DescribeRecoveryPoint API request.
func (r DescribeRecoveryPointRequest) Send(ctx context.Context) (*DescribeRecoveryPointOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeRecoveryPointOutput), nil
}

// DescribeRecoveryPointRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns metadata associated with a recovery point, including ID, status,
// encryption, and lifecycle.
//
//    // Example sending a request using the DescribeRecoveryPointRequest method.
//    req := client.DescribeRecoveryPointRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeRecoveryPoint
func (c *Backup) DescribeRecoveryPointRequest(input *DescribeRecoveryPointInput) DescribeRecoveryPointRequest {
	op := &aws.Operation{
		Name:       opDescribeRecoveryPoint,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}",
	}

	if input == nil {
		input = &DescribeRecoveryPointInput{}
	}

	output := &DescribeRecoveryPointOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeRecoveryPointRequest{Request: req, Input: input, Copy: c.DescribeRecoveryPointRequest}
}

const opDescribeRestoreJob = "DescribeRestoreJob"

// DescribeRestoreJobRequest is a API request type for the DescribeRestoreJob API operation.
type DescribeRestoreJobRequest struct {
	*aws.Request
	Input *DescribeRestoreJobInput
	Copy  func(*DescribeRestoreJobInput) DescribeRestoreJobRequest
}

// Send marshals and sends the DescribeRestoreJob API request.
func (r DescribeRestoreJobRequest) Send(ctx context.Context) (*DescribeRestoreJobOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeRestoreJobOutput), nil
}

// DescribeRestoreJobRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns metadata associated with a restore job that is specified by a job
// ID.
//
//    // Example sending a request using the DescribeRestoreJobRequest method.
//    req := client.DescribeRestoreJobRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeRestoreJob
func (c *Backup) DescribeRestoreJobRequest(input *DescribeRestoreJobInput) DescribeRestoreJobRequest {
	op := &aws.Operation{
		Name:       opDescribeRestoreJob,
		HTTPMethod: "GET",
		HTTPPath:   "/restore-jobs/{restoreJobId}",
	}

	if input == nil {
		input = &DescribeRestoreJobInput{}
	}

	output := &DescribeRestoreJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeRestoreJobRequest{Request: req, Input: input, Copy: c.DescribeRestoreJobRequest}
}

const opExportBackupPlanTemplate = "ExportBackupPlanTemplate"

// ExportBackupPlanTemplateRequest is a API request type for the ExportBackupPlanTemplate API operation.
type ExportBackupPlanTemplateRequest struct {
	*aws.Request
	Input *ExportBackupPlanTemplateInput
	Copy  func(*ExportBackupPlanTemplateInput) ExportBackupPlanTemplateRequest
}

// Send marshals and sends the ExportBackupPlanTemplate API request.
func (r ExportBackupPlanTemplateRequest) Send(ctx context.Context) (*ExportBackupPlanTemplateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ExportBackupPlanTemplateOutput), nil
}

// ExportBackupPlanTemplateRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns the backup plan that is specified by the plan ID as a backup template.
//
//    // Example sending a request using the ExportBackupPlanTemplateRequest method.
//    req := client.ExportBackupPlanTemplateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ExportBackupPlanTemplate
func (c *Backup) ExportBackupPlanTemplateRequest(input *ExportBackupPlanTemplateInput) ExportBackupPlanTemplateRequest {
	op := &aws.Operation{
		Name:       opExportBackupPlanTemplate,
		HTTPMethod: "GET",
		HTTPPath:   "/backup/plans/{backupPlanId}/toTemplate/",
	}

	if input == nil {
		input = &ExportBackupPlanTemplateInput{}
	}

	output := &ExportBackupPlanTemplateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ExportBackupPlanTemplateRequest{Request: req, Input: input, Copy: c.ExportBackupPlanTemplateRequest}
}

const opGetBackupPlan = "GetBackupPlan"

// GetBackupPlanRequest is a API request type for the GetBackupPlan API operation.
type GetBackupPlanRequest struct {
	*aws.Request
	Input *GetBackupPlanInput
	Copy  func(*GetBackupPlanInput) GetBackupPlanRequest
}

// Send marshals and sends the GetBackupPlan API request.
func (r GetBackupPlanRequest) Send(ctx context.Context) (*GetBackupPlanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBackupPlanOutput), nil
}

// GetBackupPlanRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns the body of a backup plan in JSON format, in addition to plan metadata.
//
//    // Example sending a request using the GetBackupPlanRequest method.
//    req := client.GetBackupPlanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlan
func (c *Backup) GetBackupPlanRequest(input *GetBackupPlanInput) GetBackupPlanRequest {
	op := &aws.Operation{
		Name:       opGetBackupPlan,
		HTTPMethod: "GET",
		HTTPPath:   "/backup/plans/{backupPlanId}/",
	}

	if input == nil {
		input = &GetBackupPlanInput{}
	}

	output := &GetBackupPlanOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBackupPlanRequest{Request: req, Input: input, Copy: c.GetBackupPlanRequest}
}

const opGetBackupPlanFromJSON = "GetBackupPlanFromJSON"

// GetBackupPlanFromJSONRequest is a API request type for the GetBackupPlanFromJSON API operation.
type GetBackupPlanFromJSONRequest struct {
	*aws.Request
	Input *GetBackupPlanFromJSONInput
	Copy  func(*GetBackupPlanFromJSONInput) GetBackupPlanFromJSONRequest
}

// Send marshals and sends the GetBackupPlanFromJSON API request.
func (r GetBackupPlanFromJSONRequest) Send(ctx context.Context) (*GetBackupPlanFromJSONOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBackupPlanFromJSONOutput), nil
}

// GetBackupPlanFromJSONRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns a valid JSON document specifying a backup plan or an error.
//
//    // Example sending a request using the GetBackupPlanFromJSONRequest method.
//    req := client.GetBackupPlanFromJSONRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlanFromJSON
func (c *Backup) GetBackupPlanFromJSONRequest(input *GetBackupPlanFromJSONInput) GetBackupPlanFromJSONRequest {
	op := &aws.Operation{
		Name:       opGetBackupPlanFromJSON,
		HTTPMethod: "POST",
		HTTPPath:   "/backup/template/json/toPlan",
	}

	if input == nil {
		input = &GetBackupPlanFromJSONInput{}
	}

	output := &GetBackupPlanFromJSONOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBackupPlanFromJSONRequest{Request: req, Input: input, Copy: c.GetBackupPlanFromJSONRequest}
}

const opGetBackupPlanFromTemplate = "GetBackupPlanFromTemplate"

// GetBackupPlanFromTemplateRequest is a API request type for the GetBackupPlanFromTemplate API operation.
type GetBackupPlanFromTemplateRequest struct {
	*aws.Request
	Input *GetBackupPlanFromTemplateInput
	Copy  func(*GetBackupPlanFromTemplateInput) GetBackupPlanFromTemplateRequest
}

// Send marshals and sends the GetBackupPlanFromTemplate API request.
func (r GetBackupPlanFromTemplateRequest) Send(ctx context.Context) (*GetBackupPlanFromTemplateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBackupPlanFromTemplateOutput), nil
}

// GetBackupPlanFromTemplateRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns the template specified by its templateId as a backup plan.
//
//    // Example sending a request using the GetBackupPlanFromTemplateRequest method.
//    req := client.GetBackupPlanFromTemplateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlanFromTemplate
func (c *Backup) GetBackupPlanFromTemplateRequest(input *GetBackupPlanFromTemplateInput) GetBackupPlanFromTemplateRequest {
	op := &aws.Operation{
		Name:       opGetBackupPlanFromTemplate,
		HTTPMethod: "GET",
		HTTPPath:   "/backup/template/plans/{templateId}/toPlan",
	}

	if input == nil {
		input = &GetBackupPlanFromTemplateInput{}
	}

	output := &GetBackupPlanFromTemplateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBackupPlanFromTemplateRequest{Request: req, Input: input, Copy: c.GetBackupPlanFromTemplateRequest}
}

const opGetBackupSelection = "GetBackupSelection"

// GetBackupSelectionRequest is a API request type for the GetBackupSelection API operation.
type GetBackupSelectionRequest struct {
	*aws.Request
	Input *GetBackupSelectionInput
	Copy  func(*GetBackupSelectionInput) GetBackupSelectionRequest
}

// Send marshals and sends the GetBackupSelection API request.
func (r GetBackupSelectionRequest) Send(ctx context.Context) (*GetBackupSelectionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBackupSelectionOutput), nil
}

// GetBackupSelectionRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns selection metadata and a document in JSON format that specifies a
// list of resources that are associated with a backup plan.
//
//    // Example sending a request using the GetBackupSelectionRequest method.
//    req := client.GetBackupSelectionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupSelection
func (c *Backup) GetBackupSelectionRequest(input *GetBackupSelectionInput) GetBackupSelectionRequest {
	op := &aws.Operation{
		Name:       opGetBackupSelection,
		HTTPMethod: "GET",
		HTTPPath:   "/backup/plans/{backupPlanId}/selections/{selectionId}",
	}

	if input == nil {
		input = &GetBackupSelectionInput{}
	}

	output := &GetBackupSelectionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBackupSelectionRequest{Request: req, Input: input, Copy: c.GetBackupSelectionRequest}
}

const opGetBackupVaultAccessPolicy = "GetBackupVaultAccessPolicy"

// GetBackupVaultAccessPolicyRequest is a API request type for the GetBackupVaultAccessPolicy API operation.
type GetBackupVaultAccessPolicyRequest struct {
	*aws.Request
	Input *GetBackupVaultAccessPolicyInput
	Copy  func(*GetBackupVaultAccessPolicyInput) GetBackupVaultAccessPolicyRequest
}

// Send marshals and sends the GetBackupVaultAccessPolicy API request.
func (r GetBackupVaultAccessPolicyRequest) Send(ctx context.Context) (*GetBackupVaultAccessPolicyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBackupVaultAccessPolicyOutput), nil
}

// GetBackupVaultAccessPolicyRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns the access policy document that is associated with the named backup
// vault.
//
//    // Example sending a request using the GetBackupVaultAccessPolicyRequest method.
//    req := client.GetBackupVaultAccessPolicyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupVaultAccessPolicy
func (c *Backup) GetBackupVaultAccessPolicyRequest(input *GetBackupVaultAccessPolicyInput) GetBackupVaultAccessPolicyRequest {
	op := &aws.Operation{
		Name:       opGetBackupVaultAccessPolicy,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-vaults/{backupVaultName}/access-policy",
	}

	if input == nil {
		input = &GetBackupVaultAccessPolicyInput{}
	}

	output := &GetBackupVaultAccessPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBackupVaultAccessPolicyRequest{Request: req, Input: input, Copy: c.GetBackupVaultAccessPolicyRequest}
}

const opGetBackupVaultNotifications = "GetBackupVaultNotifications"

// GetBackupVaultNotificationsRequest is a API request type for the GetBackupVaultNotifications API operation.
type GetBackupVaultNotificationsRequest struct {
	*aws.Request
	Input *GetBackupVaultNotificationsInput
	Copy  func(*GetBackupVaultNotificationsInput) GetBackupVaultNotificationsRequest
}

// Send marshals and sends the GetBackupVaultNotifications API request.
func (r GetBackupVaultNotificationsRequest) Send(ctx context.Context) (*GetBackupVaultNotificationsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBackupVaultNotificationsOutput), nil
}

// GetBackupVaultNotificationsRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns event notifications for the specified backup vault.
//
//    // Example sending a request using the GetBackupVaultNotificationsRequest method.
//    req := client.GetBackupVaultNotificationsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupVaultNotifications
func (c *Backup) GetBackupVaultNotificationsRequest(input *GetBackupVaultNotificationsInput) GetBackupVaultNotificationsRequest {
	op := &aws.Operation{
		Name:       opGetBackupVaultNotifications,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-vaults/{backupVaultName}/notification-configuration",
	}

	if input == nil {
		input = &GetBackupVaultNotificationsInput{}
	}

	output := &GetBackupVaultNotificationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBackupVaultNotificationsRequest{Request: req, Input: input, Copy: c.GetBackupVaultNotificationsRequest}
}

const opGetRecoveryPointRestoreMetadata = "GetRecoveryPointRestoreMetadata"

// GetRecoveryPointRestoreMetadataRequest is a API request type for the GetRecoveryPointRestoreMetadata API operation.
type GetRecoveryPointRestoreMetadataRequest struct {
	*aws.Request
	Input *GetRecoveryPointRestoreMetadataInput
	Copy  func(*GetRecoveryPointRestoreMetadataInput) GetRecoveryPointRestoreMetadataRequest
}

// Send marshals and sends the GetRecoveryPointRestoreMetadata API request.
func (r GetRecoveryPointRestoreMetadataRequest) Send(ctx context.Context) (*GetRecoveryPointRestoreMetadataOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetRecoveryPointRestoreMetadataOutput), nil
}

// GetRecoveryPointRestoreMetadataRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns two sets of metadata key-value pairs. The first set lists the metadata
// that the recovery point was created with. The second set lists the metadata
// key-value pairs that are required to restore the recovery point.
//
// These sets can be the same, or the restore metadata set can contain different
// values if the target service to be restored has changed since the recovery
// point was created and now requires additional or different information in
// order to be restored.
//
//    // Example sending a request using the GetRecoveryPointRestoreMetadataRequest method.
//    req := client.GetRecoveryPointRestoreMetadataRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetRecoveryPointRestoreMetadata
func (c *Backup) GetRecoveryPointRestoreMetadataRequest(input *GetRecoveryPointRestoreMetadataInput) GetRecoveryPointRestoreMetadataRequest {
	op := &aws.Operation{
		Name:       opGetRecoveryPointRestoreMetadata,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}/restore-metadata",
	}

	if input == nil {
		input = &GetRecoveryPointRestoreMetadataInput{}
	}

	output := &GetRecoveryPointRestoreMetadataOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetRecoveryPointRestoreMetadataRequest{Request: req, Input: input, Copy: c.GetRecoveryPointRestoreMetadataRequest}
}

const opGetSupportedResourceTypes = "GetSupportedResourceTypes"

// GetSupportedResourceTypesRequest is a API request type for the GetSupportedResourceTypes API operation.
type GetSupportedResourceTypesRequest struct {
	*aws.Request
	Input *GetSupportedResourceTypesInput
	Copy  func(*GetSupportedResourceTypesInput) GetSupportedResourceTypesRequest
}

// Send marshals and sends the GetSupportedResourceTypes API request.
func (r GetSupportedResourceTypesRequest) Send(ctx context.Context) (*GetSupportedResourceTypesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSupportedResourceTypesOutput), nil
}

// GetSupportedResourceTypesRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns the AWS resource types supported by AWS Backup.
//
//    // Example sending a request using the GetSupportedResourceTypesRequest method.
//    req := client.GetSupportedResourceTypesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetSupportedResourceTypes
func (c *Backup) GetSupportedResourceTypesRequest(input *GetSupportedResourceTypesInput) GetSupportedResourceTypesRequest {
	op := &aws.Operation{
		Name:       opGetSupportedResourceTypes,
		HTTPMethod: "GET",
		HTTPPath:   "/supported-resource-types",
	}

	if input == nil {
		input = &GetSupportedResourceTypesInput{}
	}

	output := &GetSupportedResourceTypesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSupportedResourceTypesRequest{Request: req, Input: input, Copy: c.GetSupportedResourceTypesRequest}
}

const opListBackupJobs = "ListBackupJobs"

// ListBackupJobsRequest is a API request type for the ListBackupJobs API operation.
type ListBackupJobsRequest struct {
	*aws.Request
	Input *ListBackupJobsInput
	Copy  func(*ListBackupJobsInput) ListBackupJobsRequest
}

// Send marshals and sends the ListBackupJobs API request.
func (r ListBackupJobsRequest) Send(ctx context.Context) (*ListBackupJobsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBackupJobsOutput), nil
}

// ListBackupJobsRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns metadata about your backup jobs.
//
//    // Example sending a request using the ListBackupJobsRequest method.
//    req := client.ListBackupJobsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupJobs
func (c *Backup) ListBackupJobsRequest(input *ListBackupJobsInput) ListBackupJobsRequest {
	op := &aws.Operation{
		Name:       opListBackupJobs,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-jobs/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListBackupJobsInput{}
	}

	output := &ListBackupJobsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBackupJobsRequest{Request: req, Input: input, Copy: c.ListBackupJobsRequest}
}

// Paginate pages iterates over the pages of a ListBackupJobsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListBackupJobs operation.
//		req := client.ListBackupJobsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListBackupJobsRequest) Paginate(opts ...aws.Option) ListBackupJobsPager {
	return ListBackupJobsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListBackupJobsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListBackupJobsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListBackupJobsPager struct {
	aws.Pager
}

func (p *ListBackupJobsPager) CurrentPage() *ListBackupJobsOutput {
	return p.Pager.CurrentPage().(*ListBackupJobsOutput)
}

const opListBackupPlanTemplates = "ListBackupPlanTemplates"

// ListBackupPlanTemplatesRequest is a API request type for the ListBackupPlanTemplates API operation.
type ListBackupPlanTemplatesRequest struct {
	*aws.Request
	Input *ListBackupPlanTemplatesInput
	Copy  func(*ListBackupPlanTemplatesInput) ListBackupPlanTemplatesRequest
}

// Send marshals and sends the ListBackupPlanTemplates API request.
func (r ListBackupPlanTemplatesRequest) Send(ctx context.Context) (*ListBackupPlanTemplatesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBackupPlanTemplatesOutput), nil
}

// ListBackupPlanTemplatesRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns metadata of your saved backup plan templates, including the template
// ID, name, and the creation and deletion dates.
//
//    // Example sending a request using the ListBackupPlanTemplatesRequest method.
//    req := client.ListBackupPlanTemplatesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlanTemplates
func (c *Backup) ListBackupPlanTemplatesRequest(input *ListBackupPlanTemplatesInput) ListBackupPlanTemplatesRequest {
	op := &aws.Operation{
		Name:       opListBackupPlanTemplates,
		HTTPMethod: "GET",
		HTTPPath:   "/backup/template/plans",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListBackupPlanTemplatesInput{}
	}

	output := &ListBackupPlanTemplatesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBackupPlanTemplatesRequest{Request: req, Input: input, Copy: c.ListBackupPlanTemplatesRequest}
}

// Paginate pages iterates over the pages of a ListBackupPlanTemplatesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListBackupPlanTemplates operation.
//		req := client.ListBackupPlanTemplatesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListBackupPlanTemplatesRequest) Paginate(opts ...aws.Option) ListBackupPlanTemplatesPager {
	return ListBackupPlanTemplatesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListBackupPlanTemplatesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListBackupPlanTemplatesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListBackupPlanTemplatesPager struct {
	aws.Pager
}

func (p *ListBackupPlanTemplatesPager) CurrentPage() *ListBackupPlanTemplatesOutput {
	return p.Pager.CurrentPage().(*ListBackupPlanTemplatesOutput)
}

const opListBackupPlanVersions = "ListBackupPlanVersions"

// ListBackupPlanVersionsRequest is a API request type for the ListBackupPlanVersions API operation.
type ListBackupPlanVersionsRequest struct {
	*aws.Request
	Input *ListBackupPlanVersionsInput
	Copy  func(*ListBackupPlanVersionsInput) ListBackupPlanVersionsRequest
}

// Send marshals and sends the ListBackupPlanVersions API request.
func (r ListBackupPlanVersionsRequest) Send(ctx context.Context) (*ListBackupPlanVersionsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBackupPlanVersionsOutput), nil
}

// ListBackupPlanVersionsRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns version metadata of your backup plans, including Amazon Resource
// Names (ARNs), backup plan IDs, creation and deletion dates, plan names, and
// version IDs.
//
//    // Example sending a request using the ListBackupPlanVersionsRequest method.
//    req := client.ListBackupPlanVersionsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlanVersions
func (c *Backup) ListBackupPlanVersionsRequest(input *ListBackupPlanVersionsInput) ListBackupPlanVersionsRequest {
	op := &aws.Operation{
		Name:       opListBackupPlanVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/backup/plans/{backupPlanId}/versions/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListBackupPlanVersionsInput{}
	}

	output := &ListBackupPlanVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBackupPlanVersionsRequest{Request: req, Input: input, Copy: c.ListBackupPlanVersionsRequest}
}

// Paginate pages iterates over the pages of a ListBackupPlanVersionsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListBackupPlanVersions operation.
//		req := client.ListBackupPlanVersionsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListBackupPlanVersionsRequest) Paginate(opts ...aws.Option) ListBackupPlanVersionsPager {
	return ListBackupPlanVersionsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListBackupPlanVersionsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListBackupPlanVersionsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListBackupPlanVersionsPager struct {
	aws.Pager
}

func (p *ListBackupPlanVersionsPager) CurrentPage() *ListBackupPlanVersionsOutput {
	return p.Pager.CurrentPage().(*ListBackupPlanVersionsOutput)
}

const opListBackupPlans = "ListBackupPlans"

// ListBackupPlansRequest is a API request type for the ListBackupPlans API operation.
type ListBackupPlansRequest struct {
	*aws.Request
	Input *ListBackupPlansInput
	Copy  func(*ListBackupPlansInput) ListBackupPlansRequest
}

// Send marshals and sends the ListBackupPlans API request.
func (r ListBackupPlansRequest) Send(ctx context.Context) (*ListBackupPlansOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBackupPlansOutput), nil
}

// ListBackupPlansRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns metadata of your saved backup plans, including Amazon Resource Names
// (ARNs), plan IDs, creation and deletion dates, version IDs, plan names, and
// creator request IDs.
//
//    // Example sending a request using the ListBackupPlansRequest method.
//    req := client.ListBackupPlansRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlans
func (c *Backup) ListBackupPlansRequest(input *ListBackupPlansInput) ListBackupPlansRequest {
	op := &aws.Operation{
		Name:       opListBackupPlans,
		HTTPMethod: "GET",
		HTTPPath:   "/backup/plans/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListBackupPlansInput{}
	}

	output := &ListBackupPlansOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBackupPlansRequest{Request: req, Input: input, Copy: c.ListBackupPlansRequest}
}

// Paginate pages iterates over the pages of a ListBackupPlansRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListBackupPlans operation.
//		req := client.ListBackupPlansRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListBackupPlansRequest) Paginate(opts ...aws.Option) ListBackupPlansPager {
	return ListBackupPlansPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListBackupPlansInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListBackupPlansPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListBackupPlansPager struct {
	aws.Pager
}

func (p *ListBackupPlansPager) CurrentPage() *ListBackupPlansOutput {
	return p.Pager.CurrentPage().(*ListBackupPlansOutput)
}

const opListBackupSelections = "ListBackupSelections"

// ListBackupSelectionsRequest is a API request type for the ListBackupSelections API operation.
type ListBackupSelectionsRequest struct {
	*aws.Request
	Input *ListBackupSelectionsInput
	Copy  func(*ListBackupSelectionsInput) ListBackupSelectionsRequest
}

// Send marshals and sends the ListBackupSelections API request.
func (r ListBackupSelectionsRequest) Send(ctx context.Context) (*ListBackupSelectionsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBackupSelectionsOutput), nil
}

// ListBackupSelectionsRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns an array containing metadata of the resources associated with the
// target backup plan.
//
//    // Example sending a request using the ListBackupSelectionsRequest method.
//    req := client.ListBackupSelectionsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupSelections
func (c *Backup) ListBackupSelectionsRequest(input *ListBackupSelectionsInput) ListBackupSelectionsRequest {
	op := &aws.Operation{
		Name:       opListBackupSelections,
		HTTPMethod: "GET",
		HTTPPath:   "/backup/plans/{backupPlanId}/selections/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListBackupSelectionsInput{}
	}

	output := &ListBackupSelectionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBackupSelectionsRequest{Request: req, Input: input, Copy: c.ListBackupSelectionsRequest}
}

// Paginate pages iterates over the pages of a ListBackupSelectionsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListBackupSelections operation.
//		req := client.ListBackupSelectionsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListBackupSelectionsRequest) Paginate(opts ...aws.Option) ListBackupSelectionsPager {
	return ListBackupSelectionsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListBackupSelectionsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListBackupSelectionsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListBackupSelectionsPager struct {
	aws.Pager
}

func (p *ListBackupSelectionsPager) CurrentPage() *ListBackupSelectionsOutput {
	return p.Pager.CurrentPage().(*ListBackupSelectionsOutput)
}

const opListBackupVaults = "ListBackupVaults"

// ListBackupVaultsRequest is a API request type for the ListBackupVaults API operation.
type ListBackupVaultsRequest struct {
	*aws.Request
	Input *ListBackupVaultsInput
	Copy  func(*ListBackupVaultsInput) ListBackupVaultsRequest
}

// Send marshals and sends the ListBackupVaults API request.
func (r ListBackupVaultsRequest) Send(ctx context.Context) (*ListBackupVaultsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBackupVaultsOutput), nil
}

// ListBackupVaultsRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns a list of recovery point storage containers along with information
// about them.
//
//    // Example sending a request using the ListBackupVaultsRequest method.
//    req := client.ListBackupVaultsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupVaults
func (c *Backup) ListBackupVaultsRequest(input *ListBackupVaultsInput) ListBackupVaultsRequest {
	op := &aws.Operation{
		Name:       opListBackupVaults,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-vaults/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListBackupVaultsInput{}
	}

	output := &ListBackupVaultsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBackupVaultsRequest{Request: req, Input: input, Copy: c.ListBackupVaultsRequest}
}

// Paginate pages iterates over the pages of a ListBackupVaultsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListBackupVaults operation.
//		req := client.ListBackupVaultsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListBackupVaultsRequest) Paginate(opts ...aws.Option) ListBackupVaultsPager {
	return ListBackupVaultsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListBackupVaultsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListBackupVaultsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListBackupVaultsPager struct {
	aws.Pager
}

func (p *ListBackupVaultsPager) CurrentPage() *ListBackupVaultsOutput {
	return p.Pager.CurrentPage().(*ListBackupVaultsOutput)
}

const opListProtectedResources = "ListProtectedResources"

// ListProtectedResourcesRequest is a API request type for the ListProtectedResources API operation.
type ListProtectedResourcesRequest struct {
	*aws.Request
	Input *ListProtectedResourcesInput
	Copy  func(*ListProtectedResourcesInput) ListProtectedResourcesRequest
}

// Send marshals and sends the ListProtectedResources API request.
func (r ListProtectedResourcesRequest) Send(ctx context.Context) (*ListProtectedResourcesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListProtectedResourcesOutput), nil
}

// ListProtectedResourcesRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns an array of resources successfully backed up by AWS Backup, including
// the time the resource was saved, an Amazon Resource Name (ARN) of the resource,
// and a resource type.
//
//    // Example sending a request using the ListProtectedResourcesRequest method.
//    req := client.ListProtectedResourcesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListProtectedResources
func (c *Backup) ListProtectedResourcesRequest(input *ListProtectedResourcesInput) ListProtectedResourcesRequest {
	op := &aws.Operation{
		Name:       opListProtectedResources,
		HTTPMethod: "GET",
		HTTPPath:   "/resources/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListProtectedResourcesInput{}
	}

	output := &ListProtectedResourcesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListProtectedResourcesRequest{Request: req, Input: input, Copy: c.ListProtectedResourcesRequest}
}

// Paginate pages iterates over the pages of a ListProtectedResourcesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListProtectedResources operation.
//		req := client.ListProtectedResourcesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListProtectedResourcesRequest) Paginate(opts ...aws.Option) ListProtectedResourcesPager {
	return ListProtectedResourcesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListProtectedResourcesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListProtectedResourcesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListProtectedResourcesPager struct {
	aws.Pager
}

func (p *ListProtectedResourcesPager) CurrentPage() *ListProtectedResourcesOutput {
	return p.Pager.CurrentPage().(*ListProtectedResourcesOutput)
}

const opListRecoveryPointsByBackupVault = "ListRecoveryPointsByBackupVault"

// ListRecoveryPointsByBackupVaultRequest is a API request type for the ListRecoveryPointsByBackupVault API operation.
type ListRecoveryPointsByBackupVaultRequest struct {
	*aws.Request
	Input *ListRecoveryPointsByBackupVaultInput
	Copy  func(*ListRecoveryPointsByBackupVaultInput) ListRecoveryPointsByBackupVaultRequest
}

// Send marshals and sends the ListRecoveryPointsByBackupVault API request.
func (r ListRecoveryPointsByBackupVaultRequest) Send(ctx context.Context) (*ListRecoveryPointsByBackupVaultOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListRecoveryPointsByBackupVaultOutput), nil
}

// ListRecoveryPointsByBackupVaultRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns detailed information about the recovery points stored in a backup
// vault.
//
//    // Example sending a request using the ListRecoveryPointsByBackupVaultRequest method.
//    req := client.ListRecoveryPointsByBackupVaultRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRecoveryPointsByBackupVault
func (c *Backup) ListRecoveryPointsByBackupVaultRequest(input *ListRecoveryPointsByBackupVaultInput) ListRecoveryPointsByBackupVaultRequest {
	op := &aws.Operation{
		Name:       opListRecoveryPointsByBackupVault,
		HTTPMethod: "GET",
		HTTPPath:   "/backup-vaults/{backupVaultName}/recovery-points/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListRecoveryPointsByBackupVaultInput{}
	}

	output := &ListRecoveryPointsByBackupVaultOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListRecoveryPointsByBackupVaultRequest{Request: req, Input: input, Copy: c.ListRecoveryPointsByBackupVaultRequest}
}

// Paginate pages iterates over the pages of a ListRecoveryPointsByBackupVaultRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListRecoveryPointsByBackupVault operation.
//		req := client.ListRecoveryPointsByBackupVaultRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListRecoveryPointsByBackupVaultRequest) Paginate(opts ...aws.Option) ListRecoveryPointsByBackupVaultPager {
	return ListRecoveryPointsByBackupVaultPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListRecoveryPointsByBackupVaultInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListRecoveryPointsByBackupVaultPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListRecoveryPointsByBackupVaultPager struct {
	aws.Pager
}

func (p *ListRecoveryPointsByBackupVaultPager) CurrentPage() *ListRecoveryPointsByBackupVaultOutput {
	return p.Pager.CurrentPage().(*ListRecoveryPointsByBackupVaultOutput)
}

const opListRecoveryPointsByResource = "ListRecoveryPointsByResource"

// ListRecoveryPointsByResourceRequest is a API request type for the ListRecoveryPointsByResource API operation.
type ListRecoveryPointsByResourceRequest struct {
	*aws.Request
	Input *ListRecoveryPointsByResourceInput
	Copy  func(*ListRecoveryPointsByResourceInput) ListRecoveryPointsByResourceRequest
}

// Send marshals and sends the ListRecoveryPointsByResource API request.
func (r ListRecoveryPointsByResourceRequest) Send(ctx context.Context) (*ListRecoveryPointsByResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListRecoveryPointsByResourceOutput), nil
}

// ListRecoveryPointsByResourceRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns detailed information about recovery points of the type specified
// by a resource Amazon Resource Name (ARN).
//
//    // Example sending a request using the ListRecoveryPointsByResourceRequest method.
//    req := client.ListRecoveryPointsByResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRecoveryPointsByResource
func (c *Backup) ListRecoveryPointsByResourceRequest(input *ListRecoveryPointsByResourceInput) ListRecoveryPointsByResourceRequest {
	op := &aws.Operation{
		Name:       opListRecoveryPointsByResource,
		HTTPMethod: "GET",
		HTTPPath:   "/resources/{resourceArn}/recovery-points/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListRecoveryPointsByResourceInput{}
	}

	output := &ListRecoveryPointsByResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListRecoveryPointsByResourceRequest{Request: req, Input: input, Copy: c.ListRecoveryPointsByResourceRequest}
}

// Paginate pages iterates over the pages of a ListRecoveryPointsByResourceRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListRecoveryPointsByResource operation.
//		req := client.ListRecoveryPointsByResourceRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListRecoveryPointsByResourceRequest) Paginate(opts ...aws.Option) ListRecoveryPointsByResourcePager {
	return ListRecoveryPointsByResourcePager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListRecoveryPointsByResourceInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListRecoveryPointsByResourcePager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListRecoveryPointsByResourcePager struct {
	aws.Pager
}

func (p *ListRecoveryPointsByResourcePager) CurrentPage() *ListRecoveryPointsByResourceOutput {
	return p.Pager.CurrentPage().(*ListRecoveryPointsByResourceOutput)
}

const opListRestoreJobs = "ListRestoreJobs"

// ListRestoreJobsRequest is a API request type for the ListRestoreJobs API operation.
type ListRestoreJobsRequest struct {
	*aws.Request
	Input *ListRestoreJobsInput
	Copy  func(*ListRestoreJobsInput) ListRestoreJobsRequest
}

// Send marshals and sends the ListRestoreJobs API request.
func (r ListRestoreJobsRequest) Send(ctx context.Context) (*ListRestoreJobsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListRestoreJobsOutput), nil
}

// ListRestoreJobsRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns a list of jobs that AWS Backup initiated to restore a saved resource,
// including metadata about the recovery process.
//
//    // Example sending a request using the ListRestoreJobsRequest method.
//    req := client.ListRestoreJobsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRestoreJobs
func (c *Backup) ListRestoreJobsRequest(input *ListRestoreJobsInput) ListRestoreJobsRequest {
	op := &aws.Operation{
		Name:       opListRestoreJobs,
		HTTPMethod: "GET",
		HTTPPath:   "/restore-jobs/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListRestoreJobsInput{}
	}

	output := &ListRestoreJobsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListRestoreJobsRequest{Request: req, Input: input, Copy: c.ListRestoreJobsRequest}
}

// Paginate pages iterates over the pages of a ListRestoreJobsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListRestoreJobs operation.
//		req := client.ListRestoreJobsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListRestoreJobsRequest) Paginate(opts ...aws.Option) ListRestoreJobsPager {
	return ListRestoreJobsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListRestoreJobsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListRestoreJobsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListRestoreJobsPager struct {
	aws.Pager
}

func (p *ListRestoreJobsPager) CurrentPage() *ListRestoreJobsOutput {
	return p.Pager.CurrentPage().(*ListRestoreJobsOutput)
}

const opListTags = "ListTags"

// ListTagsRequest is a API request type for the ListTags API operation.
type ListTagsRequest struct {
	*aws.Request
	Input *ListTagsInput
	Copy  func(*ListTagsInput) ListTagsRequest
}

// Send marshals and sends the ListTags API request.
func (r ListTagsRequest) Send(ctx context.Context) (*ListTagsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTagsOutput), nil
}

// ListTagsRequest returns a request value for making API operation for
// AWS Backup.
//
// Returns a list of key-value pairs assigned to a target recovery point, backup
// plan, or backup vault.
//
//    // Example sending a request using the ListTagsRequest method.
//    req := client.ListTagsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListTags
func (c *Backup) ListTagsRequest(input *ListTagsInput) ListTagsRequest {
	op := &aws.Operation{
		Name:       opListTags,
		HTTPMethod: "GET",
		HTTPPath:   "/tags/{resourceArn}/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListTagsInput{}
	}

	output := &ListTagsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTagsRequest{Request: req, Input: input, Copy: c.ListTagsRequest}
}

// Paginate pages iterates over the pages of a ListTagsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListTags operation.
//		req := client.ListTagsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListTagsRequest) Paginate(opts ...aws.Option) ListTagsPager {
	return ListTagsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListTagsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListTagsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListTagsPager struct {
	aws.Pager
}

func (p *ListTagsPager) CurrentPage() *ListTagsOutput {
	return p.Pager.CurrentPage().(*ListTagsOutput)
}

const opPutBackupVaultAccessPolicy = "PutBackupVaultAccessPolicy"

// PutBackupVaultAccessPolicyRequest is a API request type for the PutBackupVaultAccessPolicy API operation.
type PutBackupVaultAccessPolicyRequest struct {
	*aws.Request
	Input *PutBackupVaultAccessPolicyInput
	Copy  func(*PutBackupVaultAccessPolicyInput) PutBackupVaultAccessPolicyRequest
}

// Send marshals and sends the PutBackupVaultAccessPolicy API request.
func (r PutBackupVaultAccessPolicyRequest) Send(ctx context.Context) (*PutBackupVaultAccessPolicyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutBackupVaultAccessPolicyOutput), nil
}

// PutBackupVaultAccessPolicyRequest returns a request value for making API operation for
// AWS Backup.
//
// Sets a resource-based policy that is used to manage access permissions on
// the target backup vault. Requires a backup vault name and an access policy
// document in JSON format.
//
//    // Example sending a request using the PutBackupVaultAccessPolicyRequest method.
//    req := client.PutBackupVaultAccessPolicyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/PutBackupVaultAccessPolicy
func (c *Backup) PutBackupVaultAccessPolicyRequest(input *PutBackupVaultAccessPolicyInput) PutBackupVaultAccessPolicyRequest {
	op := &aws.Operation{
		Name:       opPutBackupVaultAccessPolicy,
		HTTPMethod: "PUT",
		HTTPPath:   "/backup-vaults/{backupVaultName}/access-policy",
	}

	if input == nil {
		input = &PutBackupVaultAccessPolicyInput{}
	}

	output := &PutBackupVaultAccessPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return PutBackupVaultAccessPolicyRequest{Request: req, Input: input, Copy: c.PutBackupVaultAccessPolicyRequest}
}

const opPutBackupVaultNotifications = "PutBackupVaultNotifications"

// PutBackupVaultNotificationsRequest is a API request type for the PutBackupVaultNotifications API operation.
type PutBackupVaultNotificationsRequest struct {
	*aws.Request
	Input *PutBackupVaultNotificationsInput
	Copy  func(*PutBackupVaultNotificationsInput) PutBackupVaultNotificationsRequest
}

// Send marshals and sends the PutBackupVaultNotifications API request.
func (r PutBackupVaultNotificationsRequest) Send(ctx context.Context) (*PutBackupVaultNotificationsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutBackupVaultNotificationsOutput), nil
}

// PutBackupVaultNotificationsRequest returns a request value for making API operation for
// AWS Backup.
//
// Turns on notifications on a backup vault for the specified topic and events.
//
//    // Example sending a request using the PutBackupVaultNotificationsRequest method.
//    req := client.PutBackupVaultNotificationsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/PutBackupVaultNotifications
func (c *Backup) PutBackupVaultNotificationsRequest(input *PutBackupVaultNotificationsInput) PutBackupVaultNotificationsRequest {
	op := &aws.Operation{
		Name:       opPutBackupVaultNotifications,
		HTTPMethod: "PUT",
		HTTPPath:   "/backup-vaults/{backupVaultName}/notification-configuration",
	}

	if input == nil {
		input = &PutBackupVaultNotificationsInput{}
	}

	output := &PutBackupVaultNotificationsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return PutBackupVaultNotificationsRequest{Request: req, Input: input, Copy: c.PutBackupVaultNotificationsRequest}
}

const opStartBackupJob = "StartBackupJob"

// StartBackupJobRequest is a API request type for the StartBackupJob API operation.
type StartBackupJobRequest struct {
	*aws.Request
	Input *StartBackupJobInput
	Copy  func(*StartBackupJobInput) StartBackupJobRequest
}

// Send marshals and sends the StartBackupJob API request.
func (r StartBackupJobRequest) Send(ctx context.Context) (*StartBackupJobOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartBackupJobOutput), nil
}

// StartBackupJobRequest returns a request value for making API operation for
// AWS Backup.
//
// Starts a job to create a one-time backup of the specified resource.
//
//    // Example sending a request using the StartBackupJobRequest method.
//    req := client.StartBackupJobRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StartBackupJob
func (c *Backup) StartBackupJobRequest(input *StartBackupJobInput) StartBackupJobRequest {
	op := &aws.Operation{
		Name:       opStartBackupJob,
		HTTPMethod: "PUT",
		HTTPPath:   "/backup-jobs",
	}

	if input == nil {
		input = &StartBackupJobInput{}
	}

	output := &StartBackupJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartBackupJobRequest{Request: req, Input: input, Copy: c.StartBackupJobRequest}
}

const opStartRestoreJob = "StartRestoreJob"

// StartRestoreJobRequest is a API request type for the StartRestoreJob API operation.
type StartRestoreJobRequest struct {
	*aws.Request
	Input *StartRestoreJobInput
	Copy  func(*StartRestoreJobInput) StartRestoreJobRequest
}

// Send marshals and sends the StartRestoreJob API request.
func (r StartRestoreJobRequest) Send(ctx context.Context) (*StartRestoreJobOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartRestoreJobOutput), nil
}

// StartRestoreJobRequest returns a request value for making API operation for
// AWS Backup.
//
// Recovers the saved resource identified by an Amazon Resource Name (ARN).
//
// If the resource ARN is included in the request, then the last complete backup
// of that resource is recovered. If the ARN of a recovery point is supplied,
// then that recovery point is restored.
//
//    // Example sending a request using the StartRestoreJobRequest method.
//    req := client.StartRestoreJobRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StartRestoreJob
func (c *Backup) StartRestoreJobRequest(input *StartRestoreJobInput) StartRestoreJobRequest {
	op := &aws.Operation{
		Name:       opStartRestoreJob,
		HTTPMethod: "PUT",
		HTTPPath:   "/restore-jobs",
	}

	if input == nil {
		input = &StartRestoreJobInput{}
	}

	output := &StartRestoreJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartRestoreJobRequest{Request: req, Input: input, Copy: c.StartRestoreJobRequest}
}

const opStopBackupJob = "StopBackupJob"

// StopBackupJobRequest is a API request type for the StopBackupJob API operation.
type StopBackupJobRequest struct {
	*aws.Request
	Input *StopBackupJobInput
	Copy  func(*StopBackupJobInput) StopBackupJobRequest
}

// Send marshals and sends the StopBackupJob API request.
func (r StopBackupJobRequest) Send(ctx context.Context) (*StopBackupJobOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StopBackupJobOutput), nil
}

// StopBackupJobRequest returns a request value for making API operation for
// AWS Backup.
//
// Attempts to cancel a job to create a one-time backup of a resource.
//
//    // Example sending a request using the StopBackupJobRequest method.
//    req := client.StopBackupJobRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StopBackupJob
func (c *Backup) StopBackupJobRequest(input *StopBackupJobInput) StopBackupJobRequest {
	op := &aws.Operation{
		Name:       opStopBackupJob,
		HTTPMethod: "POST",
		HTTPPath:   "/backup-jobs/{backupJobId}",
	}

	if input == nil {
		input = &StopBackupJobInput{}
	}

	output := &StopBackupJobOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return StopBackupJobRequest{Request: req, Input: input, Copy: c.StopBackupJobRequest}
}

const opTagResource = "TagResource"

// TagResourceRequest is a API request type for the TagResource API operation.
type TagResourceRequest struct {
	*aws.Request
	Input *TagResourceInput
	Copy  func(*TagResourceInput) TagResourceRequest
}

// Send marshals and sends the TagResource API request.
func (r TagResourceRequest) Send(ctx context.Context) (*TagResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TagResourceOutput), nil
}

// TagResourceRequest returns a request value for making API operation for
// AWS Backup.
//
// Assigns a set of key-value pairs to a recovery point, backup plan, or backup
// vault identified by an Amazon Resource Name (ARN).
//
//    // Example sending a request using the TagResourceRequest method.
//    req := client.TagResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/TagResource
func (c *Backup) TagResourceRequest(input *TagResourceInput) TagResourceRequest {
	op := &aws.Operation{
		Name:       opTagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/tags/{resourceArn}",
	}

	if input == nil {
		input = &TagResourceInput{}
	}

	output := &TagResourceOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return TagResourceRequest{Request: req, Input: input, Copy: c.TagResourceRequest}
}

const opUntagResource = "UntagResource"

// UntagResourceRequest is a API request type for the UntagResource API operation.
type UntagResourceRequest struct {
	*aws.Request
	Input *UntagResourceInput
	Copy  func(*UntagResourceInput) UntagResourceRequest
}

// Send marshals and sends the UntagResource API request.
func (r UntagResourceRequest) Send(ctx context.Context) (*UntagResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UntagResourceOutput), nil
}

// UntagResourceRequest returns a request value for making API operation for
// AWS Backup.
//
// Removes a set of key-value pairs from a recovery point, backup plan, or backup
// vault identified by an Amazon Resource Name (ARN)
//
//    // Example sending a request using the UntagResourceRequest method.
//    req := client.UntagResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UntagResource
func (c *Backup) UntagResourceRequest(input *UntagResourceInput) UntagResourceRequest {
	op := &aws.Operation{
		Name:       opUntagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/untag/{resourceArn}",
	}

	if input == nil {
		input = &UntagResourceInput{}
	}

	output := &UntagResourceOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return UntagResourceRequest{Request: req, Input: input, Copy: c.UntagResourceRequest}
}

const opUpdateBackupPlan = "UpdateBackupPlan"

// UpdateBackupPlanRequest is a API request type for the UpdateBackupPlan API operation.
type UpdateBackupPlanRequest struct {
	*aws.Request
	Input *UpdateBackupPlanInput
	Copy  func(*UpdateBackupPlanInput) UpdateBackupPlanRequest
}

// Send marshals and sends the UpdateBackupPlan API request.
func (r UpdateBackupPlanRequest) Send(ctx context.Context) (*UpdateBackupPlanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateBackupPlanOutput), nil
}

// UpdateBackupPlanRequest returns a request value for making API operation for
// AWS Backup.
//
// Replaces the body of a saved backup plan identified by its backupPlanId with
// the input document in JSON format. The new version is uniquely identified
// by a VersionId.
//
//    // Example sending a request using the UpdateBackupPlanRequest method.
//    req := client.UpdateBackupPlanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UpdateBackupPlan
func (c *Backup) UpdateBackupPlanRequest(input *UpdateBackupPlanInput) UpdateBackupPlanRequest {
	op := &aws.Operation{
		Name:       opUpdateBackupPlan,
		HTTPMethod: "POST",
		HTTPPath:   "/backup/plans/{backupPlanId}",
	}

	if input == nil {
		input = &UpdateBackupPlanInput{}
	}

	output := &UpdateBackupPlanOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateBackupPlanRequest{Request: req, Input: input, Copy: c.UpdateBackupPlanRequest}
}

const opUpdateRecoveryPointLifecycle = "UpdateRecoveryPointLifecycle"

// UpdateRecoveryPointLifecycleRequest is a API request type for the UpdateRecoveryPointLifecycle API operation.
type UpdateRecoveryPointLifecycleRequest struct {
	*aws.Request
	Input *UpdateRecoveryPointLifecycleInput
	Copy  func(*UpdateRecoveryPointLifecycleInput) UpdateRecoveryPointLifecycleRequest
}

// Send marshals and sends the UpdateRecoveryPointLifecycle API request.
func (r UpdateRecoveryPointLifecycleRequest) Send(ctx context.Context) (*UpdateRecoveryPointLifecycleOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRecoveryPointLifecycleOutput), nil
}

// UpdateRecoveryPointLifecycleRequest returns a request value for making API operation for
// AWS Backup.
//
// Sets the transition lifecycle of a recovery point.
//
// The lifecycle defines when a protected resource is transitioned to cold storage
// and when it expires. AWS Backup transitions and expires backups automatically
// according to the lifecycle that you define.
//
// Backups transitioned to cold storage must be stored in cold storage for a
// minimum of 90 days. Therefore, the expire after days setting must be 90
// days greater than the transition to cold after days setting. The transition
// to cold after days setting cannot be changed after a backup has been transitioned
// to cold.
//
//    // Example sending a request using the UpdateRecoveryPointLifecycleRequest method.
//    req := client.UpdateRecoveryPointLifecycleRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UpdateRecoveryPointLifecycle
func (c *Backup) UpdateRecoveryPointLifecycleRequest(input *UpdateRecoveryPointLifecycleInput) UpdateRecoveryPointLifecycleRequest {
	op := &aws.Operation{
		Name:       opUpdateRecoveryPointLifecycle,
		HTTPMethod: "POST",
		HTTPPath:   "/backup-vaults/{backupVaultName}/recovery-points/{recoveryPointArn}",
	}

	if input == nil {
		input = &UpdateRecoveryPointLifecycleInput{}
	}

	output := &UpdateRecoveryPointLifecycleOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateRecoveryPointLifecycleRequest{Request: req, Input: input, Copy: c.UpdateRecoveryPointLifecycleRequest}
}

// Contains DeleteAt and MoveToColdStorageAt timestamps, which are used to specify
// a lifecycle for a recovery point.
//
// The lifecycle defines when a protected resource is transitioned to cold storage
// and when it expires. AWS Backup transitions and expires backups automatically
// according to the lifecycle that you define.
//
// Backups transitioned to cold storage must be stored in cold storage for a
// minimum of 90 days. Therefore, the expire after days setting must be 90
// days greater than the transition to cold after days setting. The transition
// to cold after days setting cannot be changed after a backup has been transitioned
// to cold.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CalculatedLifecycle
type CalculatedLifecycle struct {
	_ struct{} `type:"structure"`

	// A timestamp that specifies when to delete a recovery point.
	DeleteAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A timestamp that specifies when to transition a recovery point to cold storage.
	MoveToColdStorageAt *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s CalculatedLifecycle) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CalculatedLifecycle) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CalculatedLifecycle) MarshalFields(e protocol.FieldEncoder) error {
	if s.DeleteAt != nil {
		v := *s.DeleteAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DeleteAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.MoveToColdStorageAt != nil {
		v := *s.MoveToColdStorageAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MoveToColdStorageAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Contains an array of triplets made up of a condition type (such as StringEquals),
// a key, and a value. Conditions are used to filter resources in a selection
// that is assigned to a backup plan.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/Condition
type Condition struct {
	_ struct{} `type:"structure"`

	// The key in a key-value pair. For example, in "ec2:ResourceTag/Department":
	// "accounting", "ec2:ResourceTag/Department" is the key.
	//
	// ConditionKey is a required field
	ConditionKey *string `type:"string" required:"true"`

	// An operation, such as StringEquals, that is applied to a key-value pair used
	// to filter resources in a selection.
	//
	// ConditionType is a required field
	ConditionType ConditionType `type:"string" required:"true" enum:"true"`

	// The value in a key-value pair. For example, in "ec2:ResourceTag/Department":
	// "accounting", "accounting" is the value.
	//
	// ConditionValue is a required field
	ConditionValue *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Condition) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Condition) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Condition) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Condition"}

	if s.ConditionKey == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConditionKey"))
	}
	if len(s.ConditionType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ConditionType"))
	}

	if s.ConditionValue == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConditionValue"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Condition) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConditionKey != nil {
		v := *s.ConditionKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ConditionKey", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ConditionType) > 0 {
		v := s.ConditionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ConditionType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ConditionValue != nil {
		v := *s.ConditionValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ConditionValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupPlanInput
type CreateBackupPlanInput struct {
	_ struct{} `type:"structure"`

	// Specifies the body of a backup plan. Includes a BackupPlanName and one or
	// more sets of Rules.
	//
	// BackupPlan is a required field
	BackupPlan *PlanInput `type:"structure" required:"true"`

	// To help organize your resources, you can assign your own metadata to the
	// resources that you create. Each tag is a key-value pair. The specified tags
	// are assigned to all backups created with this plan.
	BackupPlanTags map[string]string `type:"map"`

	// Identifies the request and allows failed requests to be retried without the
	// risk of executing the operation twice. If the request includes a CreatorRequestId
	// that matches an existing backup plan, that plan is returned. This parameter
	// is optional.
	CreatorRequestId *string `type:"string"`
}

// String returns the string representation
func (s CreateBackupPlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBackupPlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBackupPlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateBackupPlanInput"}

	if s.BackupPlan == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlan"))
	}
	if s.BackupPlan != nil {
		if err := s.BackupPlan.Validate(); err != nil {
			invalidParams.AddNested("BackupPlan", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBackupPlanInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlan != nil {
		v := s.BackupPlan

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackupPlan", v, metadata)
	}
	if len(s.BackupPlanTags) > 0 {
		v := s.BackupPlanTags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "BackupPlanTags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupPlanOutput
type CreateBackupPlanOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for
	// example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
	BackupPlanArn *string `type:"string"`

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// The date and time that a backup plan is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
	// 1024 bytes long. They cannot be edited.
	VersionId *string `type:"string"`
}

// String returns the string representation
func (s CreateBackupPlanOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBackupPlanOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateBackupPlanOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBackupPlanOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanArn != nil {
		v := *s.BackupPlanArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupSelectionInput
type CreateBackupSelectionInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies the backup plan to be associated with the selection of
	// resources.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`

	// Specifies the body of a request to assign a set of resources to a backup
	// plan.
	//
	// It includes an array of resources, an optional array of patterns to exclude
	// resources, an optional role to provide access to the AWS service the resource
	// belongs to, and an optional array of tags used to identify a set of resources.
	//
	// BackupSelection is a required field
	BackupSelection *Selection `type:"structure" required:"true"`

	// A unique string that identifies the request and allows failed requests to
	// be retried without the risk of executing the operation twice.
	CreatorRequestId *string `type:"string"`
}

// String returns the string representation
func (s CreateBackupSelectionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBackupSelectionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBackupSelectionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateBackupSelectionInput"}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}

	if s.BackupSelection == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupSelection"))
	}
	if s.BackupSelection != nil {
		if err := s.BackupSelection.Validate(); err != nil {
			invalidParams.AddNested("BackupSelection", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBackupSelectionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupSelection != nil {
		v := s.BackupSelection

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackupSelection", v, metadata)
	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupSelectionOutput
type CreateBackupSelectionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// The date and time a backup selection is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Uniquely identifies the body of a request to assign a set of resources to
	// a backup plan.
	SelectionId *string `type:"string"`
}

// String returns the string representation
func (s CreateBackupSelectionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBackupSelectionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateBackupSelectionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBackupSelectionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.SelectionId != nil {
		v := *s.SelectionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SelectionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupVaultInput
type CreateBackupVaultInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`

	// Metadata that you can assign to help organize the resources that you create.
	// Each tag is a key-value pair.
	BackupVaultTags map[string]string `type:"map"`

	// A unique string that identifies the request and allows failed requests to
	// be retried without the risk of executing the operation twice.
	CreatorRequestId *string `type:"string"`

	// The server-side encryption key that is used to protect your backups; for
	// example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
	EncryptionKeyArn *string `type:"string"`
}

// String returns the string representation
func (s CreateBackupVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBackupVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBackupVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateBackupVaultInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBackupVaultInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.BackupVaultTags) > 0 {
		v := s.BackupVaultTags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "BackupVaultTags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EncryptionKeyArn != nil {
		v := *s.EncryptionKeyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EncryptionKeyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/CreateBackupVaultOutput
type CreateBackupVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for
	// example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the Region where they are created. They consist of lowercase letters, numbers,
	// and hyphens.
	BackupVaultName *string `type:"string"`

	// The date and time a backup vault is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s CreateBackupVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBackupVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateBackupVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBackupVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupPlanInput
type DeleteBackupPlanInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a backup plan.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBackupPlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupPlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBackupPlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBackupPlanInput"}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupPlanInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupPlanOutput
type DeleteBackupPlanOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for
	// example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
	BackupPlanArn *string `type:"string"`

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// The date and time a backup plan is deleted, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	DeletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
	// 1,024 bytes long. Version Ids cannot be edited.
	VersionId *string `type:"string"`
}

// String returns the string representation
func (s DeleteBackupPlanOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupPlanOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBackupPlanOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupPlanOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanArn != nil {
		v := *s.BackupPlanArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DeletionDate != nil {
		v := *s.DeletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DeletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupSelectionInput
type DeleteBackupSelectionInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a backup plan.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`

	// Uniquely identifies the body of a request to assign a set of resources to
	// a backup plan.
	//
	// SelectionId is a required field
	SelectionId *string `location:"uri" locationName:"selectionId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBackupSelectionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupSelectionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBackupSelectionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBackupSelectionInput"}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}

	if s.SelectionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("SelectionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupSelectionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SelectionId != nil {
		v := *s.SelectionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "selectionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupSelectionOutput
type DeleteBackupSelectionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBackupSelectionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupSelectionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBackupSelectionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupSelectionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVaultAccessPolicyInput
type DeleteBackupVaultAccessPolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBackupVaultAccessPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupVaultAccessPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBackupVaultAccessPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBackupVaultAccessPolicyInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupVaultAccessPolicyInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVaultAccessPolicyOutput
type DeleteBackupVaultAccessPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBackupVaultAccessPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupVaultAccessPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBackupVaultAccessPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupVaultAccessPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVaultInput
type DeleteBackupVaultInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// theAWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBackupVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBackupVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBackupVaultInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupVaultInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVaultNotificationsInput
type DeleteBackupVaultNotificationsInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the Region where they are created. They consist of lowercase letters, numbers,
	// and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBackupVaultNotificationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupVaultNotificationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBackupVaultNotificationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBackupVaultNotificationsInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupVaultNotificationsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVaultNotificationsOutput
type DeleteBackupVaultNotificationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBackupVaultNotificationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupVaultNotificationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBackupVaultNotificationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupVaultNotificationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteBackupVaultOutput
type DeleteBackupVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBackupVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBackupVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBackupVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteRecoveryPointInput
type DeleteRecoveryPointInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`

	// An Amazon Resource Name (ARN) that uniquely identifies a recovery point;
	// for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	//
	// RecoveryPointArn is a required field
	RecoveryPointArn *string `location:"uri" locationName:"recoveryPointArn" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteRecoveryPointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRecoveryPointInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteRecoveryPointInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteRecoveryPointInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if s.RecoveryPointArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RecoveryPointArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRecoveryPointInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "recoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DeleteRecoveryPointOutput
type DeleteRecoveryPointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteRecoveryPointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRecoveryPointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteRecoveryPointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRecoveryPointOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeBackupJobInput
type DescribeBackupJobInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a request to AWS Backup to back up a resource.
	//
	// BackupJobId is a required field
	BackupJobId *string `location:"uri" locationName:"backupJobId" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeBackupJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBackupJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeBackupJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeBackupJobInput"}

	if s.BackupJobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupJobId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeBackupJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupJobId != nil {
		v := *s.BackupJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeBackupJobOutput
type DescribeBackupJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Uniquely identifies a request to AWS Backup to back up a resource.
	BackupJobId *string `type:"string"`

	// The size, in bytes, of a backup.
	BackupSizeInBytes *int64 `type:"long"`

	// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for
	// example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	BackupVaultName *string `type:"string"`

	// The size in bytes transferred to a backup vault at the time that the job
	// status was queried.
	BytesTransferred *int64 `type:"long"`

	// The date and time that a job to create a backup job is completed, in Unix
	// format and Coordinated Universal Time (UTC). The value of CreationDate is
	// accurate to milliseconds. For example, the value 1516925490.087 represents
	// Friday, January 26, 2018 12:11:30.087 AM.
	CompletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Contains identifying information about the creation of a backup job, including
	// the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the
	// backup plan that is used to create it.
	CreatedBy *RecoveryPointCreator `type:"structure"`

	// The date and time that a backup job is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The date and time that a job to back up resources is expected to be completed,
	// in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate
	// is accurate to milliseconds. For example, the value 1516925490.087 represents
	// Friday, January 26, 2018 12:11:30.087 AM.
	ExpectedCompletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Specifies the IAM role ARN used to create the target recovery point; for
	// example, arn:aws:iam::123456789012:role/S3Access.
	IamRoleArn *string `type:"string"`

	// Contains an estimated percentage that is complete of a job at the time the
	// job status was queried.
	PercentDone *string `type:"string"`

	// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`

	// An ARN that uniquely identifies a saved resource. The format of the ARN depends
	// on the resource type.
	ResourceArn *string `type:"string"`

	// The type of AWS resource to be backed-up; for example, an Amazon Elastic
	// Block Store (Amazon EBS) volume or an Amazon Relational Database Service
	// (Amazon RDS) database.
	ResourceType *string `type:"string"`

	// Specifies the time in Unix format and Coordinated Universal Time (UTC) when
	// a backup job must be started before it is canceled. The value is calculated
	// by adding the start window to the scheduled time. So if the scheduled time
	// were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00
	// PM on the date specified. The value of StartBy is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	StartBy *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The current state of a resource recovery point.
	State JobState `type:"string" enum:"true"`

	// A detailed message explaining the status of the job to back up a resource.
	StatusMessage *string `type:"string"`
}

// String returns the string representation
func (s DescribeBackupJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBackupJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeBackupJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeBackupJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupJobId != nil {
		v := *s.BackupJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupSizeInBytes != nil {
		v := *s.BackupSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BytesTransferred != nil {
		v := *s.BytesTransferred

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BytesTransferred", protocol.Int64Value(v), metadata)
	}
	if s.CompletionDate != nil {
		v := *s.CompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedBy != nil {
		v := s.CreatedBy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CreatedBy", v, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ExpectedCompletionDate != nil {
		v := *s.ExpectedCompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpectedCompletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PercentDone != nil {
		v := *s.PercentDone

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PercentDone", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceType != nil {
		v := *s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartBy != nil {
		v := *s.StartBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartBy", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusMessage != nil {
		v := *s.StatusMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StatusMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeBackupVaultInput
type DescribeBackupVaultInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeBackupVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBackupVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeBackupVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeBackupVaultInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeBackupVaultInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeBackupVaultOutput
type DescribeBackupVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for
	// example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the Region where they are created. They consist of lowercase letters, numbers,
	// and hyphens.
	BackupVaultName *string `type:"string"`

	// The date and time that a backup vault is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A unique string that identifies the request and allows failed requests to
	// be retried without the risk of executing the operation twice.
	CreatorRequestId *string `type:"string"`

	// The server-side encryption key that is used to protect your backups; for
	// example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
	EncryptionKeyArn *string `type:"string"`

	// The number of recovery points that are stored in a backup vault.
	NumberOfRecoveryPoints *int64 `type:"long"`
}

// String returns the string representation
func (s DescribeBackupVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBackupVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeBackupVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeBackupVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EncryptionKeyArn != nil {
		v := *s.EncryptionKeyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EncryptionKeyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NumberOfRecoveryPoints != nil {
		v := *s.NumberOfRecoveryPoints

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberOfRecoveryPoints", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeProtectedResourceInput
type DescribeProtectedResourceInput struct {
	_ struct{} `type:"structure"`

	// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format
	// of the ARN depends on the resource type.
	//
	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resourceArn" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeProtectedResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeProtectedResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeProtectedResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeProtectedResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeProtectedResourceInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeProtectedResourceOutput
type DescribeProtectedResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The date and time that a resource was last backed up, in Unix format and
	// Coordinated Universal Time (UTC). The value of LastBackupTime is accurate
	// to milliseconds. For example, the value 1516925490.087 represents Friday,
	// January 26, 2018 12:11:30.087 AM.
	LastBackupTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// An ARN that uniquely identifies a resource. The format of the ARN depends
	// on the resource type.
	ResourceArn *string `type:"string"`

	// The type of AWS resource saved as a recovery point; for example, an EBS volume
	// or an Amazon RDS database.
	ResourceType *string `type:"string"`
}

// String returns the string representation
func (s DescribeProtectedResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeProtectedResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeProtectedResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeProtectedResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.LastBackupTime != nil {
		v := *s.LastBackupTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastBackupTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceType != nil {
		v := *s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeRecoveryPointInput
type DescribeRecoveryPointInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`

	// An Amazon Resource Name (ARN) that uniquely identifies a recovery point;
	// for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	//
	// RecoveryPointArn is a required field
	RecoveryPointArn *string `location:"uri" locationName:"recoveryPointArn" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeRecoveryPointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRecoveryPointInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeRecoveryPointInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeRecoveryPointInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if s.RecoveryPointArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RecoveryPointArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeRecoveryPointInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "recoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeRecoveryPointOutput
type DescribeRecoveryPointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The size, in bytes, of a backup.
	BackupSizeInBytes *int64 `type:"long"`

	// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the Region where they are created. They consist of lowercase letters, numbers,
	// and hyphens.
	BackupVaultName *string `type:"string"`

	// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt
	// timestamps.
	CalculatedLifecycle *CalculatedLifecycle `type:"structure"`

	// The date and time that a job to create a recovery point is completed, in
	// Unix format and Coordinated Universal Time (UTC). The value of CompletionDate
	// is accurate to milliseconds. For example, the value 1516925490.087 represents
	// Friday, January 26, 2018 12:11:30.087 AM.
	CompletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Contains identifying information about the creation of a recovery point,
	// including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId
	// of the backup plan used to create it.
	CreatedBy *RecoveryPointCreator `type:"structure"`

	// The date and time that a recovery point is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The server-side encryption key used to protect your backups; for example,
	// arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
	EncryptionKeyArn *string `type:"string"`

	// Specifies the IAM role ARN used to create the target recovery point; for
	// example, arn:aws:iam::123456789012:role/S3Access.
	IamRoleArn *string `type:"string"`

	// A Boolean value that is returned as TRUE if the specified recovery point
	// is encrypted, or FALSE if the recovery point is not encrypted.
	IsEncrypted *bool `type:"boolean"`

	// The date and time that a recovery point was last restored, in Unix format
	// and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate
	// to milliseconds. For example, the value 1516925490.087 represents Friday,
	// January 26, 2018 12:11:30.087 AM.
	LastRestoreTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The lifecycle defines when a protected resource is transitioned to cold storage
	// and when it expires. AWS Backup transitions and expires backups automatically
	// according to the lifecycle that you define.
	//
	// Backups that are transitioned to cold storage must be stored in cold storage
	// for a minimum of 90 days. Therefore, the expire after days setting must
	// be 90 days greater than the transition to cold after days setting. The
	// transition to cold after days setting cannot be changed after a backup
	// has been transitioned to cold.
	Lifecycle *Lifecycle `type:"structure"`

	// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`

	// An ARN that uniquely identifies a saved resource. The format of the ARN depends
	// on the resource type.
	ResourceArn *string `type:"string"`

	// The type of AWS resource to save as a recovery point; for example, an Amazon
	// Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database
	// Service (Amazon RDS) database.
	ResourceType *string `type:"string"`

	// A status code specifying the state of the recovery point.
	//
	// A partial status indicates that the recovery point was not successfully re-created
	// and must be retried.
	Status RecoveryPointStatus `type:"string" enum:"true"`

	// Specifies the storage class of the recovery point. Valid values are WARM
	// or COLD.
	StorageClass StorageClass `type:"string" enum:"true"`
}

// String returns the string representation
func (s DescribeRecoveryPointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRecoveryPointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeRecoveryPointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeRecoveryPointOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupSizeInBytes != nil {
		v := *s.BackupSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CalculatedLifecycle != nil {
		v := s.CalculatedLifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CalculatedLifecycle", v, metadata)
	}
	if s.CompletionDate != nil {
		v := *s.CompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedBy != nil {
		v := s.CreatedBy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CreatedBy", v, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.EncryptionKeyArn != nil {
		v := *s.EncryptionKeyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EncryptionKeyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IsEncrypted != nil {
		v := *s.IsEncrypted

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsEncrypted", protocol.BoolValue(v), metadata)
	}
	if s.LastRestoreTime != nil {
		v := *s.LastRestoreTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastRestoreTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Lifecycle != nil {
		v := s.Lifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Lifecycle", v, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceType != nil {
		v := *s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeRestoreJobInput
type DescribeRestoreJobInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies the job that restores a recovery point.
	//
	// RestoreJobId is a required field
	RestoreJobId *string `location:"uri" locationName:"restoreJobId" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeRestoreJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRestoreJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeRestoreJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeRestoreJobInput"}

	if s.RestoreJobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestoreJobId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeRestoreJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.RestoreJobId != nil {
		v := *s.RestoreJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restoreJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/DescribeRestoreJobOutput
type DescribeRestoreJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The size, in bytes, of the restored resource.
	BackupSizeInBytes *int64 `type:"long"`

	// The date and time that a job to restore a recovery point is completed, in
	// Unix format and Coordinated Universal Time (UTC). The value of CompletionDate
	// is accurate to milliseconds. For example, the value 1516925490.087 represents
	// Friday, January 26, 2018 12:11:30.087 AM.
	CompletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// An Amazon Resource Name (ARN) that uniquely identifies a resource whose recovery
	// point is being restored. The format of the ARN depends on the resource type
	// of the backed-up resource.
	CreatedResourceArn *string `type:"string"`

	// The date and time that a restore job is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The amount of time in minutes that a job restoring a recovery point is expected
	// to take.
	ExpectedCompletionTimeMinutes *int64 `type:"long"`

	// Specifies the IAM role ARN used to create the target recovery point; for
	// example, arn:aws:iam::123456789012:role/S3Access.
	IamRoleArn *string `type:"string"`

	// Contains an estimated percentage that is complete of a job at the time the
	// job status was queried.
	PercentDone *string `type:"string"`

	// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`

	// Uniquely identifies the job that restores a recovery point.
	RestoreJobId *string `type:"string"`

	// Status code specifying the state of the job that is initiated by AWS Backup
	// to restore a recovery point.
	Status RestoreJobStatus `type:"string" enum:"true"`

	// A detailed message explaining the status of a job to restore a recovery point.
	StatusMessage *string `type:"string"`
}

// String returns the string representation
func (s DescribeRestoreJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRestoreJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeRestoreJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeRestoreJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupSizeInBytes != nil {
		v := *s.BackupSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.CompletionDate != nil {
		v := *s.CompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedResourceArn != nil {
		v := *s.CreatedResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ExpectedCompletionTimeMinutes != nil {
		v := *s.ExpectedCompletionTimeMinutes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpectedCompletionTimeMinutes", protocol.Int64Value(v), metadata)
	}
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PercentDone != nil {
		v := *s.PercentDone

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PercentDone", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestoreJobId != nil {
		v := *s.RestoreJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RestoreJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusMessage != nil {
		v := *s.StatusMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StatusMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ExportBackupPlanTemplateInput
type ExportBackupPlanTemplateInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a backup plan.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`
}

// String returns the string representation
func (s ExportBackupPlanTemplateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ExportBackupPlanTemplateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ExportBackupPlanTemplateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ExportBackupPlanTemplateInput"}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ExportBackupPlanTemplateInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ExportBackupPlanTemplateOutput
type ExportBackupPlanTemplateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The body of a backup plan template in JSON format.
	//
	// This is a signed JSON document that cannot be modified before being passed
	// to GetBackupPlanFromJSON.
	BackupPlanTemplateJson *string `type:"string"`
}

// String returns the string representation
func (s ExportBackupPlanTemplateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ExportBackupPlanTemplateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ExportBackupPlanTemplateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ExportBackupPlanTemplateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanTemplateJson != nil {
		v := *s.BackupPlanTemplateJson

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanTemplateJson", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlanFromJSONInput
type GetBackupPlanFromJSONInput struct {
	_ struct{} `type:"structure"`

	// A customer-supplied backup plan document in JSON format.
	//
	// BackupPlanTemplateJson is a required field
	BackupPlanTemplateJson *string `type:"string" required:"true"`
}

// String returns the string representation
func (s GetBackupPlanFromJSONInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupPlanFromJSONInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBackupPlanFromJSONInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBackupPlanFromJSONInput"}

	if s.BackupPlanTemplateJson == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanTemplateJson"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupPlanFromJSONInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanTemplateJson != nil {
		v := *s.BackupPlanTemplateJson

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanTemplateJson", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlanFromJSONOutput
type GetBackupPlanFromJSONOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Specifies the body of a backup plan. Includes a BackupPlanName and one or
	// more sets of Rules.
	BackupPlan *Plan `type:"structure"`
}

// String returns the string representation
func (s GetBackupPlanFromJSONOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupPlanFromJSONOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBackupPlanFromJSONOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupPlanFromJSONOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlan != nil {
		v := s.BackupPlan

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackupPlan", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlanFromTemplateInput
type GetBackupPlanFromTemplateInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a stored backup plan template.
	//
	// BackupPlanTemplateId is a required field
	BackupPlanTemplateId *string `location:"uri" locationName:"templateId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBackupPlanFromTemplateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupPlanFromTemplateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBackupPlanFromTemplateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBackupPlanFromTemplateInput"}

	if s.BackupPlanTemplateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanTemplateId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupPlanFromTemplateInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanTemplateId != nil {
		v := *s.BackupPlanTemplateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "templateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlanFromTemplateOutput
type GetBackupPlanFromTemplateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Returns the body of a backup plan based on the target template, including
	// the name, rules, and backup vault of the plan.
	BackupPlanDocument *Plan `type:"structure"`
}

// String returns the string representation
func (s GetBackupPlanFromTemplateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupPlanFromTemplateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBackupPlanFromTemplateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupPlanFromTemplateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanDocument != nil {
		v := s.BackupPlanDocument

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackupPlanDocument", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlanInput
type GetBackupPlanInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a backup plan.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`

	// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
	// 1,024 bytes long. Version IDs cannot be edited.
	VersionId *string `location:"querystring" locationName:"versionId" type:"string"`
}

// String returns the string representation
func (s GetBackupPlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupPlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBackupPlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBackupPlanInput"}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupPlanInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "versionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupPlanOutput
type GetBackupPlanOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Specifies the body of a backup plan. Includes a BackupPlanName and one or
	// more sets of Rules.
	BackupPlan *Plan `type:"structure"`

	// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for
	// example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
	BackupPlanArn *string `type:"string"`

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// The date and time that a backup plan is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A unique string that identifies the request and allows failed requests to
	// be retried without the risk of executing the operation twice.
	CreatorRequestId *string `type:"string"`

	// The date and time that a backup plan is deleted, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	DeletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The last time a job to back up resources was executed with this backup plan.
	// A date and time, in Unix format and Coordinated Universal Time (UTC). The
	// value of LastExecutionDate is accurate to milliseconds. For example, the
	// value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
	LastExecutionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
	// 1,024 bytes long. Version IDs cannot be edited.
	VersionId *string `type:"string"`
}

// String returns the string representation
func (s GetBackupPlanOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupPlanOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBackupPlanOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupPlanOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlan != nil {
		v := s.BackupPlan

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackupPlan", v, metadata)
	}
	if s.BackupPlanArn != nil {
		v := *s.BackupPlanArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DeletionDate != nil {
		v := *s.DeletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DeletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.LastExecutionDate != nil {
		v := *s.LastExecutionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastExecutionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupSelectionInput
type GetBackupSelectionInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a backup plan.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`

	// Uniquely identifies the body of a request to assign a set of resources to
	// a backup plan.
	//
	// SelectionId is a required field
	SelectionId *string `location:"uri" locationName:"selectionId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBackupSelectionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupSelectionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBackupSelectionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBackupSelectionInput"}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}

	if s.SelectionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("SelectionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupSelectionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SelectionId != nil {
		v := *s.SelectionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "selectionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupSelectionOutput
type GetBackupSelectionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// Specifies the body of a request to assign a set of resources to a backup
	// plan.
	//
	// It includes an array of resources, an optional array of patterns to exclude
	// resources, an optional role to provide access to the AWS service that the
	// resource belongs to, and an optional array of tags used to identify a set
	// of resources.
	BackupSelection *Selection `type:"structure"`

	// The date and time a backup selection is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A unique string that identifies the request and allows failed requests to
	// be retried without the risk of executing the operation twice.
	CreatorRequestId *string `type:"string"`

	// Uniquely identifies the body of a request to assign a set of resources to
	// a backup plan.
	SelectionId *string `type:"string"`
}

// String returns the string representation
func (s GetBackupSelectionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupSelectionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBackupSelectionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupSelectionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupSelection != nil {
		v := s.BackupSelection

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackupSelection", v, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SelectionId != nil {
		v := *s.SelectionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SelectionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupVaultAccessPolicyInput
type GetBackupVaultAccessPolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBackupVaultAccessPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupVaultAccessPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBackupVaultAccessPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBackupVaultAccessPolicyInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupVaultAccessPolicyInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupVaultAccessPolicyOutput
type GetBackupVaultAccessPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for
	// example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the Region where they are created. They consist of lowercase letters, numbers,
	// and hyphens.
	BackupVaultName *string `type:"string"`

	// The backup vault access policy document in JSON format.
	Policy *string `type:"string"`
}

// String returns the string representation
func (s GetBackupVaultAccessPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupVaultAccessPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBackupVaultAccessPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupVaultAccessPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Policy != nil {
		v := *s.Policy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupVaultNotificationsInput
type GetBackupVaultNotificationsInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBackupVaultNotificationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupVaultNotificationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBackupVaultNotificationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBackupVaultNotificationsInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupVaultNotificationsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetBackupVaultNotificationsOutput
type GetBackupVaultNotificationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for
	// example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// An array of events that indicate the status of jobs to back up resources
	// to the backup vault.
	BackupVaultEvents []VaultEvent `type:"list"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the Region where they are created. They consist of lowercase letters, numbers,
	// and hyphens.
	BackupVaultName *string `type:"string"`

	// An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon
	// SNS) topic; for example, arn:aws:sns:us-west-2:111122223333:MyTopic.
	SNSTopicArn *string `type:"string"`
}

// String returns the string representation
func (s GetBackupVaultNotificationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBackupVaultNotificationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBackupVaultNotificationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBackupVaultNotificationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.BackupVaultEvents) > 0 {
		v := s.BackupVaultEvents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BackupVaultEvents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SNSTopicArn != nil {
		v := *s.SNSTopicArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SNSTopicArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetRecoveryPointRestoreMetadataInput
type GetRecoveryPointRestoreMetadataInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`

	// An Amazon Resource Name (ARN) that uniquely identifies a recovery point;
	// for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	//
	// RecoveryPointArn is a required field
	RecoveryPointArn *string `location:"uri" locationName:"recoveryPointArn" type:"string" required:"true"`
}

// String returns the string representation
func (s GetRecoveryPointRestoreMetadataInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRecoveryPointRestoreMetadataInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetRecoveryPointRestoreMetadataInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetRecoveryPointRestoreMetadataInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if s.RecoveryPointArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RecoveryPointArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRecoveryPointRestoreMetadataInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "recoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetRecoveryPointRestoreMetadataOutput
type GetRecoveryPointRestoreMetadataOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`

	// A set of metadata key-value pairs that lists the metadata key-value pairs
	// that are required to restore the recovery point.
	RestoreMetadata map[string]string `type:"map"`
}

// String returns the string representation
func (s GetRecoveryPointRestoreMetadataOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRecoveryPointRestoreMetadataOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetRecoveryPointRestoreMetadataOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRecoveryPointRestoreMetadataOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RestoreMetadata) > 0 {
		v := s.RestoreMetadata

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "RestoreMetadata", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetSupportedResourceTypesInput
type GetSupportedResourceTypesInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetSupportedResourceTypesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSupportedResourceTypesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSupportedResourceTypesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/GetSupportedResourceTypesOutput
type GetSupportedResourceTypesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Contains a string with the supported AWS resource types:
	//
	//    * EBS for Amazon Elastic Block Store
	//
	//    * SGW for AWS Storage Gateway
	//
	//    * RDS for Amazon Relational Database Service
	//
	//    * DDB for Amazon DynamoDB
	//
	//    * EFS for Amazon Elastic File System
	ResourceTypes []string `type:"list"`
}

// String returns the string representation
func (s GetSupportedResourceTypesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSupportedResourceTypesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSupportedResourceTypesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSupportedResourceTypesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ResourceTypes) > 0 {
		v := s.ResourceTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Contains detailed information about a backup job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupJob
type Job struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a request to AWS Backup to back up a resource.
	BackupJobId *string `type:"string"`

	// The size, in bytes, of a backup.
	BackupSizeInBytes *int64 `type:"long"`

	// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for
	// example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	BackupVaultName *string `type:"string"`

	// The size in bytes transferred to a backup vault at the time that the job
	// status was queried.
	BytesTransferred *int64 `type:"long"`

	// The date and time a job to create a backup job is completed, in Unix format
	// and Coordinated Universal Time (UTC). The value of CompletionDate is accurate
	// to milliseconds. For example, the value 1516925490.087 represents Friday,
	// January 26, 2018 12:11:30.087 AM.
	CompletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Contains identifying information about the creation of a backup job, including
	// the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the
	// backup plan used to create it.
	CreatedBy *RecoveryPointCreator `type:"structure"`

	// The date and time a backup job is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The date and time a job to back up resources is expected to be completed,
	// in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate
	// is accurate to milliseconds. For example, the value 1516925490.087 represents
	// Friday, January 26, 2018 12:11:30.087 AM.
	ExpectedCompletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Specifies the IAM role ARN used to create the target recovery point; for
	// example, arn:aws:iam::123456789012:role/S3Access.
	IamRoleArn *string `type:"string"`

	// Contains an estimated percentage complete of a job at the time the job status
	// was queried.
	PercentDone *string `type:"string"`

	// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`

	// An ARN that uniquely identifies a resource. The format of the ARN depends
	// on the resource type.
	ResourceArn *string `type:"string"`

	// The type of AWS resource to be backed-up; for example, an Amazon Elastic
	// Block Store (Amazon EBS) volume or an Amazon Relational Database Service
	// (Amazon RDS) database.
	ResourceType *string `type:"string"`

	// Specifies the time in Unix format and Coordinated Universal Time (UTC) when
	// a backup job must be started before it is canceled. The value is calculated
	// by adding the start window to the scheduled time. So if the scheduled time
	// were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00
	// PM on the date specified. The value of StartBy is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	StartBy *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The current state of a resource recovery point.
	State JobState `type:"string" enum:"true"`

	// A detailed message explaining the status of the job to back up a resource.
	StatusMessage *string `type:"string"`
}

// String returns the string representation
func (s Job) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Job) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Job) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupJobId != nil {
		v := *s.BackupJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupSizeInBytes != nil {
		v := *s.BackupSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BytesTransferred != nil {
		v := *s.BytesTransferred

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BytesTransferred", protocol.Int64Value(v), metadata)
	}
	if s.CompletionDate != nil {
		v := *s.CompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedBy != nil {
		v := s.CreatedBy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CreatedBy", v, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ExpectedCompletionDate != nil {
		v := *s.ExpectedCompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpectedCompletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PercentDone != nil {
		v := *s.PercentDone

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PercentDone", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceType != nil {
		v := *s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartBy != nil {
		v := *s.StartBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartBy", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusMessage != nil {
		v := *s.StatusMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StatusMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains an array of Transition objects specifying how long in days before
// a recovery point transitions to cold storage or is deleted.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/Lifecycle
type Lifecycle struct {
	_ struct{} `type:"structure"`

	// Specifies the number of days after creation that a recovery point is deleted.
	// Must be greater than MoveToColdStorageAfterDays.
	DeleteAfterDays *int64 `type:"long"`

	// Specifies the number of days after creation that a recovery point is moved
	// to cold storage.
	MoveToColdStorageAfterDays *int64 `type:"long"`
}

// String returns the string representation
func (s Lifecycle) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Lifecycle) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Lifecycle) MarshalFields(e protocol.FieldEncoder) error {
	if s.DeleteAfterDays != nil {
		v := *s.DeleteAfterDays

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DeleteAfterDays", protocol.Int64Value(v), metadata)
	}
	if s.MoveToColdStorageAfterDays != nil {
		v := *s.MoveToColdStorageAfterDays

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MoveToColdStorageAfterDays", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupJobsInput
type ListBackupJobsInput struct {
	_ struct{} `type:"structure"`

	// Returns only backup jobs that will be stored in the specified backup vault.
	// Backup vaults are identified by names that are unique to the account used
	// to create them and the AWS Region where they are created. They consist of
	// lowercase letters, numbers, and hyphens.
	ByBackupVaultName *string `location:"querystring" locationName:"backupVaultName" type:"string"`

	// Returns only backup jobs that were created after the specified date.
	ByCreatedAfter *time.Time `location:"querystring" locationName:"createdAfter" type:"timestamp" timestampFormat:"unix"`

	// Returns only backup jobs that were created before the specified date.
	ByCreatedBefore *time.Time `location:"querystring" locationName:"createdBefore" type:"timestamp" timestampFormat:"unix"`

	// Returns only backup jobs that match the specified resource Amazon Resource
	// Name (ARN).
	ByResourceArn *string `location:"querystring" locationName:"resourceArn" type:"string"`

	// Returns only backup jobs for the specified resources:
	//
	//    * EBS for Amazon Elastic Block Store
	//
	//    * SGW for AWS Storage Gateway
	//
	//    * RDS for Amazon Relational Database Service
	//
	//    * DDB for Amazon DynamoDB
	//
	//    * EFS for Amazon Elastic File System
	ByResourceType *string `location:"querystring" locationName:"resourceType" type:"string"`

	// Returns only backup jobs that are in the specified state.
	ByState JobState `location:"querystring" locationName:"state" type:"string" enum:"true"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBackupJobsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupJobsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBackupJobsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBackupJobsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupJobsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ByBackupVaultName != nil {
		v := *s.ByBackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ByCreatedAfter != nil {
		v := *s.ByCreatedAfter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "createdAfter", protocol.TimeValue{V: v, Format: protocol.RFC822TimeFromat}, metadata)
	}
	if s.ByCreatedBefore != nil {
		v := *s.ByCreatedBefore

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "createdBefore", protocol.TimeValue{V: v, Format: protocol.RFC822TimeFromat}, metadata)
	}
	if s.ByResourceArn != nil {
		v := *s.ByResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "resourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ByResourceType != nil {
		v := *s.ByResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "resourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ByState) > 0 {
		v := s.ByState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "state", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupJobsOutput
type ListBackupJobsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of structures containing metadata about your backup jobs returned
	// in JSON format.
	BackupJobs []Job `type:"list"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListBackupJobsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupJobsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBackupJobsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupJobsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BackupJobs) > 0 {
		v := s.BackupJobs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BackupJobs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlanTemplatesInput
type ListBackupPlanTemplatesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBackupPlanTemplatesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupPlanTemplatesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBackupPlanTemplatesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBackupPlanTemplatesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupPlanTemplatesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlanTemplatesOutput
type ListBackupPlanTemplatesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of template list items containing metadata about your saved templates.
	BackupPlanTemplatesList []PlanTemplatesListMember `type:"list"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListBackupPlanTemplatesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupPlanTemplatesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBackupPlanTemplatesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupPlanTemplatesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BackupPlanTemplatesList) > 0 {
		v := s.BackupPlanTemplatesList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BackupPlanTemplatesList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlanVersionsInput
type ListBackupPlanVersionsInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a backup plan.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBackupPlanVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupPlanVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBackupPlanVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBackupPlanVersionsInput"}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupPlanVersionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlanVersionsOutput
type ListBackupPlanVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of version list items containing metadata about your backup plans.
	BackupPlanVersionsList []PlansListMember `type:"list"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListBackupPlanVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupPlanVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBackupPlanVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupPlanVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BackupPlanVersionsList) > 0 {
		v := s.BackupPlanVersionsList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BackupPlanVersionsList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlansInput
type ListBackupPlansInput struct {
	_ struct{} `type:"structure"`

	// A Boolean value with a default value of FALSE that returns deleted backup
	// plans when set to TRUE.
	IncludeDeleted *bool `location:"querystring" locationName:"includeDeleted" type:"boolean"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBackupPlansInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupPlansInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBackupPlansInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBackupPlansInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupPlansInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.IncludeDeleted != nil {
		v := *s.IncludeDeleted

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "includeDeleted", protocol.BoolValue(v), metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupPlansOutput
type ListBackupPlansOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of backup plan list items containing metadata about your saved backup
	// plans.
	BackupPlansList []PlansListMember `type:"list"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListBackupPlansOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupPlansOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBackupPlansOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupPlansOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BackupPlansList) > 0 {
		v := s.BackupPlansList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BackupPlansList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupSelectionsInput
type ListBackupSelectionsInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a backup plan.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBackupSelectionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupSelectionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBackupSelectionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBackupSelectionsInput"}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupSelectionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupSelectionsOutput
type ListBackupSelectionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of backup selection list items containing metadata about each resource
	// in the list.
	BackupSelectionsList []SelectionsListMember `type:"list"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListBackupSelectionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupSelectionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBackupSelectionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupSelectionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BackupSelectionsList) > 0 {
		v := s.BackupSelectionsList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BackupSelectionsList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupVaultsInput
type ListBackupVaultsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBackupVaultsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupVaultsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBackupVaultsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBackupVaultsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupVaultsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListBackupVaultsOutput
type ListBackupVaultsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An array of backup vault list members containing vault metadata, including
	// Amazon Resource Name (ARN), display name, creation date, number of saved
	// recovery points, and encryption information if the resources saved in the
	// backup vault are encrypted.
	BackupVaultList []VaultListMember `type:"list"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListBackupVaultsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupVaultsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBackupVaultsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBackupVaultsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BackupVaultList) > 0 {
		v := s.BackupVaultList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BackupVaultList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListProtectedResourcesInput
type ListProtectedResourcesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListProtectedResourcesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListProtectedResourcesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListProtectedResourcesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListProtectedResourcesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListProtectedResourcesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListProtectedResourcesOutput
type ListProtectedResourcesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`

	// An array of resources successfully backed up by AWS Backup including the
	// time the resource was saved, an Amazon Resource Name (ARN) of the resource,
	// and a resource type.
	Results []ProtectedResource `type:"list"`
}

// String returns the string representation
func (s ListProtectedResourcesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListProtectedResourcesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListProtectedResourcesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListProtectedResourcesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Results) > 0 {
		v := s.Results

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Results", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRecoveryPointsByBackupVaultInput
type ListRecoveryPointsByBackupVaultInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`

	// Returns only recovery points that match the specified backup plan ID.
	ByBackupPlanId *string `location:"querystring" locationName:"backupPlanId" type:"string"`

	// Returns only recovery points that were created after the specified timestamp.
	ByCreatedAfter *time.Time `location:"querystring" locationName:"createdAfter" type:"timestamp" timestampFormat:"unix"`

	// Returns only recovery points that were created before the specified timestamp.
	ByCreatedBefore *time.Time `location:"querystring" locationName:"createdBefore" type:"timestamp" timestampFormat:"unix"`

	// Returns only recovery points that match the specified resource Amazon Resource
	// Name (ARN).
	ByResourceArn *string `location:"querystring" locationName:"resourceArn" type:"string"`

	// Returns only recovery points that match the specified resource type.
	ByResourceType *string `location:"querystring" locationName:"resourceType" type:"string"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListRecoveryPointsByBackupVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRecoveryPointsByBackupVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListRecoveryPointsByBackupVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListRecoveryPointsByBackupVaultInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListRecoveryPointsByBackupVaultInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ByBackupPlanId != nil {
		v := *s.ByBackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ByCreatedAfter != nil {
		v := *s.ByCreatedAfter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "createdAfter", protocol.TimeValue{V: v, Format: protocol.RFC822TimeFromat}, metadata)
	}
	if s.ByCreatedBefore != nil {
		v := *s.ByCreatedBefore

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "createdBefore", protocol.TimeValue{V: v, Format: protocol.RFC822TimeFromat}, metadata)
	}
	if s.ByResourceArn != nil {
		v := *s.ByResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "resourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ByResourceType != nil {
		v := *s.ByResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "resourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRecoveryPointsByBackupVaultOutput
type ListRecoveryPointsByBackupVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`

	// An array of objects that contain detailed information about recovery points
	// saved in a backup vault.
	RecoveryPoints []RecoveryPointByBackupVault `type:"list"`
}

// String returns the string representation
func (s ListRecoveryPointsByBackupVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRecoveryPointsByBackupVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListRecoveryPointsByBackupVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListRecoveryPointsByBackupVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RecoveryPoints) > 0 {
		v := s.RecoveryPoints

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RecoveryPoints", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRecoveryPointsByResourceInput
type ListRecoveryPointsByResourceInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// An ARN that uniquely identifies a resource. The format of the ARN depends
	// on the resource type.
	//
	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resourceArn" type:"string" required:"true"`
}

// String returns the string representation
func (s ListRecoveryPointsByResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRecoveryPointsByResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListRecoveryPointsByResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListRecoveryPointsByResourceInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListRecoveryPointsByResourceInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRecoveryPointsByResourceOutput
type ListRecoveryPointsByResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`

	// An array of objects that contain detailed information about recovery points
	// of the specified resource type.
	RecoveryPoints []RecoveryPointByResource `type:"list"`
}

// String returns the string representation
func (s ListRecoveryPointsByResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRecoveryPointsByResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListRecoveryPointsByResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListRecoveryPointsByResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RecoveryPoints) > 0 {
		v := s.RecoveryPoints

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RecoveryPoints", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRestoreJobsInput
type ListRestoreJobsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListRestoreJobsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRestoreJobsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListRestoreJobsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListRestoreJobsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListRestoreJobsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListRestoreJobsOutput
type ListRestoreJobsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`

	// An array of objects that contain detailed information about jobs to restore
	// saved resources.
	RestoreJobs []RestoreJobsListMember `type:"list"`
}

// String returns the string representation
func (s ListRestoreJobsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRestoreJobsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListRestoreJobsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListRestoreJobsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RestoreJobs) > 0 {
		v := s.RestoreJobs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RestoreJobs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListTagsInput
type ListTagsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of items to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format
	// of the ARN depends on the type of resource. Valid targets for ListTags are
	// recovery points, backup plans, and backup vaults.
	//
	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resourceArn" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTagsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ListTagsOutput
type ListTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The next item following a partial list of returned items. For example, if
	// a request is made to return maxResults number of items, NextToken allows
	// you to return more items in your list starting at the location pointed to
	// by the next token.
	NextToken *string `type:"string"`

	// To help organize your resources, you can assign your own metadata to the
	// resources you create. Each tag is a key-value pair.
	Tags map[string]string `type:"map"`
}

// String returns the string representation
func (s ListTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Contains an optional backup plan display name and an array of BackupRule
// objects, each of which specifies a backup rule. Each rule in a backup plan
// is a separate scheduled task and can back up a different selection of AWS
// resources.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupPlan
type Plan struct {
	_ struct{} `type:"structure"`

	// The display name of a backup plan.
	//
	// BackupPlanName is a required field
	BackupPlanName *string `type:"string" required:"true"`

	// An array of BackupRule objects, each of which specifies a scheduled task
	// that is used to back up a selection of resources.
	//
	// Rules is a required field
	Rules []Rule `type:"list" required:"true"`
}

// String returns the string representation
func (s Plan) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Plan) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Plan) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanName != nil {
		v := *s.BackupPlanName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Rules) > 0 {
		v := s.Rules

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Rules", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Contains an optional backup plan display name and an array of BackupRule
// objects, each of which specifies a backup rule. Each rule in a backup plan
// is a separate scheduled task and can back up a different selection of AWS
// resources.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupPlanInput
type PlanInput struct {
	_ struct{} `type:"structure"`

	// The display name of a backup plan.
	//
	// BackupPlanName is a required field
	BackupPlanName *string `type:"string" required:"true"`

	// An array of BackupRule objects, each of which specifies a scheduled task
	// that is used to back up a selection of resources.
	//
	// Rules is a required field
	Rules []RuleInput `type:"list" required:"true"`
}

// String returns the string representation
func (s PlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PlanInput"}

	if s.BackupPlanName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanName"))
	}

	if s.Rules == nil {
		invalidParams.Add(aws.NewErrParamRequired("Rules"))
	}
	if s.Rules != nil {
		for i, v := range s.Rules {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Rules", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PlanInput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanName != nil {
		v := *s.BackupPlanName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Rules) > 0 {
		v := s.Rules

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Rules", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// An object specifying metadata associated with a backup plan template.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupPlanTemplatesListMember
type PlanTemplatesListMember struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a stored backup plan template.
	BackupPlanTemplateId *string `type:"string"`

	// The optional display name of a backup plan template.
	BackupPlanTemplateName *string `type:"string"`
}

// String returns the string representation
func (s PlanTemplatesListMember) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PlanTemplatesListMember) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PlanTemplatesListMember) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanTemplateId != nil {
		v := *s.BackupPlanTemplateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanTemplateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanTemplateName != nil {
		v := *s.BackupPlanTemplateName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanTemplateName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains metadata about a backup plan.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupPlansListMember
type PlansListMember struct {
	_ struct{} `type:"structure"`

	// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for
	// example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
	BackupPlanArn *string `type:"string"`

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// The display name of a saved backup plan.
	BackupPlanName *string `type:"string"`

	// The date and time a resource backup plan is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A unique string that identifies the request and allows failed requests to
	// be retried without the risk of executing the operation twice.
	CreatorRequestId *string `type:"string"`

	// The date and time a backup plan is deleted, in Unix format and Coordinated
	// Universal Time (UTC). The value of DeletionDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	DeletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The last time a job to back up resources was executed with this rule. A date
	// and time, in Unix format and Coordinated Universal Time (UTC). The value
	// of LastExecutionDate is accurate to milliseconds. For example, the value
	// 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
	LastExecutionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
	// 1,024 bytes long. Version IDs cannot be edited.
	VersionId *string `type:"string"`
}

// String returns the string representation
func (s PlansListMember) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PlansListMember) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PlansListMember) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanArn != nil {
		v := *s.BackupPlanArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanName != nil {
		v := *s.BackupPlanName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DeletionDate != nil {
		v := *s.DeletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DeletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.LastExecutionDate != nil {
		v := *s.LastExecutionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastExecutionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A structure that contains information about a backed-up resource.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/ProtectedResource
type ProtectedResource struct {
	_ struct{} `type:"structure"`

	// The date and time a resource was last backed up, in Unix format and Coordinated
	// Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	LastBackupTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format
	// of the ARN depends on the resource type.
	ResourceArn *string `type:"string"`

	// The type of AWS resource; for example, an Amazon Elastic Block Store (Amazon
	// EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
	ResourceType *string `type:"string"`
}

// String returns the string representation
func (s ProtectedResource) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ProtectedResource) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ProtectedResource) MarshalFields(e protocol.FieldEncoder) error {
	if s.LastBackupTime != nil {
		v := *s.LastBackupTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastBackupTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceType != nil {
		v := *s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/PutBackupVaultAccessPolicyInput
type PutBackupVaultAccessPolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`

	// The backup vault access policy document in JSON format.
	Policy *string `type:"string"`
}

// String returns the string representation
func (s PutBackupVaultAccessPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutBackupVaultAccessPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutBackupVaultAccessPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutBackupVaultAccessPolicyInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutBackupVaultAccessPolicyInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Policy != nil {
		v := *s.Policy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/PutBackupVaultAccessPolicyOutput
type PutBackupVaultAccessPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s PutBackupVaultAccessPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutBackupVaultAccessPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutBackupVaultAccessPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutBackupVaultAccessPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/PutBackupVaultNotificationsInput
type PutBackupVaultNotificationsInput struct {
	_ struct{} `type:"structure"`

	// An array of events that indicate the status of jobs to back up resources
	// to the backup vault.
	//
	// BackupVaultEvents is a required field
	BackupVaultEvents []VaultEvent `type:"list" required:"true"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) that specifies the topic for a backup vaults
	// events; for example, arn:aws:sns:us-west-2:111122223333:MyVaultTopic.
	//
	// SNSTopicArn is a required field
	SNSTopicArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s PutBackupVaultNotificationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutBackupVaultNotificationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutBackupVaultNotificationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutBackupVaultNotificationsInput"}

	if s.BackupVaultEvents == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultEvents"))
	}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if s.SNSTopicArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SNSTopicArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutBackupVaultNotificationsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.BackupVaultEvents) > 0 {
		v := s.BackupVaultEvents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "BackupVaultEvents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.SNSTopicArn != nil {
		v := *s.SNSTopicArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SNSTopicArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/PutBackupVaultNotificationsOutput
type PutBackupVaultNotificationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s PutBackupVaultNotificationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutBackupVaultNotificationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutBackupVaultNotificationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutBackupVaultNotificationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Contains detailed information about the recovery points stored in a backup
// vault.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/RecoveryPointByBackupVault
type RecoveryPointByBackupVault struct {
	_ struct{} `type:"structure"`

	// The size, in bytes, of a backup.
	BackupSizeInBytes *int64 `type:"long"`

	// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	BackupVaultName *string `type:"string"`

	// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt
	// timestamps.
	CalculatedLifecycle *CalculatedLifecycle `type:"structure"`

	// The date and time a job to restore a recovery point is completed, in Unix
	// format and Coordinated Universal Time (UTC). The value of CompletionDate
	// is accurate to milliseconds. For example, the value 1516925490.087 represents
	// Friday, January 26, 2018 12:11:30.087 AM.
	CompletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Contains identifying information about the creation of a recovery point,
	// including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId
	// of the backup plan that is used to create it.
	CreatedBy *RecoveryPointCreator `type:"structure"`

	// The date and time a recovery point is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The server-side encryption key that is used to protect your backups; for
	// example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
	EncryptionKeyArn *string `type:"string"`

	// Specifies the IAM role ARN used to create the target recovery point; for
	// example, arn:aws:iam::123456789012:role/S3Access.
	IamRoleArn *string `type:"string"`

	// A Boolean value that is returned as TRUE if the specified recovery point
	// is encrypted, or FALSE if the recovery point is not encrypted.
	IsEncrypted *bool `type:"boolean"`

	// The date and time a recovery point was last restored, in Unix format and
	// Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate
	// to milliseconds. For example, the value 1516925490.087 represents Friday,
	// January 26, 2018 12:11:30.087 AM.
	LastRestoreTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The lifecycle defines when a protected resource is transitioned to cold storage
	// and when it expires. AWS Backup transitions and expires backups automatically
	// according to the lifecycle that you define.
	//
	// Backups transitioned to cold storage must be stored in cold storage for a
	// minimum of 90 days. Therefore, the expire after days setting must be 90
	// days greater than the transition to cold after days setting. The transition
	// to cold after days setting cannot be changed after a backup has been transitioned
	// to cold.
	Lifecycle *Lifecycle `type:"structure"`

	// An Amazon Resource Name (ARN) that uniquely identifies a recovery point;
	// for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`

	// An ARN that uniquely identifies a resource. The format of the ARN depends
	// on the resource type.
	ResourceArn *string `type:"string"`

	// The type of AWS resource saved as a recovery point; for example, an Amazon
	// Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database
	// Service (Amazon RDS) database.
	ResourceType *string `type:"string"`

	// A status code specifying the state of the recovery point.
	Status RecoveryPointStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s RecoveryPointByBackupVault) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RecoveryPointByBackupVault) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RecoveryPointByBackupVault) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupSizeInBytes != nil {
		v := *s.BackupSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CalculatedLifecycle != nil {
		v := s.CalculatedLifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CalculatedLifecycle", v, metadata)
	}
	if s.CompletionDate != nil {
		v := *s.CompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedBy != nil {
		v := s.CreatedBy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CreatedBy", v, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.EncryptionKeyArn != nil {
		v := *s.EncryptionKeyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EncryptionKeyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IsEncrypted != nil {
		v := *s.IsEncrypted

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsEncrypted", protocol.BoolValue(v), metadata)
	}
	if s.LastRestoreTime != nil {
		v := *s.LastRestoreTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastRestoreTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Lifecycle != nil {
		v := s.Lifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Lifecycle", v, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceType != nil {
		v := *s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Contains detailed information about a saved recovery point.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/RecoveryPointByResource
type RecoveryPointByResource struct {
	_ struct{} `type:"structure"`

	// The size, in bytes, of a backup.
	BackupSizeBytes *int64 `type:"long"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	BackupVaultName *string `type:"string"`

	// The date and time a recovery point is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The server-side encryption key that is used to protect your backups; for
	// example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
	EncryptionKeyArn *string `type:"string"`

	// An Amazon Resource Name (ARN) that uniquely identifies a recovery point;
	// for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`

	// A status code specifying the state of the recovery point.
	Status RecoveryPointStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s RecoveryPointByResource) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RecoveryPointByResource) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RecoveryPointByResource) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupSizeBytes != nil {
		v := *s.BackupSizeBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupSizeBytes", protocol.Int64Value(v), metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.EncryptionKeyArn != nil {
		v := *s.EncryptionKeyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EncryptionKeyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Contains information about the backup plan and rule that AWS Backup used
// to initiate the recovery point backup.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/RecoveryPointCreator
type RecoveryPointCreator struct {
	_ struct{} `type:"structure"`

	// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for
	// example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
	BackupPlanArn *string `type:"string"`

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// Version IDs are unique, randomly generated, Unicode, UTF-8 encoded strings
	// that are at most 1,024 bytes long. They cannot be edited.
	BackupPlanVersion *string `type:"string"`

	// Uniquely identifies a rule used to schedule the backup of a selection of
	// resources.
	BackupRuleId *string `type:"string"`
}

// String returns the string representation
func (s RecoveryPointCreator) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RecoveryPointCreator) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RecoveryPointCreator) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanArn != nil {
		v := *s.BackupPlanArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanVersion != nil {
		v := *s.BackupPlanVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupRuleId != nil {
		v := *s.BackupRuleId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupRuleId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains metadata about a restore job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/RestoreJobsListMember
type RestoreJobsListMember struct {
	_ struct{} `type:"structure"`

	// The size, in bytes, of the restored resource.
	BackupSizeInBytes *int64 `type:"long"`

	// The date and time a job to restore a recovery point is completed, in Unix
	// format and Coordinated Universal Time (UTC). The value of CompletionDate
	// is accurate to milliseconds. For example, the value 1516925490.087 represents
	// Friday, January 26, 2018 12:11:30.087 AM.
	CompletionDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format
	// of the ARN depends on the resource type.
	CreatedResourceArn *string `type:"string"`

	// The date and time a restore job is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The amount of time in minutes that a job restoring a recovery point is expected
	// to take.
	ExpectedCompletionTimeMinutes *int64 `type:"long"`

	// Specifies the IAM role ARN used to create the target recovery point; for
	// example, arn:aws:iam::123456789012:role/S3Access.
	IamRoleArn *string `type:"string"`

	// Contains an estimated percentage complete of a job at the time the job status
	// was queried.
	PercentDone *string `type:"string"`

	// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`

	// Uniquely identifies the job that restores a recovery point.
	RestoreJobId *string `type:"string"`

	// A status code specifying the state of the job initiated by AWS Backup to
	// restore a recovery point.
	Status RestoreJobStatus `type:"string" enum:"true"`

	// A detailed message explaining the status of the job to restore a recovery
	// point.
	StatusMessage *string `type:"string"`
}

// String returns the string representation
func (s RestoreJobsListMember) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RestoreJobsListMember) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RestoreJobsListMember) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupSizeInBytes != nil {
		v := *s.BackupSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.CompletionDate != nil {
		v := *s.CompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedResourceArn != nil {
		v := *s.CreatedResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ExpectedCompletionTimeMinutes != nil {
		v := *s.ExpectedCompletionTimeMinutes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpectedCompletionTimeMinutes", protocol.Int64Value(v), metadata)
	}
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PercentDone != nil {
		v := *s.PercentDone

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PercentDone", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestoreJobId != nil {
		v := *s.RestoreJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RestoreJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusMessage != nil {
		v := *s.StatusMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StatusMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Specifies a scheduled task used to back up a selection of resources.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupRule
type Rule struct {
	_ struct{} `type:"structure"`

	// A value in minutes after a backup job is successfully started before it must
	// be completed or it is canceled by AWS Backup. This value is optional.
	CompletionWindowMinutes *int64 `type:"long"`

	// The lifecycle defines when a protected resource is transitioned to cold storage
	// and when it expires. AWS Backup transitions and expires backups automatically
	// according to the lifecycle that you define.
	//
	// Backups transitioned to cold storage must be stored in cold storage for a
	// minimum of 90 days. Therefore, the expire after days setting must be 90
	// days greater than the transition to cold after days setting. The transition
	// to cold after days setting cannot be changed after a backup has been transitioned
	// to cold.
	Lifecycle *Lifecycle `type:"structure"`

	// An array of key-value pair strings that are assigned to resources that are
	// associated with this rule when restored from backup.
	RecoveryPointTags map[string]string `type:"map"`

	// Uniquely identifies a rule that is used to schedule the backup of a selection
	// of resources.
	RuleId *string `type:"string"`

	// An optional display name for a backup rule.
	//
	// RuleName is a required field
	RuleName *string `type:"string" required:"true"`

	// A CRON expression specifying when AWS Backup initiates a backup job.
	ScheduleExpression *string `type:"string"`

	// An optional value that specifies a period of time in minutes after a backup
	// is scheduled before a job is canceled if it doesn't start successfully.
	StartWindowMinutes *int64 `type:"long"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// TargetBackupVaultName is a required field
	TargetBackupVaultName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Rule) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Rule) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Rule) MarshalFields(e protocol.FieldEncoder) error {
	if s.CompletionWindowMinutes != nil {
		v := *s.CompletionWindowMinutes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionWindowMinutes", protocol.Int64Value(v), metadata)
	}
	if s.Lifecycle != nil {
		v := s.Lifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Lifecycle", v, metadata)
	}
	if len(s.RecoveryPointTags) > 0 {
		v := s.RecoveryPointTags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "RecoveryPointTags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RuleId != nil {
		v := *s.RuleId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ScheduleExpression != nil {
		v := *s.ScheduleExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ScheduleExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartWindowMinutes != nil {
		v := *s.StartWindowMinutes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartWindowMinutes", protocol.Int64Value(v), metadata)
	}
	if s.TargetBackupVaultName != nil {
		v := *s.TargetBackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetBackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Specifies a scheduled task used to back up a selection of resources.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupRuleInput
type RuleInput struct {
	_ struct{} `type:"structure"`

	// The amount of time AWS Backup attempts a backup before canceling the job
	// and returning an error.
	CompletionWindowMinutes *int64 `type:"long"`

	// The lifecycle defines when a protected resource is transitioned to cold storage
	// and when it expires. AWS Backup will transition and expire backups automatically
	// according to the lifecycle that you define.
	//
	// Backups transitioned to cold storage must be stored in cold storage for a
	// minimum of 90 days. Therefore, the expire after days setting must be 90
	// days greater than the transition to cold after days. The transition to
	// cold after days setting cannot be changed after a backup has been transitioned
	// to cold.
	Lifecycle *Lifecycle `type:"structure"`

	// To help organize your resources, you can assign your own metadata to the
	// resources that you create. Each tag is a key-value pair.
	RecoveryPointTags map[string]string `type:"map"`

	// >An optional display name for a backup rule.
	//
	// RuleName is a required field
	RuleName *string `type:"string" required:"true"`

	// A CRON expression specifying when AWS Backup initiates a backup job.
	ScheduleExpression *string `type:"string"`

	// The amount of time in minutes before beginning a backup.
	StartWindowMinutes *int64 `type:"long"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// TargetBackupVaultName is a required field
	TargetBackupVaultName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s RuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RuleInput"}

	if s.RuleName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleName"))
	}

	if s.TargetBackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetBackupVaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RuleInput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CompletionWindowMinutes != nil {
		v := *s.CompletionWindowMinutes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionWindowMinutes", protocol.Int64Value(v), metadata)
	}
	if s.Lifecycle != nil {
		v := s.Lifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Lifecycle", v, metadata)
	}
	if len(s.RecoveryPointTags) > 0 {
		v := s.RecoveryPointTags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "RecoveryPointTags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ScheduleExpression != nil {
		v := *s.ScheduleExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ScheduleExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartWindowMinutes != nil {
		v := *s.StartWindowMinutes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartWindowMinutes", protocol.Int64Value(v), metadata)
	}
	if s.TargetBackupVaultName != nil {
		v := *s.TargetBackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetBackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Used to specify a set of resources to a backup plan.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupSelection
type Selection struct {
	_ struct{} `type:"structure"`

	// The ARN of the IAM role that AWS Backup uses to authenticate when restoring
	// the target resource; for example, arn:aws:iam::123456789012:role/S3Access.
	//
	// IamRoleArn is a required field
	IamRoleArn *string `type:"string" required:"true"`

	// An array of conditions used to specify a set of resources to assign to a
	// backup plan; for example, "StringEquals": {"ec2:ResourceTag/Department":
	// "accounting".
	ListOfTags []Condition `type:"list"`

	// An array of strings that either contain Amazon Resource Names (ARNs) or match
	// patterns such as "arn:aws:ec2:us-east-1:123456789012:volume/*" of resources
	// to assign to a backup plan.
	Resources []string `type:"list"`

	// The display name of a resource selection document.
	//
	// SelectionName is a required field
	SelectionName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Selection) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Selection) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Selection) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Selection"}

	if s.IamRoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("IamRoleArn"))
	}

	if s.SelectionName == nil {
		invalidParams.Add(aws.NewErrParamRequired("SelectionName"))
	}
	if s.ListOfTags != nil {
		for i, v := range s.ListOfTags {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ListOfTags", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Selection) MarshalFields(e protocol.FieldEncoder) error {
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ListOfTags) > 0 {
		v := s.ListOfTags

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ListOfTags", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Resources) > 0 {
		v := s.Resources

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Resources", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.SelectionName != nil {
		v := *s.SelectionName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SelectionName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains metadata about a BackupSelection object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupSelectionsListMember
type SelectionsListMember struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// The date and time a backup plan is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A unique string that identifies the request and allows failed requests to
	// be retried without the risk of executing the operation twice.
	CreatorRequestId *string `type:"string"`

	// Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery
	// point; for example, arn:aws:iam::123456789012:role/S3Access.
	IamRoleArn *string `type:"string"`

	// Uniquely identifies a request to assign a set of resources to a backup plan.
	SelectionId *string `type:"string"`

	// The display name of a resource selection document.
	SelectionName *string `type:"string"`
}

// String returns the string representation
func (s SelectionsListMember) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SelectionsListMember) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SelectionsListMember) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SelectionId != nil {
		v := *s.SelectionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SelectionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SelectionName != nil {
		v := *s.SelectionName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SelectionName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StartBackupJobInput
type StartBackupJobInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `type:"string" required:"true"`

	// The amount of time AWS Backup attempts a backup before canceling the job
	// and returning an error.
	CompleteWindowMinutes *int64 `type:"long"`

	// Specifies the IAM role ARN used to create the target recovery point; for
	// example, arn:aws:iam::123456789012:role/S3Access.
	//
	// IamRoleArn is a required field
	IamRoleArn *string `type:"string" required:"true"`

	// A customer chosen string that can be used to distinguish between calls to
	// StartBackupJob. Idempotency tokens time out after one hour. Therefore, if
	// you call StartBackupJob multiple times with the same idempotency token within
	// one hour, AWS Backup recognizes that you are requesting only one backup job
	// and initiates only one. If you change the idempotency token for each call,
	// AWS Backup recognizes that you are requesting to start multiple backups.
	IdempotencyToken *string `type:"string"`

	// The lifecycle defines when a protected resource is transitioned to cold storage
	// and when it expires. AWS Backup will transition and expire backups automatically
	// according to the lifecycle that you define.
	//
	// Backups transitioned to cold storage must be stored in cold storage for a
	// minimum of 90 days. Therefore, the expire after days setting must be 90
	// days greater than the transition to cold after days setting. The transition
	// to cold after days setting cannot be changed after a backup has been transitioned
	// to cold.
	Lifecycle *Lifecycle `type:"structure"`

	// To help organize your resources, you can assign your own metadata to the
	// resources that you create. Each tag is a key-value pair.
	RecoveryPointTags map[string]string `type:"map"`

	// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format
	// of the ARN depends on the resource type.
	//
	// ResourceArn is a required field
	ResourceArn *string `type:"string" required:"true"`

	// The amount of time in minutes before beginning a backup.
	StartWindowMinutes *int64 `type:"long"`
}

// String returns the string representation
func (s StartBackupJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartBackupJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartBackupJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartBackupJobInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if s.IamRoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("IamRoleArn"))
	}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartBackupJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CompleteWindowMinutes != nil {
		v := *s.CompleteWindowMinutes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompleteWindowMinutes", protocol.Int64Value(v), metadata)
	}
	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdempotencyToken != nil {
		v := *s.IdempotencyToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IdempotencyToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Lifecycle != nil {
		v := s.Lifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Lifecycle", v, metadata)
	}
	if len(s.RecoveryPointTags) > 0 {
		v := s.RecoveryPointTags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "RecoveryPointTags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartWindowMinutes != nil {
		v := *s.StartWindowMinutes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartWindowMinutes", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StartBackupJobOutput
type StartBackupJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Uniquely identifies a request to AWS Backup to back up a resource.
	BackupJobId *string `type:"string"`

	// The date and time that a backup job is started, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`
}

// String returns the string representation
func (s StartBackupJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartBackupJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartBackupJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartBackupJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupJobId != nil {
		v := *s.BackupJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StartRestoreJobInput
type StartRestoreJobInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the IAM role that AWS Backup uses to create
	// the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
	//
	// IamRoleArn is a required field
	IamRoleArn *string `type:"string" required:"true"`

	// A customer chosen string that can be used to distinguish between calls to
	// StartRestoreJob. Idempotency tokens time out after one hour. Therefore, if
	// you call StartRestoreJob multiple times with the same idempotency token within
	// one hour, AWS Backup recognizes that you are requesting only one restore
	// job and initiates only one. If you change the idempotency token for each
	// call, AWS Backup recognizes that you are requesting to start multiple restores.
	IdempotencyToken *string `type:"string"`

	// A set of metadata key-value pairs. Lists the metadata that the recovery point
	// was created with.
	//
	// Metadata is a required field
	Metadata map[string]string `type:"map" required:"true"`

	// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	//
	// RecoveryPointArn is a required field
	RecoveryPointArn *string `type:"string" required:"true"`

	// Starts a job to restore a recovery point for one of the following resources:
	//
	//    * EBS for Amazon Elastic Block Store
	//
	//    * SGW for AWS Storage Gateway
	//
	//    * RDS for Amazon Relational Database Service
	//
	//    * DDB for Amazon DynamoDB
	//
	//    * EFS for Amazon Elastic File System
	ResourceType *string `type:"string"`
}

// String returns the string representation
func (s StartRestoreJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartRestoreJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartRestoreJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartRestoreJobInput"}

	if s.IamRoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("IamRoleArn"))
	}

	if s.Metadata == nil {
		invalidParams.Add(aws.NewErrParamRequired("Metadata"))
	}

	if s.RecoveryPointArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RecoveryPointArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartRestoreJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.IamRoleArn != nil {
		v := *s.IamRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdempotencyToken != nil {
		v := *s.IdempotencyToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IdempotencyToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Metadata) > 0 {
		v := s.Metadata

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Metadata", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceType != nil {
		v := *s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StartRestoreJobOutput
type StartRestoreJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Uniquely identifies the job that restores a recovery point.
	RestoreJobId *string `type:"string"`
}

// String returns the string representation
func (s StartRestoreJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartRestoreJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartRestoreJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartRestoreJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.RestoreJobId != nil {
		v := *s.RestoreJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RestoreJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StopBackupJobInput
type StopBackupJobInput struct {
	_ struct{} `type:"structure"`

	// Uniquely identifies a request to AWS Backup to back up a resource.
	//
	// BackupJobId is a required field
	BackupJobId *string `location:"uri" locationName:"backupJobId" type:"string" required:"true"`
}

// String returns the string representation
func (s StopBackupJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopBackupJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StopBackupJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StopBackupJobInput"}

	if s.BackupJobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupJobId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StopBackupJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupJobId != nil {
		v := *s.BackupJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/StopBackupJobOutput
type StopBackupJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s StopBackupJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopBackupJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StopBackupJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StopBackupJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/TagResourceInput
type TagResourceInput struct {
	_ struct{} `type:"structure"`

	// An ARN that uniquely identifies a resource. The format of the ARN depends
	// on the type of the tagged resource.
	//
	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resourceArn" type:"string" required:"true"`

	// Key-value pairs that are used to help organize your resources. You can assign
	// your own metadata to the resources you create.
	//
	// Tags is a required field
	Tags map[string]string `type:"map" required:"true"`
}

// String returns the string representation
func (s TagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TagResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TagResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if s.Tags == nil {
		invalidParams.Add(aws.NewErrParamRequired("Tags"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TagResourceInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/TagResourceOutput
type TagResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s TagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TagResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TagResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UntagResourceInput
type UntagResourceInput struct {
	_ struct{} `type:"structure"`

	// An ARN that uniquely identifies a resource. The format of the ARN depends
	// on the type of the tagged resource.
	//
	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resourceArn" type:"string" required:"true"`

	// A list of keys to identify which key-value tags to remove from a resource.
	//
	// TagKeyList is a required field
	TagKeyList []string `type:"list" required:"true"`
}

// String returns the string representation
func (s UntagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UntagResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UntagResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if s.TagKeyList == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagKeyList"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UntagResourceInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.TagKeyList) > 0 {
		v := s.TagKeyList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TagKeyList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UntagResourceOutput
type UntagResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UntagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UntagResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UntagResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UpdateBackupPlanInput
type UpdateBackupPlanInput struct {
	_ struct{} `type:"structure"`

	// Specifies the body of a backup plan. Includes a BackupPlanName and one or
	// more sets of Rules.
	//
	// BackupPlan is a required field
	BackupPlan *PlanInput `type:"structure" required:"true"`

	// Uniquely identifies a backup plan.
	//
	// BackupPlanId is a required field
	BackupPlanId *string `location:"uri" locationName:"backupPlanId" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateBackupPlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBackupPlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateBackupPlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateBackupPlanInput"}

	if s.BackupPlan == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlan"))
	}

	if s.BackupPlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupPlanId"))
	}
	if s.BackupPlan != nil {
		if err := s.BackupPlan.Validate(); err != nil {
			invalidParams.AddNested("BackupPlan", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateBackupPlanInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BackupPlan != nil {
		v := s.BackupPlan

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackupPlan", v, metadata)
	}
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UpdateBackupPlanOutput
type UpdateBackupPlanOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for
	// example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
	BackupPlanArn *string `type:"string"`

	// Uniquely identifies a backup plan.
	BackupPlanId *string `type:"string"`

	// The date and time a backup plan is updated, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
	// 1,024 bytes long. Version Ids cannot be edited.
	VersionId *string `type:"string"`
}

// String returns the string representation
func (s UpdateBackupPlanOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBackupPlanOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateBackupPlanOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateBackupPlanOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupPlanArn != nil {
		v := *s.BackupPlanArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupPlanId != nil {
		v := *s.BackupPlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupPlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UpdateRecoveryPointLifecycleInput
type UpdateRecoveryPointLifecycleInput struct {
	_ struct{} `type:"structure"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	//
	// BackupVaultName is a required field
	BackupVaultName *string `location:"uri" locationName:"backupVaultName" type:"string" required:"true"`

	// The lifecycle defines when a protected resource is transitioned to cold storage
	// and when it expires. AWS Backup transitions and expires backups automatically
	// according to the lifecycle that you define.
	//
	// Backups transitioned to cold storage must be stored in cold storage for a
	// minimum of 90 days. Therefore, the expire after days setting must be 90
	// days greater than the transition to cold after days setting. The transition
	// to cold after days setting cannot be changed after a backup has been transitioned
	// to cold.
	Lifecycle *Lifecycle `type:"structure"`

	// An Amazon Resource Name (ARN) that uniquely identifies a recovery point;
	// for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	//
	// RecoveryPointArn is a required field
	RecoveryPointArn *string `location:"uri" locationName:"recoveryPointArn" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateRecoveryPointLifecycleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRecoveryPointLifecycleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateRecoveryPointLifecycleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateRecoveryPointLifecycleInput"}

	if s.BackupVaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupVaultName"))
	}

	if s.RecoveryPointArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RecoveryPointArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateRecoveryPointLifecycleInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Lifecycle != nil {
		v := s.Lifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Lifecycle", v, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "backupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "recoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/UpdateRecoveryPointLifecycleOutput
type UpdateRecoveryPointLifecycleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt
	// timestamps.
	CalculatedLifecycle *CalculatedLifecycle `type:"structure"`

	// The lifecycle defines when a protected resource is transitioned to cold storage
	// and when it expires. AWS Backup transitions and expires backups automatically
	// according to the lifecycle that you define.
	//
	// Backups transitioned to cold storage must be stored in cold storage for a
	// minimum of 90 days. Therefore, the expire after days setting must be 90
	// days greater than the transition to cold after days setting. The transition
	// to cold after days setting cannot be changed after a backup has been transitioned
	// to cold.
	Lifecycle *Lifecycle `type:"structure"`

	// An Amazon Resource Name (ARN) that uniquely identifies a recovery point;
	// for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
	RecoveryPointArn *string `type:"string"`
}

// String returns the string representation
func (s UpdateRecoveryPointLifecycleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRecoveryPointLifecycleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateRecoveryPointLifecycleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateRecoveryPointLifecycleOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CalculatedLifecycle != nil {
		v := s.CalculatedLifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CalculatedLifecycle", v, metadata)
	}
	if s.Lifecycle != nil {
		v := s.Lifecycle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Lifecycle", v, metadata)
	}
	if s.RecoveryPointArn != nil {
		v := *s.RecoveryPointArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecoveryPointArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains metadata about a backup vault.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/backup-2018-11-15/BackupVaultListMember
type VaultListMember struct {
	_ struct{} `type:"structure"`

	// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for
	// example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
	BackupVaultArn *string `type:"string"`

	// The name of a logical container where backups are stored. Backup vaults are
	// identified by names that are unique to the account used to create them and
	// the AWS Region where they are created. They consist of lowercase letters,
	// numbers, and hyphens.
	BackupVaultName *string `type:"string"`

	// The date and time a resource backup is created, in Unix format and Coordinated
	// Universal Time (UTC). The value of CreationDate is accurate to milliseconds.
	// For example, the value 1516925490.087 represents Friday, January 26, 2018
	// 12:11:30.087 AM.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A unique string that identifies the request and allows failed requests to
	// be retried without the risk of executing the operation twice.
	CreatorRequestId *string `type:"string"`

	// The server-side encryption key that is used to protect your backups; for
	// example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
	EncryptionKeyArn *string `type:"string"`

	// The number of recovery points that are stored in a backup vault.
	NumberOfRecoveryPoints *int64 `type:"long"`
}

// String returns the string representation
func (s VaultListMember) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VaultListMember) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VaultListMember) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackupVaultArn != nil {
		v := *s.BackupVaultArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BackupVaultName != nil {
		v := *s.BackupVaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BackupVaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorRequestId != nil {
		v := *s.CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EncryptionKeyArn != nil {
		v := *s.EncryptionKeyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EncryptionKeyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NumberOfRecoveryPoints != nil {
		v := *s.NumberOfRecoveryPoints

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberOfRecoveryPoints", protocol.Int64Value(v), metadata)
	}
	return nil
}

type ConditionType string

// Enum values for ConditionType
const (
	ConditionTypeStringequals ConditionType = "STRINGEQUALS"
)

func (enum ConditionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ConditionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type JobState string

// Enum values for JobState
const (
	JobStateCreated   JobState = "CREATED"
	JobStatePending   JobState = "PENDING"
	JobStateRunning   JobState = "RUNNING"
	JobStateAborting  JobState = "ABORTING"
	JobStateAborted   JobState = "ABORTED"
	JobStateCompleted JobState = "COMPLETED"
	JobStateFailed    JobState = "FAILED"
	JobStateExpired   JobState = "EXPIRED"
)

func (enum JobState) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum JobState) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RecoveryPointStatus string

// Enum values for RecoveryPointStatus
const (
	RecoveryPointStatusCompleted RecoveryPointStatus = "COMPLETED"
	RecoveryPointStatusPartial   RecoveryPointStatus = "PARTIAL"
	RecoveryPointStatusDeleting  RecoveryPointStatus = "DELETING"
	RecoveryPointStatusExpired   RecoveryPointStatus = "EXPIRED"
)

func (enum RecoveryPointStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RecoveryPointStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RestoreJobStatus string

// Enum values for RestoreJobStatus
const (
	RestoreJobStatusPending   RestoreJobStatus = "PENDING"
	RestoreJobStatusRunning   RestoreJobStatus = "RUNNING"
	RestoreJobStatusCompleted RestoreJobStatus = "COMPLETED"
	RestoreJobStatusAborted   RestoreJobStatus = "ABORTED"
	RestoreJobStatusFailed    RestoreJobStatus = "FAILED"
)

func (enum RestoreJobStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RestoreJobStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type StorageClass string

// Enum values for StorageClass
const (
	StorageClassWarm    StorageClass = "WARM"
	StorageClassCold    StorageClass = "COLD"
	StorageClassDeleted StorageClass = "DELETED"
)

func (enum StorageClass) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum StorageClass) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type VaultEvent string

// Enum values for VaultEvent
const (
	VaultEventBackupJobStarted      VaultEvent = "BACKUP_JOB_STARTED"
	VaultEventBackupJobCompleted    VaultEvent = "BACKUP_JOB_COMPLETED"
	VaultEventRestoreJobStarted     VaultEvent = "RESTORE_JOB_STARTED"
	VaultEventRestoreJobCompleted   VaultEvent = "RESTORE_JOB_COMPLETED"
	VaultEventRecoveryPointModified VaultEvent = "RECOVERY_POINT_MODIFIED"
	VaultEventBackupPlanCreated     VaultEvent = "BACKUP_PLAN_CREATED"
	VaultEventBackupPlanModified    VaultEvent = "BACKUP_PLAN_MODIFIED"
)

func (enum VaultEvent) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum VaultEvent) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
