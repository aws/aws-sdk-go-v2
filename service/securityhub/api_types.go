// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package securityhub

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

var _ aws.Config
var _ = awsutil.Prettify

// The details of an AWS account.
type AccountDetails struct {
	_ struct{} `type:"structure"`

	// The ID of an AWS account.
	AccountId *string `type:"string"`

	// The email of an AWS account.
	Email *string `type:"string"`
}

// String returns the string representation
func (s AccountDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AccountDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Email != nil {
		v := *s.Email

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Email", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// An ActionTarget object.
type ActionTarget struct {
	_ struct{} `type:"structure"`

	// The ARN for the target action.
	//
	// ActionTargetArn is a required field
	ActionTargetArn *string `type:"string" required:"true"`

	// The description of the target action.
	//
	// Description is a required field
	Description *string `type:"string" required:"true"`

	// The name of the action target.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`
}

// String returns the string representation
func (s ActionTarget) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ActionTarget) MarshalFields(e protocol.FieldEncoder) error {
	if s.ActionTargetArn != nil {
		v := *s.ActionTargetArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ActionTargetArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about an Availability Zone.
type AvailabilityZone struct {
	_ struct{} `type:"structure"`

	// The ID of the subnet. You can specify one subnet per Availability Zone.
	SubnetId *string `type:"string"`

	// The name of the Availability Zone.
	ZoneName *string `type:"string"`
}

// String returns the string representation
func (s AvailabilityZone) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AvailabilityZone) MarshalFields(e protocol.FieldEncoder) error {
	if s.SubnetId != nil {
		v := *s.SubnetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubnetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ZoneName != nil {
		v := *s.ZoneName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ZoneName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A distribution configuration.
type AwsCloudFrontDistributionDetails struct {
	_ struct{} `type:"structure"`

	// The domain name corresponding to the distribution.
	DomainName *string `type:"string"`

	// The entity tag is a hash of the object.
	ETag *string `type:"string"`

	// The date and time that the distribution was last modified.
	LastModifiedTime *string `type:"string"`

	// A complex type that controls whether access logs are written for the distribution.
	Logging *AwsCloudFrontDistributionLogging `type:"structure"`

	// A complex type that contains information about origins for this distribution.
	Origins *AwsCloudFrontDistributionOrigins `type:"structure"`

	// Indicates the current status of the distribution.
	Status *string `type:"string"`

	// A unique identifier that specifies the AWS WAF web ACL, if any, to associate
	// with this distribution.
	WebAclId *string `type:"string"`
}

// String returns the string representation
func (s AwsCloudFrontDistributionDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsCloudFrontDistributionDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ETag != nil {
		v := *s.ETag

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ETag", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastModifiedTime != nil {
		v := *s.LastModifiedTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModifiedTime", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Logging != nil {
		v := s.Logging

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Logging", v, metadata)
	}
	if s.Origins != nil {
		v := s.Origins

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Origins", v, metadata)
	}
	if s.Status != nil {
		v := *s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.WebAclId != nil {
		v := *s.WebAclId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "WebAclId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A complex type that controls whether access logs are written for the distribution.
type AwsCloudFrontDistributionLogging struct {
	_ struct{} `type:"structure"`

	// The Amazon S3 bucket to store the access logs in.
	Bucket *string `type:"string"`

	// With this field, you can enable or disable the selected distribution.
	Enabled *bool `type:"boolean"`

	// Specifies whether you want CloudFront to include cookies in access logs.
	IncludeCookies *bool `type:"boolean"`

	// An optional string that you want CloudFront to prefix to the access log filenames
	// for this distribution.
	Prefix *string `type:"string"`
}

// String returns the string representation
func (s AwsCloudFrontDistributionLogging) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsCloudFrontDistributionLogging) MarshalFields(e protocol.FieldEncoder) error {
	if s.Bucket != nil {
		v := *s.Bucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Bucket", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Enabled", protocol.BoolValue(v), metadata)
	}
	if s.IncludeCookies != nil {
		v := *s.IncludeCookies

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IncludeCookies", protocol.BoolValue(v), metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A complex type that describes the Amazon S3 bucket, HTTP server (for example,
// a web server), Amazon MediaStore, or other server from which CloudFront gets
// your files.
type AwsCloudFrontDistributionOriginItem struct {
	_ struct{} `type:"structure"`

	// Amazon S3 origins: The DNS name of the Amazon S3 bucket from which you want
	// CloudFront to get objects for this origin.
	DomainName *string `type:"string"`

	// A unique identifier for the origin or origin group.
	Id *string `type:"string"`

	// An optional element that causes CloudFront to request your content from a
	// directory in your Amazon S3 bucket or your custom origin.
	OriginPath *string `type:"string"`
}

// String returns the string representation
func (s AwsCloudFrontDistributionOriginItem) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsCloudFrontDistributionOriginItem) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OriginPath != nil {
		v := *s.OriginPath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OriginPath", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A complex type that contains information about origins and origin groups
// for this distribution.
type AwsCloudFrontDistributionOrigins struct {
	_ struct{} `type:"structure"`

	// A complex type that contains origins or origin groups for this distribution.
	Items []AwsCloudFrontDistributionOriginItem `type:"list"`
}

// String returns the string representation
func (s AwsCloudFrontDistributionOrigins) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsCloudFrontDistributionOrigins) MarshalFields(e protocol.FieldEncoder) error {
	if s.Items != nil {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Items", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The details of an Amazon EC2 instance.
type AwsEc2InstanceDetails struct {
	_ struct{} `type:"structure"`

	// The IAM profile ARN of the instance.
	IamInstanceProfileArn *string `type:"string"`

	// The Amazon Machine Image (AMI) ID of the instance.
	ImageId *string `type:"string"`

	// The IPv4 addresses associated with the instance.
	IpV4Addresses []string `type:"list"`

	// The IPv6 addresses associated with the instance.
	IpV6Addresses []string `type:"list"`

	// The key name associated with the instance.
	KeyName *string `type:"string"`

	// The date/time the instance was launched.
	LaunchedAt *string `type:"string"`

	// The identifier of the subnet that the instance was launched in.
	SubnetId *string `type:"string"`

	// The instance type of the instance.
	Type *string `type:"string"`

	// The identifier of the VPC that the instance was launched in.
	VpcId *string `type:"string"`
}

// String returns the string representation
func (s AwsEc2InstanceDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsEc2InstanceDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.IamInstanceProfileArn != nil {
		v := *s.IamInstanceProfileArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IamInstanceProfileArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ImageId != nil {
		v := *s.ImageId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ImageId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IpV4Addresses != nil {
		v := s.IpV4Addresses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IpV4Addresses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.IpV6Addresses != nil {
		v := s.IpV6Addresses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IpV6Addresses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.KeyName != nil {
		v := *s.KeyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LaunchedAt != nil {
		v := *s.LaunchedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LaunchedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SubnetId != nil {
		v := *s.SubnetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubnetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VpcId != nil {
		v := *s.VpcId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VpcId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about a load balancer.
type AwsElbv2LoadBalancerDetails struct {
	_ struct{} `type:"structure"`

	// The Availability Zones for the load balancer.
	AvailabilityZones []AvailabilityZone `type:"list"`

	// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
	CanonicalHostedZoneId *string `type:"string"`

	// The date and time the load balancer was created.
	CreatedTime *string `type:"string"`

	// The public DNS name of the load balancer.
	DNSName *string `type:"string"`

	// The type of IP addresses used by the subnets for your load balancer. The
	// possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and
	// IPv6 addresses).
	IpAddressType *string `type:"string"`

	// The nodes of an Internet-facing load balancer have public IP addresses.
	Scheme *string `type:"string"`

	// The IDs of the security groups for the load balancer.
	SecurityGroups []string `type:"list"`

	// The state of the load balancer.
	State *LoadBalancerState `type:"structure"`

	// The type of load balancer.
	Type *string `type:"string"`

	// The ID of the VPC for the load balancer.
	VpcId *string `type:"string"`
}

// String returns the string representation
func (s AwsElbv2LoadBalancerDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsElbv2LoadBalancerDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.AvailabilityZones != nil {
		v := s.AvailabilityZones

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AvailabilityZones", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.CanonicalHostedZoneId != nil {
		v := *s.CanonicalHostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CanonicalHostedZoneId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedTime != nil {
		v := *s.CreatedTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedTime", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DNSName != nil {
		v := *s.DNSName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DNSName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IpAddressType != nil {
		v := *s.IpAddressType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IpAddressType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Scheme != nil {
		v := *s.Scheme

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Scheme", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SecurityGroups != nil {
		v := s.SecurityGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SecurityGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.State != nil {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "State", v, metadata)
	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VpcId != nil {
		v := *s.VpcId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VpcId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// IAM access key details related to a finding.
type AwsIamAccessKeyDetails struct {
	_ struct{} `type:"structure"`

	// The creation date/time of the IAM access key related to a finding.
	CreatedAt *string `type:"string"`

	// The ID of the principal associated with an access key.
	PrincipalId *string `type:"string"`

	// The name of the principal.
	PrincipalName *string `type:"string"`

	// The type of principal associated with an access key.
	PrincipalType *string `type:"string"`

	// The status of the IAM access key related to a finding.
	Status AwsIamAccessKeyStatus `type:"string" enum:"true"`

	// The user associated with the IAM access key related to a finding.
	//
	// The UserName parameter has been replaced with the PrincipalName parameter
	// because access keys can also be assigned to principals that are not IAM users.
	UserName *string `deprecated:"true" type:"string"`
}

// String returns the string representation
func (s AwsIamAccessKeyDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsIamAccessKeyDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PrincipalId != nil {
		v := *s.PrincipalId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PrincipalId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PrincipalName != nil {
		v := *s.PrincipalName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PrincipalName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PrincipalType != nil {
		v := *s.PrincipalType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PrincipalType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.UserName != nil {
		v := *s.UserName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UserName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains information about an IAM role, including all of the role's policies.
type AwsIamRoleDetails struct {
	_ struct{} `type:"structure"`

	// The trust policy that grants permission to assume the role.
	AssumeRolePolicyDocument *string `min:"1" type:"string"`

	// The date and time, in ISO 8601 date-time format, when the role was created.
	CreateDate *string `type:"string"`

	// The maximum session duration (in seconds) that you want to set for the specified
	// role.
	MaxSessionDuration *int64 `type:"integer"`

	// The path to the role.
	Path *string `type:"string"`

	// The stable and unique string identifying the role.
	RoleId *string `type:"string"`

	// The friendly name that identifies the role.
	RoleName *string `type:"string"`
}

// String returns the string representation
func (s AwsIamRoleDetails) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AwsIamRoleDetails) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AwsIamRoleDetails"}
	if s.AssumeRolePolicyDocument != nil && len(*s.AssumeRolePolicyDocument) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AssumeRolePolicyDocument", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsIamRoleDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.AssumeRolePolicyDocument != nil {
		v := *s.AssumeRolePolicyDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AssumeRolePolicyDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreateDate != nil {
		v := *s.CreateDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreateDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxSessionDuration != nil {
		v := *s.MaxSessionDuration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxSessionDuration", protocol.Int64Value(v), metadata)
	}
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleId != nil {
		v := *s.RoleId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RoleId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleName != nil {
		v := *s.RoleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RoleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains metadata about a customer master key (CMK).
type AwsKmsKeyDetails struct {
	_ struct{} `type:"structure"`

	// The twelve-digit account ID of the AWS account that owns the CMK.
	AWSAccountId *string `type:"string"`

	// The date and time when the CMK was created.
	CreationDate *float64 `type:"double"`

	// The globally unique identifier for the CMK.
	KeyId *string `type:"string"`

	// The manager of the CMK. CMKs in your AWS account are either customer managed
	// or AWS managed.
	KeyManager *string `type:"string"`

	// The state of the CMK.
	KeyState *string `type:"string"`

	// The source of the CMK's key material. When this value is AWS_KMS, AWS KMS
	// created the key material. When this value is EXTERNAL, the key material was
	// imported from your existing key management infrastructure or the CMK lacks
	// key material. When this value is AWS_CLOUDHSM, the key material was created
	// in the AWS CloudHSM cluster associated with a custom key store.
	Origin *string `type:"string"`
}

// String returns the string representation
func (s AwsKmsKeyDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsKmsKeyDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.AWSAccountId != nil {
		v := *s.AWSAccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AWSAccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.Float64Value(v), metadata)
	}
	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KeyManager != nil {
		v := *s.KeyManager

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyManager", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KeyState != nil {
		v := *s.KeyState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyState", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Origin != nil {
		v := *s.Origin

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Origin", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The code for the Lambda function. You can specify either an object in Amazon
// S3, or upload a deployment package directly.
type AwsLambdaFunctionCode struct {
	_ struct{} `type:"structure"`

	// An Amazon S3 bucket in the same AWS Region as your function. The bucket can
	// be in a different AWS account.
	S3Bucket *string `type:"string"`

	// The Amazon S3 key of the deployment package.
	S3Key *string `type:"string"`

	// For versioned objects, the version of the deployment package object to use.
	S3ObjectVersion *string `type:"string"`

	// The base64-encoded contents of the deployment package. AWS SDK and AWS CLI
	// clients handle the encoding for you.
	ZipFile *string `type:"string"`
}

// String returns the string representation
func (s AwsLambdaFunctionCode) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsLambdaFunctionCode) MarshalFields(e protocol.FieldEncoder) error {
	if s.S3Bucket != nil {
		v := *s.S3Bucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "S3Bucket", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.S3Key != nil {
		v := *s.S3Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "S3Key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.S3ObjectVersion != nil {
		v := *s.S3ObjectVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "S3ObjectVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ZipFile != nil {
		v := *s.ZipFile

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ZipFile", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The dead-letter queue for failed asynchronous invocations.
type AwsLambdaFunctionDeadLetterConfig struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
	TargetArn *string `type:"string"`
}

// String returns the string representation
func (s AwsLambdaFunctionDeadLetterConfig) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsLambdaFunctionDeadLetterConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.TargetArn != nil {
		v := *s.TargetArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Details about a function's configuration.
type AwsLambdaFunctionDetails struct {
	_ struct{} `type:"structure"`

	// An AwsLambdaFunctionCode object.
	Code *AwsLambdaFunctionCode `type:"structure"`

	// The SHA256 hash of the function's deployment package.
	CodeSha256 *string `type:"string"`

	// The function's dead letter queue.
	DeadLetterConfig *AwsLambdaFunctionDeadLetterConfig `type:"structure"`

	// The function's environment variables.
	Environment *AwsLambdaFunctionEnvironment `type:"structure"`

	// The name of the function.
	FunctionName *string `type:"string"`

	// The function that Lambda calls to begin executing your function.
	Handler *string `type:"string"`

	// The KMS key that's used to encrypt the function's environment variables.
	// This key is only returned if you've configured a customer managed CMK.
	KmsKeyArn *string `type:"string"`

	// The date and time that the function was last updated, in ISO-8601 format
	// (YYYY-MM-DDThh:mm:ss.sTZD).
	LastModified *string `type:"string"`

	// The function's layers.
	Layers []AwsLambdaFunctionLayer `type:"list"`

	// For Lambda@Edge functions, the ARN of the master function.
	MasterArn *string `type:"string"`

	// The memory that's allocated to the function.
	MemorySize *int64 `type:"integer"`

	// The latest updated revision of the function or alias.
	RevisionId *string `type:"string"`

	// The function's execution role.
	Role *string `type:"string"`

	// The runtime environment for the Lambda function.
	Runtime *string `type:"string"`

	// The amount of time that Lambda allows a function to run before stopping it.
	Timeout *int64 `type:"integer"`

	// The function's AWS X-Ray tracing configuration.
	TracingConfig *AwsLambdaFunctionTracingConfig `type:"structure"`

	// The version of the Lambda function.
	Version *string `type:"string"`

	// The function's networking configuration.
	VpcConfig *AwsLambdaFunctionVpcConfig `type:"structure"`
}

// String returns the string representation
func (s AwsLambdaFunctionDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsLambdaFunctionDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.Code != nil {
		v := s.Code

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Code", v, metadata)
	}
	if s.CodeSha256 != nil {
		v := *s.CodeSha256

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CodeSha256", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DeadLetterConfig != nil {
		v := s.DeadLetterConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DeadLetterConfig", v, metadata)
	}
	if s.Environment != nil {
		v := s.Environment

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Environment", v, metadata)
	}
	if s.FunctionName != nil {
		v := *s.FunctionName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FunctionName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Handler != nil {
		v := *s.Handler

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Handler", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KmsKeyArn != nil {
		v := *s.KmsKeyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KmsKeyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastModified != nil {
		v := *s.LastModified

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastModified", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Layers != nil {
		v := s.Layers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Layers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.MasterArn != nil {
		v := *s.MasterArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MasterArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MemorySize != nil {
		v := *s.MemorySize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MemorySize", protocol.Int64Value(v), metadata)
	}
	if s.RevisionId != nil {
		v := *s.RevisionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RevisionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Role != nil {
		v := *s.Role

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Role", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Runtime != nil {
		v := *s.Runtime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Runtime", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Timeout != nil {
		v := *s.Timeout

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Timeout", protocol.Int64Value(v), metadata)
	}
	if s.TracingConfig != nil {
		v := s.TracingConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TracingConfig", v, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VpcConfig != nil {
		v := s.VpcConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "VpcConfig", v, metadata)
	}
	return nil
}

// A function's environment variable settings.
type AwsLambdaFunctionEnvironment struct {
	_ struct{} `type:"structure"`

	// An AwsLambdaFunctionEnvironmentError object.
	Error *AwsLambdaFunctionEnvironmentError `type:"structure"`

	// Environment variable key-value pairs.
	Variables map[string]string `type:"map"`
}

// String returns the string representation
func (s AwsLambdaFunctionEnvironment) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsLambdaFunctionEnvironment) MarshalFields(e protocol.FieldEncoder) error {
	if s.Error != nil {
		v := s.Error

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Error", v, metadata)
	}
	if s.Variables != nil {
		v := s.Variables

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Variables", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Error messages for environment variables that couldn't be applied.
type AwsLambdaFunctionEnvironmentError struct {
	_ struct{} `type:"structure"`

	// The error code.
	ErrorCode *string `type:"string"`

	// The error message.
	Message *string `type:"string"`
}

// String returns the string representation
func (s AwsLambdaFunctionEnvironmentError) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsLambdaFunctionEnvironmentError) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorCode != nil {
		v := *s.ErrorCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ErrorCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Message", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// An AWS Lambda layer.
type AwsLambdaFunctionLayer struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the function layer.
	Arn *string `type:"string"`

	// The size of the layer archive in bytes.
	CodeSize *int64 `type:"integer"`
}

// String returns the string representation
func (s AwsLambdaFunctionLayer) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsLambdaFunctionLayer) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CodeSize != nil {
		v := *s.CodeSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CodeSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The function's AWS X-Ray tracing configuration.
type AwsLambdaFunctionTracingConfig struct {
	_ struct{} `type:"structure"`

	// The tracing mode.
	Mode *string `type:"string"`
}

// String returns the string representation
func (s AwsLambdaFunctionTracingConfig) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsLambdaFunctionTracingConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.Mode != nil {
		v := *s.Mode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Mode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The VPC security groups and subnets that are attached to a Lambda function.
// For more information, see VPC Settings.
type AwsLambdaFunctionVpcConfig struct {
	_ struct{} `type:"structure"`

	// A list of VPC security groups IDs.
	SecurityGroupIds []string `type:"list"`

	// A list of VPC subnet IDs.
	SubnetIds []string `type:"list"`

	// The ID of the VPC.
	VpcId *string `type:"string"`
}

// String returns the string representation
func (s AwsLambdaFunctionVpcConfig) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsLambdaFunctionVpcConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.SecurityGroupIds != nil {
		v := s.SecurityGroupIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SecurityGroupIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.SubnetIds != nil {
		v := s.SubnetIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SubnetIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.VpcId != nil {
		v := *s.VpcId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VpcId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The details of an Amazon S3 bucket.
type AwsS3BucketDetails struct {
	_ struct{} `type:"structure"`

	// The canonical user ID of the owner of the S3 bucket.
	OwnerId *string `type:"string"`

	// The display name of the owner of the S3 bucket.
	OwnerName *string `type:"string"`
}

// String returns the string representation
func (s AwsS3BucketDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsS3BucketDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.OwnerId != nil {
		v := *s.OwnerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OwnerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OwnerName != nil {
		v := *s.OwnerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OwnerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides consistent format for the contents of the Security Hub-aggregated
// findings. AwsSecurityFinding format enables you to share findings between
// AWS security services and third-party solutions, and compliance checks.
//
// A finding is a potential security issue generated either by AWS services
// (Amazon GuardDuty, Amazon Inspector, and Amazon Macie) or by the integrated
// third-party solutions and compliance checks.
type AwsSecurityFinding struct {
	_ struct{} `type:"structure"`

	// The AWS account ID that a finding is generated in.
	//
	// AwsAccountId is a required field
	AwsAccountId *string `type:"string" required:"true"`

	// This data type is exclusive to findings that are generated as the result
	// of a check run against a specific rule in a supported standard (for example,
	// CIS AWS Foundations). Contains compliance-related finding details.
	Compliance *Compliance `type:"structure"`

	// A finding's confidence. Confidence is defined as the likelihood that a finding
	// accurately identifies the behavior or issue that it was intended to identify.
	// Confidence is scored on a 0-100 basis using a ratio scale, where 0 means
	// zero percent confidence and 100 means 100 percent confidence.
	Confidence *int64 `type:"integer"`

	// An ISO8601-formatted timestamp that indicates when the security-findings
	// provider created the potential security issue that a finding captured.
	//
	// CreatedAt is a required field
	CreatedAt *string `type:"string" required:"true"`

	// The level of importance assigned to the resources associated with the finding.
	// A score of 0 means that the underlying resources have no criticality, and
	// a score of 100 is reserved for the most critical resources.
	Criticality *int64 `type:"integer"`

	// A finding's description.
	//
	// In this release, Description is a required property.
	//
	// Description is a required field
	Description *string `type:"string" required:"true"`

	// An ISO8601-formatted timestamp that indicates when the security-findings
	// provider first observed the potential security issue that a finding captured.
	FirstObservedAt *string `type:"string"`

	// The identifier for the solution-specific component (a discrete unit of logic)
	// that generated a finding. In various security-findings providers' solutions,
	// this generator can be called a rule, a check, a detector, a plug-in, etc.
	//
	// GeneratorId is a required field
	GeneratorId *string `type:"string" required:"true"`

	// The security findings provider-specific identifier for a finding.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`

	// An ISO8601-formatted timestamp that indicates when the security-findings
	// provider most recently observed the potential security issue that a finding
	// captured.
	LastObservedAt *string `type:"string"`

	// A list of malware related to a finding.
	Malware []Malware `type:"list"`

	// The details of network-related information about a finding.
	Network *Network `type:"structure"`

	// A user-defined note added to a finding.
	Note *Note `type:"structure"`

	// The details of process-related information about a finding.
	Process *ProcessDetails `type:"structure"`

	// The ARN generated by Security Hub that uniquely identifies a third-party
	// company (security-findings provider) after this provider's product (solution
	// that generates findings) is registered with Security Hub.
	//
	// ProductArn is a required field
	ProductArn *string `type:"string" required:"true"`

	// A data type where security-findings providers can include additional solution-specific
	// details that aren't part of the defined AwsSecurityFinding format.
	ProductFields map[string]string `type:"map"`

	// The record state of a finding.
	RecordState RecordState `type:"string" enum:"true"`

	// A list of related findings.
	RelatedFindings []RelatedFinding `type:"list"`

	// A data type that describes the remediation options for a finding.
	Remediation *Remediation `type:"structure"`

	// A set of resource data types that describe the resources that the finding
	// refers to.
	//
	// Resources is a required field
	Resources []Resource `type:"list" required:"true"`

	// The schema version that a finding is formatted for.
	//
	// SchemaVersion is a required field
	SchemaVersion *string `type:"string" required:"true"`

	// A finding's severity.
	//
	// Severity is a required field
	Severity *Severity `type:"structure" required:"true"`

	// A URL that links to a page about the current finding in the security-findings
	// provider's solution.
	SourceUrl *string `type:"string"`

	// Threat intel details related to a finding.
	ThreatIntelIndicators []ThreatIntelIndicator `type:"list"`

	// A finding's title.
	//
	// In this release, Title is a required property.
	//
	// Title is a required field
	Title *string `type:"string" required:"true"`

	// One or more finding types in the format of namespace/category/classifier
	// that classify a finding.
	//
	// Valid namespace values are: Software and Configuration Checks | TTPs | Effects
	// | Unusual Behaviors | Sensitive Data Identifications
	//
	// Types is a required field
	Types []string `type:"list" required:"true"`

	// An ISO8601-formatted timestamp that indicates when the security-findings
	// provider last updated the finding record.
	//
	// UpdatedAt is a required field
	UpdatedAt *string `type:"string" required:"true"`

	// A list of name/value string pairs associated with the finding. These are
	// custom, user-defined fields added to a finding.
	UserDefinedFields map[string]string `type:"map"`

	// Indicates the veracity of a finding.
	VerificationState VerificationState `type:"string" enum:"true"`

	// The workflow state of a finding.
	WorkflowState WorkflowState `type:"string" enum:"true"`
}

// String returns the string representation
func (s AwsSecurityFinding) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AwsSecurityFinding) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AwsSecurityFinding"}

	if s.AwsAccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AwsAccountId"))
	}

	if s.CreatedAt == nil {
		invalidParams.Add(aws.NewErrParamRequired("CreatedAt"))
	}

	if s.Description == nil {
		invalidParams.Add(aws.NewErrParamRequired("Description"))
	}

	if s.GeneratorId == nil {
		invalidParams.Add(aws.NewErrParamRequired("GeneratorId"))
	}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if s.ProductArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ProductArn"))
	}

	if s.Resources == nil {
		invalidParams.Add(aws.NewErrParamRequired("Resources"))
	}

	if s.SchemaVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaVersion"))
	}

	if s.Severity == nil {
		invalidParams.Add(aws.NewErrParamRequired("Severity"))
	}

	if s.Title == nil {
		invalidParams.Add(aws.NewErrParamRequired("Title"))
	}

	if s.Types == nil {
		invalidParams.Add(aws.NewErrParamRequired("Types"))
	}

	if s.UpdatedAt == nil {
		invalidParams.Add(aws.NewErrParamRequired("UpdatedAt"))
	}
	if s.Malware != nil {
		for i, v := range s.Malware {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Malware", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.Note != nil {
		if err := s.Note.Validate(); err != nil {
			invalidParams.AddNested("Note", err.(aws.ErrInvalidParams))
		}
	}
	if s.RelatedFindings != nil {
		for i, v := range s.RelatedFindings {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "RelatedFindings", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.Resources != nil {
		for i, v := range s.Resources {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Resources", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.Severity != nil {
		if err := s.Severity.Validate(); err != nil {
			invalidParams.AddNested("Severity", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsSecurityFinding) MarshalFields(e protocol.FieldEncoder) error {
	if s.AwsAccountId != nil {
		v := *s.AwsAccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AwsAccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Compliance != nil {
		v := s.Compliance

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Compliance", v, metadata)
	}
	if s.Confidence != nil {
		v := *s.Confidence

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Confidence", protocol.Int64Value(v), metadata)
	}
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Criticality != nil {
		v := *s.Criticality

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Criticality", protocol.Int64Value(v), metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FirstObservedAt != nil {
		v := *s.FirstObservedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FirstObservedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GeneratorId != nil {
		v := *s.GeneratorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GeneratorId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastObservedAt != nil {
		v := *s.LastObservedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastObservedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Malware != nil {
		v := s.Malware

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Malware", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Network != nil {
		v := s.Network

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Network", v, metadata)
	}
	if s.Note != nil {
		v := s.Note

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Note", v, metadata)
	}
	if s.Process != nil {
		v := s.Process

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Process", v, metadata)
	}
	if s.ProductArn != nil {
		v := *s.ProductArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ProductArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProductFields != nil {
		v := s.ProductFields

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "ProductFields", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.RecordState) > 0 {
		v := s.RecordState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecordState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RelatedFindings != nil {
		v := s.RelatedFindings

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RelatedFindings", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Remediation != nil {
		v := s.Remediation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Remediation", v, metadata)
	}
	if s.Resources != nil {
		v := s.Resources

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Resources", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SchemaVersion != nil {
		v := *s.SchemaVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Severity != nil {
		v := s.Severity

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Severity", v, metadata)
	}
	if s.SourceUrl != nil {
		v := *s.SourceUrl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SourceUrl", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThreatIntelIndicators != nil {
		v := s.ThreatIntelIndicators

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ThreatIntelIndicators", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Title != nil {
		v := *s.Title

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Title", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Types != nil {
		v := s.Types

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Types", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.UpdatedAt != nil {
		v := *s.UpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdatedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserDefinedFields != nil {
		v := s.UserDefinedFields

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "UserDefinedFields", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.VerificationState) > 0 {
		v := s.VerificationState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VerificationState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.WorkflowState) > 0 {
		v := s.WorkflowState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "WorkflowState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// A collection of attributes that are applied to all active Security Hub-aggregated
// findings and that result in a subset of findings that are included in this
// insight.
type AwsSecurityFindingFilters struct {
	_ struct{} `type:"structure"`

	// The AWS account ID that a finding is generated in.
	AwsAccountId []StringFilter `type:"list"`

	// The name of the findings provider (company) that owns the solution (product)
	// that generates findings.
	CompanyName []StringFilter `type:"list"`

	// Exclusive to findings that are generated as the result of a check run against
	// a specific rule in a supported standard (for example, CIS AWS Foundations).
	// Contains compliance-related finding details.
	ComplianceStatus []StringFilter `type:"list"`

	// A finding's confidence. Confidence is defined as the likelihood that a finding
	// accurately identifies the behavior or issue that it was intended to identify.
	// Confidence is scored on a 0-100 basis using a ratio scale, where 0 means
	// zero percent confidence and 100 means 100 percent confidence.
	Confidence []NumberFilter `type:"list"`

	// An ISO8601-formatted timestamp that indicates when the security-findings
	// provider captured the potential security issue that a finding captured.
	CreatedAt []DateFilter `type:"list"`

	// The level of importance assigned to the resources associated with the finding.
	// A score of 0 means that the underlying resources have no criticality, and
	// a score of 100 is reserved for the most critical resources.
	Criticality []NumberFilter `type:"list"`

	// A finding's description.
	Description []StringFilter `type:"list"`

	// An ISO8601-formatted timestamp that indicates when the security-findings
	// provider first observed the potential security issue that a finding captured.
	FirstObservedAt []DateFilter `type:"list"`

	// The identifier for the solution-specific component (a discrete unit of logic)
	// that generated a finding. In various security-findings providers' solutions,
	// this generator can be called a rule, a check, a detector, a plug-in, etc.
	GeneratorId []StringFilter `type:"list"`

	// The security findings provider-specific identifier for a finding.
	Id []StringFilter `type:"list"`

	// A keyword for a finding.
	Keyword []KeywordFilter `type:"list"`

	// An ISO8601-formatted timestamp that indicates when the security-findings
	// provider most recently observed the potential security issue that a finding
	// captured.
	LastObservedAt []DateFilter `type:"list"`

	// The name of the malware that was observed.
	MalwareName []StringFilter `type:"list"`

	// The filesystem path of the malware that was observed.
	MalwarePath []StringFilter `type:"list"`

	// The state of the malware that was observed.
	MalwareState []StringFilter `type:"list"`

	// The type of the malware that was observed.
	MalwareType []StringFilter `type:"list"`

	// The destination domain of network-related information about a finding.
	NetworkDestinationDomain []StringFilter `type:"list"`

	// The destination IPv4 address of network-related information about a finding.
	NetworkDestinationIpV4 []IpFilter `type:"list"`

	// The destination IPv6 address of network-related information about a finding.
	NetworkDestinationIpV6 []IpFilter `type:"list"`

	// The destination port of network-related information about a finding.
	NetworkDestinationPort []NumberFilter `type:"list"`

	// Indicates the direction of network traffic associated with a finding.
	NetworkDirection []StringFilter `type:"list"`

	// The protocol of network-related information about a finding.
	NetworkProtocol []StringFilter `type:"list"`

	// The source domain of network-related information about a finding.
	NetworkSourceDomain []StringFilter `type:"list"`

	// The source IPv4 address of network-related information about a finding.
	NetworkSourceIpV4 []IpFilter `type:"list"`

	// The source IPv6 address of network-related information about a finding.
	NetworkSourceIpV6 []IpFilter `type:"list"`

	// The source media access control (MAC) address of network-related information
	// about a finding.
	NetworkSourceMac []StringFilter `type:"list"`

	// The source port of network-related information about a finding.
	NetworkSourcePort []NumberFilter `type:"list"`

	// The text of a note.
	NoteText []StringFilter `type:"list"`

	// The timestamp of when the note was updated.
	NoteUpdatedAt []DateFilter `type:"list"`

	// The principal that created a note.
	NoteUpdatedBy []StringFilter `type:"list"`

	// The date/time that the process was launched.
	ProcessLaunchedAt []DateFilter `type:"list"`

	// The name of the process.
	ProcessName []StringFilter `type:"list"`

	// The parent process ID.
	ProcessParentPid []NumberFilter `type:"list"`

	// The path to the process executable.
	ProcessPath []StringFilter `type:"list"`

	// The process ID.
	ProcessPid []NumberFilter `type:"list"`

	// The date/time that the process was terminated.
	ProcessTerminatedAt []DateFilter `type:"list"`

	// The ARN generated by Security Hub that uniquely identifies a third-party
	// company (security findings provider) after this provider's product (solution
	// that generates findings) is registered with Security Hub.
	ProductArn []StringFilter `type:"list"`

	// A data type where security-findings providers can include additional solution-specific
	// details that aren't part of the defined AwsSecurityFinding format.
	ProductFields []MapFilter `type:"list"`

	// The name of the solution (product) that generates findings.
	ProductName []StringFilter `type:"list"`

	// The recommendation of what to do about the issue described in a finding.
	RecommendationText []StringFilter `type:"list"`

	// The updated record state for the finding.
	RecordState []StringFilter `type:"list"`

	// The solution-generated identifier for a related finding.
	RelatedFindingsId []StringFilter `type:"list"`

	// The ARN of the solution that generated a related finding.
	RelatedFindingsProductArn []StringFilter `type:"list"`

	// The IAM profile ARN of the instance.
	ResourceAwsEc2InstanceIamInstanceProfileArn []StringFilter `type:"list"`

	// The Amazon Machine Image (AMI) ID of the instance.
	ResourceAwsEc2InstanceImageId []StringFilter `type:"list"`

	// The IPv4 addresses associated with the instance.
	ResourceAwsEc2InstanceIpV4Addresses []IpFilter `type:"list"`

	// The IPv6 addresses associated with the instance.
	ResourceAwsEc2InstanceIpV6Addresses []IpFilter `type:"list"`

	// The key name associated with the instance.
	ResourceAwsEc2InstanceKeyName []StringFilter `type:"list"`

	// The date/time the instance was launched.
	ResourceAwsEc2InstanceLaunchedAt []DateFilter `type:"list"`

	// The identifier of the subnet that the instance was launched in.
	ResourceAwsEc2InstanceSubnetId []StringFilter `type:"list"`

	// The instance type of the instance.
	ResourceAwsEc2InstanceType []StringFilter `type:"list"`

	// The identifier of the VPC that the instance was launched in.
	ResourceAwsEc2InstanceVpcId []StringFilter `type:"list"`

	// The creation date/time of the IAM access key related to a finding.
	ResourceAwsIamAccessKeyCreatedAt []DateFilter `type:"list"`

	// The status of the IAM access key related to a finding.
	ResourceAwsIamAccessKeyStatus []StringFilter `type:"list"`

	// The user associated with the IAM access key related to a finding.
	ResourceAwsIamAccessKeyUserName []StringFilter `type:"list"`

	// The canonical user ID of the owner of the S3 bucket.
	ResourceAwsS3BucketOwnerId []StringFilter `type:"list"`

	// The display name of the owner of the S3 bucket.
	ResourceAwsS3BucketOwnerName []StringFilter `type:"list"`

	// The identifier of the image related to a finding.
	ResourceContainerImageId []StringFilter `type:"list"`

	// The name of the image related to a finding.
	ResourceContainerImageName []StringFilter `type:"list"`

	// The date/time that the container was started.
	ResourceContainerLaunchedAt []DateFilter `type:"list"`

	// The name of the container related to a finding.
	ResourceContainerName []StringFilter `type:"list"`

	// The details of a resource that doesn't have a specific subfield for the resource
	// type defined.
	ResourceDetailsOther []MapFilter `type:"list"`

	// The canonical identifier for the given resource type.
	ResourceId []StringFilter `type:"list"`

	// The canonical AWS partition name that the Region is assigned to.
	ResourcePartition []StringFilter `type:"list"`

	// The canonical AWS external Region name where this resource is located.
	ResourceRegion []StringFilter `type:"list"`

	// A list of AWS tags associated with a resource at the time the finding was
	// processed.
	ResourceTags []MapFilter `type:"list"`

	// Specifies the type of the resource that details are provided for.
	ResourceType []StringFilter `type:"list"`

	// The label of a finding's severity.
	SeverityLabel []StringFilter `type:"list"`

	// The normalized severity of a finding.
	SeverityNormalized []NumberFilter `type:"list"`

	// The native severity as defined by the security-findings provider's solution
	// that generated the finding.
	SeverityProduct []NumberFilter `type:"list"`

	// A URL that links to a page about the current finding in the security-findings
	// provider's solution.
	SourceUrl []StringFilter `type:"list"`

	// The category of a threat intel indicator.
	ThreatIntelIndicatorCategory []StringFilter `type:"list"`

	// The date/time of the last observation of a threat intel indicator.
	ThreatIntelIndicatorLastObservedAt []DateFilter `type:"list"`

	// The source of the threat intel.
	ThreatIntelIndicatorSource []StringFilter `type:"list"`

	// The URL for more details from the source of the threat intel.
	ThreatIntelIndicatorSourceUrl []StringFilter `type:"list"`

	// The type of a threat intel indicator.
	ThreatIntelIndicatorType []StringFilter `type:"list"`

	// The value of a threat intel indicator.
	ThreatIntelIndicatorValue []StringFilter `type:"list"`

	// A finding's title.
	Title []StringFilter `type:"list"`

	// A finding type in the format of namespace/category/classifier that classifies
	// a finding.
	Type []StringFilter `type:"list"`

	// An ISO8601-formatted timestamp that indicates when the security-findings
	// provider last updated the finding record.
	UpdatedAt []DateFilter `type:"list"`

	// A list of name/value string pairs associated with the finding. These are
	// custom, user-defined fields added to a finding.
	UserDefinedFields []MapFilter `type:"list"`

	// The veracity of a finding.
	VerificationState []StringFilter `type:"list"`

	// The workflow state of a finding.
	WorkflowState []StringFilter `type:"list"`
}

// String returns the string representation
func (s AwsSecurityFindingFilters) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsSecurityFindingFilters) MarshalFields(e protocol.FieldEncoder) error {
	if s.AwsAccountId != nil {
		v := s.AwsAccountId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AwsAccountId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.CompanyName != nil {
		v := s.CompanyName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "CompanyName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ComplianceStatus != nil {
		v := s.ComplianceStatus

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ComplianceStatus", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Confidence != nil {
		v := s.Confidence

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Confidence", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.CreatedAt != nil {
		v := s.CreatedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "CreatedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Criticality != nil {
		v := s.Criticality

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Criticality", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Description != nil {
		v := s.Description

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Description", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.FirstObservedAt != nil {
		v := s.FirstObservedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FirstObservedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.GeneratorId != nil {
		v := s.GeneratorId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "GeneratorId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Id != nil {
		v := s.Id

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Id", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Keyword != nil {
		v := s.Keyword

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Keyword", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.LastObservedAt != nil {
		v := s.LastObservedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "LastObservedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.MalwareName != nil {
		v := s.MalwareName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "MalwareName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.MalwarePath != nil {
		v := s.MalwarePath

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "MalwarePath", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.MalwareState != nil {
		v := s.MalwareState

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "MalwareState", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.MalwareType != nil {
		v := s.MalwareType

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "MalwareType", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkDestinationDomain != nil {
		v := s.NetworkDestinationDomain

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkDestinationDomain", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkDestinationIpV4 != nil {
		v := s.NetworkDestinationIpV4

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkDestinationIpV4", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkDestinationIpV6 != nil {
		v := s.NetworkDestinationIpV6

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkDestinationIpV6", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkDestinationPort != nil {
		v := s.NetworkDestinationPort

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkDestinationPort", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkDirection != nil {
		v := s.NetworkDirection

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkDirection", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkProtocol != nil {
		v := s.NetworkProtocol

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkProtocol", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkSourceDomain != nil {
		v := s.NetworkSourceDomain

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkSourceDomain", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkSourceIpV4 != nil {
		v := s.NetworkSourceIpV4

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkSourceIpV4", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkSourceIpV6 != nil {
		v := s.NetworkSourceIpV6

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkSourceIpV6", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkSourceMac != nil {
		v := s.NetworkSourceMac

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkSourceMac", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NetworkSourcePort != nil {
		v := s.NetworkSourcePort

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NetworkSourcePort", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NoteText != nil {
		v := s.NoteText

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NoteText", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NoteUpdatedAt != nil {
		v := s.NoteUpdatedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NoteUpdatedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NoteUpdatedBy != nil {
		v := s.NoteUpdatedBy

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NoteUpdatedBy", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProcessLaunchedAt != nil {
		v := s.ProcessLaunchedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProcessLaunchedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProcessName != nil {
		v := s.ProcessName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProcessName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProcessParentPid != nil {
		v := s.ProcessParentPid

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProcessParentPid", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProcessPath != nil {
		v := s.ProcessPath

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProcessPath", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProcessPid != nil {
		v := s.ProcessPid

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProcessPid", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProcessTerminatedAt != nil {
		v := s.ProcessTerminatedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProcessTerminatedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProductArn != nil {
		v := s.ProductArn

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProductArn", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProductFields != nil {
		v := s.ProductFields

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProductFields", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ProductName != nil {
		v := s.ProductName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProductName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RecommendationText != nil {
		v := s.RecommendationText

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RecommendationText", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RecordState != nil {
		v := s.RecordState

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RecordState", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RelatedFindingsId != nil {
		v := s.RelatedFindingsId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RelatedFindingsId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RelatedFindingsProductArn != nil {
		v := s.RelatedFindingsProductArn

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RelatedFindingsProductArn", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceIamInstanceProfileArn != nil {
		v := s.ResourceAwsEc2InstanceIamInstanceProfileArn

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceIamInstanceProfileArn", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceImageId != nil {
		v := s.ResourceAwsEc2InstanceImageId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceImageId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceIpV4Addresses != nil {
		v := s.ResourceAwsEc2InstanceIpV4Addresses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceIpV4Addresses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceIpV6Addresses != nil {
		v := s.ResourceAwsEc2InstanceIpV6Addresses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceIpV6Addresses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceKeyName != nil {
		v := s.ResourceAwsEc2InstanceKeyName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceKeyName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceLaunchedAt != nil {
		v := s.ResourceAwsEc2InstanceLaunchedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceLaunchedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceSubnetId != nil {
		v := s.ResourceAwsEc2InstanceSubnetId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceSubnetId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceType != nil {
		v := s.ResourceAwsEc2InstanceType

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceType", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsEc2InstanceVpcId != nil {
		v := s.ResourceAwsEc2InstanceVpcId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsEc2InstanceVpcId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsIamAccessKeyCreatedAt != nil {
		v := s.ResourceAwsIamAccessKeyCreatedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsIamAccessKeyCreatedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsIamAccessKeyStatus != nil {
		v := s.ResourceAwsIamAccessKeyStatus

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsIamAccessKeyStatus", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsIamAccessKeyUserName != nil {
		v := s.ResourceAwsIamAccessKeyUserName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsIamAccessKeyUserName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsS3BucketOwnerId != nil {
		v := s.ResourceAwsS3BucketOwnerId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsS3BucketOwnerId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceAwsS3BucketOwnerName != nil {
		v := s.ResourceAwsS3BucketOwnerName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceAwsS3BucketOwnerName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceContainerImageId != nil {
		v := s.ResourceContainerImageId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceContainerImageId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceContainerImageName != nil {
		v := s.ResourceContainerImageName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceContainerImageName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceContainerLaunchedAt != nil {
		v := s.ResourceContainerLaunchedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceContainerLaunchedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceContainerName != nil {
		v := s.ResourceContainerName

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceContainerName", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceDetailsOther != nil {
		v := s.ResourceDetailsOther

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceDetailsOther", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceId != nil {
		v := s.ResourceId

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceId", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourcePartition != nil {
		v := s.ResourcePartition

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourcePartition", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceRegion != nil {
		v := s.ResourceRegion

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceRegion", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceTags != nil {
		v := s.ResourceTags

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceTags", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceType != nil {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceType", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SeverityLabel != nil {
		v := s.SeverityLabel

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SeverityLabel", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SeverityNormalized != nil {
		v := s.SeverityNormalized

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SeverityNormalized", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SeverityProduct != nil {
		v := s.SeverityProduct

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SeverityProduct", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SourceUrl != nil {
		v := s.SourceUrl

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SourceUrl", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ThreatIntelIndicatorCategory != nil {
		v := s.ThreatIntelIndicatorCategory

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ThreatIntelIndicatorCategory", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ThreatIntelIndicatorLastObservedAt != nil {
		v := s.ThreatIntelIndicatorLastObservedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ThreatIntelIndicatorLastObservedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ThreatIntelIndicatorSource != nil {
		v := s.ThreatIntelIndicatorSource

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ThreatIntelIndicatorSource", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ThreatIntelIndicatorSourceUrl != nil {
		v := s.ThreatIntelIndicatorSourceUrl

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ThreatIntelIndicatorSourceUrl", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ThreatIntelIndicatorType != nil {
		v := s.ThreatIntelIndicatorType

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ThreatIntelIndicatorType", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ThreatIntelIndicatorValue != nil {
		v := s.ThreatIntelIndicatorValue

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ThreatIntelIndicatorValue", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Title != nil {
		v := s.Title

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Title", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Type != nil {
		v := s.Type

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Type", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.UpdatedAt != nil {
		v := s.UpdatedAt

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UpdatedAt", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.UserDefinedFields != nil {
		v := s.UserDefinedFields

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UserDefinedFields", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.VerificationState != nil {
		v := s.VerificationState

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "VerificationState", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.WorkflowState != nil {
		v := s.WorkflowState

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "WorkflowState", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A wrapper type for the topic's Amazon Resource Name (ARN).
type AwsSnsTopicDetails struct {
	_ struct{} `type:"structure"`

	// The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom
	// CMK.
	KmsMasterKeyId *string `type:"string"`

	// The subscription's owner.
	Owner *string `type:"string"`

	// Subscription is an embedded property that describes the subscription endpoints
	// of an Amazon SNS topic.
	Subscription []AwsSnsTopicSubscription `type:"list"`

	// The name of the topic.
	TopicName *string `type:"string"`
}

// String returns the string representation
func (s AwsSnsTopicDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsSnsTopicDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.KmsMasterKeyId != nil {
		v := *s.KmsMasterKeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KmsMasterKeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Owner != nil {
		v := *s.Owner

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Owner", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Subscription != nil {
		v := s.Subscription

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Subscription", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.TopicName != nil {
		v := *s.TopicName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TopicName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A wrapper type for the attributes of an Amazon SNS subscription.
type AwsSnsTopicSubscription struct {
	_ struct{} `type:"structure"`

	// The subscription's endpoint (format depends on the protocol).
	Endpoint *string `type:"string"`

	// The subscription's protocol.
	Protocol *string `type:"string"`
}

// String returns the string representation
func (s AwsSnsTopicSubscription) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsSnsTopicSubscription) MarshalFields(e protocol.FieldEncoder) error {
	if s.Endpoint != nil {
		v := *s.Endpoint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Endpoint", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Protocol != nil {
		v := *s.Protocol

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Protocol", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Data about a queue.
type AwsSqsQueueDetails struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the dead-letter queue to which Amazon SQS
	// moves messages after the value of maxReceiveCount is exceeded.
	DeadLetterTargetArn *string `type:"string"`

	// The length of time, in seconds, for which Amazon SQS can reuse a data key
	// to encrypt or decrypt messages before calling AWS KMS again.
	KmsDataKeyReusePeriodSeconds *int64 `type:"integer"`

	// The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom
	// CMK.
	KmsMasterKeyId *string `type:"string"`

	// The name of the new queue.
	QueueName *string `type:"string"`
}

// String returns the string representation
func (s AwsSqsQueueDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AwsSqsQueueDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.DeadLetterTargetArn != nil {
		v := *s.DeadLetterTargetArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DeadLetterTargetArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KmsDataKeyReusePeriodSeconds != nil {
		v := *s.KmsDataKeyReusePeriodSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KmsDataKeyReusePeriodSeconds", protocol.Int64Value(v), metadata)
	}
	if s.KmsMasterKeyId != nil {
		v := *s.KmsMasterKeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KmsMasterKeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.QueueName != nil {
		v := *s.QueueName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QueueName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Exclusive to findings that are generated as the result of a check run against
// a specific rule in a supported standard (for example, CIS AWS Foundations).
// Contains compliance-related finding details.
//
// Values include the following:
//
//    * Allowed values are the following: PASSED - Compliance check passed for
//    all evaluated resources. WARNING - Some information is missing or this
//    check is not supported given your configuration. FAILED - Compliance check
//    failed for at least one evaluated resource. NOT_AVAILABLE - Check could
//    not be performed due to a service outage or API error.
type Compliance struct {
	_ struct{} `type:"structure"`

	// The result of a compliance check.
	Status ComplianceStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s Compliance) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Compliance) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Container details related to a finding.
type ContainerDetails struct {
	_ struct{} `type:"structure"`

	// The identifier of the image related to a finding.
	ImageId *string `type:"string"`

	// The name of the image related to a finding.
	ImageName *string `type:"string"`

	// The date and time when the container started.
	LaunchedAt *string `type:"string"`

	// The name of the container related to a finding.
	Name *string `type:"string"`
}

// String returns the string representation
func (s ContainerDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ContainerDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.ImageId != nil {
		v := *s.ImageId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ImageId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ImageName != nil {
		v := *s.ImageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ImageName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LaunchedAt != nil {
		v := *s.LaunchedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LaunchedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A date filter for querying findings.
type DateFilter struct {
	_ struct{} `type:"structure"`

	// A date range for the date filter.
	DateRange *DateRange `type:"structure"`

	// An end date for the date filter.
	End *string `type:"string"`

	// A start date for the date filter.
	Start *string `type:"string"`
}

// String returns the string representation
func (s DateFilter) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DateFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.DateRange != nil {
		v := s.DateRange

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DateRange", v, metadata)
	}
	if s.End != nil {
		v := *s.End

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "End", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Start != nil {
		v := *s.Start

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Start", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A date range for the date filter.
type DateRange struct {
	_ struct{} `type:"structure"`

	// A date range unit for the date filter.
	Unit DateRangeUnit `type:"string" enum:"true"`

	// A date range value for the date filter.
	Value *int64 `type:"integer"`
}

// String returns the string representation
func (s DateRange) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DateRange) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Unit) > 0 {
		v := s.Unit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Unit", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Includes details of the list of the findings that can't be imported.
type ImportFindingsError struct {
	_ struct{} `type:"structure"`

	// The code of the error made during the BatchImportFindings operation.
	//
	// ErrorCode is a required field
	ErrorCode *string `type:"string" required:"true"`

	// The message of the error made during the BatchImportFindings operation.
	//
	// ErrorMessage is a required field
	ErrorMessage *string `type:"string" required:"true"`

	// The ID of the error made during the BatchImportFindings operation.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`
}

// String returns the string representation
func (s ImportFindingsError) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ImportFindingsError) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorCode != nil {
		v := *s.ErrorCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ErrorCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ErrorMessage != nil {
		v := *s.ErrorMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ErrorMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains information about a Security Hub insight.
type Insight struct {
	_ struct{} `type:"structure"`

	// One or more attributes used to filter the findings included in the insight.
	// Only findings that match the criteria defined in the filters are included
	// in the insight.
	//
	// Filters is a required field
	Filters *AwsSecurityFindingFilters `type:"structure" required:"true"`

	// The attribute that the insight's findings are grouped by. This attribute
	// is used as a findings aggregator for the purposes of viewing and managing
	// multiple related findings under a single operand.
	//
	// GroupByAttribute is a required field
	GroupByAttribute *string `type:"string" required:"true"`

	// The ARN of a Security Hub insight.
	//
	// InsightArn is a required field
	InsightArn *string `type:"string" required:"true"`

	// The name of a Security Hub insight.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Insight) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Insight) MarshalFields(e protocol.FieldEncoder) error {
	if s.Filters != nil {
		v := s.Filters

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Filters", v, metadata)
	}
	if s.GroupByAttribute != nil {
		v := *s.GroupByAttribute

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupByAttribute", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InsightArn != nil {
		v := *s.InsightArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InsightArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The insight result values returned by the GetInsightResults operation.
type InsightResultValue struct {
	_ struct{} `type:"structure"`

	// The number of findings returned for each GroupByAttributeValue.
	//
	// Count is a required field
	Count *int64 `type:"integer" required:"true"`

	// The value of the attribute that the findings are grouped by for the insight
	// whose results are returned by the GetInsightResults operation.
	//
	// GroupByAttributeValue is a required field
	GroupByAttributeValue *string `type:"string" required:"true"`
}

// String returns the string representation
func (s InsightResultValue) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InsightResultValue) MarshalFields(e protocol.FieldEncoder) error {
	if s.Count != nil {
		v := *s.Count

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Count", protocol.Int64Value(v), metadata)
	}
	if s.GroupByAttributeValue != nil {
		v := *s.GroupByAttributeValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupByAttributeValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The insight results returned by the GetInsightResults operation.
type InsightResults struct {
	_ struct{} `type:"structure"`

	// The attribute that the findings are grouped by for the insight whose results
	// are returned by the GetInsightResults operation.
	//
	// GroupByAttribute is a required field
	GroupByAttribute *string `type:"string" required:"true"`

	// The ARN of the insight whose results are returned by the GetInsightResults
	// operation.
	//
	// InsightArn is a required field
	InsightArn *string `type:"string" required:"true"`

	// The list of insight result values returned by the GetInsightResults operation.
	//
	// ResultValues is a required field
	ResultValues []InsightResultValue `type:"list" required:"true"`
}

// String returns the string representation
func (s InsightResults) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InsightResults) MarshalFields(e protocol.FieldEncoder) error {
	if s.GroupByAttribute != nil {
		v := *s.GroupByAttribute

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupByAttribute", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InsightArn != nil {
		v := *s.InsightArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InsightArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResultValues != nil {
		v := s.ResultValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResultValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Details about an invitation.
type Invitation struct {
	_ struct{} `type:"structure"`

	// The account ID of the Security Hub master account that the invitation was
	// sent from.
	AccountId *string `type:"string"`

	// The ID of the invitation sent to the member account.
	InvitationId *string `type:"string"`

	// The timestamp of when the invitation was sent.
	InvitedAt *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// The current status of the association between member and master accounts.
	MemberStatus *string `type:"string"`
}

// String returns the string representation
func (s Invitation) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Invitation) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InvitationId != nil {
		v := *s.InvitationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InvitationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InvitedAt != nil {
		v := *s.InvitedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InvitedAt",
			protocol.TimeValue{V: v, Format: "iso8601", QuotedFormatTime: true}, metadata)
	}
	if s.MemberStatus != nil {
		v := *s.MemberStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MemberStatus", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The IP filter for querying findings.
type IpFilter struct {
	_ struct{} `type:"structure"`

	// A finding's CIDR value.
	Cidr *string `type:"string"`
}

// String returns the string representation
func (s IpFilter) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s IpFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.Cidr != nil {
		v := *s.Cidr

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Cidr", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A keyword filter for querying findings.
type KeywordFilter struct {
	_ struct{} `type:"structure"`

	// A value for the keyword.
	Value *string `type:"string"`
}

// String returns the string representation
func (s KeywordFilter) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s KeywordFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about the state of the load balancer.
type LoadBalancerState struct {
	_ struct{} `type:"structure"`

	// The state code. The initial state of the load balancer is provisioning. After
	// the load balancer is fully set up and ready to route traffic, its state is
	// active. If the load balancer could not be set up, its state is failed.
	Code *string `type:"string"`

	// A description of the state.
	Reason *string `type:"string"`
}

// String returns the string representation
func (s LoadBalancerState) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LoadBalancerState) MarshalFields(e protocol.FieldEncoder) error {
	if s.Code != nil {
		v := *s.Code

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Reason != nil {
		v := *s.Reason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Reason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A list of malware related to a finding.
type Malware struct {
	_ struct{} `type:"structure"`

	// The name of the malware that was observed.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The file system path of the malware that was observed.
	Path *string `type:"string"`

	// The state of the malware that was observed.
	State MalwareState `type:"string" enum:"true"`

	// The type of the malware that was observed.
	Type MalwareType `type:"string" enum:"true"`
}

// String returns the string representation
func (s Malware) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Malware) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Malware"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Malware) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The map filter for querying findings.
type MapFilter struct {
	_ struct{} `type:"structure"`

	// The condition to apply to a key value when querying for findings with a map
	// filter.
	Comparison MapFilterComparison `type:"string" enum:"true"`

	// The key of the map filter.
	Key *string `type:"string"`

	// The value for the key in the map filter.
	Value *string `type:"string"`
}

// String returns the string representation
func (s MapFilter) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MapFilter) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Comparison) > 0 {
		v := s.Comparison

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Comparison", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The details about a member account.
type Member struct {
	_ struct{} `type:"structure"`

	// The AWS account ID of the member account.
	AccountId *string `type:"string"`

	// The email address of the member account.
	Email *string `type:"string"`

	// A timestamp for the date and time when the invitation was sent to the member
	// account.
	InvitedAt *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// The AWS account ID of the Security Hub master account associated with this
	// member account.
	MasterId *string `type:"string"`

	// The status of the relationship between the member account and its master
	// account.
	MemberStatus *string `type:"string"`

	// The timestamp for the date and time when the member account was updated.
	UpdatedAt *time.Time `type:"timestamp" timestampFormat:"iso8601"`
}

// String returns the string representation
func (s Member) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Member) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Email != nil {
		v := *s.Email

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Email", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InvitedAt != nil {
		v := *s.InvitedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InvitedAt",
			protocol.TimeValue{V: v, Format: "iso8601", QuotedFormatTime: true}, metadata)
	}
	if s.MasterId != nil {
		v := *s.MasterId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MasterId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MemberStatus != nil {
		v := *s.MemberStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MemberStatus", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UpdatedAt != nil {
		v := *s.UpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdatedAt",
			protocol.TimeValue{V: v, Format: "iso8601", QuotedFormatTime: true}, metadata)
	}
	return nil
}

// The details of network-related information about a finding.
type Network struct {
	_ struct{} `type:"structure"`

	// The destination domain of network-related information about a finding.
	DestinationDomain *string `type:"string"`

	// The destination IPv4 address of network-related information about a finding.
	DestinationIpV4 *string `type:"string"`

	// The destination IPv6 address of network-related information about a finding.
	DestinationIpV6 *string `type:"string"`

	// The destination port of network-related information about a finding.
	DestinationPort *int64 `type:"integer"`

	// The direction of network traffic associated with a finding.
	Direction NetworkDirection `type:"string" enum:"true"`

	// The protocol of network-related information about a finding.
	Protocol *string `type:"string"`

	// The source domain of network-related information about a finding.
	SourceDomain *string `type:"string"`

	// The source IPv4 address of network-related information about a finding.
	SourceIpV4 *string `type:"string"`

	// The source IPv6 address of network-related information about a finding.
	SourceIpV6 *string `type:"string"`

	// The source media access control (MAC) address of network-related information
	// about a finding.
	SourceMac *string `type:"string"`

	// The source port of network-related information about a finding.
	SourcePort *int64 `type:"integer"`
}

// String returns the string representation
func (s Network) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Network) MarshalFields(e protocol.FieldEncoder) error {
	if s.DestinationDomain != nil {
		v := *s.DestinationDomain

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DestinationDomain", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DestinationIpV4 != nil {
		v := *s.DestinationIpV4

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DestinationIpV4", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DestinationIpV6 != nil {
		v := *s.DestinationIpV6

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DestinationIpV6", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DestinationPort != nil {
		v := *s.DestinationPort

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DestinationPort", protocol.Int64Value(v), metadata)
	}
	if len(s.Direction) > 0 {
		v := s.Direction

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Direction", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Protocol != nil {
		v := *s.Protocol

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Protocol", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SourceDomain != nil {
		v := *s.SourceDomain

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SourceDomain", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SourceIpV4 != nil {
		v := *s.SourceIpV4

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SourceIpV4", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SourceIpV6 != nil {
		v := *s.SourceIpV6

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SourceIpV6", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SourceMac != nil {
		v := *s.SourceMac

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SourceMac", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SourcePort != nil {
		v := *s.SourcePort

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SourcePort", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A user-defined note added to a finding.
type Note struct {
	_ struct{} `type:"structure"`

	// The text of a note.
	//
	// Text is a required field
	Text *string `type:"string" required:"true"`

	// The timestamp of when the note was updated.
	//
	// UpdatedAt is a required field
	UpdatedAt *string `type:"string" required:"true"`

	// The principal that created a note.
	//
	// UpdatedBy is a required field
	UpdatedBy *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Note) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Note) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Note"}

	if s.Text == nil {
		invalidParams.Add(aws.NewErrParamRequired("Text"))
	}

	if s.UpdatedAt == nil {
		invalidParams.Add(aws.NewErrParamRequired("UpdatedAt"))
	}

	if s.UpdatedBy == nil {
		invalidParams.Add(aws.NewErrParamRequired("UpdatedBy"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Note) MarshalFields(e protocol.FieldEncoder) error {
	if s.Text != nil {
		v := *s.Text

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Text", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UpdatedAt != nil {
		v := *s.UpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdatedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UpdatedBy != nil {
		v := *s.UpdatedBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdatedBy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The updated note.
type NoteUpdate struct {
	_ struct{} `type:"structure"`

	// The updated note text.
	//
	// Text is a required field
	Text *string `type:"string" required:"true"`

	// The principal that updated the note.
	//
	// UpdatedBy is a required field
	UpdatedBy *string `type:"string" required:"true"`
}

// String returns the string representation
func (s NoteUpdate) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *NoteUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "NoteUpdate"}

	if s.Text == nil {
		invalidParams.Add(aws.NewErrParamRequired("Text"))
	}

	if s.UpdatedBy == nil {
		invalidParams.Add(aws.NewErrParamRequired("UpdatedBy"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NoteUpdate) MarshalFields(e protocol.FieldEncoder) error {
	if s.Text != nil {
		v := *s.Text

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Text", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UpdatedBy != nil {
		v := *s.UpdatedBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdatedBy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A number filter for querying findings.
type NumberFilter struct {
	_ struct{} `type:"structure"`

	// The equal-to condition to be applied to a single field when querying for
	// findings.
	Eq *float64 `type:"double"`

	// The greater-than-equal condition to be applied to a single field when querying
	// for findings.
	Gte *float64 `type:"double"`

	// The less-than-equal condition to be applied to a single field when querying
	// for findings.
	Lte *float64 `type:"double"`
}

// String returns the string representation
func (s NumberFilter) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NumberFilter) MarshalFields(e protocol.FieldEncoder) error {
	if s.Eq != nil {
		v := *s.Eq

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Eq", protocol.Float64Value(v), metadata)
	}
	if s.Gte != nil {
		v := *s.Gte

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Gte", protocol.Float64Value(v), metadata)
	}
	if s.Lte != nil {
		v := *s.Lte

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Lte", protocol.Float64Value(v), metadata)
	}
	return nil
}

// The details of process-related information about a finding.
type ProcessDetails struct {
	_ struct{} `type:"structure"`

	// The date/time that the process was launched.
	LaunchedAt *string `type:"string"`

	// The name of the process.
	Name *string `type:"string"`

	// The parent process ID.
	ParentPid *int64 `type:"integer"`

	// The path to the process executable.
	Path *string `type:"string"`

	// The process ID.
	Pid *int64 `type:"integer"`

	// The date and time when the process was terminated.
	TerminatedAt *string `type:"string"`
}

// String returns the string representation
func (s ProcessDetails) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ProcessDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.LaunchedAt != nil {
		v := *s.LaunchedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LaunchedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentPid != nil {
		v := *s.ParentPid

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentPid", protocol.Int64Value(v), metadata)
	}
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Pid != nil {
		v := *s.Pid

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Pid", protocol.Int64Value(v), metadata)
	}
	if s.TerminatedAt != nil {
		v := *s.TerminatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TerminatedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains details about a product.
type Product struct {
	_ struct{} `type:"structure"`

	// The URL used to activate the product.
	ActivationUrl *string `type:"string"`

	// The categories assigned to the product.
	Categories []string `type:"list"`

	// The name of the company that provides the product.
	CompanyName *string `type:"string"`

	// A description of the product.
	Description *string `type:"string"`

	// The URL for the page that contains more information about the product.
	MarketplaceUrl *string `type:"string"`

	// The ARN assigned to the product.
	//
	// ProductArn is a required field
	ProductArn *string `type:"string" required:"true"`

	// The name of the product.
	ProductName *string `type:"string"`

	// The resource policy associated with the product.
	ProductSubscriptionResourcePolicy *string `type:"string"`
}

// String returns the string representation
func (s Product) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Product) MarshalFields(e protocol.FieldEncoder) error {
	if s.ActivationUrl != nil {
		v := *s.ActivationUrl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ActivationUrl", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Categories != nil {
		v := s.Categories

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Categories", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.CompanyName != nil {
		v := *s.CompanyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompanyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MarketplaceUrl != nil {
		v := *s.MarketplaceUrl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MarketplaceUrl", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProductArn != nil {
		v := *s.ProductArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ProductArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProductName != nil {
		v := *s.ProductName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ProductName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProductSubscriptionResourcePolicy != nil {
		v := *s.ProductSubscriptionResourcePolicy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ProductSubscriptionResourcePolicy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A recommendation on how to remediate the issue identified in a finding.
type Recommendation struct {
	_ struct{} `type:"structure"`

	// Describes the recommended steps to take to remediate an issue identified
	// in a finding.
	Text *string `type:"string"`

	// A URL to a page or site that contains information about how to remediate
	// a finding.
	Url *string `type:"string"`
}

// String returns the string representation
func (s Recommendation) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Recommendation) MarshalFields(e protocol.FieldEncoder) error {
	if s.Text != nil {
		v := *s.Text

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Text", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Details about a related finding.
type RelatedFinding struct {
	_ struct{} `type:"structure"`

	// The product-generated identifier for a related finding.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`

	// The ARN of the product that generated a related finding.
	//
	// ProductArn is a required field
	ProductArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s RelatedFinding) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RelatedFinding) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RelatedFinding"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if s.ProductArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ProductArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RelatedFinding) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProductArn != nil {
		v := *s.ProductArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ProductArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Details about the remediation steps for a finding.
type Remediation struct {
	_ struct{} `type:"structure"`

	// A recommendation on the steps to take to remediate the issue identified by
	// a finding.
	Recommendation *Recommendation `type:"structure"`
}

// String returns the string representation
func (s Remediation) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Remediation) MarshalFields(e protocol.FieldEncoder) error {
	if s.Recommendation != nil {
		v := s.Recommendation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Recommendation", v, metadata)
	}
	return nil
}

// A resource related to a finding.
type Resource struct {
	_ struct{} `type:"structure"`

	// Additional details about the resource related to a finding.
	Details *ResourceDetails `type:"structure"`

	// The canonical identifier for the given resource type.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`

	// The canonical AWS partition name that the Region is assigned to.
	Partition Partition `type:"string" enum:"true"`

	// The canonical AWS external Region name where this resource is located.
	Region *string `type:"string"`

	// A list of AWS tags associated with a resource at the time the finding was
	// processed.
	Tags map[string]string `type:"map"`

	// The type of the resource that details are provided for.
	//
	// Type is a required field
	Type *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Resource) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Resource) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Resource"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if s.Type == nil {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}
	if s.Details != nil {
		if err := s.Details.Validate(); err != nil {
			invalidParams.AddNested("Details", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Resource) MarshalFields(e protocol.FieldEncoder) error {
	if s.Details != nil {
		v := s.Details

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Details", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Partition) > 0 {
		v := s.Partition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Partition", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Region != nil {
		v := *s.Region

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Region", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Tags != nil {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Additional details about a resource related to a finding.
type ResourceDetails struct {
	_ struct{} `type:"structure"`

	// Details about a CloudFront distribution.
	AwsCloudFrontDistribution *AwsCloudFrontDistributionDetails `type:"structure"`

	// Details about an Amazon EC2 instance related to a finding.
	AwsEc2Instance *AwsEc2InstanceDetails `type:"structure"`

	// Details about a load balancer.
	AwsElbv2LoadBalancer *AwsElbv2LoadBalancerDetails `type:"structure"`

	// Details about an IAM access key related to a finding.
	AwsIamAccessKey *AwsIamAccessKeyDetails `type:"structure"`

	// Details about an IAM role.
	AwsIamRole *AwsIamRoleDetails `type:"structure"`

	// Details about a KMS key.
	AwsKmsKey *AwsKmsKeyDetails `type:"structure"`

	// Details about a Lambda function.
	AwsLambdaFunction *AwsLambdaFunctionDetails `type:"structure"`

	// Details about an Amazon S3 Bucket related to a finding.
	AwsS3Bucket *AwsS3BucketDetails `type:"structure"`

	// Details about an SNS topic.
	AwsSnsTopic *AwsSnsTopicDetails `type:"structure"`

	// Details about an SQS queue.
	AwsSqsQueue *AwsSqsQueueDetails `type:"structure"`

	// Details about a container resource related to a finding.
	Container *ContainerDetails `type:"structure"`

	// Details about a resource that doesn't have a specific type defined.
	Other map[string]string `type:"map"`
}

// String returns the string representation
func (s ResourceDetails) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ResourceDetails) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ResourceDetails"}
	if s.AwsIamRole != nil {
		if err := s.AwsIamRole.Validate(); err != nil {
			invalidParams.AddNested("AwsIamRole", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourceDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.AwsCloudFrontDistribution != nil {
		v := s.AwsCloudFrontDistribution

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsCloudFrontDistribution", v, metadata)
	}
	if s.AwsEc2Instance != nil {
		v := s.AwsEc2Instance

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsEc2Instance", v, metadata)
	}
	if s.AwsElbv2LoadBalancer != nil {
		v := s.AwsElbv2LoadBalancer

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsElbv2LoadBalancer", v, metadata)
	}
	if s.AwsIamAccessKey != nil {
		v := s.AwsIamAccessKey

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsIamAccessKey", v, metadata)
	}
	if s.AwsIamRole != nil {
		v := s.AwsIamRole

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsIamRole", v, metadata)
	}
	if s.AwsKmsKey != nil {
		v := s.AwsKmsKey

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsKmsKey", v, metadata)
	}
	if s.AwsLambdaFunction != nil {
		v := s.AwsLambdaFunction

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsLambdaFunction", v, metadata)
	}
	if s.AwsS3Bucket != nil {
		v := s.AwsS3Bucket

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsS3Bucket", v, metadata)
	}
	if s.AwsSnsTopic != nil {
		v := s.AwsSnsTopic

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsSnsTopic", v, metadata)
	}
	if s.AwsSqsQueue != nil {
		v := s.AwsSqsQueue

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AwsSqsQueue", v, metadata)
	}
	if s.Container != nil {
		v := s.Container

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Container", v, metadata)
	}
	if s.Other != nil {
		v := s.Other

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Other", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Details about the account that wasn't processed.
type Result struct {
	_ struct{} `type:"structure"`

	// An AWS account ID of the account that wasn't be processed.
	AccountId *string `type:"string"`

	// The reason that the account wasn't be processed.
	ProcessingResult *string `type:"string"`
}

// String returns the string representation
func (s Result) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Result) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProcessingResult != nil {
		v := *s.ProcessingResult

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ProcessingResult", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The severity of the finding.
type Severity struct {
	_ struct{} `type:"structure"`

	// The normalized severity of a finding.
	//
	// Normalized is a required field
	Normalized *int64 `type:"integer" required:"true"`

	// The native severity as defined by the AWS service or integrated partner product
	// that generated the finding.
	Product *float64 `type:"double"`
}

// String returns the string representation
func (s Severity) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Severity) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Severity"}

	if s.Normalized == nil {
		invalidParams.Add(aws.NewErrParamRequired("Normalized"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Severity) MarshalFields(e protocol.FieldEncoder) error {
	if s.Normalized != nil {
		v := *s.Normalized

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Normalized", protocol.Int64Value(v), metadata)
	}
	if s.Product != nil {
		v := *s.Product

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Product", protocol.Float64Value(v), metadata)
	}
	return nil
}

// A collection of finding attributes used to sort findings.
type SortCriterion struct {
	_ struct{} `type:"structure"`

	// The finding attribute used to sort findings.
	Field *string `type:"string"`

	// The order used to sort findings.
	SortOrder SortOrder `type:"string" enum:"true"`
}

// String returns the string representation
func (s SortCriterion) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SortCriterion) MarshalFields(e protocol.FieldEncoder) error {
	if s.Field != nil {
		v := *s.Field

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Field", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SortOrder) > 0 {
		v := s.SortOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SortOrder", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Details for an individual compliance standard control.
type StandardsControl struct {
	_ struct{} `type:"structure"`

	// The identifier of the compliance standard control.
	ControlId *string `type:"string"`

	// The current status of the compliance standard control. Indicates whether
	// the control is enabled or disabled. Security Hub does not check against disabled
	// controls.
	ControlStatus ControlStatus `type:"string" enum:"true"`

	// The date and time that the status of the compliance standard control was
	// most recently updated.
	ControlStatusUpdatedAt *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// The longer description of the compliance standard control. Provides information
	// about what the control is checking for.
	Description *string `type:"string"`

	// The reason provided for the most recent change in status for the control.
	DisabledReason *string `type:"string"`

	// A link to remediation information for the control in the Security Hub user
	// documentation
	RemediationUrl *string `type:"string"`

	// The severity of findings generated from this compliance standard control.
	//
	// The finding severity is based on an assessment of how easy it would be to
	// compromise AWS resources if the compliance issue is detected.
	SeverityRating SeverityRating `type:"string" enum:"true"`

	// The ARN of the compliance standard control.
	StandardsControlArn *string `type:"string"`

	// The title of the compliance standard control.
	Title *string `type:"string"`
}

// String returns the string representation
func (s StandardsControl) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StandardsControl) MarshalFields(e protocol.FieldEncoder) error {
	if s.ControlId != nil {
		v := *s.ControlId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ControlId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ControlStatus) > 0 {
		v := s.ControlStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ControlStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ControlStatusUpdatedAt != nil {
		v := *s.ControlStatusUpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ControlStatusUpdatedAt",
			protocol.TimeValue{V: v, Format: "iso8601", QuotedFormatTime: true}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DisabledReason != nil {
		v := *s.DisabledReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DisabledReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RemediationUrl != nil {
		v := *s.RemediationUrl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RemediationUrl", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SeverityRating) > 0 {
		v := s.SeverityRating

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SeverityRating", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StandardsControlArn != nil {
		v := *s.StandardsControlArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StandardsControlArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Title != nil {
		v := *s.Title

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Title", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A resource that represents your subscription to a supported standard.
type StandardsSubscription struct {
	_ struct{} `type:"structure"`

	// The ARN of a standard.
	//
	// In this release, Security Hub supports only the CIS AWS Foundations standard,
	// which uses the following ARN: arn:aws:securityhub:::ruleset/cis-aws-foundations-benchmark/v/1.2.0.
	//
	// StandardsArn is a required field
	StandardsArn *string `type:"string" required:"true"`

	// A key-value pair of input for the standard.
	//
	// StandardsInput is a required field
	StandardsInput map[string]string `type:"map" required:"true"`

	// The status of the standards subscription.
	//
	// StandardsStatus is a required field
	StandardsStatus StandardsStatus `type:"string" required:"true" enum:"true"`

	// The ARN of a resource that represents your subscription to a supported standard.
	//
	// StandardsSubscriptionArn is a required field
	StandardsSubscriptionArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s StandardsSubscription) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StandardsSubscription) MarshalFields(e protocol.FieldEncoder) error {
	if s.StandardsArn != nil {
		v := *s.StandardsArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StandardsArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StandardsInput != nil {
		v := s.StandardsInput

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "StandardsInput", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.StandardsStatus) > 0 {
		v := s.StandardsStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StandardsStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StandardsSubscriptionArn != nil {
		v := *s.StandardsSubscriptionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StandardsSubscriptionArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The standard that you want to enable.
type StandardsSubscriptionRequest struct {
	_ struct{} `type:"structure"`

	// The ARN of the standard that you want to enable.
	//
	// In this release, Security Hub only supports the CIS AWS Foundations standard.
	//
	// Its ARN is arn:aws:securityhub:::ruleset/cis-aws-foundations-benchmark/v/1.2.0.
	//
	// StandardsArn is a required field
	StandardsArn *string `type:"string" required:"true"`

	// A key-value pair of input for the standard.
	StandardsInput map[string]string `type:"map"`
}

// String returns the string representation
func (s StandardsSubscriptionRequest) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StandardsSubscriptionRequest) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StandardsSubscriptionRequest"}

	if s.StandardsArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("StandardsArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StandardsSubscriptionRequest) MarshalFields(e protocol.FieldEncoder) error {
	if s.StandardsArn != nil {
		v := *s.StandardsArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StandardsArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StandardsInput != nil {
		v := s.StandardsInput

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "StandardsInput", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// A string filter for querying findings.
type StringFilter struct {
	_ struct{} `type:"structure"`

	// The condition to be applied to a string value when querying for findings.
	Comparison StringFilterComparison `type:"string" enum:"true"`

	// The string filter value.
	Value *string `type:"string"`
}

// String returns the string representation
func (s StringFilter) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StringFilter) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Comparison) > 0 {
		v := s.Comparison

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Comparison", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Details about the threat intel related to a finding.
type ThreatIntelIndicator struct {
	_ struct{} `type:"structure"`

	// The category of a threat intel indicator.
	Category ThreatIntelIndicatorCategory `type:"string" enum:"true"`

	// The date and time when the most recent instance of a threat intel indicator
	// was observed.
	LastObservedAt *string `type:"string"`

	// The source of the threat intel indicator.
	Source *string `type:"string"`

	// The URL to the page or site where you can get more information about the
	// threat intel indicator.
	SourceUrl *string `type:"string"`

	// The type of a threat intel indicator.
	Type ThreatIntelIndicatorType `type:"string" enum:"true"`

	// The value of a threat intel indicator.
	Value *string `type:"string"`
}

// String returns the string representation
func (s ThreatIntelIndicator) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThreatIntelIndicator) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Category) > 0 {
		v := s.Category

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Category", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.LastObservedAt != nil {
		v := *s.LastObservedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastObservedAt", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Source != nil {
		v := *s.Source

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Source", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SourceUrl != nil {
		v := *s.SourceUrl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SourceUrl", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}
