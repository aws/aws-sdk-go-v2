// Code generated by smithy-go-codegen DO NOT EDIT.

package securityhub

import (
	"bytes"
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/securityhub/types"
	smithy "github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/httpbinding"
	smithyjson "github.com/awslabs/smithy-go/json"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

type awsRestjson1_serializeOpAcceptInvitation struct {
}

func (*awsRestjson1_serializeOpAcceptInvitation) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpAcceptInvitation) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*AcceptInvitationInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/master")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentAcceptInvitationInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsAcceptInvitationInput(v *AcceptInvitationInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentAcceptInvitationInput(v *AcceptInvitationInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.InvitationId != nil {
		ok := object.Key("InvitationId")
		ok.String(*v.InvitationId)
	}

	if v.MasterId != nil {
		ok := object.Key("MasterId")
		ok.String(*v.MasterId)
	}

	return nil
}

type awsRestjson1_serializeOpBatchDisableStandards struct {
}

func (*awsRestjson1_serializeOpBatchDisableStandards) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpBatchDisableStandards) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchDisableStandardsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/standards/deregister")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentBatchDisableStandardsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsBatchDisableStandardsInput(v *BatchDisableStandardsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentBatchDisableStandardsInput(v *BatchDisableStandardsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.StandardsSubscriptionArns != nil {
		ok := object.Key("StandardsSubscriptionArns")
		if err := awsRestjson1_serializeDocumentStandardsSubscriptionArns(v.StandardsSubscriptionArns, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpBatchEnableStandards struct {
}

func (*awsRestjson1_serializeOpBatchEnableStandards) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpBatchEnableStandards) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchEnableStandardsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/standards/register")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentBatchEnableStandardsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsBatchEnableStandardsInput(v *BatchEnableStandardsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentBatchEnableStandardsInput(v *BatchEnableStandardsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.StandardsSubscriptionRequests != nil {
		ok := object.Key("StandardsSubscriptionRequests")
		if err := awsRestjson1_serializeDocumentStandardsSubscriptionRequests(v.StandardsSubscriptionRequests, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpBatchImportFindings struct {
}

func (*awsRestjson1_serializeOpBatchImportFindings) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpBatchImportFindings) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchImportFindingsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/findings/import")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentBatchImportFindingsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsBatchImportFindingsInput(v *BatchImportFindingsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentBatchImportFindingsInput(v *BatchImportFindingsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Findings != nil {
		ok := object.Key("Findings")
		if err := awsRestjson1_serializeDocumentAwsSecurityFindingList(v.Findings, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpBatchUpdateFindings struct {
}

func (*awsRestjson1_serializeOpBatchUpdateFindings) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpBatchUpdateFindings) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchUpdateFindingsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/findings/batchupdate")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PATCH"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentBatchUpdateFindingsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsBatchUpdateFindingsInput(v *BatchUpdateFindingsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentBatchUpdateFindingsInput(v *BatchUpdateFindingsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Confidence != nil {
		ok := object.Key("Confidence")
		ok.Integer(*v.Confidence)
	}

	if v.Criticality != nil {
		ok := object.Key("Criticality")
		ok.Integer(*v.Criticality)
	}

	if v.FindingIdentifiers != nil {
		ok := object.Key("FindingIdentifiers")
		if err := awsRestjson1_serializeDocumentAwsSecurityFindingIdentifierList(v.FindingIdentifiers, ok); err != nil {
			return err
		}
	}

	if v.Note != nil {
		ok := object.Key("Note")
		if err := awsRestjson1_serializeDocumentNoteUpdate(v.Note, ok); err != nil {
			return err
		}
	}

	if v.RelatedFindings != nil {
		ok := object.Key("RelatedFindings")
		if err := awsRestjson1_serializeDocumentRelatedFindingList(v.RelatedFindings, ok); err != nil {
			return err
		}
	}

	if v.Severity != nil {
		ok := object.Key("Severity")
		if err := awsRestjson1_serializeDocumentSeverityUpdate(v.Severity, ok); err != nil {
			return err
		}
	}

	if v.Types != nil {
		ok := object.Key("Types")
		if err := awsRestjson1_serializeDocumentTypeList(v.Types, ok); err != nil {
			return err
		}
	}

	if v.UserDefinedFields != nil {
		ok := object.Key("UserDefinedFields")
		if err := awsRestjson1_serializeDocumentFieldMap(v.UserDefinedFields, ok); err != nil {
			return err
		}
	}

	if len(v.VerificationState) > 0 {
		ok := object.Key("VerificationState")
		ok.String(string(v.VerificationState))
	}

	if v.Workflow != nil {
		ok := object.Key("Workflow")
		if err := awsRestjson1_serializeDocumentWorkflowUpdate(v.Workflow, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateActionTarget struct {
}

func (*awsRestjson1_serializeOpCreateActionTarget) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateActionTarget) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateActionTargetInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/actionTargets")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentCreateActionTargetInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsCreateActionTargetInput(v *CreateActionTargetInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentCreateActionTargetInput(v *CreateActionTargetInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("Description")
		ok.String(*v.Description)
	}

	if v.Id != nil {
		ok := object.Key("Id")
		ok.String(*v.Id)
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	return nil
}

type awsRestjson1_serializeOpCreateInsight struct {
}

func (*awsRestjson1_serializeOpCreateInsight) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateInsight) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateInsightInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/insights")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentCreateInsightInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsCreateInsightInput(v *CreateInsightInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentCreateInsightInput(v *CreateInsightInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("Filters")
		if err := awsRestjson1_serializeDocumentAwsSecurityFindingFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.GroupByAttribute != nil {
		ok := object.Key("GroupByAttribute")
		ok.String(*v.GroupByAttribute)
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	return nil
}

type awsRestjson1_serializeOpCreateMembers struct {
}

func (*awsRestjson1_serializeOpCreateMembers) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateMembers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateMembersInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/members")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentCreateMembersInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsCreateMembersInput(v *CreateMembersInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentCreateMembersInput(v *CreateMembersInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccountDetails != nil {
		ok := object.Key("AccountDetails")
		if err := awsRestjson1_serializeDocumentAccountDetailsList(v.AccountDetails, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeclineInvitations struct {
}

func (*awsRestjson1_serializeOpDeclineInvitations) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeclineInvitations) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeclineInvitationsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/invitations/decline")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDeclineInvitationsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDeclineInvitationsInput(v *DeclineInvitationsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDeclineInvitationsInput(v *DeclineInvitationsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccountIds != nil {
		ok := object.Key("AccountIds")
		if err := awsRestjson1_serializeDocumentAccountIdList(v.AccountIds, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteActionTarget struct {
}

func (*awsRestjson1_serializeOpDeleteActionTarget) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteActionTarget) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteActionTargetInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/actionTargets/{ActionTargetArn+}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsDeleteActionTargetInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDeleteActionTargetInput(v *DeleteActionTargetInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ActionTargetArn != nil {
		if err := encoder.SetURI("ActionTargetArn").String(*v.ActionTargetArn); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteInsight struct {
}

func (*awsRestjson1_serializeOpDeleteInsight) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteInsight) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteInsightInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/insights/{InsightArn+}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsDeleteInsightInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDeleteInsightInput(v *DeleteInsightInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.InsightArn != nil {
		if err := encoder.SetURI("InsightArn").String(*v.InsightArn); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteInvitations struct {
}

func (*awsRestjson1_serializeOpDeleteInvitations) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteInvitations) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteInvitationsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/invitations/delete")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDeleteInvitationsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDeleteInvitationsInput(v *DeleteInvitationsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDeleteInvitationsInput(v *DeleteInvitationsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccountIds != nil {
		ok := object.Key("AccountIds")
		if err := awsRestjson1_serializeDocumentAccountIdList(v.AccountIds, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteMembers struct {
}

func (*awsRestjson1_serializeOpDeleteMembers) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteMembers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteMembersInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/members/delete")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDeleteMembersInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDeleteMembersInput(v *DeleteMembersInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDeleteMembersInput(v *DeleteMembersInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccountIds != nil {
		ok := object.Key("AccountIds")
		if err := awsRestjson1_serializeDocumentAccountIdList(v.AccountIds, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeActionTargets struct {
}

func (*awsRestjson1_serializeOpDescribeActionTargets) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeActionTargets) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeActionTargetsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/actionTargets/get")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDescribeActionTargetsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeActionTargetsInput(v *DescribeActionTargetsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDescribeActionTargetsInput(v *DescribeActionTargetsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ActionTargetArns != nil {
		ok := object.Key("ActionTargetArns")
		if err := awsRestjson1_serializeDocumentArnList(v.ActionTargetArns, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("MaxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("NextToken")
		ok.String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpDescribeHub struct {
}

func (*awsRestjson1_serializeOpDescribeHub) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeHub) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeHubInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/accounts")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsDescribeHubInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeHubInput(v *DescribeHubInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.HubArn != nil {
		encoder.SetQuery("HubArn").String(*v.HubArn)
	}

	return nil
}

type awsRestjson1_serializeOpDescribeProducts struct {
}

func (*awsRestjson1_serializeOpDescribeProducts) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeProducts) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeProductsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/products")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsDescribeProductsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeProductsInput(v *DescribeProductsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.MaxResults != nil {
		encoder.SetQuery("MaxResults").Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		encoder.SetQuery("NextToken").String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpDescribeStandards struct {
}

func (*awsRestjson1_serializeOpDescribeStandards) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeStandards) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeStandardsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/standards")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsDescribeStandardsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeStandardsInput(v *DescribeStandardsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.MaxResults != nil {
		encoder.SetQuery("MaxResults").Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		encoder.SetQuery("NextToken").String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpDescribeStandardsControls struct {
}

func (*awsRestjson1_serializeOpDescribeStandardsControls) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeStandardsControls) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeStandardsControlsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/standards/controls/{StandardsSubscriptionArn+}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsDescribeStandardsControlsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeStandardsControlsInput(v *DescribeStandardsControlsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.MaxResults != nil {
		encoder.SetQuery("MaxResults").Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		encoder.SetQuery("NextToken").String(*v.NextToken)
	}

	if v.StandardsSubscriptionArn != nil {
		if err := encoder.SetURI("StandardsSubscriptionArn").String(*v.StandardsSubscriptionArn); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDisableImportFindingsForProduct struct {
}

func (*awsRestjson1_serializeOpDisableImportFindingsForProduct) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDisableImportFindingsForProduct) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DisableImportFindingsForProductInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/productSubscriptions/{ProductSubscriptionArn+}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsDisableImportFindingsForProductInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDisableImportFindingsForProductInput(v *DisableImportFindingsForProductInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ProductSubscriptionArn != nil {
		if err := encoder.SetURI("ProductSubscriptionArn").String(*v.ProductSubscriptionArn); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDisableSecurityHub struct {
}

func (*awsRestjson1_serializeOpDisableSecurityHub) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDisableSecurityHub) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DisableSecurityHubInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/accounts")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDisableSecurityHubInput(v *DisableSecurityHubInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

type awsRestjson1_serializeOpDisassociateFromMasterAccount struct {
}

func (*awsRestjson1_serializeOpDisassociateFromMasterAccount) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDisassociateFromMasterAccount) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DisassociateFromMasterAccountInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/master/disassociate")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDisassociateFromMasterAccountInput(v *DisassociateFromMasterAccountInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

type awsRestjson1_serializeOpDisassociateMembers struct {
}

func (*awsRestjson1_serializeOpDisassociateMembers) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDisassociateMembers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DisassociateMembersInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/members/disassociate")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDisassociateMembersInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDisassociateMembersInput(v *DisassociateMembersInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDisassociateMembersInput(v *DisassociateMembersInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccountIds != nil {
		ok := object.Key("AccountIds")
		if err := awsRestjson1_serializeDocumentAccountIdList(v.AccountIds, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpEnableImportFindingsForProduct struct {
}

func (*awsRestjson1_serializeOpEnableImportFindingsForProduct) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpEnableImportFindingsForProduct) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*EnableImportFindingsForProductInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/productSubscriptions")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentEnableImportFindingsForProductInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsEnableImportFindingsForProductInput(v *EnableImportFindingsForProductInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentEnableImportFindingsForProductInput(v *EnableImportFindingsForProductInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ProductArn != nil {
		ok := object.Key("ProductArn")
		ok.String(*v.ProductArn)
	}

	return nil
}

type awsRestjson1_serializeOpEnableSecurityHub struct {
}

func (*awsRestjson1_serializeOpEnableSecurityHub) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpEnableSecurityHub) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*EnableSecurityHubInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/accounts")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentEnableSecurityHubInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsEnableSecurityHubInput(v *EnableSecurityHubInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentEnableSecurityHubInput(v *EnableSecurityHubInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.EnableDefaultStandards != nil {
		ok := object.Key("EnableDefaultStandards")
		ok.Boolean(*v.EnableDefaultStandards)
	}

	if v.Tags != nil {
		ok := object.Key("Tags")
		if err := awsRestjson1_serializeDocumentTagMap(v.Tags, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpGetEnabledStandards struct {
}

func (*awsRestjson1_serializeOpGetEnabledStandards) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpGetEnabledStandards) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetEnabledStandardsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/standards/get")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentGetEnabledStandardsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsGetEnabledStandardsInput(v *GetEnabledStandardsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentGetEnabledStandardsInput(v *GetEnabledStandardsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.MaxResults != nil {
		ok := object.Key("MaxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("NextToken")
		ok.String(*v.NextToken)
	}

	if v.StandardsSubscriptionArns != nil {
		ok := object.Key("StandardsSubscriptionArns")
		if err := awsRestjson1_serializeDocumentStandardsSubscriptionArns(v.StandardsSubscriptionArns, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpGetFindings struct {
}

func (*awsRestjson1_serializeOpGetFindings) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpGetFindings) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetFindingsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/findings")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentGetFindingsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsGetFindingsInput(v *GetFindingsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentGetFindingsInput(v *GetFindingsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("Filters")
		if err := awsRestjson1_serializeDocumentAwsSecurityFindingFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("MaxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("NextToken")
		ok.String(*v.NextToken)
	}

	if v.SortCriteria != nil {
		ok := object.Key("SortCriteria")
		if err := awsRestjson1_serializeDocumentSortCriteria(v.SortCriteria, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpGetInsightResults struct {
}

func (*awsRestjson1_serializeOpGetInsightResults) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpGetInsightResults) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetInsightResultsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/insights/results/{InsightArn+}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsGetInsightResultsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsGetInsightResultsInput(v *GetInsightResultsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.InsightArn != nil {
		if err := encoder.SetURI("InsightArn").String(*v.InsightArn); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpGetInsights struct {
}

func (*awsRestjson1_serializeOpGetInsights) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpGetInsights) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetInsightsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/insights/get")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentGetInsightsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsGetInsightsInput(v *GetInsightsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentGetInsightsInput(v *GetInsightsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.InsightArns != nil {
		ok := object.Key("InsightArns")
		if err := awsRestjson1_serializeDocumentArnList(v.InsightArns, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("MaxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("NextToken")
		ok.String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpGetInvitationsCount struct {
}

func (*awsRestjson1_serializeOpGetInvitationsCount) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpGetInvitationsCount) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetInvitationsCountInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/invitations/count")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsGetInvitationsCountInput(v *GetInvitationsCountInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

type awsRestjson1_serializeOpGetMasterAccount struct {
}

func (*awsRestjson1_serializeOpGetMasterAccount) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpGetMasterAccount) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetMasterAccountInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/master")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsGetMasterAccountInput(v *GetMasterAccountInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

type awsRestjson1_serializeOpGetMembers struct {
}

func (*awsRestjson1_serializeOpGetMembers) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpGetMembers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetMembersInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/members/get")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentGetMembersInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsGetMembersInput(v *GetMembersInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentGetMembersInput(v *GetMembersInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccountIds != nil {
		ok := object.Key("AccountIds")
		if err := awsRestjson1_serializeDocumentAccountIdList(v.AccountIds, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpInviteMembers struct {
}

func (*awsRestjson1_serializeOpInviteMembers) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpInviteMembers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*InviteMembersInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/members/invite")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentInviteMembersInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsInviteMembersInput(v *InviteMembersInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentInviteMembersInput(v *InviteMembersInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccountIds != nil {
		ok := object.Key("AccountIds")
		if err := awsRestjson1_serializeDocumentAccountIdList(v.AccountIds, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListEnabledProductsForImport struct {
}

func (*awsRestjson1_serializeOpListEnabledProductsForImport) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListEnabledProductsForImport) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListEnabledProductsForImportInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/productSubscriptions")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsListEnabledProductsForImportInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsListEnabledProductsForImportInput(v *ListEnabledProductsForImportInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.MaxResults != nil {
		encoder.SetQuery("MaxResults").Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		encoder.SetQuery("NextToken").String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpListInvitations struct {
}

func (*awsRestjson1_serializeOpListInvitations) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListInvitations) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListInvitationsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/invitations")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsListInvitationsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsListInvitationsInput(v *ListInvitationsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.MaxResults != nil {
		encoder.SetQuery("MaxResults").Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		encoder.SetQuery("NextToken").String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpListMembers struct {
}

func (*awsRestjson1_serializeOpListMembers) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListMembers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListMembersInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/members")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsListMembersInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsListMembersInput(v *ListMembersInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.MaxResults != nil {
		encoder.SetQuery("MaxResults").Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		encoder.SetQuery("NextToken").String(*v.NextToken)
	}

	if v.OnlyAssociated != nil {
		encoder.SetQuery("OnlyAssociated").Boolean(*v.OnlyAssociated)
	}

	return nil
}

type awsRestjson1_serializeOpListTagsForResource struct {
}

func (*awsRestjson1_serializeOpListTagsForResource) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListTagsForResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListTagsForResourceInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/tags/{ResourceArn}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsListTagsForResourceInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsListTagsForResourceInput(v *ListTagsForResourceInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ResourceArn != nil {
		if err := encoder.SetURI("ResourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpTagResource struct {
}

func (*awsRestjson1_serializeOpTagResource) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpTagResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*TagResourceInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/tags/{ResourceArn}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsTagResourceInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentTagResourceInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsTagResourceInput(v *TagResourceInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ResourceArn != nil {
		if err := encoder.SetURI("ResourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentTagResourceInput(v *TagResourceInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Tags != nil {
		ok := object.Key("Tags")
		if err := awsRestjson1_serializeDocumentTagMap(v.Tags, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpUntagResource struct {
}

func (*awsRestjson1_serializeOpUntagResource) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUntagResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UntagResourceInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/tags/{ResourceArn}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsUntagResourceInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsUntagResourceInput(v *UntagResourceInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ResourceArn != nil {
		if err := encoder.SetURI("ResourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	if v.TagKeys != nil {
		for i := range v.TagKeys {
			if v.TagKeys[i] == nil {
				continue
			}
			encoder.AddQuery("tagKeys").String(*v.TagKeys[i])
		}
	}

	return nil
}

type awsRestjson1_serializeOpUpdateActionTarget struct {
}

func (*awsRestjson1_serializeOpUpdateActionTarget) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateActionTarget) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateActionTargetInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/actionTargets/{ActionTargetArn+}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PATCH"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsUpdateActionTargetInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentUpdateActionTargetInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsUpdateActionTargetInput(v *UpdateActionTargetInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ActionTargetArn != nil {
		if err := encoder.SetURI("ActionTargetArn").String(*v.ActionTargetArn); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentUpdateActionTargetInput(v *UpdateActionTargetInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("Description")
		ok.String(*v.Description)
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	return nil
}

type awsRestjson1_serializeOpUpdateFindings struct {
}

func (*awsRestjson1_serializeOpUpdateFindings) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateFindings) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateFindingsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/findings")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PATCH"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentUpdateFindingsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsUpdateFindingsInput(v *UpdateFindingsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentUpdateFindingsInput(v *UpdateFindingsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("Filters")
		if err := awsRestjson1_serializeDocumentAwsSecurityFindingFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.Note != nil {
		ok := object.Key("Note")
		if err := awsRestjson1_serializeDocumentNoteUpdate(v.Note, ok); err != nil {
			return err
		}
	}

	if len(v.RecordState) > 0 {
		ok := object.Key("RecordState")
		ok.String(string(v.RecordState))
	}

	return nil
}

type awsRestjson1_serializeOpUpdateInsight struct {
}

func (*awsRestjson1_serializeOpUpdateInsight) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateInsight) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateInsightInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/insights/{InsightArn+}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PATCH"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsUpdateInsightInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentUpdateInsightInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsUpdateInsightInput(v *UpdateInsightInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.InsightArn != nil {
		if err := encoder.SetURI("InsightArn").String(*v.InsightArn); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentUpdateInsightInput(v *UpdateInsightInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("Filters")
		if err := awsRestjson1_serializeDocumentAwsSecurityFindingFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.GroupByAttribute != nil {
		ok := object.Key("GroupByAttribute")
		ok.String(*v.GroupByAttribute)
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	return nil
}

type awsRestjson1_serializeOpUpdateSecurityHubConfiguration struct {
}

func (*awsRestjson1_serializeOpUpdateSecurityHubConfiguration) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateSecurityHubConfiguration) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateSecurityHubConfigurationInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/accounts")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PATCH"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentUpdateSecurityHubConfigurationInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsUpdateSecurityHubConfigurationInput(v *UpdateSecurityHubConfigurationInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentUpdateSecurityHubConfigurationInput(v *UpdateSecurityHubConfigurationInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AutoEnableControls != nil {
		ok := object.Key("AutoEnableControls")
		ok.Boolean(*v.AutoEnableControls)
	}

	return nil
}

type awsRestjson1_serializeOpUpdateStandardsControl struct {
}

func (*awsRestjson1_serializeOpUpdateStandardsControl) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateStandardsControl) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateStandardsControlInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/standards/control/{StandardsControlArn+}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PATCH"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeHttpBindingsUpdateStandardsControlInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentUpdateStandardsControlInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsUpdateStandardsControlInput(v *UpdateStandardsControlInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.StandardsControlArn != nil {
		if err := encoder.SetURI("StandardsControlArn").String(*v.StandardsControlArn); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentUpdateStandardsControlInput(v *UpdateStandardsControlInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.ControlStatus) > 0 {
		ok := object.Key("ControlStatus")
		ok.String(string(v.ControlStatus))
	}

	if v.DisabledReason != nil {
		ok := object.Key("DisabledReason")
		ok.String(*v.DisabledReason)
	}

	return nil
}

func awsRestjson1_serializeDocumentAccountDetails(v *types.AccountDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccountId != nil {
		ok := object.Key("AccountId")
		ok.String(*v.AccountId)
	}

	if v.Email != nil {
		ok := object.Key("Email")
		ok.String(*v.Email)
	}

	return nil
}

func awsRestjson1_serializeDocumentAccountDetailsList(v []*types.AccountDetails, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAccountDetails(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAccountIdList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentArnList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentAvailabilityZone(v *types.AvailabilityZone, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.SubnetId != nil {
		ok := object.Key("SubnetId")
		ok.String(*v.SubnetId)
	}

	if v.ZoneName != nil {
		ok := object.Key("ZoneName")
		ok.String(*v.ZoneName)
	}

	return nil
}

func awsRestjson1_serializeDocumentAvailabilityZones(v []*types.AvailabilityZone, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAvailabilityZone(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsAutoScalingAutoScalingGroupDetails(v *types.AwsAutoScalingAutoScalingGroupDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CreatedTime != nil {
		ok := object.Key("CreatedTime")
		ok.String(*v.CreatedTime)
	}

	if v.HealthCheckGracePeriod != nil {
		ok := object.Key("HealthCheckGracePeriod")
		ok.Integer(*v.HealthCheckGracePeriod)
	}

	if v.HealthCheckType != nil {
		ok := object.Key("HealthCheckType")
		ok.String(*v.HealthCheckType)
	}

	if v.LaunchConfigurationName != nil {
		ok := object.Key("LaunchConfigurationName")
		ok.String(*v.LaunchConfigurationName)
	}

	if v.LoadBalancerNames != nil {
		ok := object.Key("LoadBalancerNames")
		if err := awsRestjson1_serializeDocumentStringList(v.LoadBalancerNames, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCloudFrontDistributionDetails(v *types.AwsCloudFrontDistributionDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DomainName != nil {
		ok := object.Key("DomainName")
		ok.String(*v.DomainName)
	}

	if v.ETag != nil {
		ok := object.Key("ETag")
		ok.String(*v.ETag)
	}

	if v.LastModifiedTime != nil {
		ok := object.Key("LastModifiedTime")
		ok.String(*v.LastModifiedTime)
	}

	if v.Logging != nil {
		ok := object.Key("Logging")
		if err := awsRestjson1_serializeDocumentAwsCloudFrontDistributionLogging(v.Logging, ok); err != nil {
			return err
		}
	}

	if v.Origins != nil {
		ok := object.Key("Origins")
		if err := awsRestjson1_serializeDocumentAwsCloudFrontDistributionOrigins(v.Origins, ok); err != nil {
			return err
		}
	}

	if v.Status != nil {
		ok := object.Key("Status")
		ok.String(*v.Status)
	}

	if v.WebAclId != nil {
		ok := object.Key("WebAclId")
		ok.String(*v.WebAclId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCloudFrontDistributionLogging(v *types.AwsCloudFrontDistributionLogging, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Bucket != nil {
		ok := object.Key("Bucket")
		ok.String(*v.Bucket)
	}

	if v.Enabled != nil {
		ok := object.Key("Enabled")
		ok.Boolean(*v.Enabled)
	}

	if v.IncludeCookies != nil {
		ok := object.Key("IncludeCookies")
		ok.Boolean(*v.IncludeCookies)
	}

	if v.Prefix != nil {
		ok := object.Key("Prefix")
		ok.String(*v.Prefix)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCloudFrontDistributionOriginItem(v *types.AwsCloudFrontDistributionOriginItem, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DomainName != nil {
		ok := object.Key("DomainName")
		ok.String(*v.DomainName)
	}

	if v.Id != nil {
		ok := object.Key("Id")
		ok.String(*v.Id)
	}

	if v.OriginPath != nil {
		ok := object.Key("OriginPath")
		ok.String(*v.OriginPath)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCloudFrontDistributionOriginItemList(v []*types.AwsCloudFrontDistributionOriginItem, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsCloudFrontDistributionOriginItem(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsCloudFrontDistributionOrigins(v *types.AwsCloudFrontDistributionOrigins, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Items != nil {
		ok := object.Key("Items")
		if err := awsRestjson1_serializeDocumentAwsCloudFrontDistributionOriginItemList(v.Items, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCodeBuildProjectDetails(v *types.AwsCodeBuildProjectDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.EncryptionKey != nil {
		ok := object.Key("EncryptionKey")
		ok.String(*v.EncryptionKey)
	}

	if v.Environment != nil {
		ok := object.Key("Environment")
		if err := awsRestjson1_serializeDocumentAwsCodeBuildProjectEnvironment(v.Environment, ok); err != nil {
			return err
		}
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	if v.ServiceRole != nil {
		ok := object.Key("ServiceRole")
		ok.String(*v.ServiceRole)
	}

	if v.Source != nil {
		ok := object.Key("Source")
		if err := awsRestjson1_serializeDocumentAwsCodeBuildProjectSource(v.Source, ok); err != nil {
			return err
		}
	}

	if v.VpcConfig != nil {
		ok := object.Key("VpcConfig")
		if err := awsRestjson1_serializeDocumentAwsCodeBuildProjectVpcConfig(v.VpcConfig, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCodeBuildProjectEnvironment(v *types.AwsCodeBuildProjectEnvironment, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Certificate != nil {
		ok := object.Key("Certificate")
		ok.String(*v.Certificate)
	}

	if v.ImagePullCredentialsType != nil {
		ok := object.Key("ImagePullCredentialsType")
		ok.String(*v.ImagePullCredentialsType)
	}

	if v.RegistryCredential != nil {
		ok := object.Key("RegistryCredential")
		if err := awsRestjson1_serializeDocumentAwsCodeBuildProjectEnvironmentRegistryCredential(v.RegistryCredential, ok); err != nil {
			return err
		}
	}

	if v.Type != nil {
		ok := object.Key("Type")
		ok.String(*v.Type)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCodeBuildProjectEnvironmentRegistryCredential(v *types.AwsCodeBuildProjectEnvironmentRegistryCredential, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Credential != nil {
		ok := object.Key("Credential")
		ok.String(*v.Credential)
	}

	if v.CredentialProvider != nil {
		ok := object.Key("CredentialProvider")
		ok.String(*v.CredentialProvider)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCodeBuildProjectSource(v *types.AwsCodeBuildProjectSource, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.GitCloneDepth != nil {
		ok := object.Key("GitCloneDepth")
		ok.Integer(*v.GitCloneDepth)
	}

	if v.InsecureSsl != nil {
		ok := object.Key("InsecureSsl")
		ok.Boolean(*v.InsecureSsl)
	}

	if v.Location != nil {
		ok := object.Key("Location")
		ok.String(*v.Location)
	}

	if v.Type != nil {
		ok := object.Key("Type")
		ok.String(*v.Type)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsCodeBuildProjectVpcConfig(v *types.AwsCodeBuildProjectVpcConfig, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.SecurityGroupIds != nil {
		ok := object.Key("SecurityGroupIds")
		if err := awsRestjson1_serializeDocumentNonEmptyStringList(v.SecurityGroupIds, ok); err != nil {
			return err
		}
	}

	if v.Subnets != nil {
		ok := object.Key("Subnets")
		if err := awsRestjson1_serializeDocumentNonEmptyStringList(v.Subnets, ok); err != nil {
			return err
		}
	}

	if v.VpcId != nil {
		ok := object.Key("VpcId")
		ok.String(*v.VpcId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2InstanceDetails(v *types.AwsEc2InstanceDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.IamInstanceProfileArn != nil {
		ok := object.Key("IamInstanceProfileArn")
		ok.String(*v.IamInstanceProfileArn)
	}

	if v.ImageId != nil {
		ok := object.Key("ImageId")
		ok.String(*v.ImageId)
	}

	if v.IpV4Addresses != nil {
		ok := object.Key("IpV4Addresses")
		if err := awsRestjson1_serializeDocumentStringList(v.IpV4Addresses, ok); err != nil {
			return err
		}
	}

	if v.IpV6Addresses != nil {
		ok := object.Key("IpV6Addresses")
		if err := awsRestjson1_serializeDocumentStringList(v.IpV6Addresses, ok); err != nil {
			return err
		}
	}

	if v.KeyName != nil {
		ok := object.Key("KeyName")
		ok.String(*v.KeyName)
	}

	if v.LaunchedAt != nil {
		ok := object.Key("LaunchedAt")
		ok.String(*v.LaunchedAt)
	}

	if v.SubnetId != nil {
		ok := object.Key("SubnetId")
		ok.String(*v.SubnetId)
	}

	if v.Type != nil {
		ok := object.Key("Type")
		ok.String(*v.Type)
	}

	if v.VpcId != nil {
		ok := object.Key("VpcId")
		ok.String(*v.VpcId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2NetworkInterfaceAttachment(v *types.AwsEc2NetworkInterfaceAttachment, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AttachmentId != nil {
		ok := object.Key("AttachmentId")
		ok.String(*v.AttachmentId)
	}

	if v.AttachTime != nil {
		ok := object.Key("AttachTime")
		ok.String(*v.AttachTime)
	}

	if v.DeleteOnTermination != nil {
		ok := object.Key("DeleteOnTermination")
		ok.Boolean(*v.DeleteOnTermination)
	}

	if v.DeviceIndex != nil {
		ok := object.Key("DeviceIndex")
		ok.Integer(*v.DeviceIndex)
	}

	if v.InstanceId != nil {
		ok := object.Key("InstanceId")
		ok.String(*v.InstanceId)
	}

	if v.InstanceOwnerId != nil {
		ok := object.Key("InstanceOwnerId")
		ok.String(*v.InstanceOwnerId)
	}

	if v.Status != nil {
		ok := object.Key("Status")
		ok.String(*v.Status)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2NetworkInterfaceDetails(v *types.AwsEc2NetworkInterfaceDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Attachment != nil {
		ok := object.Key("Attachment")
		if err := awsRestjson1_serializeDocumentAwsEc2NetworkInterfaceAttachment(v.Attachment, ok); err != nil {
			return err
		}
	}

	if v.NetworkInterfaceId != nil {
		ok := object.Key("NetworkInterfaceId")
		ok.String(*v.NetworkInterfaceId)
	}

	if v.SecurityGroups != nil {
		ok := object.Key("SecurityGroups")
		if err := awsRestjson1_serializeDocumentAwsEc2NetworkInterfaceSecurityGroupList(v.SecurityGroups, ok); err != nil {
			return err
		}
	}

	if v.SourceDestCheck != nil {
		ok := object.Key("SourceDestCheck")
		ok.Boolean(*v.SourceDestCheck)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2NetworkInterfaceSecurityGroup(v *types.AwsEc2NetworkInterfaceSecurityGroup, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.GroupId != nil {
		ok := object.Key("GroupId")
		ok.String(*v.GroupId)
	}

	if v.GroupName != nil {
		ok := object.Key("GroupName")
		ok.String(*v.GroupName)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2NetworkInterfaceSecurityGroupList(v []*types.AwsEc2NetworkInterfaceSecurityGroup, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsEc2NetworkInterfaceSecurityGroup(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupDetails(v *types.AwsEc2SecurityGroupDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.GroupId != nil {
		ok := object.Key("GroupId")
		ok.String(*v.GroupId)
	}

	if v.GroupName != nil {
		ok := object.Key("GroupName")
		ok.String(*v.GroupName)
	}

	if v.IpPermissions != nil {
		ok := object.Key("IpPermissions")
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpPermissionList(v.IpPermissions, ok); err != nil {
			return err
		}
	}

	if v.IpPermissionsEgress != nil {
		ok := object.Key("IpPermissionsEgress")
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpPermissionList(v.IpPermissionsEgress, ok); err != nil {
			return err
		}
	}

	if v.OwnerId != nil {
		ok := object.Key("OwnerId")
		ok.String(*v.OwnerId)
	}

	if v.VpcId != nil {
		ok := object.Key("VpcId")
		ok.String(*v.VpcId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpPermission(v *types.AwsEc2SecurityGroupIpPermission, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.FromPort != nil {
		ok := object.Key("FromPort")
		ok.Integer(*v.FromPort)
	}

	if v.IpProtocol != nil {
		ok := object.Key("IpProtocol")
		ok.String(*v.IpProtocol)
	}

	if v.IpRanges != nil {
		ok := object.Key("IpRanges")
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpRangeList(v.IpRanges, ok); err != nil {
			return err
		}
	}

	if v.Ipv6Ranges != nil {
		ok := object.Key("Ipv6Ranges")
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpv6RangeList(v.Ipv6Ranges, ok); err != nil {
			return err
		}
	}

	if v.PrefixListIds != nil {
		ok := object.Key("PrefixListIds")
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupPrefixListIdList(v.PrefixListIds, ok); err != nil {
			return err
		}
	}

	if v.ToPort != nil {
		ok := object.Key("ToPort")
		ok.Integer(*v.ToPort)
	}

	if v.UserIdGroupPairs != nil {
		ok := object.Key("UserIdGroupPairs")
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupUserIdGroupPairList(v.UserIdGroupPairs, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpPermissionList(v []*types.AwsEc2SecurityGroupIpPermission, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpPermission(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpRange(v *types.AwsEc2SecurityGroupIpRange, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CidrIp != nil {
		ok := object.Key("CidrIp")
		ok.String(*v.CidrIp)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpRangeList(v []*types.AwsEc2SecurityGroupIpRange, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpRange(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpv6Range(v *types.AwsEc2SecurityGroupIpv6Range, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CidrIpv6 != nil {
		ok := object.Key("CidrIpv6")
		ok.String(*v.CidrIpv6)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpv6RangeList(v []*types.AwsEc2SecurityGroupIpv6Range, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupIpv6Range(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupPrefixListId(v *types.AwsEc2SecurityGroupPrefixListId, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.PrefixListId != nil {
		ok := object.Key("PrefixListId")
		ok.String(*v.PrefixListId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupPrefixListIdList(v []*types.AwsEc2SecurityGroupPrefixListId, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupPrefixListId(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupUserIdGroupPair(v *types.AwsEc2SecurityGroupUserIdGroupPair, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.GroupId != nil {
		ok := object.Key("GroupId")
		ok.String(*v.GroupId)
	}

	if v.GroupName != nil {
		ok := object.Key("GroupName")
		ok.String(*v.GroupName)
	}

	if v.PeeringStatus != nil {
		ok := object.Key("PeeringStatus")
		ok.String(*v.PeeringStatus)
	}

	if v.UserId != nil {
		ok := object.Key("UserId")
		ok.String(*v.UserId)
	}

	if v.VpcId != nil {
		ok := object.Key("VpcId")
		ok.String(*v.VpcId)
	}

	if v.VpcPeeringConnectionId != nil {
		ok := object.Key("VpcPeeringConnectionId")
		ok.String(*v.VpcPeeringConnectionId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2SecurityGroupUserIdGroupPairList(v []*types.AwsEc2SecurityGroupUserIdGroupPair, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupUserIdGroupPair(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsEc2VolumeAttachment(v *types.AwsEc2VolumeAttachment, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AttachTime != nil {
		ok := object.Key("AttachTime")
		ok.String(*v.AttachTime)
	}

	if v.DeleteOnTermination != nil {
		ok := object.Key("DeleteOnTermination")
		ok.Boolean(*v.DeleteOnTermination)
	}

	if v.InstanceId != nil {
		ok := object.Key("InstanceId")
		ok.String(*v.InstanceId)
	}

	if v.Status != nil {
		ok := object.Key("Status")
		ok.String(*v.Status)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2VolumeAttachmentList(v []*types.AwsEc2VolumeAttachment, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsEc2VolumeAttachment(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsEc2VolumeDetails(v *types.AwsEc2VolumeDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Attachments != nil {
		ok := object.Key("Attachments")
		if err := awsRestjson1_serializeDocumentAwsEc2VolumeAttachmentList(v.Attachments, ok); err != nil {
			return err
		}
	}

	if v.CreateTime != nil {
		ok := object.Key("CreateTime")
		ok.String(*v.CreateTime)
	}

	if v.Encrypted != nil {
		ok := object.Key("Encrypted")
		ok.Boolean(*v.Encrypted)
	}

	if v.KmsKeyId != nil {
		ok := object.Key("KmsKeyId")
		ok.String(*v.KmsKeyId)
	}

	if v.Size != nil {
		ok := object.Key("Size")
		ok.Integer(*v.Size)
	}

	if v.SnapshotId != nil {
		ok := object.Key("SnapshotId")
		ok.String(*v.SnapshotId)
	}

	if v.Status != nil {
		ok := object.Key("Status")
		ok.String(*v.Status)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsEc2VpcDetails(v *types.AwsEc2VpcDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CidrBlockAssociationSet != nil {
		ok := object.Key("CidrBlockAssociationSet")
		if err := awsRestjson1_serializeDocumentCidrBlockAssociationList(v.CidrBlockAssociationSet, ok); err != nil {
			return err
		}
	}

	if v.DhcpOptionsId != nil {
		ok := object.Key("DhcpOptionsId")
		ok.String(*v.DhcpOptionsId)
	}

	if v.Ipv6CidrBlockAssociationSet != nil {
		ok := object.Key("Ipv6CidrBlockAssociationSet")
		if err := awsRestjson1_serializeDocumentIpv6CidrBlockAssociationList(v.Ipv6CidrBlockAssociationSet, ok); err != nil {
			return err
		}
	}

	if v.State != nil {
		ok := object.Key("State")
		ok.String(*v.State)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsElasticsearchDomainDetails(v *types.AwsElasticsearchDomainDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AccessPolicies != nil {
		ok := object.Key("AccessPolicies")
		ok.String(*v.AccessPolicies)
	}

	if v.DomainEndpointOptions != nil {
		ok := object.Key("DomainEndpointOptions")
		if err := awsRestjson1_serializeDocumentAwsElasticsearchDomainDomainEndpointOptions(v.DomainEndpointOptions, ok); err != nil {
			return err
		}
	}

	if v.DomainId != nil {
		ok := object.Key("DomainId")
		ok.String(*v.DomainId)
	}

	if v.DomainName != nil {
		ok := object.Key("DomainName")
		ok.String(*v.DomainName)
	}

	if v.ElasticsearchVersion != nil {
		ok := object.Key("ElasticsearchVersion")
		ok.String(*v.ElasticsearchVersion)
	}

	if v.EncryptionAtRestOptions != nil {
		ok := object.Key("EncryptionAtRestOptions")
		if err := awsRestjson1_serializeDocumentAwsElasticsearchDomainEncryptionAtRestOptions(v.EncryptionAtRestOptions, ok); err != nil {
			return err
		}
	}

	if v.Endpoint != nil {
		ok := object.Key("Endpoint")
		ok.String(*v.Endpoint)
	}

	if v.Endpoints != nil {
		ok := object.Key("Endpoints")
		if err := awsRestjson1_serializeDocumentFieldMap(v.Endpoints, ok); err != nil {
			return err
		}
	}

	if v.NodeToNodeEncryptionOptions != nil {
		ok := object.Key("NodeToNodeEncryptionOptions")
		if err := awsRestjson1_serializeDocumentAwsElasticsearchDomainNodeToNodeEncryptionOptions(v.NodeToNodeEncryptionOptions, ok); err != nil {
			return err
		}
	}

	if v.VPCOptions != nil {
		ok := object.Key("VPCOptions")
		if err := awsRestjson1_serializeDocumentAwsElasticsearchDomainVPCOptions(v.VPCOptions, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsElasticsearchDomainDomainEndpointOptions(v *types.AwsElasticsearchDomainDomainEndpointOptions, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.EnforceHTTPS != nil {
		ok := object.Key("EnforceHTTPS")
		ok.Boolean(*v.EnforceHTTPS)
	}

	if v.TLSSecurityPolicy != nil {
		ok := object.Key("TLSSecurityPolicy")
		ok.String(*v.TLSSecurityPolicy)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsElasticsearchDomainEncryptionAtRestOptions(v *types.AwsElasticsearchDomainEncryptionAtRestOptions, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Enabled != nil {
		ok := object.Key("Enabled")
		ok.Boolean(*v.Enabled)
	}

	if v.KmsKeyId != nil {
		ok := object.Key("KmsKeyId")
		ok.String(*v.KmsKeyId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsElasticsearchDomainNodeToNodeEncryptionOptions(v *types.AwsElasticsearchDomainNodeToNodeEncryptionOptions, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Enabled != nil {
		ok := object.Key("Enabled")
		ok.Boolean(*v.Enabled)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsElasticsearchDomainVPCOptions(v *types.AwsElasticsearchDomainVPCOptions, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AvailabilityZones != nil {
		ok := object.Key("AvailabilityZones")
		if err := awsRestjson1_serializeDocumentNonEmptyStringList(v.AvailabilityZones, ok); err != nil {
			return err
		}
	}

	if v.SecurityGroupIds != nil {
		ok := object.Key("SecurityGroupIds")
		if err := awsRestjson1_serializeDocumentNonEmptyStringList(v.SecurityGroupIds, ok); err != nil {
			return err
		}
	}

	if v.SubnetIds != nil {
		ok := object.Key("SubnetIds")
		if err := awsRestjson1_serializeDocumentNonEmptyStringList(v.SubnetIds, ok); err != nil {
			return err
		}
	}

	if v.VPCId != nil {
		ok := object.Key("VPCId")
		ok.String(*v.VPCId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsElbv2LoadBalancerDetails(v *types.AwsElbv2LoadBalancerDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AvailabilityZones != nil {
		ok := object.Key("AvailabilityZones")
		if err := awsRestjson1_serializeDocumentAvailabilityZones(v.AvailabilityZones, ok); err != nil {
			return err
		}
	}

	if v.CanonicalHostedZoneId != nil {
		ok := object.Key("CanonicalHostedZoneId")
		ok.String(*v.CanonicalHostedZoneId)
	}

	if v.CreatedTime != nil {
		ok := object.Key("CreatedTime")
		ok.String(*v.CreatedTime)
	}

	if v.DNSName != nil {
		ok := object.Key("DNSName")
		ok.String(*v.DNSName)
	}

	if v.IpAddressType != nil {
		ok := object.Key("IpAddressType")
		ok.String(*v.IpAddressType)
	}

	if v.Scheme != nil {
		ok := object.Key("Scheme")
		ok.String(*v.Scheme)
	}

	if v.SecurityGroups != nil {
		ok := object.Key("SecurityGroups")
		if err := awsRestjson1_serializeDocumentSecurityGroups(v.SecurityGroups, ok); err != nil {
			return err
		}
	}

	if v.State != nil {
		ok := object.Key("State")
		if err := awsRestjson1_serializeDocumentLoadBalancerState(v.State, ok); err != nil {
			return err
		}
	}

	if v.Type != nil {
		ok := object.Key("Type")
		ok.String(*v.Type)
	}

	if v.VpcId != nil {
		ok := object.Key("VpcId")
		ok.String(*v.VpcId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsIamAccessKeyDetails(v *types.AwsIamAccessKeyDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CreatedAt != nil {
		ok := object.Key("CreatedAt")
		ok.String(*v.CreatedAt)
	}

	if v.PrincipalId != nil {
		ok := object.Key("PrincipalId")
		ok.String(*v.PrincipalId)
	}

	if v.PrincipalName != nil {
		ok := object.Key("PrincipalName")
		ok.String(*v.PrincipalName)
	}

	if v.PrincipalType != nil {
		ok := object.Key("PrincipalType")
		ok.String(*v.PrincipalType)
	}

	if len(v.Status) > 0 {
		ok := object.Key("Status")
		ok.String(string(v.Status))
	}

	if v.UserName != nil {
		ok := object.Key("UserName")
		ok.String(*v.UserName)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsIamRoleDetails(v *types.AwsIamRoleDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AssumeRolePolicyDocument != nil {
		ok := object.Key("AssumeRolePolicyDocument")
		ok.String(*v.AssumeRolePolicyDocument)
	}

	if v.CreateDate != nil {
		ok := object.Key("CreateDate")
		ok.String(*v.CreateDate)
	}

	if v.MaxSessionDuration != nil {
		ok := object.Key("MaxSessionDuration")
		ok.Integer(*v.MaxSessionDuration)
	}

	if v.Path != nil {
		ok := object.Key("Path")
		ok.String(*v.Path)
	}

	if v.RoleId != nil {
		ok := object.Key("RoleId")
		ok.String(*v.RoleId)
	}

	if v.RoleName != nil {
		ok := object.Key("RoleName")
		ok.String(*v.RoleName)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsKmsKeyDetails(v *types.AwsKmsKeyDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AWSAccountId != nil {
		ok := object.Key("AWSAccountId")
		ok.String(*v.AWSAccountId)
	}

	if v.CreationDate != nil {
		ok := object.Key("CreationDate")
		ok.Double(*v.CreationDate)
	}

	if v.KeyId != nil {
		ok := object.Key("KeyId")
		ok.String(*v.KeyId)
	}

	if v.KeyManager != nil {
		ok := object.Key("KeyManager")
		ok.String(*v.KeyManager)
	}

	if v.KeyState != nil {
		ok := object.Key("KeyState")
		ok.String(*v.KeyState)
	}

	if v.Origin != nil {
		ok := object.Key("Origin")
		ok.String(*v.Origin)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionCode(v *types.AwsLambdaFunctionCode, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.S3Bucket != nil {
		ok := object.Key("S3Bucket")
		ok.String(*v.S3Bucket)
	}

	if v.S3Key != nil {
		ok := object.Key("S3Key")
		ok.String(*v.S3Key)
	}

	if v.S3ObjectVersion != nil {
		ok := object.Key("S3ObjectVersion")
		ok.String(*v.S3ObjectVersion)
	}

	if v.ZipFile != nil {
		ok := object.Key("ZipFile")
		ok.String(*v.ZipFile)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionDeadLetterConfig(v *types.AwsLambdaFunctionDeadLetterConfig, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.TargetArn != nil {
		ok := object.Key("TargetArn")
		ok.String(*v.TargetArn)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionDetails(v *types.AwsLambdaFunctionDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Code != nil {
		ok := object.Key("Code")
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionCode(v.Code, ok); err != nil {
			return err
		}
	}

	if v.CodeSha256 != nil {
		ok := object.Key("CodeSha256")
		ok.String(*v.CodeSha256)
	}

	if v.DeadLetterConfig != nil {
		ok := object.Key("DeadLetterConfig")
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionDeadLetterConfig(v.DeadLetterConfig, ok); err != nil {
			return err
		}
	}

	if v.Environment != nil {
		ok := object.Key("Environment")
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionEnvironment(v.Environment, ok); err != nil {
			return err
		}
	}

	if v.FunctionName != nil {
		ok := object.Key("FunctionName")
		ok.String(*v.FunctionName)
	}

	if v.Handler != nil {
		ok := object.Key("Handler")
		ok.String(*v.Handler)
	}

	if v.KmsKeyArn != nil {
		ok := object.Key("KmsKeyArn")
		ok.String(*v.KmsKeyArn)
	}

	if v.LastModified != nil {
		ok := object.Key("LastModified")
		ok.String(*v.LastModified)
	}

	if v.Layers != nil {
		ok := object.Key("Layers")
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionLayerList(v.Layers, ok); err != nil {
			return err
		}
	}

	if v.MasterArn != nil {
		ok := object.Key("MasterArn")
		ok.String(*v.MasterArn)
	}

	if v.MemorySize != nil {
		ok := object.Key("MemorySize")
		ok.Integer(*v.MemorySize)
	}

	if v.RevisionId != nil {
		ok := object.Key("RevisionId")
		ok.String(*v.RevisionId)
	}

	if v.Role != nil {
		ok := object.Key("Role")
		ok.String(*v.Role)
	}

	if v.Runtime != nil {
		ok := object.Key("Runtime")
		ok.String(*v.Runtime)
	}

	if v.Timeout != nil {
		ok := object.Key("Timeout")
		ok.Integer(*v.Timeout)
	}

	if v.TracingConfig != nil {
		ok := object.Key("TracingConfig")
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionTracingConfig(v.TracingConfig, ok); err != nil {
			return err
		}
	}

	if v.Version != nil {
		ok := object.Key("Version")
		ok.String(*v.Version)
	}

	if v.VpcConfig != nil {
		ok := object.Key("VpcConfig")
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionVpcConfig(v.VpcConfig, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionEnvironment(v *types.AwsLambdaFunctionEnvironment, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Error != nil {
		ok := object.Key("Error")
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionEnvironmentError(v.Error, ok); err != nil {
			return err
		}
	}

	if v.Variables != nil {
		ok := object.Key("Variables")
		if err := awsRestjson1_serializeDocumentFieldMap(v.Variables, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionEnvironmentError(v *types.AwsLambdaFunctionEnvironmentError, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ErrorCode != nil {
		ok := object.Key("ErrorCode")
		ok.String(*v.ErrorCode)
	}

	if v.Message != nil {
		ok := object.Key("Message")
		ok.String(*v.Message)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionLayer(v *types.AwsLambdaFunctionLayer, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Arn != nil {
		ok := object.Key("Arn")
		ok.String(*v.Arn)
	}

	if v.CodeSize != nil {
		ok := object.Key("CodeSize")
		ok.Integer(*v.CodeSize)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionLayerList(v []*types.AwsLambdaFunctionLayer, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionLayer(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionTracingConfig(v *types.AwsLambdaFunctionTracingConfig, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Mode != nil {
		ok := object.Key("Mode")
		ok.String(*v.Mode)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaFunctionVpcConfig(v *types.AwsLambdaFunctionVpcConfig, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.SecurityGroupIds != nil {
		ok := object.Key("SecurityGroupIds")
		if err := awsRestjson1_serializeDocumentNonEmptyStringList(v.SecurityGroupIds, ok); err != nil {
			return err
		}
	}

	if v.SubnetIds != nil {
		ok := object.Key("SubnetIds")
		if err := awsRestjson1_serializeDocumentNonEmptyStringList(v.SubnetIds, ok); err != nil {
			return err
		}
	}

	if v.VpcId != nil {
		ok := object.Key("VpcId")
		ok.String(*v.VpcId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsLambdaLayerVersionDetails(v *types.AwsLambdaLayerVersionDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CompatibleRuntimes != nil {
		ok := object.Key("CompatibleRuntimes")
		if err := awsRestjson1_serializeDocumentNonEmptyStringList(v.CompatibleRuntimes, ok); err != nil {
			return err
		}
	}

	if v.CreatedDate != nil {
		ok := object.Key("CreatedDate")
		ok.String(*v.CreatedDate)
	}

	if v.Version != nil {
		ok := object.Key("Version")
		ok.Long(*v.Version)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsRdsDbInstanceAssociatedRole(v *types.AwsRdsDbInstanceAssociatedRole, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.FeatureName != nil {
		ok := object.Key("FeatureName")
		ok.String(*v.FeatureName)
	}

	if v.RoleArn != nil {
		ok := object.Key("RoleArn")
		ok.String(*v.RoleArn)
	}

	if v.Status != nil {
		ok := object.Key("Status")
		ok.String(*v.Status)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsRdsDbInstanceAssociatedRoles(v []*types.AwsRdsDbInstanceAssociatedRole, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsRdsDbInstanceAssociatedRole(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsRdsDbInstanceDetails(v *types.AwsRdsDbInstanceDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AssociatedRoles != nil {
		ok := object.Key("AssociatedRoles")
		if err := awsRestjson1_serializeDocumentAwsRdsDbInstanceAssociatedRoles(v.AssociatedRoles, ok); err != nil {
			return err
		}
	}

	if v.CACertificateIdentifier != nil {
		ok := object.Key("CACertificateIdentifier")
		ok.String(*v.CACertificateIdentifier)
	}

	if v.DBClusterIdentifier != nil {
		ok := object.Key("DBClusterIdentifier")
		ok.String(*v.DBClusterIdentifier)
	}

	if v.DBInstanceClass != nil {
		ok := object.Key("DBInstanceClass")
		ok.String(*v.DBInstanceClass)
	}

	if v.DBInstanceIdentifier != nil {
		ok := object.Key("DBInstanceIdentifier")
		ok.String(*v.DBInstanceIdentifier)
	}

	if v.DbInstancePort != nil {
		ok := object.Key("DbInstancePort")
		ok.Integer(*v.DbInstancePort)
	}

	if v.DbiResourceId != nil {
		ok := object.Key("DbiResourceId")
		ok.String(*v.DbiResourceId)
	}

	if v.DBName != nil {
		ok := object.Key("DBName")
		ok.String(*v.DBName)
	}

	if v.DeletionProtection != nil {
		ok := object.Key("DeletionProtection")
		ok.Boolean(*v.DeletionProtection)
	}

	if v.Endpoint != nil {
		ok := object.Key("Endpoint")
		if err := awsRestjson1_serializeDocumentAwsRdsDbInstanceEndpoint(v.Endpoint, ok); err != nil {
			return err
		}
	}

	if v.Engine != nil {
		ok := object.Key("Engine")
		ok.String(*v.Engine)
	}

	if v.EngineVersion != nil {
		ok := object.Key("EngineVersion")
		ok.String(*v.EngineVersion)
	}

	if v.IAMDatabaseAuthenticationEnabled != nil {
		ok := object.Key("IAMDatabaseAuthenticationEnabled")
		ok.Boolean(*v.IAMDatabaseAuthenticationEnabled)
	}

	if v.InstanceCreateTime != nil {
		ok := object.Key("InstanceCreateTime")
		ok.String(*v.InstanceCreateTime)
	}

	if v.KmsKeyId != nil {
		ok := object.Key("KmsKeyId")
		ok.String(*v.KmsKeyId)
	}

	if v.PubliclyAccessible != nil {
		ok := object.Key("PubliclyAccessible")
		ok.Boolean(*v.PubliclyAccessible)
	}

	if v.StorageEncrypted != nil {
		ok := object.Key("StorageEncrypted")
		ok.Boolean(*v.StorageEncrypted)
	}

	if v.TdeCredentialArn != nil {
		ok := object.Key("TdeCredentialArn")
		ok.String(*v.TdeCredentialArn)
	}

	if v.VpcSecurityGroups != nil {
		ok := object.Key("VpcSecurityGroups")
		if err := awsRestjson1_serializeDocumentAwsRdsDbInstanceVpcSecurityGroups(v.VpcSecurityGroups, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsRdsDbInstanceEndpoint(v *types.AwsRdsDbInstanceEndpoint, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Address != nil {
		ok := object.Key("Address")
		ok.String(*v.Address)
	}

	if v.HostedZoneId != nil {
		ok := object.Key("HostedZoneId")
		ok.String(*v.HostedZoneId)
	}

	if v.Port != nil {
		ok := object.Key("Port")
		ok.Integer(*v.Port)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsRdsDbInstanceVpcSecurityGroup(v *types.AwsRdsDbInstanceVpcSecurityGroup, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Status != nil {
		ok := object.Key("Status")
		ok.String(*v.Status)
	}

	if v.VpcSecurityGroupId != nil {
		ok := object.Key("VpcSecurityGroupId")
		ok.String(*v.VpcSecurityGroupId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsRdsDbInstanceVpcSecurityGroups(v []*types.AwsRdsDbInstanceVpcSecurityGroup, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsRdsDbInstanceVpcSecurityGroup(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsS3BucketDetails(v *types.AwsS3BucketDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CreatedAt != nil {
		ok := object.Key("CreatedAt")
		ok.String(*v.CreatedAt)
	}

	if v.OwnerId != nil {
		ok := object.Key("OwnerId")
		ok.String(*v.OwnerId)
	}

	if v.OwnerName != nil {
		ok := object.Key("OwnerName")
		ok.String(*v.OwnerName)
	}

	if v.ServerSideEncryptionConfiguration != nil {
		ok := object.Key("ServerSideEncryptionConfiguration")
		if err := awsRestjson1_serializeDocumentAwsS3BucketServerSideEncryptionConfiguration(v.ServerSideEncryptionConfiguration, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsS3BucketServerSideEncryptionByDefault(v *types.AwsS3BucketServerSideEncryptionByDefault, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.KMSMasterKeyID != nil {
		ok := object.Key("KMSMasterKeyID")
		ok.String(*v.KMSMasterKeyID)
	}

	if v.SSEAlgorithm != nil {
		ok := object.Key("SSEAlgorithm")
		ok.String(*v.SSEAlgorithm)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsS3BucketServerSideEncryptionConfiguration(v *types.AwsS3BucketServerSideEncryptionConfiguration, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Rules != nil {
		ok := object.Key("Rules")
		if err := awsRestjson1_serializeDocumentAwsS3BucketServerSideEncryptionRules(v.Rules, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsS3BucketServerSideEncryptionRule(v *types.AwsS3BucketServerSideEncryptionRule, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApplyServerSideEncryptionByDefault != nil {
		ok := object.Key("ApplyServerSideEncryptionByDefault")
		if err := awsRestjson1_serializeDocumentAwsS3BucketServerSideEncryptionByDefault(v.ApplyServerSideEncryptionByDefault, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsS3BucketServerSideEncryptionRules(v []*types.AwsS3BucketServerSideEncryptionRule, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsS3BucketServerSideEncryptionRule(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsS3ObjectDetails(v *types.AwsS3ObjectDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ContentType != nil {
		ok := object.Key("ContentType")
		ok.String(*v.ContentType)
	}

	if v.ETag != nil {
		ok := object.Key("ETag")
		ok.String(*v.ETag)
	}

	if v.LastModified != nil {
		ok := object.Key("LastModified")
		ok.String(*v.LastModified)
	}

	if v.ServerSideEncryption != nil {
		ok := object.Key("ServerSideEncryption")
		ok.String(*v.ServerSideEncryption)
	}

	if v.SSEKMSKeyId != nil {
		ok := object.Key("SSEKMSKeyId")
		ok.String(*v.SSEKMSKeyId)
	}

	if v.VersionId != nil {
		ok := object.Key("VersionId")
		ok.String(*v.VersionId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsSecurityFinding(v *types.AwsSecurityFinding, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AwsAccountId != nil {
		ok := object.Key("AwsAccountId")
		ok.String(*v.AwsAccountId)
	}

	if v.Compliance != nil {
		ok := object.Key("Compliance")
		if err := awsRestjson1_serializeDocumentCompliance(v.Compliance, ok); err != nil {
			return err
		}
	}

	if v.Confidence != nil {
		ok := object.Key("Confidence")
		ok.Integer(*v.Confidence)
	}

	if v.CreatedAt != nil {
		ok := object.Key("CreatedAt")
		ok.String(*v.CreatedAt)
	}

	if v.Criticality != nil {
		ok := object.Key("Criticality")
		ok.Integer(*v.Criticality)
	}

	if v.Description != nil {
		ok := object.Key("Description")
		ok.String(*v.Description)
	}

	if v.FirstObservedAt != nil {
		ok := object.Key("FirstObservedAt")
		ok.String(*v.FirstObservedAt)
	}

	if v.GeneratorId != nil {
		ok := object.Key("GeneratorId")
		ok.String(*v.GeneratorId)
	}

	if v.Id != nil {
		ok := object.Key("Id")
		ok.String(*v.Id)
	}

	if v.LastObservedAt != nil {
		ok := object.Key("LastObservedAt")
		ok.String(*v.LastObservedAt)
	}

	if v.Malware != nil {
		ok := object.Key("Malware")
		if err := awsRestjson1_serializeDocumentMalwareList(v.Malware, ok); err != nil {
			return err
		}
	}

	if v.Network != nil {
		ok := object.Key("Network")
		if err := awsRestjson1_serializeDocumentNetwork(v.Network, ok); err != nil {
			return err
		}
	}

	if v.NetworkPath != nil {
		ok := object.Key("NetworkPath")
		if err := awsRestjson1_serializeDocumentNetworkPathList(v.NetworkPath, ok); err != nil {
			return err
		}
	}

	if v.Note != nil {
		ok := object.Key("Note")
		if err := awsRestjson1_serializeDocumentNote(v.Note, ok); err != nil {
			return err
		}
	}

	if v.Process != nil {
		ok := object.Key("Process")
		if err := awsRestjson1_serializeDocumentProcessDetails(v.Process, ok); err != nil {
			return err
		}
	}

	if v.ProductArn != nil {
		ok := object.Key("ProductArn")
		ok.String(*v.ProductArn)
	}

	if v.ProductFields != nil {
		ok := object.Key("ProductFields")
		if err := awsRestjson1_serializeDocumentFieldMap(v.ProductFields, ok); err != nil {
			return err
		}
	}

	if len(v.RecordState) > 0 {
		ok := object.Key("RecordState")
		ok.String(string(v.RecordState))
	}

	if v.RelatedFindings != nil {
		ok := object.Key("RelatedFindings")
		if err := awsRestjson1_serializeDocumentRelatedFindingList(v.RelatedFindings, ok); err != nil {
			return err
		}
	}

	if v.Remediation != nil {
		ok := object.Key("Remediation")
		if err := awsRestjson1_serializeDocumentRemediation(v.Remediation, ok); err != nil {
			return err
		}
	}

	if v.Resources != nil {
		ok := object.Key("Resources")
		if err := awsRestjson1_serializeDocumentResourceList(v.Resources, ok); err != nil {
			return err
		}
	}

	if v.SchemaVersion != nil {
		ok := object.Key("SchemaVersion")
		ok.String(*v.SchemaVersion)
	}

	if v.Severity != nil {
		ok := object.Key("Severity")
		if err := awsRestjson1_serializeDocumentSeverity(v.Severity, ok); err != nil {
			return err
		}
	}

	if v.SourceUrl != nil {
		ok := object.Key("SourceUrl")
		ok.String(*v.SourceUrl)
	}

	if v.ThreatIntelIndicators != nil {
		ok := object.Key("ThreatIntelIndicators")
		if err := awsRestjson1_serializeDocumentThreatIntelIndicatorList(v.ThreatIntelIndicators, ok); err != nil {
			return err
		}
	}

	if v.Title != nil {
		ok := object.Key("Title")
		ok.String(*v.Title)
	}

	if v.Types != nil {
		ok := object.Key("Types")
		if err := awsRestjson1_serializeDocumentTypeList(v.Types, ok); err != nil {
			return err
		}
	}

	if v.UpdatedAt != nil {
		ok := object.Key("UpdatedAt")
		ok.String(*v.UpdatedAt)
	}

	if v.UserDefinedFields != nil {
		ok := object.Key("UserDefinedFields")
		if err := awsRestjson1_serializeDocumentFieldMap(v.UserDefinedFields, ok); err != nil {
			return err
		}
	}

	if len(v.VerificationState) > 0 {
		ok := object.Key("VerificationState")
		ok.String(string(v.VerificationState))
	}

	if v.Vulnerabilities != nil {
		ok := object.Key("Vulnerabilities")
		if err := awsRestjson1_serializeDocumentVulnerabilityList(v.Vulnerabilities, ok); err != nil {
			return err
		}
	}

	if v.Workflow != nil {
		ok := object.Key("Workflow")
		if err := awsRestjson1_serializeDocumentWorkflow(v.Workflow, ok); err != nil {
			return err
		}
	}

	if len(v.WorkflowState) > 0 {
		ok := object.Key("WorkflowState")
		ok.String(string(v.WorkflowState))
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsSecurityFindingFilters(v *types.AwsSecurityFindingFilters, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AwsAccountId != nil {
		ok := object.Key("AwsAccountId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.AwsAccountId, ok); err != nil {
			return err
		}
	}

	if v.CompanyName != nil {
		ok := object.Key("CompanyName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.CompanyName, ok); err != nil {
			return err
		}
	}

	if v.ComplianceStatus != nil {
		ok := object.Key("ComplianceStatus")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ComplianceStatus, ok); err != nil {
			return err
		}
	}

	if v.Confidence != nil {
		ok := object.Key("Confidence")
		if err := awsRestjson1_serializeDocumentNumberFilterList(v.Confidence, ok); err != nil {
			return err
		}
	}

	if v.CreatedAt != nil {
		ok := object.Key("CreatedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.CreatedAt, ok); err != nil {
			return err
		}
	}

	if v.Criticality != nil {
		ok := object.Key("Criticality")
		if err := awsRestjson1_serializeDocumentNumberFilterList(v.Criticality, ok); err != nil {
			return err
		}
	}

	if v.Description != nil {
		ok := object.Key("Description")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.Description, ok); err != nil {
			return err
		}
	}

	if v.FirstObservedAt != nil {
		ok := object.Key("FirstObservedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.FirstObservedAt, ok); err != nil {
			return err
		}
	}

	if v.GeneratorId != nil {
		ok := object.Key("GeneratorId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.GeneratorId, ok); err != nil {
			return err
		}
	}

	if v.Id != nil {
		ok := object.Key("Id")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.Id, ok); err != nil {
			return err
		}
	}

	if v.Keyword != nil {
		ok := object.Key("Keyword")
		if err := awsRestjson1_serializeDocumentKeywordFilterList(v.Keyword, ok); err != nil {
			return err
		}
	}

	if v.LastObservedAt != nil {
		ok := object.Key("LastObservedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.LastObservedAt, ok); err != nil {
			return err
		}
	}

	if v.MalwareName != nil {
		ok := object.Key("MalwareName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.MalwareName, ok); err != nil {
			return err
		}
	}

	if v.MalwarePath != nil {
		ok := object.Key("MalwarePath")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.MalwarePath, ok); err != nil {
			return err
		}
	}

	if v.MalwareState != nil {
		ok := object.Key("MalwareState")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.MalwareState, ok); err != nil {
			return err
		}
	}

	if v.MalwareType != nil {
		ok := object.Key("MalwareType")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.MalwareType, ok); err != nil {
			return err
		}
	}

	if v.NetworkDestinationDomain != nil {
		ok := object.Key("NetworkDestinationDomain")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.NetworkDestinationDomain, ok); err != nil {
			return err
		}
	}

	if v.NetworkDestinationIpV4 != nil {
		ok := object.Key("NetworkDestinationIpV4")
		if err := awsRestjson1_serializeDocumentIpFilterList(v.NetworkDestinationIpV4, ok); err != nil {
			return err
		}
	}

	if v.NetworkDestinationIpV6 != nil {
		ok := object.Key("NetworkDestinationIpV6")
		if err := awsRestjson1_serializeDocumentIpFilterList(v.NetworkDestinationIpV6, ok); err != nil {
			return err
		}
	}

	if v.NetworkDestinationPort != nil {
		ok := object.Key("NetworkDestinationPort")
		if err := awsRestjson1_serializeDocumentNumberFilterList(v.NetworkDestinationPort, ok); err != nil {
			return err
		}
	}

	if v.NetworkDirection != nil {
		ok := object.Key("NetworkDirection")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.NetworkDirection, ok); err != nil {
			return err
		}
	}

	if v.NetworkProtocol != nil {
		ok := object.Key("NetworkProtocol")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.NetworkProtocol, ok); err != nil {
			return err
		}
	}

	if v.NetworkSourceDomain != nil {
		ok := object.Key("NetworkSourceDomain")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.NetworkSourceDomain, ok); err != nil {
			return err
		}
	}

	if v.NetworkSourceIpV4 != nil {
		ok := object.Key("NetworkSourceIpV4")
		if err := awsRestjson1_serializeDocumentIpFilterList(v.NetworkSourceIpV4, ok); err != nil {
			return err
		}
	}

	if v.NetworkSourceIpV6 != nil {
		ok := object.Key("NetworkSourceIpV6")
		if err := awsRestjson1_serializeDocumentIpFilterList(v.NetworkSourceIpV6, ok); err != nil {
			return err
		}
	}

	if v.NetworkSourceMac != nil {
		ok := object.Key("NetworkSourceMac")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.NetworkSourceMac, ok); err != nil {
			return err
		}
	}

	if v.NetworkSourcePort != nil {
		ok := object.Key("NetworkSourcePort")
		if err := awsRestjson1_serializeDocumentNumberFilterList(v.NetworkSourcePort, ok); err != nil {
			return err
		}
	}

	if v.NoteText != nil {
		ok := object.Key("NoteText")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.NoteText, ok); err != nil {
			return err
		}
	}

	if v.NoteUpdatedAt != nil {
		ok := object.Key("NoteUpdatedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.NoteUpdatedAt, ok); err != nil {
			return err
		}
	}

	if v.NoteUpdatedBy != nil {
		ok := object.Key("NoteUpdatedBy")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.NoteUpdatedBy, ok); err != nil {
			return err
		}
	}

	if v.ProcessLaunchedAt != nil {
		ok := object.Key("ProcessLaunchedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.ProcessLaunchedAt, ok); err != nil {
			return err
		}
	}

	if v.ProcessName != nil {
		ok := object.Key("ProcessName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ProcessName, ok); err != nil {
			return err
		}
	}

	if v.ProcessParentPid != nil {
		ok := object.Key("ProcessParentPid")
		if err := awsRestjson1_serializeDocumentNumberFilterList(v.ProcessParentPid, ok); err != nil {
			return err
		}
	}

	if v.ProcessPath != nil {
		ok := object.Key("ProcessPath")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ProcessPath, ok); err != nil {
			return err
		}
	}

	if v.ProcessPid != nil {
		ok := object.Key("ProcessPid")
		if err := awsRestjson1_serializeDocumentNumberFilterList(v.ProcessPid, ok); err != nil {
			return err
		}
	}

	if v.ProcessTerminatedAt != nil {
		ok := object.Key("ProcessTerminatedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.ProcessTerminatedAt, ok); err != nil {
			return err
		}
	}

	if v.ProductArn != nil {
		ok := object.Key("ProductArn")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ProductArn, ok); err != nil {
			return err
		}
	}

	if v.ProductFields != nil {
		ok := object.Key("ProductFields")
		if err := awsRestjson1_serializeDocumentMapFilterList(v.ProductFields, ok); err != nil {
			return err
		}
	}

	if v.ProductName != nil {
		ok := object.Key("ProductName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ProductName, ok); err != nil {
			return err
		}
	}

	if v.RecommendationText != nil {
		ok := object.Key("RecommendationText")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.RecommendationText, ok); err != nil {
			return err
		}
	}

	if v.RecordState != nil {
		ok := object.Key("RecordState")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.RecordState, ok); err != nil {
			return err
		}
	}

	if v.RelatedFindingsId != nil {
		ok := object.Key("RelatedFindingsId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.RelatedFindingsId, ok); err != nil {
			return err
		}
	}

	if v.RelatedFindingsProductArn != nil {
		ok := object.Key("RelatedFindingsProductArn")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.RelatedFindingsProductArn, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceIamInstanceProfileArn != nil {
		ok := object.Key("ResourceAwsEc2InstanceIamInstanceProfileArn")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsEc2InstanceIamInstanceProfileArn, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceImageId != nil {
		ok := object.Key("ResourceAwsEc2InstanceImageId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsEc2InstanceImageId, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceIpV4Addresses != nil {
		ok := object.Key("ResourceAwsEc2InstanceIpV4Addresses")
		if err := awsRestjson1_serializeDocumentIpFilterList(v.ResourceAwsEc2InstanceIpV4Addresses, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceIpV6Addresses != nil {
		ok := object.Key("ResourceAwsEc2InstanceIpV6Addresses")
		if err := awsRestjson1_serializeDocumentIpFilterList(v.ResourceAwsEc2InstanceIpV6Addresses, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceKeyName != nil {
		ok := object.Key("ResourceAwsEc2InstanceKeyName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsEc2InstanceKeyName, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceLaunchedAt != nil {
		ok := object.Key("ResourceAwsEc2InstanceLaunchedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.ResourceAwsEc2InstanceLaunchedAt, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceSubnetId != nil {
		ok := object.Key("ResourceAwsEc2InstanceSubnetId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsEc2InstanceSubnetId, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceType != nil {
		ok := object.Key("ResourceAwsEc2InstanceType")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsEc2InstanceType, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsEc2InstanceVpcId != nil {
		ok := object.Key("ResourceAwsEc2InstanceVpcId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsEc2InstanceVpcId, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsIamAccessKeyCreatedAt != nil {
		ok := object.Key("ResourceAwsIamAccessKeyCreatedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.ResourceAwsIamAccessKeyCreatedAt, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsIamAccessKeyStatus != nil {
		ok := object.Key("ResourceAwsIamAccessKeyStatus")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsIamAccessKeyStatus, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsIamAccessKeyUserName != nil {
		ok := object.Key("ResourceAwsIamAccessKeyUserName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsIamAccessKeyUserName, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsS3BucketOwnerId != nil {
		ok := object.Key("ResourceAwsS3BucketOwnerId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsS3BucketOwnerId, ok); err != nil {
			return err
		}
	}

	if v.ResourceAwsS3BucketOwnerName != nil {
		ok := object.Key("ResourceAwsS3BucketOwnerName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceAwsS3BucketOwnerName, ok); err != nil {
			return err
		}
	}

	if v.ResourceContainerImageId != nil {
		ok := object.Key("ResourceContainerImageId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceContainerImageId, ok); err != nil {
			return err
		}
	}

	if v.ResourceContainerImageName != nil {
		ok := object.Key("ResourceContainerImageName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceContainerImageName, ok); err != nil {
			return err
		}
	}

	if v.ResourceContainerLaunchedAt != nil {
		ok := object.Key("ResourceContainerLaunchedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.ResourceContainerLaunchedAt, ok); err != nil {
			return err
		}
	}

	if v.ResourceContainerName != nil {
		ok := object.Key("ResourceContainerName")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceContainerName, ok); err != nil {
			return err
		}
	}

	if v.ResourceDetailsOther != nil {
		ok := object.Key("ResourceDetailsOther")
		if err := awsRestjson1_serializeDocumentMapFilterList(v.ResourceDetailsOther, ok); err != nil {
			return err
		}
	}

	if v.ResourceId != nil {
		ok := object.Key("ResourceId")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceId, ok); err != nil {
			return err
		}
	}

	if v.ResourcePartition != nil {
		ok := object.Key("ResourcePartition")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourcePartition, ok); err != nil {
			return err
		}
	}

	if v.ResourceRegion != nil {
		ok := object.Key("ResourceRegion")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceRegion, ok); err != nil {
			return err
		}
	}

	if v.ResourceTags != nil {
		ok := object.Key("ResourceTags")
		if err := awsRestjson1_serializeDocumentMapFilterList(v.ResourceTags, ok); err != nil {
			return err
		}
	}

	if v.ResourceType != nil {
		ok := object.Key("ResourceType")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ResourceType, ok); err != nil {
			return err
		}
	}

	if v.SeverityLabel != nil {
		ok := object.Key("SeverityLabel")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.SeverityLabel, ok); err != nil {
			return err
		}
	}

	if v.SeverityNormalized != nil {
		ok := object.Key("SeverityNormalized")
		if err := awsRestjson1_serializeDocumentNumberFilterList(v.SeverityNormalized, ok); err != nil {
			return err
		}
	}

	if v.SeverityProduct != nil {
		ok := object.Key("SeverityProduct")
		if err := awsRestjson1_serializeDocumentNumberFilterList(v.SeverityProduct, ok); err != nil {
			return err
		}
	}

	if v.SourceUrl != nil {
		ok := object.Key("SourceUrl")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.SourceUrl, ok); err != nil {
			return err
		}
	}

	if v.ThreatIntelIndicatorCategory != nil {
		ok := object.Key("ThreatIntelIndicatorCategory")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ThreatIntelIndicatorCategory, ok); err != nil {
			return err
		}
	}

	if v.ThreatIntelIndicatorLastObservedAt != nil {
		ok := object.Key("ThreatIntelIndicatorLastObservedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.ThreatIntelIndicatorLastObservedAt, ok); err != nil {
			return err
		}
	}

	if v.ThreatIntelIndicatorSource != nil {
		ok := object.Key("ThreatIntelIndicatorSource")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ThreatIntelIndicatorSource, ok); err != nil {
			return err
		}
	}

	if v.ThreatIntelIndicatorSourceUrl != nil {
		ok := object.Key("ThreatIntelIndicatorSourceUrl")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ThreatIntelIndicatorSourceUrl, ok); err != nil {
			return err
		}
	}

	if v.ThreatIntelIndicatorType != nil {
		ok := object.Key("ThreatIntelIndicatorType")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ThreatIntelIndicatorType, ok); err != nil {
			return err
		}
	}

	if v.ThreatIntelIndicatorValue != nil {
		ok := object.Key("ThreatIntelIndicatorValue")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.ThreatIntelIndicatorValue, ok); err != nil {
			return err
		}
	}

	if v.Title != nil {
		ok := object.Key("Title")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.Title, ok); err != nil {
			return err
		}
	}

	if v.Type != nil {
		ok := object.Key("Type")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.Type, ok); err != nil {
			return err
		}
	}

	if v.UpdatedAt != nil {
		ok := object.Key("UpdatedAt")
		if err := awsRestjson1_serializeDocumentDateFilterList(v.UpdatedAt, ok); err != nil {
			return err
		}
	}

	if v.UserDefinedFields != nil {
		ok := object.Key("UserDefinedFields")
		if err := awsRestjson1_serializeDocumentMapFilterList(v.UserDefinedFields, ok); err != nil {
			return err
		}
	}

	if v.VerificationState != nil {
		ok := object.Key("VerificationState")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.VerificationState, ok); err != nil {
			return err
		}
	}

	if v.WorkflowState != nil {
		ok := object.Key("WorkflowState")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.WorkflowState, ok); err != nil {
			return err
		}
	}

	if v.WorkflowStatus != nil {
		ok := object.Key("WorkflowStatus")
		if err := awsRestjson1_serializeDocumentStringFilterList(v.WorkflowStatus, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsSecurityFindingIdentifier(v *types.AwsSecurityFindingIdentifier, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Id != nil {
		ok := object.Key("Id")
		ok.String(*v.Id)
	}

	if v.ProductArn != nil {
		ok := object.Key("ProductArn")
		ok.String(*v.ProductArn)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsSecurityFindingIdentifierList(v []*types.AwsSecurityFindingIdentifier, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsSecurityFindingIdentifier(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsSecurityFindingList(v []*types.AwsSecurityFinding, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsSecurityFinding(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsSnsTopicDetails(v *types.AwsSnsTopicDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.KmsMasterKeyId != nil {
		ok := object.Key("KmsMasterKeyId")
		ok.String(*v.KmsMasterKeyId)
	}

	if v.Owner != nil {
		ok := object.Key("Owner")
		ok.String(*v.Owner)
	}

	if v.Subscription != nil {
		ok := object.Key("Subscription")
		if err := awsRestjson1_serializeDocumentAwsSnsTopicSubscriptionList(v.Subscription, ok); err != nil {
			return err
		}
	}

	if v.TopicName != nil {
		ok := object.Key("TopicName")
		ok.String(*v.TopicName)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsSnsTopicSubscription(v *types.AwsSnsTopicSubscription, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Endpoint != nil {
		ok := object.Key("Endpoint")
		ok.String(*v.Endpoint)
	}

	if v.Protocol != nil {
		ok := object.Key("Protocol")
		ok.String(*v.Protocol)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsSnsTopicSubscriptionList(v []*types.AwsSnsTopicSubscription, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsSnsTopicSubscription(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentAwsSqsQueueDetails(v *types.AwsSqsQueueDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DeadLetterTargetArn != nil {
		ok := object.Key("DeadLetterTargetArn")
		ok.String(*v.DeadLetterTargetArn)
	}

	if v.KmsDataKeyReusePeriodSeconds != nil {
		ok := object.Key("KmsDataKeyReusePeriodSeconds")
		ok.Integer(*v.KmsDataKeyReusePeriodSeconds)
	}

	if v.KmsMasterKeyId != nil {
		ok := object.Key("KmsMasterKeyId")
		ok.String(*v.KmsMasterKeyId)
	}

	if v.QueueName != nil {
		ok := object.Key("QueueName")
		ok.String(*v.QueueName)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsWafWebAclDetails(v *types.AwsWafWebAclDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DefaultAction != nil {
		ok := object.Key("DefaultAction")
		ok.String(*v.DefaultAction)
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	if v.Rules != nil {
		ok := object.Key("Rules")
		if err := awsRestjson1_serializeDocumentAwsWafWebAclRuleList(v.Rules, ok); err != nil {
			return err
		}
	}

	if v.WebAclId != nil {
		ok := object.Key("WebAclId")
		ok.String(*v.WebAclId)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsWafWebAclRule(v *types.AwsWafWebAclRule, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Action != nil {
		ok := object.Key("Action")
		if err := awsRestjson1_serializeDocumentWafAction(v.Action, ok); err != nil {
			return err
		}
	}

	if v.ExcludedRules != nil {
		ok := object.Key("ExcludedRules")
		if err := awsRestjson1_serializeDocumentWafExcludedRuleList(v.ExcludedRules, ok); err != nil {
			return err
		}
	}

	if v.OverrideAction != nil {
		ok := object.Key("OverrideAction")
		if err := awsRestjson1_serializeDocumentWafOverrideAction(v.OverrideAction, ok); err != nil {
			return err
		}
	}

	if v.Priority != nil {
		ok := object.Key("Priority")
		ok.Integer(*v.Priority)
	}

	if v.RuleId != nil {
		ok := object.Key("RuleId")
		ok.String(*v.RuleId)
	}

	if v.Type != nil {
		ok := object.Key("Type")
		ok.String(*v.Type)
	}

	return nil
}

func awsRestjson1_serializeDocumentAwsWafWebAclRuleList(v []*types.AwsWafWebAclRule, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentAwsWafWebAclRule(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentCidrBlockAssociation(v *types.CidrBlockAssociation, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AssociationId != nil {
		ok := object.Key("AssociationId")
		ok.String(*v.AssociationId)
	}

	if v.CidrBlock != nil {
		ok := object.Key("CidrBlock")
		ok.String(*v.CidrBlock)
	}

	if v.CidrBlockState != nil {
		ok := object.Key("CidrBlockState")
		ok.String(*v.CidrBlockState)
	}

	return nil
}

func awsRestjson1_serializeDocumentCidrBlockAssociationList(v []*types.CidrBlockAssociation, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentCidrBlockAssociation(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentCompliance(v *types.Compliance, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RelatedRequirements != nil {
		ok := object.Key("RelatedRequirements")
		if err := awsRestjson1_serializeDocumentRelatedRequirementsList(v.RelatedRequirements, ok); err != nil {
			return err
		}
	}

	if len(v.Status) > 0 {
		ok := object.Key("Status")
		ok.String(string(v.Status))
	}

	if v.StatusReasons != nil {
		ok := object.Key("StatusReasons")
		if err := awsRestjson1_serializeDocumentStatusReasonsList(v.StatusReasons, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentContainerDetails(v *types.ContainerDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ImageId != nil {
		ok := object.Key("ImageId")
		ok.String(*v.ImageId)
	}

	if v.ImageName != nil {
		ok := object.Key("ImageName")
		ok.String(*v.ImageName)
	}

	if v.LaunchedAt != nil {
		ok := object.Key("LaunchedAt")
		ok.String(*v.LaunchedAt)
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	return nil
}

func awsRestjson1_serializeDocumentCvss(v *types.Cvss, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BaseScore != nil {
		ok := object.Key("BaseScore")
		ok.Double(*v.BaseScore)
	}

	if v.BaseVector != nil {
		ok := object.Key("BaseVector")
		ok.String(*v.BaseVector)
	}

	if v.Version != nil {
		ok := object.Key("Version")
		ok.String(*v.Version)
	}

	return nil
}

func awsRestjson1_serializeDocumentCvssList(v []*types.Cvss, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentCvss(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentDateFilter(v *types.DateFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DateRange != nil {
		ok := object.Key("DateRange")
		if err := awsRestjson1_serializeDocumentDateRange(v.DateRange, ok); err != nil {
			return err
		}
	}

	if v.End != nil {
		ok := object.Key("End")
		ok.String(*v.End)
	}

	if v.Start != nil {
		ok := object.Key("Start")
		ok.String(*v.Start)
	}

	return nil
}

func awsRestjson1_serializeDocumentDateFilterList(v []*types.DateFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentDateFilter(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentDateRange(v *types.DateRange, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Unit) > 0 {
		ok := object.Key("Unit")
		ok.String(string(v.Unit))
	}

	if v.Value != nil {
		ok := object.Key("Value")
		ok.Integer(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentFieldMap(v map[string]*string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		if vv := v[key]; vv == nil {
			om.Null()
			continue
		}
		om.String(*v[key])
	}
	return nil
}

func awsRestjson1_serializeDocumentIpFilter(v *types.IpFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Cidr != nil {
		ok := object.Key("Cidr")
		ok.String(*v.Cidr)
	}

	return nil
}

func awsRestjson1_serializeDocumentIpFilterList(v []*types.IpFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentIpFilter(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentIpv6CidrBlockAssociation(v *types.Ipv6CidrBlockAssociation, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AssociationId != nil {
		ok := object.Key("AssociationId")
		ok.String(*v.AssociationId)
	}

	if v.CidrBlockState != nil {
		ok := object.Key("CidrBlockState")
		ok.String(*v.CidrBlockState)
	}

	if v.Ipv6CidrBlock != nil {
		ok := object.Key("Ipv6CidrBlock")
		ok.String(*v.Ipv6CidrBlock)
	}

	return nil
}

func awsRestjson1_serializeDocumentIpv6CidrBlockAssociationList(v []*types.Ipv6CidrBlockAssociation, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentIpv6CidrBlockAssociation(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentKeywordFilter(v *types.KeywordFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Value != nil {
		ok := object.Key("Value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentKeywordFilterList(v []*types.KeywordFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentKeywordFilter(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentLoadBalancerState(v *types.LoadBalancerState, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Code != nil {
		ok := object.Key("Code")
		ok.String(*v.Code)
	}

	if v.Reason != nil {
		ok := object.Key("Reason")
		ok.String(*v.Reason)
	}

	return nil
}

func awsRestjson1_serializeDocumentMalware(v *types.Malware, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	if v.Path != nil {
		ok := object.Key("Path")
		ok.String(*v.Path)
	}

	if len(v.State) > 0 {
		ok := object.Key("State")
		ok.String(string(v.State))
	}

	if len(v.Type) > 0 {
		ok := object.Key("Type")
		ok.String(string(v.Type))
	}

	return nil
}

func awsRestjson1_serializeDocumentMalwareList(v []*types.Malware, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentMalware(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentMapFilter(v *types.MapFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Comparison) > 0 {
		ok := object.Key("Comparison")
		ok.String(string(v.Comparison))
	}

	if v.Key != nil {
		ok := object.Key("Key")
		ok.String(*v.Key)
	}

	if v.Value != nil {
		ok := object.Key("Value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentMapFilterList(v []*types.MapFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentMapFilter(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentNetwork(v *types.Network, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DestinationDomain != nil {
		ok := object.Key("DestinationDomain")
		ok.String(*v.DestinationDomain)
	}

	if v.DestinationIpV4 != nil {
		ok := object.Key("DestinationIpV4")
		ok.String(*v.DestinationIpV4)
	}

	if v.DestinationIpV6 != nil {
		ok := object.Key("DestinationIpV6")
		ok.String(*v.DestinationIpV6)
	}

	if v.DestinationPort != nil {
		ok := object.Key("DestinationPort")
		ok.Integer(*v.DestinationPort)
	}

	if len(v.Direction) > 0 {
		ok := object.Key("Direction")
		ok.String(string(v.Direction))
	}

	if v.OpenPortRange != nil {
		ok := object.Key("OpenPortRange")
		if err := awsRestjson1_serializeDocumentPortRange(v.OpenPortRange, ok); err != nil {
			return err
		}
	}

	if v.Protocol != nil {
		ok := object.Key("Protocol")
		ok.String(*v.Protocol)
	}

	if v.SourceDomain != nil {
		ok := object.Key("SourceDomain")
		ok.String(*v.SourceDomain)
	}

	if v.SourceIpV4 != nil {
		ok := object.Key("SourceIpV4")
		ok.String(*v.SourceIpV4)
	}

	if v.SourceIpV6 != nil {
		ok := object.Key("SourceIpV6")
		ok.String(*v.SourceIpV6)
	}

	if v.SourceMac != nil {
		ok := object.Key("SourceMac")
		ok.String(*v.SourceMac)
	}

	if v.SourcePort != nil {
		ok := object.Key("SourcePort")
		ok.Integer(*v.SourcePort)
	}

	return nil
}

func awsRestjson1_serializeDocumentNetworkHeader(v *types.NetworkHeader, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Destination != nil {
		ok := object.Key("Destination")
		if err := awsRestjson1_serializeDocumentNetworkPathComponentDetails(v.Destination, ok); err != nil {
			return err
		}
	}

	if v.Protocol != nil {
		ok := object.Key("Protocol")
		ok.String(*v.Protocol)
	}

	if v.Source != nil {
		ok := object.Key("Source")
		if err := awsRestjson1_serializeDocumentNetworkPathComponentDetails(v.Source, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentNetworkPathComponent(v *types.NetworkPathComponent, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ComponentId != nil {
		ok := object.Key("ComponentId")
		ok.String(*v.ComponentId)
	}

	if v.ComponentType != nil {
		ok := object.Key("ComponentType")
		ok.String(*v.ComponentType)
	}

	if v.Egress != nil {
		ok := object.Key("Egress")
		if err := awsRestjson1_serializeDocumentNetworkHeader(v.Egress, ok); err != nil {
			return err
		}
	}

	if v.Ingress != nil {
		ok := object.Key("Ingress")
		if err := awsRestjson1_serializeDocumentNetworkHeader(v.Ingress, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentNetworkPathComponentDetails(v *types.NetworkPathComponentDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Address != nil {
		ok := object.Key("Address")
		if err := awsRestjson1_serializeDocumentStringList(v.Address, ok); err != nil {
			return err
		}
	}

	if v.PortRanges != nil {
		ok := object.Key("PortRanges")
		if err := awsRestjson1_serializeDocumentPortRangeList(v.PortRanges, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentNetworkPathList(v []*types.NetworkPathComponent, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentNetworkPathComponent(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentNonEmptyStringList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentNote(v *types.Note, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Text != nil {
		ok := object.Key("Text")
		ok.String(*v.Text)
	}

	if v.UpdatedAt != nil {
		ok := object.Key("UpdatedAt")
		ok.String(*v.UpdatedAt)
	}

	if v.UpdatedBy != nil {
		ok := object.Key("UpdatedBy")
		ok.String(*v.UpdatedBy)
	}

	return nil
}

func awsRestjson1_serializeDocumentNoteUpdate(v *types.NoteUpdate, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Text != nil {
		ok := object.Key("Text")
		ok.String(*v.Text)
	}

	if v.UpdatedBy != nil {
		ok := object.Key("UpdatedBy")
		ok.String(*v.UpdatedBy)
	}

	return nil
}

func awsRestjson1_serializeDocumentNumberFilter(v *types.NumberFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Eq != nil {
		ok := object.Key("Eq")
		ok.Double(*v.Eq)
	}

	if v.Gte != nil {
		ok := object.Key("Gte")
		ok.Double(*v.Gte)
	}

	if v.Lte != nil {
		ok := object.Key("Lte")
		ok.Double(*v.Lte)
	}

	return nil
}

func awsRestjson1_serializeDocumentNumberFilterList(v []*types.NumberFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentNumberFilter(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentPortRange(v *types.PortRange, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Begin != nil {
		ok := object.Key("Begin")
		ok.Integer(*v.Begin)
	}

	if v.End != nil {
		ok := object.Key("End")
		ok.Integer(*v.End)
	}

	return nil
}

func awsRestjson1_serializeDocumentPortRangeList(v []*types.PortRange, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentPortRange(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentProcessDetails(v *types.ProcessDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.LaunchedAt != nil {
		ok := object.Key("LaunchedAt")
		ok.String(*v.LaunchedAt)
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	if v.ParentPid != nil {
		ok := object.Key("ParentPid")
		ok.Integer(*v.ParentPid)
	}

	if v.Path != nil {
		ok := object.Key("Path")
		ok.String(*v.Path)
	}

	if v.Pid != nil {
		ok := object.Key("Pid")
		ok.Integer(*v.Pid)
	}

	if v.TerminatedAt != nil {
		ok := object.Key("TerminatedAt")
		ok.String(*v.TerminatedAt)
	}

	return nil
}

func awsRestjson1_serializeDocumentRecommendation(v *types.Recommendation, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Text != nil {
		ok := object.Key("Text")
		ok.String(*v.Text)
	}

	if v.Url != nil {
		ok := object.Key("Url")
		ok.String(*v.Url)
	}

	return nil
}

func awsRestjson1_serializeDocumentRelatedFinding(v *types.RelatedFinding, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Id != nil {
		ok := object.Key("Id")
		ok.String(*v.Id)
	}

	if v.ProductArn != nil {
		ok := object.Key("ProductArn")
		ok.String(*v.ProductArn)
	}

	return nil
}

func awsRestjson1_serializeDocumentRelatedFindingList(v []*types.RelatedFinding, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentRelatedFinding(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentRelatedRequirementsList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentRemediation(v *types.Remediation, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Recommendation != nil {
		ok := object.Key("Recommendation")
		if err := awsRestjson1_serializeDocumentRecommendation(v.Recommendation, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentResource(v *types.Resource, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Details != nil {
		ok := object.Key("Details")
		if err := awsRestjson1_serializeDocumentResourceDetails(v.Details, ok); err != nil {
			return err
		}
	}

	if v.Id != nil {
		ok := object.Key("Id")
		ok.String(*v.Id)
	}

	if len(v.Partition) > 0 {
		ok := object.Key("Partition")
		ok.String(string(v.Partition))
	}

	if v.Region != nil {
		ok := object.Key("Region")
		ok.String(*v.Region)
	}

	if v.Tags != nil {
		ok := object.Key("Tags")
		if err := awsRestjson1_serializeDocumentFieldMap(v.Tags, ok); err != nil {
			return err
		}
	}

	if v.Type != nil {
		ok := object.Key("Type")
		ok.String(*v.Type)
	}

	return nil
}

func awsRestjson1_serializeDocumentResourceDetails(v *types.ResourceDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AwsAutoScalingAutoScalingGroup != nil {
		ok := object.Key("AwsAutoScalingAutoScalingGroup")
		if err := awsRestjson1_serializeDocumentAwsAutoScalingAutoScalingGroupDetails(v.AwsAutoScalingAutoScalingGroup, ok); err != nil {
			return err
		}
	}

	if v.AwsCloudFrontDistribution != nil {
		ok := object.Key("AwsCloudFrontDistribution")
		if err := awsRestjson1_serializeDocumentAwsCloudFrontDistributionDetails(v.AwsCloudFrontDistribution, ok); err != nil {
			return err
		}
	}

	if v.AwsCodeBuildProject != nil {
		ok := object.Key("AwsCodeBuildProject")
		if err := awsRestjson1_serializeDocumentAwsCodeBuildProjectDetails(v.AwsCodeBuildProject, ok); err != nil {
			return err
		}
	}

	if v.AwsEc2Instance != nil {
		ok := object.Key("AwsEc2Instance")
		if err := awsRestjson1_serializeDocumentAwsEc2InstanceDetails(v.AwsEc2Instance, ok); err != nil {
			return err
		}
	}

	if v.AwsEc2NetworkInterface != nil {
		ok := object.Key("AwsEc2NetworkInterface")
		if err := awsRestjson1_serializeDocumentAwsEc2NetworkInterfaceDetails(v.AwsEc2NetworkInterface, ok); err != nil {
			return err
		}
	}

	if v.AwsEc2SecurityGroup != nil {
		ok := object.Key("AwsEc2SecurityGroup")
		if err := awsRestjson1_serializeDocumentAwsEc2SecurityGroupDetails(v.AwsEc2SecurityGroup, ok); err != nil {
			return err
		}
	}

	if v.AwsEc2Volume != nil {
		ok := object.Key("AwsEc2Volume")
		if err := awsRestjson1_serializeDocumentAwsEc2VolumeDetails(v.AwsEc2Volume, ok); err != nil {
			return err
		}
	}

	if v.AwsEc2Vpc != nil {
		ok := object.Key("AwsEc2Vpc")
		if err := awsRestjson1_serializeDocumentAwsEc2VpcDetails(v.AwsEc2Vpc, ok); err != nil {
			return err
		}
	}

	if v.AwsElasticsearchDomain != nil {
		ok := object.Key("AwsElasticsearchDomain")
		if err := awsRestjson1_serializeDocumentAwsElasticsearchDomainDetails(v.AwsElasticsearchDomain, ok); err != nil {
			return err
		}
	}

	if v.AwsElbv2LoadBalancer != nil {
		ok := object.Key("AwsElbv2LoadBalancer")
		if err := awsRestjson1_serializeDocumentAwsElbv2LoadBalancerDetails(v.AwsElbv2LoadBalancer, ok); err != nil {
			return err
		}
	}

	if v.AwsIamAccessKey != nil {
		ok := object.Key("AwsIamAccessKey")
		if err := awsRestjson1_serializeDocumentAwsIamAccessKeyDetails(v.AwsIamAccessKey, ok); err != nil {
			return err
		}
	}

	if v.AwsIamRole != nil {
		ok := object.Key("AwsIamRole")
		if err := awsRestjson1_serializeDocumentAwsIamRoleDetails(v.AwsIamRole, ok); err != nil {
			return err
		}
	}

	if v.AwsKmsKey != nil {
		ok := object.Key("AwsKmsKey")
		if err := awsRestjson1_serializeDocumentAwsKmsKeyDetails(v.AwsKmsKey, ok); err != nil {
			return err
		}
	}

	if v.AwsLambdaFunction != nil {
		ok := object.Key("AwsLambdaFunction")
		if err := awsRestjson1_serializeDocumentAwsLambdaFunctionDetails(v.AwsLambdaFunction, ok); err != nil {
			return err
		}
	}

	if v.AwsLambdaLayerVersion != nil {
		ok := object.Key("AwsLambdaLayerVersion")
		if err := awsRestjson1_serializeDocumentAwsLambdaLayerVersionDetails(v.AwsLambdaLayerVersion, ok); err != nil {
			return err
		}
	}

	if v.AwsRdsDbInstance != nil {
		ok := object.Key("AwsRdsDbInstance")
		if err := awsRestjson1_serializeDocumentAwsRdsDbInstanceDetails(v.AwsRdsDbInstance, ok); err != nil {
			return err
		}
	}

	if v.AwsS3Bucket != nil {
		ok := object.Key("AwsS3Bucket")
		if err := awsRestjson1_serializeDocumentAwsS3BucketDetails(v.AwsS3Bucket, ok); err != nil {
			return err
		}
	}

	if v.AwsS3Object != nil {
		ok := object.Key("AwsS3Object")
		if err := awsRestjson1_serializeDocumentAwsS3ObjectDetails(v.AwsS3Object, ok); err != nil {
			return err
		}
	}

	if v.AwsSnsTopic != nil {
		ok := object.Key("AwsSnsTopic")
		if err := awsRestjson1_serializeDocumentAwsSnsTopicDetails(v.AwsSnsTopic, ok); err != nil {
			return err
		}
	}

	if v.AwsSqsQueue != nil {
		ok := object.Key("AwsSqsQueue")
		if err := awsRestjson1_serializeDocumentAwsSqsQueueDetails(v.AwsSqsQueue, ok); err != nil {
			return err
		}
	}

	if v.AwsWafWebAcl != nil {
		ok := object.Key("AwsWafWebAcl")
		if err := awsRestjson1_serializeDocumentAwsWafWebAclDetails(v.AwsWafWebAcl, ok); err != nil {
			return err
		}
	}

	if v.Container != nil {
		ok := object.Key("Container")
		if err := awsRestjson1_serializeDocumentContainerDetails(v.Container, ok); err != nil {
			return err
		}
	}

	if v.Other != nil {
		ok := object.Key("Other")
		if err := awsRestjson1_serializeDocumentFieldMap(v.Other, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentResourceList(v []*types.Resource, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentResource(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSecurityGroups(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentSeverity(v *types.Severity, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Label) > 0 {
		ok := object.Key("Label")
		ok.String(string(v.Label))
	}

	if v.Normalized != nil {
		ok := object.Key("Normalized")
		ok.Integer(*v.Normalized)
	}

	if v.Original != nil {
		ok := object.Key("Original")
		ok.String(*v.Original)
	}

	if v.Product != nil {
		ok := object.Key("Product")
		ok.Double(*v.Product)
	}

	return nil
}

func awsRestjson1_serializeDocumentSeverityUpdate(v *types.SeverityUpdate, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Label) > 0 {
		ok := object.Key("Label")
		ok.String(string(v.Label))
	}

	if v.Normalized != nil {
		ok := object.Key("Normalized")
		ok.Integer(*v.Normalized)
	}

	if v.Product != nil {
		ok := object.Key("Product")
		ok.Double(*v.Product)
	}

	return nil
}

func awsRestjson1_serializeDocumentSoftwarePackage(v *types.SoftwarePackage, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Architecture != nil {
		ok := object.Key("Architecture")
		ok.String(*v.Architecture)
	}

	if v.Epoch != nil {
		ok := object.Key("Epoch")
		ok.String(*v.Epoch)
	}

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	if v.Release != nil {
		ok := object.Key("Release")
		ok.String(*v.Release)
	}

	if v.Version != nil {
		ok := object.Key("Version")
		ok.String(*v.Version)
	}

	return nil
}

func awsRestjson1_serializeDocumentSoftwarePackageList(v []*types.SoftwarePackage, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentSoftwarePackage(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSortCriteria(v []*types.SortCriterion, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentSortCriterion(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSortCriterion(v *types.SortCriterion, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Field != nil {
		ok := object.Key("Field")
		ok.String(*v.Field)
	}

	if len(v.SortOrder) > 0 {
		ok := object.Key("SortOrder")
		ok.String(string(v.SortOrder))
	}

	return nil
}

func awsRestjson1_serializeDocumentStandardsInputParameterMap(v map[string]*string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		if vv := v[key]; vv == nil {
			om.Null()
			continue
		}
		om.String(*v[key])
	}
	return nil
}

func awsRestjson1_serializeDocumentStandardsSubscriptionArns(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentStandardsSubscriptionRequest(v *types.StandardsSubscriptionRequest, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.StandardsArn != nil {
		ok := object.Key("StandardsArn")
		ok.String(*v.StandardsArn)
	}

	if v.StandardsInput != nil {
		ok := object.Key("StandardsInput")
		if err := awsRestjson1_serializeDocumentStandardsInputParameterMap(v.StandardsInput, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentStandardsSubscriptionRequests(v []*types.StandardsSubscriptionRequest, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentStandardsSubscriptionRequest(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentStatusReason(v *types.StatusReason, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("Description")
		ok.String(*v.Description)
	}

	if v.ReasonCode != nil {
		ok := object.Key("ReasonCode")
		ok.String(*v.ReasonCode)
	}

	return nil
}

func awsRestjson1_serializeDocumentStatusReasonsList(v []*types.StatusReason, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentStatusReason(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentStringFilter(v *types.StringFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Comparison) > 0 {
		ok := object.Key("Comparison")
		ok.String(string(v.Comparison))
	}

	if v.Value != nil {
		ok := object.Key("Value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentStringFilterList(v []*types.StringFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentStringFilter(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentStringList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentTagMap(v map[string]*string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		if vv := v[key]; vv == nil {
			om.Null()
			continue
		}
		om.String(*v[key])
	}
	return nil
}

func awsRestjson1_serializeDocumentThreatIntelIndicator(v *types.ThreatIntelIndicator, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Category) > 0 {
		ok := object.Key("Category")
		ok.String(string(v.Category))
	}

	if v.LastObservedAt != nil {
		ok := object.Key("LastObservedAt")
		ok.String(*v.LastObservedAt)
	}

	if v.Source != nil {
		ok := object.Key("Source")
		ok.String(*v.Source)
	}

	if v.SourceUrl != nil {
		ok := object.Key("SourceUrl")
		ok.String(*v.SourceUrl)
	}

	if len(v.Type) > 0 {
		ok := object.Key("Type")
		ok.String(string(v.Type))
	}

	if v.Value != nil {
		ok := object.Key("Value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentThreatIntelIndicatorList(v []*types.ThreatIntelIndicator, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentThreatIntelIndicator(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentTypeList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentVulnerability(v *types.Vulnerability, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Cvss != nil {
		ok := object.Key("Cvss")
		if err := awsRestjson1_serializeDocumentCvssList(v.Cvss, ok); err != nil {
			return err
		}
	}

	if v.Id != nil {
		ok := object.Key("Id")
		ok.String(*v.Id)
	}

	if v.ReferenceUrls != nil {
		ok := object.Key("ReferenceUrls")
		if err := awsRestjson1_serializeDocumentStringList(v.ReferenceUrls, ok); err != nil {
			return err
		}
	}

	if v.RelatedVulnerabilities != nil {
		ok := object.Key("RelatedVulnerabilities")
		if err := awsRestjson1_serializeDocumentStringList(v.RelatedVulnerabilities, ok); err != nil {
			return err
		}
	}

	if v.Vendor != nil {
		ok := object.Key("Vendor")
		if err := awsRestjson1_serializeDocumentVulnerabilityVendor(v.Vendor, ok); err != nil {
			return err
		}
	}

	if v.VulnerablePackages != nil {
		ok := object.Key("VulnerablePackages")
		if err := awsRestjson1_serializeDocumentSoftwarePackageList(v.VulnerablePackages, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentVulnerabilityList(v []*types.Vulnerability, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentVulnerability(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentVulnerabilityVendor(v *types.VulnerabilityVendor, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Name != nil {
		ok := object.Key("Name")
		ok.String(*v.Name)
	}

	if v.Url != nil {
		ok := object.Key("Url")
		ok.String(*v.Url)
	}

	if v.VendorCreatedAt != nil {
		ok := object.Key("VendorCreatedAt")
		ok.String(*v.VendorCreatedAt)
	}

	if v.VendorSeverity != nil {
		ok := object.Key("VendorSeverity")
		ok.String(*v.VendorSeverity)
	}

	if v.VendorUpdatedAt != nil {
		ok := object.Key("VendorUpdatedAt")
		ok.String(*v.VendorUpdatedAt)
	}

	return nil
}

func awsRestjson1_serializeDocumentWafAction(v *types.WafAction, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Type != nil {
		ok := object.Key("Type")
		ok.String(*v.Type)
	}

	return nil
}

func awsRestjson1_serializeDocumentWafExcludedRule(v *types.WafExcludedRule, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RuleId != nil {
		ok := object.Key("RuleId")
		ok.String(*v.RuleId)
	}

	return nil
}

func awsRestjson1_serializeDocumentWafExcludedRuleList(v []*types.WafExcludedRule, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentWafExcludedRule(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentWafOverrideAction(v *types.WafOverrideAction, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Type != nil {
		ok := object.Key("Type")
		ok.String(*v.Type)
	}

	return nil
}

func awsRestjson1_serializeDocumentWorkflow(v *types.Workflow, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Status) > 0 {
		ok := object.Key("Status")
		ok.String(string(v.Status))
	}

	return nil
}

func awsRestjson1_serializeDocumentWorkflowUpdate(v *types.WorkflowUpdate, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Status) > 0 {
		ok := object.Key("Status")
		ok.String(string(v.Status))
	}

	return nil
}
