// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package mediapackage

import (
	"fmt"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

const opCreateChannel = "CreateChannel"

// CreateChannelRequest is a API request type for the CreateChannel API operation.
type CreateChannelRequest struct {
	*aws.Request
	Input *CreateChannelInput
	Copy  func(*CreateChannelInput) CreateChannelRequest
}

// Send marshals and sends the CreateChannel API request.
func (r CreateChannelRequest) Send() (*CreateChannelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateChannelOutput), nil
}

// CreateChannelRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Creates a new Channel.
//
//    // Example sending a request using the CreateChannelRequest method.
//    req := client.CreateChannelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CreateChannel
func (c *MediaPackage) CreateChannelRequest(input *CreateChannelInput) CreateChannelRequest {
	op := &aws.Operation{
		Name:       opCreateChannel,
		HTTPMethod: "POST",
		HTTPPath:   "/channels",
	}

	if input == nil {
		input = &CreateChannelInput{}
	}

	output := &CreateChannelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateChannelRequest{Request: req, Input: input, Copy: c.CreateChannelRequest}
}

const opCreateOriginEndpoint = "CreateOriginEndpoint"

// CreateOriginEndpointRequest is a API request type for the CreateOriginEndpoint API operation.
type CreateOriginEndpointRequest struct {
	*aws.Request
	Input *CreateOriginEndpointInput
	Copy  func(*CreateOriginEndpointInput) CreateOriginEndpointRequest
}

// Send marshals and sends the CreateOriginEndpoint API request.
func (r CreateOriginEndpointRequest) Send() (*CreateOriginEndpointOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateOriginEndpointOutput), nil
}

// CreateOriginEndpointRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Creates a new OriginEndpoint record.
//
//    // Example sending a request using the CreateOriginEndpointRequest method.
//    req := client.CreateOriginEndpointRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CreateOriginEndpoint
func (c *MediaPackage) CreateOriginEndpointRequest(input *CreateOriginEndpointInput) CreateOriginEndpointRequest {
	op := &aws.Operation{
		Name:       opCreateOriginEndpoint,
		HTTPMethod: "POST",
		HTTPPath:   "/origin_endpoints",
	}

	if input == nil {
		input = &CreateOriginEndpointInput{}
	}

	output := &CreateOriginEndpointOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateOriginEndpointRequest{Request: req, Input: input, Copy: c.CreateOriginEndpointRequest}
}

const opDeleteChannel = "DeleteChannel"

// DeleteChannelRequest is a API request type for the DeleteChannel API operation.
type DeleteChannelRequest struct {
	*aws.Request
	Input *DeleteChannelInput
	Copy  func(*DeleteChannelInput) DeleteChannelRequest
}

// Send marshals and sends the DeleteChannel API request.
func (r DeleteChannelRequest) Send() (*DeleteChannelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteChannelOutput), nil
}

// DeleteChannelRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Deletes an existing Channel.
//
//    // Example sending a request using the DeleteChannelRequest method.
//    req := client.DeleteChannelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DeleteChannel
func (c *MediaPackage) DeleteChannelRequest(input *DeleteChannelInput) DeleteChannelRequest {
	op := &aws.Operation{
		Name:       opDeleteChannel,
		HTTPMethod: "DELETE",
		HTTPPath:   "/channels/{id}",
	}

	if input == nil {
		input = &DeleteChannelInput{}
	}

	output := &DeleteChannelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteChannelRequest{Request: req, Input: input, Copy: c.DeleteChannelRequest}
}

const opDeleteOriginEndpoint = "DeleteOriginEndpoint"

// DeleteOriginEndpointRequest is a API request type for the DeleteOriginEndpoint API operation.
type DeleteOriginEndpointRequest struct {
	*aws.Request
	Input *DeleteOriginEndpointInput
	Copy  func(*DeleteOriginEndpointInput) DeleteOriginEndpointRequest
}

// Send marshals and sends the DeleteOriginEndpoint API request.
func (r DeleteOriginEndpointRequest) Send() (*DeleteOriginEndpointOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteOriginEndpointOutput), nil
}

// DeleteOriginEndpointRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Deletes an existing OriginEndpoint.
//
//    // Example sending a request using the DeleteOriginEndpointRequest method.
//    req := client.DeleteOriginEndpointRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DeleteOriginEndpoint
func (c *MediaPackage) DeleteOriginEndpointRequest(input *DeleteOriginEndpointInput) DeleteOriginEndpointRequest {
	op := &aws.Operation{
		Name:       opDeleteOriginEndpoint,
		HTTPMethod: "DELETE",
		HTTPPath:   "/origin_endpoints/{id}",
	}

	if input == nil {
		input = &DeleteOriginEndpointInput{}
	}

	output := &DeleteOriginEndpointOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteOriginEndpointRequest{Request: req, Input: input, Copy: c.DeleteOriginEndpointRequest}
}

const opDescribeChannel = "DescribeChannel"

// DescribeChannelRequest is a API request type for the DescribeChannel API operation.
type DescribeChannelRequest struct {
	*aws.Request
	Input *DescribeChannelInput
	Copy  func(*DescribeChannelInput) DescribeChannelRequest
}

// Send marshals and sends the DescribeChannel API request.
func (r DescribeChannelRequest) Send() (*DescribeChannelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeChannelOutput), nil
}

// DescribeChannelRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Gets details about a Channel.
//
//    // Example sending a request using the DescribeChannelRequest method.
//    req := client.DescribeChannelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DescribeChannel
func (c *MediaPackage) DescribeChannelRequest(input *DescribeChannelInput) DescribeChannelRequest {
	op := &aws.Operation{
		Name:       opDescribeChannel,
		HTTPMethod: "GET",
		HTTPPath:   "/channels/{id}",
	}

	if input == nil {
		input = &DescribeChannelInput{}
	}

	output := &DescribeChannelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeChannelRequest{Request: req, Input: input, Copy: c.DescribeChannelRequest}
}

const opDescribeOriginEndpoint = "DescribeOriginEndpoint"

// DescribeOriginEndpointRequest is a API request type for the DescribeOriginEndpoint API operation.
type DescribeOriginEndpointRequest struct {
	*aws.Request
	Input *DescribeOriginEndpointInput
	Copy  func(*DescribeOriginEndpointInput) DescribeOriginEndpointRequest
}

// Send marshals and sends the DescribeOriginEndpoint API request.
func (r DescribeOriginEndpointRequest) Send() (*DescribeOriginEndpointOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeOriginEndpointOutput), nil
}

// DescribeOriginEndpointRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Gets details about an existing OriginEndpoint.
//
//    // Example sending a request using the DescribeOriginEndpointRequest method.
//    req := client.DescribeOriginEndpointRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DescribeOriginEndpoint
func (c *MediaPackage) DescribeOriginEndpointRequest(input *DescribeOriginEndpointInput) DescribeOriginEndpointRequest {
	op := &aws.Operation{
		Name:       opDescribeOriginEndpoint,
		HTTPMethod: "GET",
		HTTPPath:   "/origin_endpoints/{id}",
	}

	if input == nil {
		input = &DescribeOriginEndpointInput{}
	}

	output := &DescribeOriginEndpointOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeOriginEndpointRequest{Request: req, Input: input, Copy: c.DescribeOriginEndpointRequest}
}

const opListChannels = "ListChannels"

// ListChannelsRequest is a API request type for the ListChannels API operation.
type ListChannelsRequest struct {
	*aws.Request
	Input *ListChannelsInput
	Copy  func(*ListChannelsInput) ListChannelsRequest
}

// Send marshals and sends the ListChannels API request.
func (r ListChannelsRequest) Send() (*ListChannelsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListChannelsOutput), nil
}

// ListChannelsRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Returns a collection of Channels.
//
//    // Example sending a request using the ListChannelsRequest method.
//    req := client.ListChannelsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/ListChannels
func (c *MediaPackage) ListChannelsRequest(input *ListChannelsInput) ListChannelsRequest {
	op := &aws.Operation{
		Name:       opListChannels,
		HTTPMethod: "GET",
		HTTPPath:   "/channels",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListChannelsInput{}
	}

	output := &ListChannelsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListChannelsRequest{Request: req, Input: input, Copy: c.ListChannelsRequest}
}

// Paginate pages iterates over the pages of a ListChannelsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListChannels operation.
//		req := client.ListChannelsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListChannelsRequest) Paginate(opts ...aws.Option) ListChannelsPager {
	return ListChannelsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListChannelsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListChannelsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListChannelsPager struct {
	aws.Pager
}

func (p *ListChannelsPager) CurrentPage() *ListChannelsOutput {
	return p.Pager.CurrentPage().(*ListChannelsOutput)
}

const opListOriginEndpoints = "ListOriginEndpoints"

// ListOriginEndpointsRequest is a API request type for the ListOriginEndpoints API operation.
type ListOriginEndpointsRequest struct {
	*aws.Request
	Input *ListOriginEndpointsInput
	Copy  func(*ListOriginEndpointsInput) ListOriginEndpointsRequest
}

// Send marshals and sends the ListOriginEndpoints API request.
func (r ListOriginEndpointsRequest) Send() (*ListOriginEndpointsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListOriginEndpointsOutput), nil
}

// ListOriginEndpointsRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Returns a collection of OriginEndpoint records.
//
//    // Example sending a request using the ListOriginEndpointsRequest method.
//    req := client.ListOriginEndpointsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/ListOriginEndpoints
func (c *MediaPackage) ListOriginEndpointsRequest(input *ListOriginEndpointsInput) ListOriginEndpointsRequest {
	op := &aws.Operation{
		Name:       opListOriginEndpoints,
		HTTPMethod: "GET",
		HTTPPath:   "/origin_endpoints",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListOriginEndpointsInput{}
	}

	output := &ListOriginEndpointsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListOriginEndpointsRequest{Request: req, Input: input, Copy: c.ListOriginEndpointsRequest}
}

// Paginate pages iterates over the pages of a ListOriginEndpointsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListOriginEndpoints operation.
//		req := client.ListOriginEndpointsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListOriginEndpointsRequest) Paginate(opts ...aws.Option) ListOriginEndpointsPager {
	return ListOriginEndpointsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListOriginEndpointsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListOriginEndpointsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListOriginEndpointsPager struct {
	aws.Pager
}

func (p *ListOriginEndpointsPager) CurrentPage() *ListOriginEndpointsOutput {
	return p.Pager.CurrentPage().(*ListOriginEndpointsOutput)
}

const opRotateChannelCredentials = "RotateChannelCredentials"

// RotateChannelCredentialsRequest is a API request type for the RotateChannelCredentials API operation.
type RotateChannelCredentialsRequest struct {
	*aws.Request
	Input *RotateChannelCredentialsInput
	Copy  func(*RotateChannelCredentialsInput) RotateChannelCredentialsRequest
}

// Send marshals and sends the RotateChannelCredentials API request.
func (r RotateChannelCredentialsRequest) Send() (*RotateChannelCredentialsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RotateChannelCredentialsOutput), nil
}

// RotateChannelCredentialsRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Changes the Channel's first IngestEndpoint's username and password. WARNING
// - This API is deprecated. Please use RotateIngestEndpointCredentials instead
//
//    // Example sending a request using the RotateChannelCredentialsRequest method.
//    req := client.RotateChannelCredentialsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/RotateChannelCredentials
func (c *MediaPackage) RotateChannelCredentialsRequest(input *RotateChannelCredentialsInput) RotateChannelCredentialsRequest {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, RotateChannelCredentials, has been deprecated")
	}
	op := &aws.Operation{
		Name:       opRotateChannelCredentials,
		HTTPMethod: "PUT",
		HTTPPath:   "/channels/{id}/credentials",
	}

	if input == nil {
		input = &RotateChannelCredentialsInput{}
	}

	output := &RotateChannelCredentialsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RotateChannelCredentialsRequest{Request: req, Input: input, Copy: c.RotateChannelCredentialsRequest}
}

const opRotateIngestEndpointCredentials = "RotateIngestEndpointCredentials"

// RotateIngestEndpointCredentialsRequest is a API request type for the RotateIngestEndpointCredentials API operation.
type RotateIngestEndpointCredentialsRequest struct {
	*aws.Request
	Input *RotateIngestEndpointCredentialsInput
	Copy  func(*RotateIngestEndpointCredentialsInput) RotateIngestEndpointCredentialsRequest
}

// Send marshals and sends the RotateIngestEndpointCredentials API request.
func (r RotateIngestEndpointCredentialsRequest) Send() (*RotateIngestEndpointCredentialsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RotateIngestEndpointCredentialsOutput), nil
}

// RotateIngestEndpointCredentialsRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Rotate the IngestEndpoint's username and password, as specified by the IngestEndpoint's
// id.
//
//    // Example sending a request using the RotateIngestEndpointCredentialsRequest method.
//    req := client.RotateIngestEndpointCredentialsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/RotateIngestEndpointCredentials
func (c *MediaPackage) RotateIngestEndpointCredentialsRequest(input *RotateIngestEndpointCredentialsInput) RotateIngestEndpointCredentialsRequest {
	op := &aws.Operation{
		Name:       opRotateIngestEndpointCredentials,
		HTTPMethod: "PUT",
		HTTPPath:   "/channels/{id}/ingest_endpoints/{ingest_endpoint_id}/credentials",
	}

	if input == nil {
		input = &RotateIngestEndpointCredentialsInput{}
	}

	output := &RotateIngestEndpointCredentialsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RotateIngestEndpointCredentialsRequest{Request: req, Input: input, Copy: c.RotateIngestEndpointCredentialsRequest}
}

const opUpdateChannel = "UpdateChannel"

// UpdateChannelRequest is a API request type for the UpdateChannel API operation.
type UpdateChannelRequest struct {
	*aws.Request
	Input *UpdateChannelInput
	Copy  func(*UpdateChannelInput) UpdateChannelRequest
}

// Send marshals and sends the UpdateChannel API request.
func (r UpdateChannelRequest) Send() (*UpdateChannelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateChannelOutput), nil
}

// UpdateChannelRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Updates an existing Channel.
//
//    // Example sending a request using the UpdateChannelRequest method.
//    req := client.UpdateChannelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/UpdateChannel
func (c *MediaPackage) UpdateChannelRequest(input *UpdateChannelInput) UpdateChannelRequest {
	op := &aws.Operation{
		Name:       opUpdateChannel,
		HTTPMethod: "PUT",
		HTTPPath:   "/channels/{id}",
	}

	if input == nil {
		input = &UpdateChannelInput{}
	}

	output := &UpdateChannelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateChannelRequest{Request: req, Input: input, Copy: c.UpdateChannelRequest}
}

const opUpdateOriginEndpoint = "UpdateOriginEndpoint"

// UpdateOriginEndpointRequest is a API request type for the UpdateOriginEndpoint API operation.
type UpdateOriginEndpointRequest struct {
	*aws.Request
	Input *UpdateOriginEndpointInput
	Copy  func(*UpdateOriginEndpointInput) UpdateOriginEndpointRequest
}

// Send marshals and sends the UpdateOriginEndpoint API request.
func (r UpdateOriginEndpointRequest) Send() (*UpdateOriginEndpointOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateOriginEndpointOutput), nil
}

// UpdateOriginEndpointRequest returns a request value for making API operation for
// AWS Elemental MediaPackage.
//
// Updates an existing OriginEndpoint.
//
//    // Example sending a request using the UpdateOriginEndpointRequest method.
//    req := client.UpdateOriginEndpointRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/UpdateOriginEndpoint
func (c *MediaPackage) UpdateOriginEndpointRequest(input *UpdateOriginEndpointInput) UpdateOriginEndpointRequest {
	op := &aws.Operation{
		Name:       opUpdateOriginEndpoint,
		HTTPMethod: "PUT",
		HTTPPath:   "/origin_endpoints/{id}",
	}

	if input == nil {
		input = &UpdateOriginEndpointInput{}
	}

	output := &UpdateOriginEndpointOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateOriginEndpointRequest{Request: req, Input: input, Copy: c.UpdateOriginEndpointRequest}
}

// A Channel resource configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/Channel
type Channel struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) assigned to the Channel.
	Arn *string `locationName:"arn" type:"string"`

	// A short text description of the Channel.
	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) ingest resource configuration.
	HlsIngest *HlsIngest `locationName:"hlsIngest" type:"structure"`

	// The ID of the Channel.
	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s Channel) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Channel) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Channel) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsIngest != nil {
		v := s.HlsIngest

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsIngest", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A Common Media Application Format (CMAF) encryption configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CmafEncryption
type CmafEncryption struct {
	_ struct{} `type:"structure"`

	// Time (in seconds) between each encryption key rotation.
	KeyRotationIntervalSeconds *int64 `locationName:"keyRotationIntervalSeconds" type:"integer"`

	// A configuration for accessing an external Secure Packager and Encoder Key
	// Exchange (SPEKE) service that will provide encryption keys.
	//
	// SpekeKeyProvider is a required field
	SpekeKeyProvider *SpekeKeyProvider `locationName:"spekeKeyProvider" type:"structure" required:"true"`
}

// String returns the string representation
func (s CmafEncryption) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CmafEncryption) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CmafEncryption) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CmafEncryption"}

	if s.SpekeKeyProvider == nil {
		invalidParams.Add(aws.NewErrParamRequired("SpekeKeyProvider"))
	}
	if s.SpekeKeyProvider != nil {
		if err := s.SpekeKeyProvider.Validate(); err != nil {
			invalidParams.AddNested("SpekeKeyProvider", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CmafEncryption) MarshalFields(e protocol.FieldEncoder) error {
	if s.KeyRotationIntervalSeconds != nil {
		v := *s.KeyRotationIntervalSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "keyRotationIntervalSeconds", protocol.Int64Value(v), metadata)
	}
	if s.SpekeKeyProvider != nil {
		v := s.SpekeKeyProvider

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "spekeKeyProvider", v, metadata)
	}
	return nil
}

// A Common Media Application Format (CMAF) packaging configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CmafPackage
type CmafPackage struct {
	_ struct{} `type:"structure"`

	// A Common Media Application Format (CMAF) encryption configuration.
	Encryption *CmafEncryption `locationName:"encryption" type:"structure"`

	// A list of HLS manifest configurations
	HlsManifests []HlsManifest `locationName:"hlsManifests" type:"list"`

	// Duration (in seconds) of each segment. Actual segments will berounded to
	// the nearest multiple of the source segment duration.
	SegmentDurationSeconds *int64 `locationName:"segmentDurationSeconds" type:"integer"`

	// An optional custom string that is prepended to the name of each segment.
	// If not specified, it defaults to the ChannelId.
	SegmentPrefix *string `locationName:"segmentPrefix" type:"string"`

	// A StreamSelection configuration.
	StreamSelection *StreamSelection `locationName:"streamSelection" type:"structure"`
}

// String returns the string representation
func (s CmafPackage) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CmafPackage) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CmafPackage) MarshalFields(e protocol.FieldEncoder) error {
	if s.Encryption != nil {
		v := s.Encryption

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "encryption", v, metadata)
	}
	if len(s.HlsManifests) > 0 {
		v := s.HlsManifests

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "hlsManifests", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SegmentDurationSeconds != nil {
		v := *s.SegmentDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "segmentDurationSeconds", protocol.Int64Value(v), metadata)
	}
	if s.SegmentPrefix != nil {
		v := *s.SegmentPrefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "segmentPrefix", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamSelection != nil {
		v := s.StreamSelection

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "streamSelection", v, metadata)
	}
	return nil
}

// A Common Media Application Format (CMAF) packaging configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CmafPackageCreateOrUpdateParameters
type CmafPackageCreateOrUpdateParameters struct {
	_ struct{} `type:"structure"`

	// A Common Media Application Format (CMAF) encryption configuration.
	Encryption *CmafEncryption `locationName:"encryption" type:"structure"`

	// A list of HLS manifest configurations
	HlsManifests []HlsManifestCreateOrUpdateParameters `locationName:"hlsManifests" type:"list"`

	// Duration (in seconds) of each segment. Actual segments will berounded to
	// the nearest multiple of the source segment duration.
	SegmentDurationSeconds *int64 `locationName:"segmentDurationSeconds" type:"integer"`

	// An optional custom string that is prepended to the name of each segment.
	// If not specified, it defaults to the ChannelId.
	SegmentPrefix *string `locationName:"segmentPrefix" type:"string"`

	// A StreamSelection configuration.
	StreamSelection *StreamSelection `locationName:"streamSelection" type:"structure"`
}

// String returns the string representation
func (s CmafPackageCreateOrUpdateParameters) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CmafPackageCreateOrUpdateParameters) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CmafPackageCreateOrUpdateParameters) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CmafPackageCreateOrUpdateParameters"}
	if s.Encryption != nil {
		if err := s.Encryption.Validate(); err != nil {
			invalidParams.AddNested("Encryption", err.(aws.ErrInvalidParams))
		}
	}
	if s.HlsManifests != nil {
		for i, v := range s.HlsManifests {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "HlsManifests", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CmafPackageCreateOrUpdateParameters) MarshalFields(e protocol.FieldEncoder) error {
	if s.Encryption != nil {
		v := s.Encryption

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "encryption", v, metadata)
	}
	if len(s.HlsManifests) > 0 {
		v := s.HlsManifests

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "hlsManifests", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SegmentDurationSeconds != nil {
		v := *s.SegmentDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "segmentDurationSeconds", protocol.Int64Value(v), metadata)
	}
	if s.SegmentPrefix != nil {
		v := *s.SegmentPrefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "segmentPrefix", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamSelection != nil {
		v := s.StreamSelection

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "streamSelection", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CreateChannelRequest
type CreateChannelInput struct {
	_ struct{} `type:"structure"`

	Description *string `locationName:"description" type:"string"`

	// Id is a required field
	Id *string `locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateChannelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateChannelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateChannelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateChannelInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateChannelInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CreateChannelResponse
type CreateChannelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) ingest resource configuration.
	HlsIngest *HlsIngest `locationName:"hlsIngest" type:"structure"`

	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s CreateChannelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateChannelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateChannelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateChannelOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsIngest != nil {
		v := s.HlsIngest

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsIngest", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CreateOriginEndpointRequest
type CreateOriginEndpointInput struct {
	_ struct{} `type:"structure"`

	// ChannelId is a required field
	ChannelId *string `locationName:"channelId" type:"string" required:"true"`

	// A Common Media Application Format (CMAF) packaging configuration.
	CmafPackage *CmafPackageCreateOrUpdateParameters `locationName:"cmafPackage" type:"structure"`

	// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
	DashPackage *DashPackage `locationName:"dashPackage" type:"structure"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) packaging configuration.
	HlsPackage *HlsPackage `locationName:"hlsPackage" type:"structure"`

	// Id is a required field
	Id *string `locationName:"id" type:"string" required:"true"`

	ManifestName *string `locationName:"manifestName" type:"string"`

	// A Microsoft Smooth Streaming (MSS) packaging configuration.
	MssPackage *MssPackage `locationName:"mssPackage" type:"structure"`

	StartoverWindowSeconds *int64 `locationName:"startoverWindowSeconds" type:"integer"`

	TimeDelaySeconds *int64 `locationName:"timeDelaySeconds" type:"integer"`

	Whitelist []string `locationName:"whitelist" type:"list"`
}

// String returns the string representation
func (s CreateOriginEndpointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateOriginEndpointInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateOriginEndpointInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateOriginEndpointInput"}

	if s.ChannelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ChannelId"))
	}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.CmafPackage != nil {
		if err := s.CmafPackage.Validate(); err != nil {
			invalidParams.AddNested("CmafPackage", err.(aws.ErrInvalidParams))
		}
	}
	if s.DashPackage != nil {
		if err := s.DashPackage.Validate(); err != nil {
			invalidParams.AddNested("DashPackage", err.(aws.ErrInvalidParams))
		}
	}
	if s.HlsPackage != nil {
		if err := s.HlsPackage.Validate(); err != nil {
			invalidParams.AddNested("HlsPackage", err.(aws.ErrInvalidParams))
		}
	}
	if s.MssPackage != nil {
		if err := s.MssPackage.Validate(); err != nil {
			invalidParams.AddNested("MssPackage", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateOriginEndpointInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ChannelId != nil {
		v := *s.ChannelId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "channelId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CmafPackage != nil {
		v := s.CmafPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "cmafPackage", v, metadata)
	}
	if s.DashPackage != nil {
		v := s.DashPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dashPackage", v, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsPackage != nil {
		v := s.HlsPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsPackage", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ManifestName != nil {
		v := *s.ManifestName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MssPackage != nil {
		v := s.MssPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "mssPackage", v, metadata)
	}
	if s.StartoverWindowSeconds != nil {
		v := *s.StartoverWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startoverWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.TimeDelaySeconds != nil {
		v := *s.TimeDelaySeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeDelaySeconds", protocol.Int64Value(v), metadata)
	}
	if len(s.Whitelist) > 0 {
		v := s.Whitelist

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "whitelist", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/CreateOriginEndpointResponse
type CreateOriginEndpointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	ChannelId *string `locationName:"channelId" type:"string"`

	// A Common Media Application Format (CMAF) packaging configuration.
	CmafPackage *CmafPackage `locationName:"cmafPackage" type:"structure"`

	// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
	DashPackage *DashPackage `locationName:"dashPackage" type:"structure"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) packaging configuration.
	HlsPackage *HlsPackage `locationName:"hlsPackage" type:"structure"`

	Id *string `locationName:"id" type:"string"`

	ManifestName *string `locationName:"manifestName" type:"string"`

	// A Microsoft Smooth Streaming (MSS) packaging configuration.
	MssPackage *MssPackage `locationName:"mssPackage" type:"structure"`

	StartoverWindowSeconds *int64 `locationName:"startoverWindowSeconds" type:"integer"`

	TimeDelaySeconds *int64 `locationName:"timeDelaySeconds" type:"integer"`

	Url *string `locationName:"url" type:"string"`

	Whitelist []string `locationName:"whitelist" type:"list"`
}

// String returns the string representation
func (s CreateOriginEndpointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateOriginEndpointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateOriginEndpointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateOriginEndpointOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChannelId != nil {
		v := *s.ChannelId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "channelId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CmafPackage != nil {
		v := s.CmafPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "cmafPackage", v, metadata)
	}
	if s.DashPackage != nil {
		v := s.DashPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dashPackage", v, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsPackage != nil {
		v := s.HlsPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsPackage", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ManifestName != nil {
		v := *s.ManifestName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MssPackage != nil {
		v := s.MssPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "mssPackage", v, metadata)
	}
	if s.StartoverWindowSeconds != nil {
		v := *s.StartoverWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startoverWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.TimeDelaySeconds != nil {
		v := *s.TimeDelaySeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeDelaySeconds", protocol.Int64Value(v), metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Whitelist) > 0 {
		v := s.Whitelist

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "whitelist", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DashEncryption
type DashEncryption struct {
	_ struct{} `type:"structure"`

	// Time (in seconds) between each encryption key rotation.
	KeyRotationIntervalSeconds *int64 `locationName:"keyRotationIntervalSeconds" type:"integer"`

	// A configuration for accessing an external Secure Packager and Encoder Key
	// Exchange (SPEKE) service that will provide encryption keys.
	//
	// SpekeKeyProvider is a required field
	SpekeKeyProvider *SpekeKeyProvider `locationName:"spekeKeyProvider" type:"structure" required:"true"`
}

// String returns the string representation
func (s DashEncryption) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DashEncryption) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DashEncryption) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DashEncryption"}

	if s.SpekeKeyProvider == nil {
		invalidParams.Add(aws.NewErrParamRequired("SpekeKeyProvider"))
	}
	if s.SpekeKeyProvider != nil {
		if err := s.SpekeKeyProvider.Validate(); err != nil {
			invalidParams.AddNested("SpekeKeyProvider", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DashEncryption) MarshalFields(e protocol.FieldEncoder) error {
	if s.KeyRotationIntervalSeconds != nil {
		v := *s.KeyRotationIntervalSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "keyRotationIntervalSeconds", protocol.Int64Value(v), metadata)
	}
	if s.SpekeKeyProvider != nil {
		v := s.SpekeKeyProvider

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "spekeKeyProvider", v, metadata)
	}
	return nil
}

// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DashPackage
type DashPackage struct {
	_ struct{} `type:"structure"`

	// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
	Encryption *DashEncryption `locationName:"encryption" type:"structure"`

	// Time window (in seconds) contained in each manifest.
	ManifestWindowSeconds *int64 `locationName:"manifestWindowSeconds" type:"integer"`

	// Minimum duration (in seconds) that a player will buffer media before starting
	// the presentation.
	MinBufferTimeSeconds *int64 `locationName:"minBufferTimeSeconds" type:"integer"`

	// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive
	// Streaming over HTTP (DASH) Media Presentation Description (MPD).
	MinUpdatePeriodSeconds *int64 `locationName:"minUpdatePeriodSeconds" type:"integer"`

	// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming
	// over HTTP (DASH)Media Presentation Description (MPD) will be partitioned
	// into multiple periods. If empty, the content will notbe partitioned into
	// more than one period. If the list contains "ADS", new periods will be created
	// wherethe Channel source contains SCTE-35 ad markers.
	PeriodTriggers []__PeriodTriggersElement `locationName:"periodTriggers" type:"list"`

	// The Dynamic Adaptive Streaming over HTTP (DASH) profile type. When set to
	// "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
	Profile Profile `locationName:"profile" type:"string" enum:"true"`

	// Duration (in seconds) of each segment. Actual segments will berounded to
	// the nearest multiple of the source segment duration.
	SegmentDurationSeconds *int64 `locationName:"segmentDurationSeconds" type:"integer"`

	// A StreamSelection configuration.
	StreamSelection *StreamSelection `locationName:"streamSelection" type:"structure"`

	// Duration (in seconds) to delay live content before presentation.
	SuggestedPresentationDelaySeconds *int64 `locationName:"suggestedPresentationDelaySeconds" type:"integer"`
}

// String returns the string representation
func (s DashPackage) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DashPackage) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DashPackage) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DashPackage"}
	if s.Encryption != nil {
		if err := s.Encryption.Validate(); err != nil {
			invalidParams.AddNested("Encryption", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DashPackage) MarshalFields(e protocol.FieldEncoder) error {
	if s.Encryption != nil {
		v := s.Encryption

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "encryption", v, metadata)
	}
	if s.ManifestWindowSeconds != nil {
		v := *s.ManifestWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.MinBufferTimeSeconds != nil {
		v := *s.MinBufferTimeSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "minBufferTimeSeconds", protocol.Int64Value(v), metadata)
	}
	if s.MinUpdatePeriodSeconds != nil {
		v := *s.MinUpdatePeriodSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "minUpdatePeriodSeconds", protocol.Int64Value(v), metadata)
	}
	if len(s.PeriodTriggers) > 0 {
		v := s.PeriodTriggers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "periodTriggers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Profile) > 0 {
		v := s.Profile

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "profile", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SegmentDurationSeconds != nil {
		v := *s.SegmentDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "segmentDurationSeconds", protocol.Int64Value(v), metadata)
	}
	if s.StreamSelection != nil {
		v := s.StreamSelection

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "streamSelection", v, metadata)
	}
	if s.SuggestedPresentationDelaySeconds != nil {
		v := *s.SuggestedPresentationDelaySeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "suggestedPresentationDelaySeconds", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DeleteChannelRequest
type DeleteChannelInput struct {
	_ struct{} `type:"structure"`

	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteChannelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteChannelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteChannelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteChannelInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteChannelInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DeleteChannelResponse
type DeleteChannelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteChannelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteChannelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteChannelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteChannelOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DeleteOriginEndpointRequest
type DeleteOriginEndpointInput struct {
	_ struct{} `type:"structure"`

	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteOriginEndpointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteOriginEndpointInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteOriginEndpointInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteOriginEndpointInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteOriginEndpointInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DeleteOriginEndpointResponse
type DeleteOriginEndpointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteOriginEndpointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteOriginEndpointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteOriginEndpointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteOriginEndpointOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DescribeChannelRequest
type DescribeChannelInput struct {
	_ struct{} `type:"structure"`

	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeChannelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeChannelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeChannelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeChannelInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeChannelInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DescribeChannelResponse
type DescribeChannelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) ingest resource configuration.
	HlsIngest *HlsIngest `locationName:"hlsIngest" type:"structure"`

	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s DescribeChannelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeChannelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeChannelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeChannelOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsIngest != nil {
		v := s.HlsIngest

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsIngest", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DescribeOriginEndpointRequest
type DescribeOriginEndpointInput struct {
	_ struct{} `type:"structure"`

	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeOriginEndpointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeOriginEndpointInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeOriginEndpointInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeOriginEndpointInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeOriginEndpointInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/DescribeOriginEndpointResponse
type DescribeOriginEndpointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	ChannelId *string `locationName:"channelId" type:"string"`

	// A Common Media Application Format (CMAF) packaging configuration.
	CmafPackage *CmafPackage `locationName:"cmafPackage" type:"structure"`

	// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
	DashPackage *DashPackage `locationName:"dashPackage" type:"structure"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) packaging configuration.
	HlsPackage *HlsPackage `locationName:"hlsPackage" type:"structure"`

	Id *string `locationName:"id" type:"string"`

	ManifestName *string `locationName:"manifestName" type:"string"`

	// A Microsoft Smooth Streaming (MSS) packaging configuration.
	MssPackage *MssPackage `locationName:"mssPackage" type:"structure"`

	StartoverWindowSeconds *int64 `locationName:"startoverWindowSeconds" type:"integer"`

	TimeDelaySeconds *int64 `locationName:"timeDelaySeconds" type:"integer"`

	Url *string `locationName:"url" type:"string"`

	Whitelist []string `locationName:"whitelist" type:"list"`
}

// String returns the string representation
func (s DescribeOriginEndpointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeOriginEndpointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeOriginEndpointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeOriginEndpointOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChannelId != nil {
		v := *s.ChannelId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "channelId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CmafPackage != nil {
		v := s.CmafPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "cmafPackage", v, metadata)
	}
	if s.DashPackage != nil {
		v := s.DashPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dashPackage", v, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsPackage != nil {
		v := s.HlsPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsPackage", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ManifestName != nil {
		v := *s.ManifestName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MssPackage != nil {
		v := s.MssPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "mssPackage", v, metadata)
	}
	if s.StartoverWindowSeconds != nil {
		v := *s.StartoverWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startoverWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.TimeDelaySeconds != nil {
		v := *s.TimeDelaySeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeDelaySeconds", protocol.Int64Value(v), metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Whitelist) > 0 {
		v := s.Whitelist

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "whitelist", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// An HTTP Live Streaming (HLS) encryption configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/HlsEncryption
type HlsEncryption struct {
	_ struct{} `type:"structure"`

	// A constant initialization vector for encryption (optional).When not specified
	// the initialization vector will be periodically rotated.
	ConstantInitializationVector *string `locationName:"constantInitializationVector" type:"string"`

	// The encryption method to use.
	EncryptionMethod EncryptionMethod `locationName:"encryptionMethod" type:"string" enum:"true"`

	// Interval (in seconds) between each encryption key rotation.
	KeyRotationIntervalSeconds *int64 `locationName:"keyRotationIntervalSeconds" type:"integer"`

	// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
	RepeatExtXKey *bool `locationName:"repeatExtXKey" type:"boolean"`

	// A configuration for accessing an external Secure Packager and Encoder Key
	// Exchange (SPEKE) service that will provide encryption keys.
	//
	// SpekeKeyProvider is a required field
	SpekeKeyProvider *SpekeKeyProvider `locationName:"spekeKeyProvider" type:"structure" required:"true"`
}

// String returns the string representation
func (s HlsEncryption) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HlsEncryption) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *HlsEncryption) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "HlsEncryption"}

	if s.SpekeKeyProvider == nil {
		invalidParams.Add(aws.NewErrParamRequired("SpekeKeyProvider"))
	}
	if s.SpekeKeyProvider != nil {
		if err := s.SpekeKeyProvider.Validate(); err != nil {
			invalidParams.AddNested("SpekeKeyProvider", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HlsEncryption) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConstantInitializationVector != nil {
		v := *s.ConstantInitializationVector

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "constantInitializationVector", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EncryptionMethod) > 0 {
		v := s.EncryptionMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "encryptionMethod", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.KeyRotationIntervalSeconds != nil {
		v := *s.KeyRotationIntervalSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "keyRotationIntervalSeconds", protocol.Int64Value(v), metadata)
	}
	if s.RepeatExtXKey != nil {
		v := *s.RepeatExtXKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "repeatExtXKey", protocol.BoolValue(v), metadata)
	}
	if s.SpekeKeyProvider != nil {
		v := s.SpekeKeyProvider

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "spekeKeyProvider", v, metadata)
	}
	return nil
}

// An HTTP Live Streaming (HLS) ingest resource configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/HlsIngest
type HlsIngest struct {
	_ struct{} `type:"structure"`

	// A list of endpoints to which the source stream should be sent.
	IngestEndpoints []IngestEndpoint `locationName:"ingestEndpoints" type:"list"`
}

// String returns the string representation
func (s HlsIngest) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HlsIngest) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HlsIngest) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IngestEndpoints) > 0 {
		v := s.IngestEndpoints

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ingestEndpoints", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A HTTP Live Streaming (HLS) manifest configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/HlsManifest
type HlsManifest struct {
	_ struct{} `type:"structure"`

	// This setting controls how ad markers are included in the packaged OriginEndpoint."NONE"
	// will omit all SCTE-35 ad markers from the output."PASSTHROUGH" causes the
	// manifest to contain a copy of the SCTE-35 admarkers (comments) taken directly
	// from the input HTTP Live Streaming (HLS) manifest."SCTE35_ENHANCED" generates
	// ad markers and blackout tags based on SCTE-35messages in the input source.
	AdMarkers AdMarkers `locationName:"adMarkers" type:"string" enum:"true"`

	// The ID of the manifest. The ID must be unique within the OriginEndpoint and
	// it cannot be changed after it is created.
	//
	// Id is a required field
	Id *string `locationName:"id" type:"string" required:"true"`

	// When enabled, an I-Frame only stream will be included in the output.
	IncludeIframeOnlyStream *bool `locationName:"includeIframeOnlyStream" type:"boolean"`

	// An optional short string appended to the end of the OriginEndpoint URL. If
	// not specified, defaults to the manifestName for the OriginEndpoint.
	ManifestName *string `locationName:"manifestName" type:"string"`

	// The HTTP Live Streaming (HLS) playlist type.When either "EVENT" or "VOD"
	// is specified, a corresponding EXT-X-PLAYLIST-TYPEentry will be included in
	// the media playlist.
	PlaylistType PlaylistType `locationName:"playlistType" type:"string" enum:"true"`

	// Time window (in seconds) contained in each parent manifest.
	PlaylistWindowSeconds *int64 `locationName:"playlistWindowSeconds" type:"integer"`

	// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME taginserted
	// into manifests. Additionally, when an interval is specifiedID3Timed Metadata
	// messages will be generated every 5 seconds using theingest time of the content.If
	// the interval is not specified, or set to 0, thenno EXT-X-PROGRAM-DATE-TIME
	// tags will be inserted into manifests and noID3Timed Metadata messages will
	// be generated. Note that irrespectiveof this parameter, if any ID3 Timed Metadata
	// is found in HTTP Live Streaming (HLS) input,it will be passed through to
	// HLS output.
	ProgramDateTimeIntervalSeconds *int64 `locationName:"programDateTimeIntervalSeconds" type:"integer"`

	// The URL of the packaged OriginEndpoint for consumption.
	Url *string `locationName:"url" type:"string"`
}

// String returns the string representation
func (s HlsManifest) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HlsManifest) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HlsManifest) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AdMarkers) > 0 {
		v := s.AdMarkers

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "adMarkers", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IncludeIframeOnlyStream != nil {
		v := *s.IncludeIframeOnlyStream

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "includeIframeOnlyStream", protocol.BoolValue(v), metadata)
	}
	if s.ManifestName != nil {
		v := *s.ManifestName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PlaylistType) > 0 {
		v := s.PlaylistType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "playlistType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.PlaylistWindowSeconds != nil {
		v := *s.PlaylistWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "playlistWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.ProgramDateTimeIntervalSeconds != nil {
		v := *s.ProgramDateTimeIntervalSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "programDateTimeIntervalSeconds", protocol.Int64Value(v), metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A HTTP Live Streaming (HLS) manifest configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/HlsManifestCreateOrUpdateParameters
type HlsManifestCreateOrUpdateParameters struct {
	_ struct{} `type:"structure"`

	// This setting controls how ad markers are included in the packaged OriginEndpoint."NONE"
	// will omit all SCTE-35 ad markers from the output."PASSTHROUGH" causes the
	// manifest to contain a copy of the SCTE-35 admarkers (comments) taken directly
	// from the input HTTP Live Streaming (HLS) manifest."SCTE35_ENHANCED" generates
	// ad markers and blackout tags based on SCTE-35messages in the input source.
	AdMarkers AdMarkers `locationName:"adMarkers" type:"string" enum:"true"`

	// The ID of the manifest. The ID must be unique within the OriginEndpoint and
	// it cannot be changed after it is created.
	//
	// Id is a required field
	Id *string `locationName:"id" type:"string" required:"true"`

	// When enabled, an I-Frame only stream will be included in the output.
	IncludeIframeOnlyStream *bool `locationName:"includeIframeOnlyStream" type:"boolean"`

	// An optional short string appended to the end of the OriginEndpoint URL. If
	// not specified, defaults to the manifestName for the OriginEndpoint.
	ManifestName *string `locationName:"manifestName" type:"string"`

	// The HTTP Live Streaming (HLS) playlist type.When either "EVENT" or "VOD"
	// is specified, a corresponding EXT-X-PLAYLIST-TYPEentry will be included in
	// the media playlist.
	PlaylistType PlaylistType `locationName:"playlistType" type:"string" enum:"true"`

	// Time window (in seconds) contained in each parent manifest.
	PlaylistWindowSeconds *int64 `locationName:"playlistWindowSeconds" type:"integer"`

	// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME taginserted
	// into manifests. Additionally, when an interval is specifiedID3Timed Metadata
	// messages will be generated every 5 seconds using theingest time of the content.If
	// the interval is not specified, or set to 0, thenno EXT-X-PROGRAM-DATE-TIME
	// tags will be inserted into manifests and noID3Timed Metadata messages will
	// be generated. Note that irrespectiveof this parameter, if any ID3 Timed Metadata
	// is found in HTTP Live Streaming (HLS) input,it will be passed through to
	// HLS output.
	ProgramDateTimeIntervalSeconds *int64 `locationName:"programDateTimeIntervalSeconds" type:"integer"`
}

// String returns the string representation
func (s HlsManifestCreateOrUpdateParameters) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HlsManifestCreateOrUpdateParameters) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *HlsManifestCreateOrUpdateParameters) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "HlsManifestCreateOrUpdateParameters"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HlsManifestCreateOrUpdateParameters) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AdMarkers) > 0 {
		v := s.AdMarkers

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "adMarkers", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IncludeIframeOnlyStream != nil {
		v := *s.IncludeIframeOnlyStream

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "includeIframeOnlyStream", protocol.BoolValue(v), metadata)
	}
	if s.ManifestName != nil {
		v := *s.ManifestName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PlaylistType) > 0 {
		v := s.PlaylistType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "playlistType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.PlaylistWindowSeconds != nil {
		v := *s.PlaylistWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "playlistWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.ProgramDateTimeIntervalSeconds != nil {
		v := *s.ProgramDateTimeIntervalSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "programDateTimeIntervalSeconds", protocol.Int64Value(v), metadata)
	}
	return nil
}

// An HTTP Live Streaming (HLS) packaging configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/HlsPackage
type HlsPackage struct {
	_ struct{} `type:"structure"`

	// This setting controls how ad markers are included in the packaged OriginEndpoint."NONE"
	// will omit all SCTE-35 ad markers from the output."PASSTHROUGH" causes the
	// manifest to contain a copy of the SCTE-35 admarkers (comments) taken directly
	// from the input HTTP Live Streaming (HLS) manifest."SCTE35_ENHANCED" generates
	// ad markers and blackout tags based on SCTE-35messages in the input source.
	AdMarkers AdMarkers `locationName:"adMarkers" type:"string" enum:"true"`

	// An HTTP Live Streaming (HLS) encryption configuration.
	Encryption *HlsEncryption `locationName:"encryption" type:"structure"`

	// When enabled, an I-Frame only stream will be included in the output.
	IncludeIframeOnlyStream *bool `locationName:"includeIframeOnlyStream" type:"boolean"`

	// The HTTP Live Streaming (HLS) playlist type.When either "EVENT" or "VOD"
	// is specified, a corresponding EXT-X-PLAYLIST-TYPEentry will be included in
	// the media playlist.
	PlaylistType PlaylistType `locationName:"playlistType" type:"string" enum:"true"`

	// Time window (in seconds) contained in each parent manifest.
	PlaylistWindowSeconds *int64 `locationName:"playlistWindowSeconds" type:"integer"`

	// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME taginserted
	// into manifests. Additionally, when an interval is specifiedID3Timed Metadata
	// messages will be generated every 5 seconds using theingest time of the content.If
	// the interval is not specified, or set to 0, thenno EXT-X-PROGRAM-DATE-TIME
	// tags will be inserted into manifests and noID3Timed Metadata messages will
	// be generated. Note that irrespectiveof this parameter, if any ID3 Timed Metadata
	// is found in HTTP Live Streaming (HLS) input,it will be passed through to
	// HLS output.
	ProgramDateTimeIntervalSeconds *int64 `locationName:"programDateTimeIntervalSeconds" type:"integer"`

	// Duration (in seconds) of each fragment. Actual fragments will berounded to
	// the nearest multiple of the source fragment duration.
	SegmentDurationSeconds *int64 `locationName:"segmentDurationSeconds" type:"integer"`

	// A StreamSelection configuration.
	StreamSelection *StreamSelection `locationName:"streamSelection" type:"structure"`

	// When enabled, audio streams will be placed in rendition groups in the output.
	UseAudioRenditionGroup *bool `locationName:"useAudioRenditionGroup" type:"boolean"`
}

// String returns the string representation
func (s HlsPackage) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HlsPackage) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *HlsPackage) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "HlsPackage"}
	if s.Encryption != nil {
		if err := s.Encryption.Validate(); err != nil {
			invalidParams.AddNested("Encryption", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HlsPackage) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AdMarkers) > 0 {
		v := s.AdMarkers

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "adMarkers", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Encryption != nil {
		v := s.Encryption

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "encryption", v, metadata)
	}
	if s.IncludeIframeOnlyStream != nil {
		v := *s.IncludeIframeOnlyStream

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "includeIframeOnlyStream", protocol.BoolValue(v), metadata)
	}
	if len(s.PlaylistType) > 0 {
		v := s.PlaylistType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "playlistType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.PlaylistWindowSeconds != nil {
		v := *s.PlaylistWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "playlistWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.ProgramDateTimeIntervalSeconds != nil {
		v := *s.ProgramDateTimeIntervalSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "programDateTimeIntervalSeconds", protocol.Int64Value(v), metadata)
	}
	if s.SegmentDurationSeconds != nil {
		v := *s.SegmentDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "segmentDurationSeconds", protocol.Int64Value(v), metadata)
	}
	if s.StreamSelection != nil {
		v := s.StreamSelection

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "streamSelection", v, metadata)
	}
	if s.UseAudioRenditionGroup != nil {
		v := *s.UseAudioRenditionGroup

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "useAudioRenditionGroup", protocol.BoolValue(v), metadata)
	}
	return nil
}

// An endpoint for ingesting source content for a Channel.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/IngestEndpoint
type IngestEndpoint struct {
	_ struct{} `type:"structure"`

	// The system generated unique identifier for the IngestEndpoint
	Id *string `locationName:"id" type:"string"`

	// The system generated password for ingest authentication.
	Password *string `locationName:"password" type:"string"`

	// The ingest URL to which the source stream should be sent.
	Url *string `locationName:"url" type:"string"`

	// The system generated username for ingest authentication.
	Username *string `locationName:"username" type:"string"`
}

// String returns the string representation
func (s IngestEndpoint) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s IngestEndpoint) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s IngestEndpoint) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Password != nil {
		v := *s.Password

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "password", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/ListChannelsRequest
type ListChannelsInput struct {
	_ struct{} `type:"structure"`

	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListChannelsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListChannelsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListChannelsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListChannelsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListChannelsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/ListChannelsResponse
type ListChannelsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Channels []Channel `locationName:"channels" type:"list"`

	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListChannelsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListChannelsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListChannelsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListChannelsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Channels) > 0 {
		v := s.Channels

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "channels", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/ListOriginEndpointsRequest
type ListOriginEndpointsInput struct {
	_ struct{} `type:"structure"`

	ChannelId *string `location:"querystring" locationName:"channelId" type:"string"`

	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListOriginEndpointsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListOriginEndpointsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListOriginEndpointsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListOriginEndpointsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListOriginEndpointsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ChannelId != nil {
		v := *s.ChannelId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "channelId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/ListOriginEndpointsResponse
type ListOriginEndpointsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	NextToken *string `locationName:"nextToken" type:"string"`

	OriginEndpoints []OriginEndpoint `locationName:"originEndpoints" type:"list"`
}

// String returns the string representation
func (s ListOriginEndpointsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListOriginEndpointsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListOriginEndpointsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListOriginEndpointsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OriginEndpoints) > 0 {
		v := s.OriginEndpoints

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "originEndpoints", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A Microsoft Smooth Streaming (MSS) encryption configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/MssEncryption
type MssEncryption struct {
	_ struct{} `type:"structure"`

	// A configuration for accessing an external Secure Packager and Encoder Key
	// Exchange (SPEKE) service that will provide encryption keys.
	//
	// SpekeKeyProvider is a required field
	SpekeKeyProvider *SpekeKeyProvider `locationName:"spekeKeyProvider" type:"structure" required:"true"`
}

// String returns the string representation
func (s MssEncryption) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MssEncryption) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MssEncryption) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "MssEncryption"}

	if s.SpekeKeyProvider == nil {
		invalidParams.Add(aws.NewErrParamRequired("SpekeKeyProvider"))
	}
	if s.SpekeKeyProvider != nil {
		if err := s.SpekeKeyProvider.Validate(); err != nil {
			invalidParams.AddNested("SpekeKeyProvider", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MssEncryption) MarshalFields(e protocol.FieldEncoder) error {
	if s.SpekeKeyProvider != nil {
		v := s.SpekeKeyProvider

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "spekeKeyProvider", v, metadata)
	}
	return nil
}

// A Microsoft Smooth Streaming (MSS) packaging configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/MssPackage
type MssPackage struct {
	_ struct{} `type:"structure"`

	// A Microsoft Smooth Streaming (MSS) encryption configuration.
	Encryption *MssEncryption `locationName:"encryption" type:"structure"`

	// The time window (in seconds) contained in each manifest.
	ManifestWindowSeconds *int64 `locationName:"manifestWindowSeconds" type:"integer"`

	// The duration (in seconds) of each segment.
	SegmentDurationSeconds *int64 `locationName:"segmentDurationSeconds" type:"integer"`

	// A StreamSelection configuration.
	StreamSelection *StreamSelection `locationName:"streamSelection" type:"structure"`
}

// String returns the string representation
func (s MssPackage) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MssPackage) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MssPackage) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "MssPackage"}
	if s.Encryption != nil {
		if err := s.Encryption.Validate(); err != nil {
			invalidParams.AddNested("Encryption", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MssPackage) MarshalFields(e protocol.FieldEncoder) error {
	if s.Encryption != nil {
		v := s.Encryption

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "encryption", v, metadata)
	}
	if s.ManifestWindowSeconds != nil {
		v := *s.ManifestWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.SegmentDurationSeconds != nil {
		v := *s.SegmentDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "segmentDurationSeconds", protocol.Int64Value(v), metadata)
	}
	if s.StreamSelection != nil {
		v := s.StreamSelection

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "streamSelection", v, metadata)
	}
	return nil
}

// An OriginEndpoint resource configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/OriginEndpoint
type OriginEndpoint struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
	Arn *string `locationName:"arn" type:"string"`

	// The ID of the Channel the OriginEndpoint is associated with.
	ChannelId *string `locationName:"channelId" type:"string"`

	// A Common Media Application Format (CMAF) packaging configuration.
	CmafPackage *CmafPackage `locationName:"cmafPackage" type:"structure"`

	// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
	DashPackage *DashPackage `locationName:"dashPackage" type:"structure"`

	// A short text description of the OriginEndpoint.
	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) packaging configuration.
	HlsPackage *HlsPackage `locationName:"hlsPackage" type:"structure"`

	// The ID of the OriginEndpoint.
	Id *string `locationName:"id" type:"string"`

	// A short string appended to the end of the OriginEndpoint URL.
	ManifestName *string `locationName:"manifestName" type:"string"`

	// A Microsoft Smooth Streaming (MSS) packaging configuration.
	MssPackage *MssPackage `locationName:"mssPackage" type:"structure"`

	// Maximum duration (seconds) of content to retain for startover playback.If
	// not specified, startover playback will be disabled for the OriginEndpoint.
	StartoverWindowSeconds *int64 `locationName:"startoverWindowSeconds" type:"integer"`

	// Amount of delay (seconds) to enforce on the playback of live content.If not
	// specified, there will be no time delay in effect for the OriginEndpoint.
	TimeDelaySeconds *int64 `locationName:"timeDelaySeconds" type:"integer"`

	// The URL of the packaged OriginEndpoint for consumption.
	Url *string `locationName:"url" type:"string"`

	// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
	Whitelist []string `locationName:"whitelist" type:"list"`
}

// String returns the string representation
func (s OriginEndpoint) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OriginEndpoint) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OriginEndpoint) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChannelId != nil {
		v := *s.ChannelId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "channelId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CmafPackage != nil {
		v := s.CmafPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "cmafPackage", v, metadata)
	}
	if s.DashPackage != nil {
		v := s.DashPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dashPackage", v, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsPackage != nil {
		v := s.HlsPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsPackage", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ManifestName != nil {
		v := *s.ManifestName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MssPackage != nil {
		v := s.MssPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "mssPackage", v, metadata)
	}
	if s.StartoverWindowSeconds != nil {
		v := *s.StartoverWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startoverWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.TimeDelaySeconds != nil {
		v := *s.TimeDelaySeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeDelaySeconds", protocol.Int64Value(v), metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Whitelist) > 0 {
		v := s.Whitelist

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "whitelist", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/RotateChannelCredentialsRequest
type RotateChannelCredentialsInput struct {
	_ struct{} `deprecated:"true" type:"structure"`

	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s RotateChannelCredentialsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RotateChannelCredentialsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RotateChannelCredentialsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RotateChannelCredentialsInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RotateChannelCredentialsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/RotateChannelCredentialsResponse
type RotateChannelCredentialsOutput struct {
	_ struct{} `deprecated:"true" type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) ingest resource configuration.
	HlsIngest *HlsIngest `locationName:"hlsIngest" type:"structure"`

	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s RotateChannelCredentialsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RotateChannelCredentialsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RotateChannelCredentialsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RotateChannelCredentialsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsIngest != nil {
		v := s.HlsIngest

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsIngest", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/RotateIngestEndpointCredentialsRequest
type RotateIngestEndpointCredentialsInput struct {
	_ struct{} `type:"structure"`

	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`

	// IngestEndpointId is a required field
	IngestEndpointId *string `location:"uri" locationName:"ingest_endpoint_id" type:"string" required:"true"`
}

// String returns the string representation
func (s RotateIngestEndpointCredentialsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RotateIngestEndpointCredentialsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RotateIngestEndpointCredentialsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RotateIngestEndpointCredentialsInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if s.IngestEndpointId == nil {
		invalidParams.Add(aws.NewErrParamRequired("IngestEndpointId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RotateIngestEndpointCredentialsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IngestEndpointId != nil {
		v := *s.IngestEndpointId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ingest_endpoint_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/RotateIngestEndpointCredentialsResponse
type RotateIngestEndpointCredentialsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) ingest resource configuration.
	HlsIngest *HlsIngest `locationName:"hlsIngest" type:"structure"`

	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s RotateIngestEndpointCredentialsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RotateIngestEndpointCredentialsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RotateIngestEndpointCredentialsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RotateIngestEndpointCredentialsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsIngest != nil {
		v := s.HlsIngest

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsIngest", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A configuration for accessing an external Secure Packager and Encoder Key
// Exchange (SPEKE) service that will provide encryption keys.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/SpekeKeyProvider
type SpekeKeyProvider struct {
	_ struct{} `type:"structure"`

	// The resource ID to include in key requests.
	//
	// ResourceId is a required field
	ResourceId *string `locationName:"resourceId" type:"string" required:"true"`

	// An Amazon Resource Name (ARN) of an IAM role that AWS ElementalMediaPackage
	// will assume when accessing the key provider service.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// The system IDs to include in key requests.
	//
	// SystemIds is a required field
	SystemIds []string `locationName:"systemIds" type:"list" required:"true"`

	// The URL of the external key provider service.
	//
	// Url is a required field
	Url *string `locationName:"url" type:"string" required:"true"`
}

// String returns the string representation
func (s SpekeKeyProvider) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SpekeKeyProvider) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SpekeKeyProvider) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SpekeKeyProvider"}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if s.SystemIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("SystemIds"))
	}

	if s.Url == nil {
		invalidParams.Add(aws.NewErrParamRequired("Url"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SpekeKeyProvider) MarshalFields(e protocol.FieldEncoder) error {
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "resourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SystemIds) > 0 {
		v := s.SystemIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "systemIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A StreamSelection configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/StreamSelection
type StreamSelection struct {
	_ struct{} `type:"structure"`

	// The maximum video bitrate (bps) to include in output.
	MaxVideoBitsPerSecond *int64 `locationName:"maxVideoBitsPerSecond" type:"integer"`

	// The minimum video bitrate (bps) to include in output.
	MinVideoBitsPerSecond *int64 `locationName:"minVideoBitsPerSecond" type:"integer"`

	// A directive that determines the order of streams in the output.
	StreamOrder StreamOrder `locationName:"streamOrder" type:"string" enum:"true"`
}

// String returns the string representation
func (s StreamSelection) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StreamSelection) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StreamSelection) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaxVideoBitsPerSecond != nil {
		v := *s.MaxVideoBitsPerSecond

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxVideoBitsPerSecond", protocol.Int64Value(v), metadata)
	}
	if s.MinVideoBitsPerSecond != nil {
		v := *s.MinVideoBitsPerSecond

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "minVideoBitsPerSecond", protocol.Int64Value(v), metadata)
	}
	if len(s.StreamOrder) > 0 {
		v := s.StreamOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamOrder", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/UpdateChannelRequest
type UpdateChannelInput struct {
	_ struct{} `type:"structure"`

	Description *string `locationName:"description" type:"string"`

	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateChannelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateChannelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateChannelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateChannelInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateChannelInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/UpdateChannelResponse
type UpdateChannelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) ingest resource configuration.
	HlsIngest *HlsIngest `locationName:"hlsIngest" type:"structure"`

	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s UpdateChannelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateChannelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateChannelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateChannelOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsIngest != nil {
		v := s.HlsIngest

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsIngest", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/UpdateOriginEndpointRequest
type UpdateOriginEndpointInput struct {
	_ struct{} `type:"structure"`

	// A Common Media Application Format (CMAF) packaging configuration.
	CmafPackage *CmafPackageCreateOrUpdateParameters `locationName:"cmafPackage" type:"structure"`

	// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
	DashPackage *DashPackage `locationName:"dashPackage" type:"structure"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) packaging configuration.
	HlsPackage *HlsPackage `locationName:"hlsPackage" type:"structure"`

	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`

	ManifestName *string `locationName:"manifestName" type:"string"`

	// A Microsoft Smooth Streaming (MSS) packaging configuration.
	MssPackage *MssPackage `locationName:"mssPackage" type:"structure"`

	StartoverWindowSeconds *int64 `locationName:"startoverWindowSeconds" type:"integer"`

	TimeDelaySeconds *int64 `locationName:"timeDelaySeconds" type:"integer"`

	Whitelist []string `locationName:"whitelist" type:"list"`
}

// String returns the string representation
func (s UpdateOriginEndpointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateOriginEndpointInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateOriginEndpointInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateOriginEndpointInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.CmafPackage != nil {
		if err := s.CmafPackage.Validate(); err != nil {
			invalidParams.AddNested("CmafPackage", err.(aws.ErrInvalidParams))
		}
	}
	if s.DashPackage != nil {
		if err := s.DashPackage.Validate(); err != nil {
			invalidParams.AddNested("DashPackage", err.(aws.ErrInvalidParams))
		}
	}
	if s.HlsPackage != nil {
		if err := s.HlsPackage.Validate(); err != nil {
			invalidParams.AddNested("HlsPackage", err.(aws.ErrInvalidParams))
		}
	}
	if s.MssPackage != nil {
		if err := s.MssPackage.Validate(); err != nil {
			invalidParams.AddNested("MssPackage", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateOriginEndpointInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.CmafPackage != nil {
		v := s.CmafPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "cmafPackage", v, metadata)
	}
	if s.DashPackage != nil {
		v := s.DashPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dashPackage", v, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsPackage != nil {
		v := s.HlsPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsPackage", v, metadata)
	}
	if s.ManifestName != nil {
		v := *s.ManifestName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MssPackage != nil {
		v := s.MssPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "mssPackage", v, metadata)
	}
	if s.StartoverWindowSeconds != nil {
		v := *s.StartoverWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startoverWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.TimeDelaySeconds != nil {
		v := *s.TimeDelaySeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeDelaySeconds", protocol.Int64Value(v), metadata)
	}
	if len(s.Whitelist) > 0 {
		v := s.Whitelist

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "whitelist", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mediapackage-2017-10-12/UpdateOriginEndpointResponse
type UpdateOriginEndpointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	ChannelId *string `locationName:"channelId" type:"string"`

	// A Common Media Application Format (CMAF) packaging configuration.
	CmafPackage *CmafPackage `locationName:"cmafPackage" type:"structure"`

	// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
	DashPackage *DashPackage `locationName:"dashPackage" type:"structure"`

	Description *string `locationName:"description" type:"string"`

	// An HTTP Live Streaming (HLS) packaging configuration.
	HlsPackage *HlsPackage `locationName:"hlsPackage" type:"structure"`

	Id *string `locationName:"id" type:"string"`

	ManifestName *string `locationName:"manifestName" type:"string"`

	// A Microsoft Smooth Streaming (MSS) packaging configuration.
	MssPackage *MssPackage `locationName:"mssPackage" type:"structure"`

	StartoverWindowSeconds *int64 `locationName:"startoverWindowSeconds" type:"integer"`

	TimeDelaySeconds *int64 `locationName:"timeDelaySeconds" type:"integer"`

	Url *string `locationName:"url" type:"string"`

	Whitelist []string `locationName:"whitelist" type:"list"`
}

// String returns the string representation
func (s UpdateOriginEndpointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateOriginEndpointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateOriginEndpointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateOriginEndpointOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChannelId != nil {
		v := *s.ChannelId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "channelId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CmafPackage != nil {
		v := s.CmafPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "cmafPackage", v, metadata)
	}
	if s.DashPackage != nil {
		v := s.DashPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dashPackage", v, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HlsPackage != nil {
		v := s.HlsPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hlsPackage", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ManifestName != nil {
		v := *s.ManifestName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "manifestName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MssPackage != nil {
		v := s.MssPackage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "mssPackage", v, metadata)
	}
	if s.StartoverWindowSeconds != nil {
		v := *s.StartoverWindowSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startoverWindowSeconds", protocol.Int64Value(v), metadata)
	}
	if s.TimeDelaySeconds != nil {
		v := *s.TimeDelaySeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeDelaySeconds", protocol.Int64Value(v), metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Whitelist) > 0 {
		v := s.Whitelist

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "whitelist", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type AdMarkers string

// Enum values for AdMarkers
const (
	AdMarkersNone           AdMarkers = "NONE"
	AdMarkersScte35Enhanced AdMarkers = "SCTE35_ENHANCED"
	AdMarkersPassthrough    AdMarkers = "PASSTHROUGH"
)

func (enum AdMarkers) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AdMarkers) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type EncryptionMethod string

// Enum values for EncryptionMethod
const (
	EncryptionMethodAes128    EncryptionMethod = "AES_128"
	EncryptionMethodSampleAes EncryptionMethod = "SAMPLE_AES"
)

func (enum EncryptionMethod) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EncryptionMethod) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type PlaylistType string

// Enum values for PlaylistType
const (
	PlaylistTypeNone  PlaylistType = "NONE"
	PlaylistTypeEvent PlaylistType = "EVENT"
	PlaylistTypeVod   PlaylistType = "VOD"
)

func (enum PlaylistType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum PlaylistType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Profile string

// Enum values for Profile
const (
	ProfileNone    Profile = "NONE"
	ProfileHbbtv15 Profile = "HBBTV_1_5"
)

func (enum Profile) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Profile) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type StreamOrder string

// Enum values for StreamOrder
const (
	StreamOrderOriginal               StreamOrder = "ORIGINAL"
	StreamOrderVideoBitrateAscending  StreamOrder = "VIDEO_BITRATE_ASCENDING"
	StreamOrderVideoBitrateDescending StreamOrder = "VIDEO_BITRATE_DESCENDING"
)

func (enum StreamOrder) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum StreamOrder) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type __PeriodTriggersElement string

// Enum values for __PeriodTriggersElement
const (
	__PeriodTriggersElementAds __PeriodTriggersElement = "ADS"
)

func (enum __PeriodTriggersElement) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum __PeriodTriggersElement) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
