// Code generated by smithy-go-codegen DO NOT EDIT.

package lambda

import (
	"context"
	awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
	"github.com/aws/aws-sdk-go-v2/aws/retry"
	"github.com/aws/aws-sdk-go-v2/aws/signer/v4"
	"github.com/aws/aws-sdk-go-v2/service/lambda/types"
	smithy "github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

// Invokes a Lambda function. You can invoke a function synchronously (and wait for
// the response), or asynchronously. To invoke a function asynchronously, set
// InvocationType to Event.  <p>For <a
// href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-sync.html">synchronous
// invocation</a>, details about the function response, including errors, are
// included in the response body and headers. For either invocation type, you can
// find more information in the <a
// href="https://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions.html">execution
// log</a> and <a
// href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-x-ray.html">trace</a>.</p>
// <p>When an error occurs, your function may be invoked multiple times. Retry
// behavior varies by error type, client, event source, and invocation type. For
// example, if you invoke a function asynchronously and it returns an error, Lambda
// executes the function up to two more times. For more information, see <a
// href="https://docs.aws.amazon.com/lambda/latest/dg/retries-on-errors.html">Retry
// Behavior</a>.</p> <p>For <a
// href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html">asynchronous
// invocation</a>, Lambda adds events to a queue before sending them to your
// function. If your function does not have enough capacity to keep up with the
// queue, events may be lost. Occasionally, your function may receive the same
// event multiple times, even if no error occurs. To retain events that were not
// processed, configure your function with a <a
// href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">dead-letter
// queue</a>.</p> <p>The status code in the API response doesn't reflect function
// errors. Error codes are reserved for errors that prevent your function from
// executing, such as permissions errors, <a
// href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">limit
// errors</a>, or issues with your function's code and configuration. For example,
// Lambda returns <code>TooManyRequestsException</code> if executing the function
// would cause you to exceed a concurrency limit at either the account level
// (<code>ConcurrentInvocationLimitExceeded</code>) or function level
// (<code>ReservedFunctionConcurrentInvocationLimitExceeded</code>).</p> <p>For
// functions with a long timeout, your client might be disconnected during
// synchronous invocation while it waits for a response. Configure your HTTP
// client, SDK, firewall, proxy, or operating system to allow for long connections
// with timeout or keep-alive settings.</p> <p>This operation requires permission
// for the <a
// href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_awslambda.html">lambda:InvokeFunction</a>
// action.</p>
func (c *Client) Invoke(ctx context.Context, params *InvokeInput, optFns ...func(*Options)) (*InvokeOutput, error) {
	stack := middleware.NewStack("Invoke", smithyhttp.NewStackRequest)
	options := c.options.Copy()
	for _, fn := range optFns {
		fn(&options)
	}
	addawsRestjson1_serdeOpInvokeMiddlewares(stack)
	awsmiddleware.AddRequestInvocationIDMiddleware(stack)
	smithyhttp.AddContentLengthMiddleware(stack)
	AddResolveEndpointMiddleware(stack, options)
	v4.AddComputePayloadSHA256Middleware(stack)
	retry.AddRetryMiddlewares(stack, options)
	addHTTPSignerV4Middleware(stack, options)
	awsmiddleware.AddAttemptClockSkewMiddleware(stack)
	addClientUserAgent(stack)
	smithyhttp.AddErrorCloseResponseBodyMiddleware(stack)
	smithyhttp.AddCloseResponseBodyMiddleware(stack)
	addOpInvokeValidationMiddleware(stack)
	stack.Initialize.Add(newServiceMetadataMiddleware_opInvoke(options.Region), middleware.Before)

	for _, fn := range options.APIOptions {
		if err := fn(stack); err != nil {
			return nil, err
		}
	}
	handler := middleware.DecorateHandler(smithyhttp.NewClientHandler(options.HTTPClient), stack)
	result, metadata, err := handler.Handle(ctx, params)
	if err != nil {
		return nil, &smithy.OperationError{
			ServiceID:     ServiceID,
			OperationName: "Invoke",
			Err:           err,
		}
	}
	out := result.(*InvokeOutput)
	out.ResultMetadata = metadata
	return out, nil
}

type InvokeInput struct {
	// Choose from the following options.
	//
	//     * RequestResponse (default) - Invoke the
	// function synchronously. Keep the connection open until the function returns a
	// response or times out. The API response includes the function response and
	// additional data.
	//
	//     * Event - Invoke the function asynchronously. Send events
	// that fail multiple times to the function's dead-letter queue (if it's
	// configured). The API response only includes a status code.
	//
	//     * DryRun -
	// Validate parameter values and verify that the user or role has permission to
	// invoke the function.
	InvocationType types.InvocationType
	// Set to Tail to include the execution log in the response.
	LogType types.LogType
	// The JSON that you want to provide to your Lambda function as input.
	Payload []byte
	// Specify a version or alias to invoke a published version of the function.
	Qualifier *string
	// Up to 3583 bytes of base64-encoded data about the invoking client to pass to the
	// function in the context object.
	ClientContext *string
	// The name of the Lambda function, version, or alias. Name formats
	//
	//     * Function
	// name - my-function (name-only), my-function:v1 (with alias).
	//
	//     * Function ARN
	// - arn:aws:lambda:us-west-2:123456789012:function:my-function.
	//
	//     * Partial ARN
	// - 123456789012:function:my-function.
	//
	// You can append a version number or alias
	// to any of the formats. The length constraint applies only to the full ARN. If
	// you specify only the function name, it is limited to 64 characters in length.
	FunctionName *string
}

type InvokeOutput struct {
	// The last 4 KB of the execution log, which is base64 encoded.
	LogResult *string
	// The response from the function, or an error object.
	Payload []byte
	// The version of the function that executed. When you invoke a function with an
	// alias, this indicates which version the alias resolved to.
	ExecutedVersion *string
	// If present, indicates that an error occurred during function execution. Details
	// about the error are included in the response payload.
	FunctionError *string

	// Metadata pertaining to the operation's result.
	ResultMetadata middleware.Metadata
}

func addawsRestjson1_serdeOpInvokeMiddlewares(stack *middleware.Stack) {
	stack.Serialize.Add(&awsRestjson1_serializeOpInvoke{}, middleware.After)
	stack.Deserialize.Add(&awsRestjson1_deserializeOpInvoke{}, middleware.After)
}

func newServiceMetadataMiddleware_opInvoke(region string) awsmiddleware.RegisterServiceMetadata {
	return awsmiddleware.RegisterServiceMetadata{
		Region:        region,
		ServiceID:     ServiceID,
		SigningName:   "lambda",
		OperationName: "Invoke",
	}
}
