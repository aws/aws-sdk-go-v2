// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package lambda

import (
	"context"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/lambda/types"
)

const opInvoke = "Invoke"

// InvokeRequest returns a request value for making API operation for
// AWS Lambda.
//
// Invokes a Lambda function. You can invoke a function synchronously (and wait
// for the response), or asynchronously. To invoke a function asynchronously,
// set InvocationType to Event.
//
// For synchronous invocation, details about the function response, including
// errors, are included in the response body and headers. For either invocation
// type, you can find more information in the execution log (https://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions.html)
// and trace (https://docs.aws.amazon.com/lambda/latest/dg/dlq.html). To record
// function errors for asynchronous invocations, configure your function with
// a dead letter queue (https://docs.aws.amazon.com/lambda/latest/dg/dlq.html).
//
// When an error occurs, your function may be invoked multiple times. Retry
// behavior varies by error type, client, event source, and invocation type.
// For example, if you invoke a function asynchronously and it returns an error,
// Lambda executes the function up to two more times. For more information,
// see Retry Behavior (https://docs.aws.amazon.com/lambda/latest/dg/retries-on-errors.html).
//
// The status code in the API response doesn't reflect function errors. Error
// codes are reserved for errors that prevent your function from executing,
// such as permissions errors, limit errors (https://docs.aws.amazon.com/lambda/latest/dg/limits.html),
// or issues with your function's code and configuration. For example, Lambda
// returns TooManyRequestsException if executing the function would cause you
// to exceed a concurrency limit at either the account level (ConcurrentInvocationLimitExceeded)
// or function level (ReservedFunctionConcurrentInvocationLimitExceeded).
//
// For functions with a long timeout, your client might be disconnected during
// synchronous invocation while it waits for a response. Configure your HTTP
// client, SDK, firewall, proxy, or operating system to allow for long connections
// with timeout or keep-alive settings.
//
// This operation requires permission for the lambda:InvokeFunction action.
//
//    // Example sending a request using InvokeRequest.
//    req := client.InvokeRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/lambda-2015-03-31/Invoke
func (c *Client) InvokeRequest(input *types.InvokeInput) InvokeRequest {
	op := &aws.Operation{
		Name:       opInvoke,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-03-31/functions/{FunctionName}/invocations",
	}

	if input == nil {
		input = &types.InvokeInput{}
	}

	req := c.newRequest(op, input, &types.InvokeOutput{})
	return InvokeRequest{Request: req, Input: input, Copy: c.InvokeRequest}
}

// InvokeRequest is the request type for the
// Invoke API operation.
type InvokeRequest struct {
	*aws.Request
	Input *types.InvokeInput
	Copy  func(*types.InvokeInput) InvokeRequest
}

// Send marshals and sends the Invoke API request.
func (r InvokeRequest) Send(ctx context.Context) (*InvokeResponse, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	resp := &InvokeResponse{
		InvokeOutput: r.Request.Data.(*types.InvokeOutput),
		response:     &aws.Response{Request: r.Request},
	}

	return resp, nil
}

// InvokeResponse is the response type for the
// Invoke API operation.
type InvokeResponse struct {
	*types.InvokeOutput

	response *aws.Response
}

// SDKResponseMetdata returns the response metadata for the
// Invoke request.
func (r *InvokeResponse) SDKResponseMetdata() *aws.Response {
	return r.response
}
