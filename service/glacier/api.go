// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package glacier

import (
	"fmt"
	"io"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opAbortMultipartUpload = "AbortMultipartUpload"

// AbortMultipartUploadRequest is a API request type for the AbortMultipartUpload API operation.
type AbortMultipartUploadRequest struct {
	*aws.Request
	Input *AbortMultipartUploadInput
	Copy  func(*AbortMultipartUploadInput) AbortMultipartUploadRequest
}

// Send marshals and sends the AbortMultipartUpload API request.
func (r AbortMultipartUploadRequest) Send() (*AbortMultipartUploadOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AbortMultipartUploadOutput), nil
}

// AbortMultipartUploadRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation aborts a multipart upload identified by the upload ID.
//
// After the Abort Multipart Upload request succeeds, you cannot upload any
// more parts to the multipart upload or complete the multipart upload. Aborting
// a completed upload fails. However, aborting an already-aborted upload will
// succeed, for a short time. For more information about uploading a part and
// completing a multipart upload, see UploadMultipartPart and CompleteMultipartUpload.
//
// This operation is idempotent.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Working with Archives
// in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html)
// and Abort Multipart Upload (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the AbortMultipartUploadRequest method.
//    req := client.AbortMultipartUploadRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) AbortMultipartUploadRequest(input *AbortMultipartUploadInput) AbortMultipartUploadRequest {
	op := &aws.Operation{
		Name:       opAbortMultipartUpload,
		HTTPMethod: "DELETE",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}",
	}

	if input == nil {
		input = &AbortMultipartUploadInput{}
	}

	output := &AbortMultipartUploadOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return AbortMultipartUploadRequest{Request: req, Input: input, Copy: c.AbortMultipartUploadRequest}
}

const opAbortVaultLock = "AbortVaultLock"

// AbortVaultLockRequest is a API request type for the AbortVaultLock API operation.
type AbortVaultLockRequest struct {
	*aws.Request
	Input *AbortVaultLockInput
	Copy  func(*AbortVaultLockInput) AbortVaultLockRequest
}

// Send marshals and sends the AbortVaultLock API request.
func (r AbortVaultLockRequest) Send() (*AbortVaultLockOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AbortVaultLockOutput), nil
}

// AbortVaultLockRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation aborts the vault locking process if the vault lock is not
// in the Locked state. If the vault lock is in the Locked state when this operation
// is requested, the operation returns an AccessDeniedException error. Aborting
// the vault locking process removes the vault lock policy from the specified
// vault.
//
// A vault lock is put into the InProgress state by calling InitiateVaultLock.
// A vault lock is put into the Locked state by calling CompleteVaultLock. You
// can get the state of a vault lock by calling GetVaultLock. For more information
// about the vault locking process, see Amazon Glacier Vault Lock (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock.html).
// For more information about vault lock policies, see Amazon Glacier Access
// Control with Vault Lock Policies (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock-policy.html).
//
// This operation is idempotent. You can successfully invoke this operation
// multiple times, if the vault lock is in the InProgress state or if there
// is no policy associated with the vault.
//
//    // Example sending a request using the AbortVaultLockRequest method.
//    req := client.AbortVaultLockRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) AbortVaultLockRequest(input *AbortVaultLockInput) AbortVaultLockRequest {
	op := &aws.Operation{
		Name:       opAbortVaultLock,
		HTTPMethod: "DELETE",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/lock-policy",
	}

	if input == nil {
		input = &AbortVaultLockInput{}
	}

	output := &AbortVaultLockOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return AbortVaultLockRequest{Request: req, Input: input, Copy: c.AbortVaultLockRequest}
}

const opAddTagsToVault = "AddTagsToVault"

// AddTagsToVaultRequest is a API request type for the AddTagsToVault API operation.
type AddTagsToVaultRequest struct {
	*aws.Request
	Input *AddTagsToVaultInput
	Copy  func(*AddTagsToVaultInput) AddTagsToVaultRequest
}

// Send marshals and sends the AddTagsToVault API request.
func (r AddTagsToVaultRequest) Send() (*AddTagsToVaultOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AddTagsToVaultOutput), nil
}

// AddTagsToVaultRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation adds the specified tags to a vault. Each tag is composed of
// a key and a value. Each vault can have up to 10 tags. If your request would
// cause the tag limit for the vault to be exceeded, the operation throws the
// LimitExceededException error. If a tag already exists on the vault under
// a specified key, the existing key value will be overwritten. For more information
// about tags, see Tagging Amazon Glacier Resources (http://docs.aws.amazon.com/amazonglacier/latest/dev/tagging.html).
//
//    // Example sending a request using the AddTagsToVaultRequest method.
//    req := client.AddTagsToVaultRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) AddTagsToVaultRequest(input *AddTagsToVaultInput) AddTagsToVaultRequest {
	op := &aws.Operation{
		Name:       opAddTagsToVault,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/tags?operation=add",
	}

	if input == nil {
		input = &AddTagsToVaultInput{}
	}

	output := &AddTagsToVaultOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return AddTagsToVaultRequest{Request: req, Input: input, Copy: c.AddTagsToVaultRequest}
}

const opCompleteMultipartUpload = "CompleteMultipartUpload"

// CompleteMultipartUploadRequest is a API request type for the CompleteMultipartUpload API operation.
type CompleteMultipartUploadRequest struct {
	*aws.Request
	Input *CompleteMultipartUploadInput
	Copy  func(*CompleteMultipartUploadInput) CompleteMultipartUploadRequest
}

// Send marshals and sends the CompleteMultipartUpload API request.
func (r CompleteMultipartUploadRequest) Send() (*UploadArchiveOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UploadArchiveOutput), nil
}

// CompleteMultipartUploadRequest returns a request value for making API operation for
// Amazon Glacier.
//
// You call this operation to inform Amazon Glacier that all the archive parts
// have been uploaded and that Amazon Glacier can now assemble the archive from
// the uploaded parts. After assembling and saving the archive to the vault,
// Amazon Glacier returns the URI path of the newly created archive resource.
// Using the URI path, you can then access the archive. After you upload an
// archive, you should save the archive ID returned to retrieve the archive
// at a later point. You can also get the vault inventory to obtain a list of
// archive IDs in a vault. For more information, see InitiateJob.
//
// In the request, you must include the computed SHA256 tree hash of the entire
// archive you have uploaded. For information about computing a SHA256 tree
// hash, see Computing Checksums (http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html).
// On the server side, Amazon Glacier also constructs the SHA256 tree hash of
// the assembled archive. If the values match, Amazon Glacier saves the archive
// to the vault; otherwise, it returns an error, and the operation fails. The
// ListParts operation returns a list of parts uploaded for a specific multipart
// upload. It includes checksum information for each uploaded part that can
// be used to debug a bad checksum issue.
//
// Additionally, Amazon Glacier also checks for any missing content ranges when
// assembling the archive, if missing content ranges are found, Amazon Glacier
// returns an error and the operation fails.
//
// Complete Multipart Upload is an idempotent operation. After your first successful
// complete multipart upload, if you call the operation again within a short
// period, the operation will succeed and return the same archive ID. This is
// useful in the event you experience a network issue that causes an aborted
// connection or receive a 500 server error, in which case you can repeat your
// Complete Multipart Upload request and get the same archive ID without creating
// duplicate archives. Note, however, that after the multipart upload completes,
// you cannot call the List Parts operation and the multipart upload will not
// appear in List Multipart Uploads response, even if idempotent complete is
// possible.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Uploading Large Archives
// in Parts (Multipart Upload) (http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html)
// and Complete Multipart Upload (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-complete-upload.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the CompleteMultipartUploadRequest method.
//    req := client.CompleteMultipartUploadRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) CompleteMultipartUploadRequest(input *CompleteMultipartUploadInput) CompleteMultipartUploadRequest {
	op := &aws.Operation{
		Name:       opCompleteMultipartUpload,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}",
	}

	if input == nil {
		input = &CompleteMultipartUploadInput{}
	}

	output := &UploadArchiveOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CompleteMultipartUploadRequest{Request: req, Input: input, Copy: c.CompleteMultipartUploadRequest}
}

const opCompleteVaultLock = "CompleteVaultLock"

// CompleteVaultLockRequest is a API request type for the CompleteVaultLock API operation.
type CompleteVaultLockRequest struct {
	*aws.Request
	Input *CompleteVaultLockInput
	Copy  func(*CompleteVaultLockInput) CompleteVaultLockRequest
}

// Send marshals and sends the CompleteVaultLock API request.
func (r CompleteVaultLockRequest) Send() (*CompleteVaultLockOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CompleteVaultLockOutput), nil
}

// CompleteVaultLockRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation completes the vault locking process by transitioning the vault
// lock from the InProgress state to the Locked state, which causes the vault
// lock policy to become unchangeable. A vault lock is put into the InProgress
// state by calling InitiateVaultLock. You can obtain the state of the vault
// lock by calling GetVaultLock. For more information about the vault locking
// process, Amazon Glacier Vault Lock (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock.html).
//
// This operation is idempotent. This request is always successful if the vault
// lock is in the Locked state and the provided lock ID matches the lock ID
// originally used to lock the vault.
//
// If an invalid lock ID is passed in the request when the vault lock is in
// the Locked state, the operation returns an AccessDeniedException error. If
// an invalid lock ID is passed in the request when the vault lock is in the
// InProgress state, the operation throws an InvalidParameter error.
//
//    // Example sending a request using the CompleteVaultLockRequest method.
//    req := client.CompleteVaultLockRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) CompleteVaultLockRequest(input *CompleteVaultLockInput) CompleteVaultLockRequest {
	op := &aws.Operation{
		Name:       opCompleteVaultLock,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/lock-policy/{lockId}",
	}

	if input == nil {
		input = &CompleteVaultLockInput{}
	}

	output := &CompleteVaultLockOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return CompleteVaultLockRequest{Request: req, Input: input, Copy: c.CompleteVaultLockRequest}
}

const opCreateVault = "CreateVault"

// CreateVaultRequest is a API request type for the CreateVault API operation.
type CreateVaultRequest struct {
	*aws.Request
	Input *CreateVaultInput
	Copy  func(*CreateVaultInput) CreateVaultRequest
}

// Send marshals and sends the CreateVault API request.
func (r CreateVaultRequest) Send() (*CreateVaultOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateVaultOutput), nil
}

// CreateVaultRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation creates a new vault with the specified name. The name of the
// vault must be unique within a region for an AWS account. You can create up
// to 1,000 vaults per account. If you need to create more vaults, contact Amazon
// Glacier.
//
// You must use the following guidelines when naming a vault.
//
//    * Names can be between 1 and 255 characters long.
//
//    * Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
//    and '.' (period).
//
// This operation is idempotent.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Creating a Vault
// in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/creating-vaults.html)
// and Create Vault  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-put.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the CreateVaultRequest method.
//    req := client.CreateVaultRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) CreateVaultRequest(input *CreateVaultInput) CreateVaultRequest {
	op := &aws.Operation{
		Name:       opCreateVault,
		HTTPMethod: "PUT",
		HTTPPath:   "/{accountId}/vaults/{vaultName}",
	}

	if input == nil {
		input = &CreateVaultInput{}
	}

	output := &CreateVaultOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateVaultRequest{Request: req, Input: input, Copy: c.CreateVaultRequest}
}

const opDeleteArchive = "DeleteArchive"

// DeleteArchiveRequest is a API request type for the DeleteArchive API operation.
type DeleteArchiveRequest struct {
	*aws.Request
	Input *DeleteArchiveInput
	Copy  func(*DeleteArchiveInput) DeleteArchiveRequest
}

// Send marshals and sends the DeleteArchive API request.
func (r DeleteArchiveRequest) Send() (*DeleteArchiveOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteArchiveOutput), nil
}

// DeleteArchiveRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation deletes an archive from a vault. Subsequent requests to initiate
// a retrieval of this archive will fail. Archive retrievals that are in progress
// for this archive ID may or may not succeed according to the following scenarios:
//
//    * If the archive retrieval job is actively preparing the data for download
//    when Amazon Glacier receives the delete archive request, the archival
//    retrieval operation might fail.
//
//    * If the archive retrieval job has successfully prepared the archive for
//    download when Amazon Glacier receives the delete archive request, you
//    will be able to download the output.
//
// This operation is idempotent. Attempting to delete an already-deleted archive
// does not result in an error.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Deleting an Archive
// in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-an-archive.html)
// and Delete Archive (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the DeleteArchiveRequest method.
//    req := client.DeleteArchiveRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) DeleteArchiveRequest(input *DeleteArchiveInput) DeleteArchiveRequest {
	op := &aws.Operation{
		Name:       opDeleteArchive,
		HTTPMethod: "DELETE",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/archives/{archiveId}",
	}

	if input == nil {
		input = &DeleteArchiveInput{}
	}

	output := &DeleteArchiveOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteArchiveRequest{Request: req, Input: input, Copy: c.DeleteArchiveRequest}
}

const opDeleteVault = "DeleteVault"

// DeleteVaultRequest is a API request type for the DeleteVault API operation.
type DeleteVaultRequest struct {
	*aws.Request
	Input *DeleteVaultInput
	Copy  func(*DeleteVaultInput) DeleteVaultRequest
}

// Send marshals and sends the DeleteVault API request.
func (r DeleteVaultRequest) Send() (*DeleteVaultOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteVaultOutput), nil
}

// DeleteVaultRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation deletes a vault. Amazon Glacier will delete a vault only if
// there are no archives in the vault as of the last inventory and there have
// been no writes to the vault since the last inventory. If either of these
// conditions is not satisfied, the vault deletion fails (that is, the vault
// is not removed) and Amazon Glacier returns an error. You can use DescribeVault
// to return the number of archives in a vault, and you can use Initiate a Job
// (POST jobs) (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html)
// to initiate a new inventory retrieval for a vault. The inventory contains
// the archive IDs you use to delete archives using Delete Archive (DELETE archive)
// (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html).
//
// This operation is idempotent.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Deleting a Vault
// in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-vaults.html)
// and Delete Vault  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-delete.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the DeleteVaultRequest method.
//    req := client.DeleteVaultRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) DeleteVaultRequest(input *DeleteVaultInput) DeleteVaultRequest {
	op := &aws.Operation{
		Name:       opDeleteVault,
		HTTPMethod: "DELETE",
		HTTPPath:   "/{accountId}/vaults/{vaultName}",
	}

	if input == nil {
		input = &DeleteVaultInput{}
	}

	output := &DeleteVaultOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteVaultRequest{Request: req, Input: input, Copy: c.DeleteVaultRequest}
}

const opDeleteVaultAccessPolicy = "DeleteVaultAccessPolicy"

// DeleteVaultAccessPolicyRequest is a API request type for the DeleteVaultAccessPolicy API operation.
type DeleteVaultAccessPolicyRequest struct {
	*aws.Request
	Input *DeleteVaultAccessPolicyInput
	Copy  func(*DeleteVaultAccessPolicyInput) DeleteVaultAccessPolicyRequest
}

// Send marshals and sends the DeleteVaultAccessPolicy API request.
func (r DeleteVaultAccessPolicyRequest) Send() (*DeleteVaultAccessPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteVaultAccessPolicyOutput), nil
}

// DeleteVaultAccessPolicyRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation deletes the access policy associated with the specified vault.
// The operation is eventually consistent; that is, it might take some time
// for Amazon Glacier to completely remove the access policy, and you might
// still see the effect of the policy for a short time after you send the delete
// request.
//
// This operation is idempotent. You can invoke delete multiple times, even
// if there is no policy associated with the vault. For more information about
// vault access policies, see Amazon Glacier Access Control with Vault Access
// Policies (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html).
//
//    // Example sending a request using the DeleteVaultAccessPolicyRequest method.
//    req := client.DeleteVaultAccessPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) DeleteVaultAccessPolicyRequest(input *DeleteVaultAccessPolicyInput) DeleteVaultAccessPolicyRequest {
	op := &aws.Operation{
		Name:       opDeleteVaultAccessPolicy,
		HTTPMethod: "DELETE",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/access-policy",
	}

	if input == nil {
		input = &DeleteVaultAccessPolicyInput{}
	}

	output := &DeleteVaultAccessPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteVaultAccessPolicyRequest{Request: req, Input: input, Copy: c.DeleteVaultAccessPolicyRequest}
}

const opDeleteVaultNotifications = "DeleteVaultNotifications"

// DeleteVaultNotificationsRequest is a API request type for the DeleteVaultNotifications API operation.
type DeleteVaultNotificationsRequest struct {
	*aws.Request
	Input *DeleteVaultNotificationsInput
	Copy  func(*DeleteVaultNotificationsInput) DeleteVaultNotificationsRequest
}

// Send marshals and sends the DeleteVaultNotifications API request.
func (r DeleteVaultNotificationsRequest) Send() (*DeleteVaultNotificationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteVaultNotificationsOutput), nil
}

// DeleteVaultNotificationsRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation deletes the notification configuration set for a vault. The
// operation is eventually consistent; that is, it might take some time for
// Amazon Glacier to completely disable the notifications and you might still
// receive some notifications for a short time after you send the delete request.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Configuring Vault
// Notifications in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html)
// and Delete Vault Notification Configuration  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the DeleteVaultNotificationsRequest method.
//    req := client.DeleteVaultNotificationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) DeleteVaultNotificationsRequest(input *DeleteVaultNotificationsInput) DeleteVaultNotificationsRequest {
	op := &aws.Operation{
		Name:       opDeleteVaultNotifications,
		HTTPMethod: "DELETE",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/notification-configuration",
	}

	if input == nil {
		input = &DeleteVaultNotificationsInput{}
	}

	output := &DeleteVaultNotificationsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteVaultNotificationsRequest{Request: req, Input: input, Copy: c.DeleteVaultNotificationsRequest}
}

const opDescribeJob = "DescribeJob"

// DescribeJobRequest is a API request type for the DescribeJob API operation.
type DescribeJobRequest struct {
	*aws.Request
	Input *DescribeJobInput
	Copy  func(*DescribeJobInput) DescribeJobRequest
}

// Send marshals and sends the DescribeJob API request.
func (r DescribeJobRequest) Send() (*DescribeJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeJobOutput), nil
}

// DescribeJobRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation returns information about a job you previously initiated,
// including the job initiation date, the user who initiated the job, the job
// status code/message and the Amazon SNS topic to notify after Amazon Glacier
// completes the job. For more information about initiating a job, see InitiateJob.
//
// This operation enables you to check the status of your job. However, it is
// strongly recommended that you set up an Amazon SNS topic and specify it in
// your initiate job request so that Amazon Glacier can notify the topic after
// it completes the job.
//
// A job ID will not expire for at least 24 hours after Amazon Glacier completes
// the job.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For more information about using this operation, see the documentation for
// the underlying REST API Describe Job (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-describe-job-get.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the DescribeJobRequest method.
//    req := client.DescribeJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) DescribeJobRequest(input *DescribeJobInput) DescribeJobRequest {
	op := &aws.Operation{
		Name:       opDescribeJob,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/jobs/{jobId}",
	}

	if input == nil {
		input = &DescribeJobInput{}
	}

	output := &DescribeJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeJobRequest{Request: req, Input: input, Copy: c.DescribeJobRequest}
}

const opDescribeVault = "DescribeVault"

// DescribeVaultRequest is a API request type for the DescribeVault API operation.
type DescribeVaultRequest struct {
	*aws.Request
	Input *DescribeVaultInput
	Copy  func(*DescribeVaultInput) DescribeVaultRequest
}

// Send marshals and sends the DescribeVault API request.
func (r DescribeVaultRequest) Send() (*DescribeVaultOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeVaultOutput), nil
}

// DescribeVaultRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation returns information about a vault, including the vault's Amazon
// Resource Name (ARN), the date the vault was created, the number of archives
// it contains, and the total size of all the archives in the vault. The number
// of archives and their total size are as of the last inventory generation.
// This means that if you add or remove an archive from a vault, and then immediately
// use Describe Vault, the change in contents will not be immediately reflected.
// If you want to retrieve the latest inventory of the vault, use InitiateJob.
// Amazon Glacier generates vault inventories approximately daily. For more
// information, see Downloading a Vault Inventory in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html).
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Retrieving Vault
// Metadata in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html)
// and Describe Vault  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-get.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the DescribeVaultRequest method.
//    req := client.DescribeVaultRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) DescribeVaultRequest(input *DescribeVaultInput) DescribeVaultRequest {
	op := &aws.Operation{
		Name:       opDescribeVault,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}",
	}

	if input == nil {
		input = &DescribeVaultInput{}
	}

	output := &DescribeVaultOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeVaultRequest{Request: req, Input: input, Copy: c.DescribeVaultRequest}
}

const opGetDataRetrievalPolicy = "GetDataRetrievalPolicy"

// GetDataRetrievalPolicyRequest is a API request type for the GetDataRetrievalPolicy API operation.
type GetDataRetrievalPolicyRequest struct {
	*aws.Request
	Input *GetDataRetrievalPolicyInput
	Copy  func(*GetDataRetrievalPolicyInput) GetDataRetrievalPolicyRequest
}

// Send marshals and sends the GetDataRetrievalPolicy API request.
func (r GetDataRetrievalPolicyRequest) Send() (*GetDataRetrievalPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDataRetrievalPolicyOutput), nil
}

// GetDataRetrievalPolicyRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation returns the current data retrieval policy for the account
// and region specified in the GET request. For more information about data
// retrieval policies, see Amazon Glacier Data Retrieval Policies (http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html).
//
//    // Example sending a request using the GetDataRetrievalPolicyRequest method.
//    req := client.GetDataRetrievalPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) GetDataRetrievalPolicyRequest(input *GetDataRetrievalPolicyInput) GetDataRetrievalPolicyRequest {
	op := &aws.Operation{
		Name:       opGetDataRetrievalPolicy,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/policies/data-retrieval",
	}

	if input == nil {
		input = &GetDataRetrievalPolicyInput{}
	}

	output := &GetDataRetrievalPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDataRetrievalPolicyRequest{Request: req, Input: input, Copy: c.GetDataRetrievalPolicyRequest}
}

const opGetJobOutput = "GetJobOutput"

// GetJobOutputRequest is a API request type for the GetJobOutput API operation.
type GetJobOutputRequest struct {
	*aws.Request
	Input *GetJobOutputInput
	Copy  func(*GetJobOutputInput) GetJobOutputRequest
}

// Send marshals and sends the GetJobOutput API request.
func (r GetJobOutputRequest) Send() (*GetJobOutputOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetJobOutputOutput), nil
}

// GetJobOutputRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation downloads the output of the job you initiated using InitiateJob.
// Depending on the job type you specified when you initiated the job, the output
// will be either the content of an archive or a vault inventory.
//
// You can download all the job output or download a portion of the output by
// specifying a byte range. In the case of an archive retrieval job, depending
// on the byte range you specify, Amazon Glacier returns the checksum for the
// portion of the data. You can compute the checksum on the client and verify
// that the values match to ensure the portion you downloaded is the correct
// data.
//
// A job ID will not expire for at least 24 hours after Amazon Glacier completes
// the job. That a byte range. For both archive and inventory retrieval jobs,
// you should verify the downloaded size against the size returned in the headers
// from the Get Job Output response.
//
// For archive retrieval jobs, you should also verify that the size is what
// you expected. If you download a portion of the output, the expected size
// is based on the range of bytes you specified. For example, if you specify
// a range of bytes=0-1048575, you should verify your download size is 1,048,576
// bytes. If you download an entire archive, the expected size is the size of
// the archive when you uploaded it to Amazon Glacier The expected size is also
// returned in the headers from the Get Job Output response.
//
// In the case of an archive retrieval job, depending on the byte range you
// specify, Amazon Glacier returns the checksum for the portion of the data.
// To ensure the portion you downloaded is the correct data, compute the checksum
// on the client, verify that the values match, and verify that the size is
// what you expected.
//
// A job ID does not expire for at least 24 hours after Amazon Glacier completes
// the job. That is, you can download the job output within the 24 hours period
// after Amazon Glacier completes the job.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and the underlying REST API, see Downloading a
// Vault Inventory (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html),
// Downloading an Archive (http://docs.aws.amazon.com/amazonglacier/latest/dev/downloading-an-archive.html),
// and Get Job Output  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-job-output-get.html)
//
//    // Example sending a request using the GetJobOutputRequest method.
//    req := client.GetJobOutputRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) GetJobOutputRequest(input *GetJobOutputInput) GetJobOutputRequest {
	op := &aws.Operation{
		Name:       opGetJobOutput,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/jobs/{jobId}/output",
	}

	if input == nil {
		input = &GetJobOutputInput{}
	}

	output := &GetJobOutputOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetJobOutputRequest{Request: req, Input: input, Copy: c.GetJobOutputRequest}
}

const opGetVaultAccessPolicy = "GetVaultAccessPolicy"

// GetVaultAccessPolicyRequest is a API request type for the GetVaultAccessPolicy API operation.
type GetVaultAccessPolicyRequest struct {
	*aws.Request
	Input *GetVaultAccessPolicyInput
	Copy  func(*GetVaultAccessPolicyInput) GetVaultAccessPolicyRequest
}

// Send marshals and sends the GetVaultAccessPolicy API request.
func (r GetVaultAccessPolicyRequest) Send() (*GetVaultAccessPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetVaultAccessPolicyOutput), nil
}

// GetVaultAccessPolicyRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation retrieves the access-policy subresource set on the vault;
// for more information on setting this subresource, see Set Vault Access Policy
// (PUT access-policy) (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html).
// If there is no access policy set on the vault, the operation returns a 404
// Not found error. For more information about vault access policies, see Amazon
// Glacier Access Control with Vault Access Policies (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html).
//
//    // Example sending a request using the GetVaultAccessPolicyRequest method.
//    req := client.GetVaultAccessPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) GetVaultAccessPolicyRequest(input *GetVaultAccessPolicyInput) GetVaultAccessPolicyRequest {
	op := &aws.Operation{
		Name:       opGetVaultAccessPolicy,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/access-policy",
	}

	if input == nil {
		input = &GetVaultAccessPolicyInput{}
	}

	output := &GetVaultAccessPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetVaultAccessPolicyRequest{Request: req, Input: input, Copy: c.GetVaultAccessPolicyRequest}
}

const opGetVaultLock = "GetVaultLock"

// GetVaultLockRequest is a API request type for the GetVaultLock API operation.
type GetVaultLockRequest struct {
	*aws.Request
	Input *GetVaultLockInput
	Copy  func(*GetVaultLockInput) GetVaultLockRequest
}

// Send marshals and sends the GetVaultLock API request.
func (r GetVaultLockRequest) Send() (*GetVaultLockOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetVaultLockOutput), nil
}

// GetVaultLockRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation retrieves the following attributes from the lock-policy subresource
// set on the specified vault:
//
//    * The vault lock policy set on the vault.
//
//    * The state of the vault lock, which is either InProgess or Locked.
//
//    * When the lock ID expires. The lock ID is used to complete the vault
//    locking process.
//
//    * When the vault lock was initiated and put into the InProgress state.
//
// A vault lock is put into the InProgress state by calling InitiateVaultLock.
// A vault lock is put into the Locked state by calling CompleteVaultLock. You
// can abort the vault locking process by calling AbortVaultLock. For more information
// about the vault locking process, Amazon Glacier Vault Lock (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock.html).
//
// If there is no vault lock policy set on the vault, the operation returns
// a 404 Not found error. For more information about vault lock policies, Amazon
// Glacier Access Control with Vault Lock Policies (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock-policy.html).
//
//    // Example sending a request using the GetVaultLockRequest method.
//    req := client.GetVaultLockRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) GetVaultLockRequest(input *GetVaultLockInput) GetVaultLockRequest {
	op := &aws.Operation{
		Name:       opGetVaultLock,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/lock-policy",
	}

	if input == nil {
		input = &GetVaultLockInput{}
	}

	output := &GetVaultLockOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetVaultLockRequest{Request: req, Input: input, Copy: c.GetVaultLockRequest}
}

const opGetVaultNotifications = "GetVaultNotifications"

// GetVaultNotificationsRequest is a API request type for the GetVaultNotifications API operation.
type GetVaultNotificationsRequest struct {
	*aws.Request
	Input *GetVaultNotificationsInput
	Copy  func(*GetVaultNotificationsInput) GetVaultNotificationsRequest
}

// Send marshals and sends the GetVaultNotifications API request.
func (r GetVaultNotificationsRequest) Send() (*GetVaultNotificationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetVaultNotificationsOutput), nil
}

// GetVaultNotificationsRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation retrieves the notification-configuration subresource of the
// specified vault.
//
// For information about setting a notification configuration on a vault, see
// SetVaultNotifications. If a notification configuration for a vault is not
// set, the operation returns a 404 Not Found error. For more information about
// vault notifications, see Configuring Vault Notifications in Amazon Glacier
// (http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html).
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Configuring Vault
// Notifications in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html)
// and Get Vault Notification Configuration  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-get.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the GetVaultNotificationsRequest method.
//    req := client.GetVaultNotificationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) GetVaultNotificationsRequest(input *GetVaultNotificationsInput) GetVaultNotificationsRequest {
	op := &aws.Operation{
		Name:       opGetVaultNotifications,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/notification-configuration",
	}

	if input == nil {
		input = &GetVaultNotificationsInput{}
	}

	output := &GetVaultNotificationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetVaultNotificationsRequest{Request: req, Input: input, Copy: c.GetVaultNotificationsRequest}
}

const opInitiateJob = "InitiateJob"

// InitiateJobRequest is a API request type for the InitiateJob API operation.
type InitiateJobRequest struct {
	*aws.Request
	Input *InitiateJobInput
	Copy  func(*InitiateJobInput) InitiateJobRequest
}

// Send marshals and sends the InitiateJob API request.
func (r InitiateJobRequest) Send() (*InitiateJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*InitiateJobOutput), nil
}

// InitiateJobRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation initiates a job of the specified type, which can be a select,
// an archival retrieval, or a vault retrieval. For more information about using
// this operation, see the documentation for the underlying REST API Initiate
// a Job (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html).
//
//    // Example sending a request using the InitiateJobRequest method.
//    req := client.InitiateJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) InitiateJobRequest(input *InitiateJobInput) InitiateJobRequest {
	op := &aws.Operation{
		Name:       opInitiateJob,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/jobs",
	}

	if input == nil {
		input = &InitiateJobInput{}
	}

	output := &InitiateJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return InitiateJobRequest{Request: req, Input: input, Copy: c.InitiateJobRequest}
}

const opInitiateMultipartUpload = "InitiateMultipartUpload"

// InitiateMultipartUploadRequest is a API request type for the InitiateMultipartUpload API operation.
type InitiateMultipartUploadRequest struct {
	*aws.Request
	Input *InitiateMultipartUploadInput
	Copy  func(*InitiateMultipartUploadInput) InitiateMultipartUploadRequest
}

// Send marshals and sends the InitiateMultipartUpload API request.
func (r InitiateMultipartUploadRequest) Send() (*InitiateMultipartUploadOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*InitiateMultipartUploadOutput), nil
}

// InitiateMultipartUploadRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation initiates a multipart upload. Amazon Glacier creates a multipart
// upload resource and returns its ID in the response. The multipart upload
// ID is used in subsequent requests to upload parts of an archive (see UploadMultipartPart).
//
// When you initiate a multipart upload, you specify the part size in number
// of bytes. The part size must be a megabyte (1024 KB) multiplied by a power
// of 2-for example, 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608
// (8 MB), and so on. The minimum allowable part size is 1 MB, and the maximum
// is 4 GB.
//
// Every part you upload to this resource (see UploadMultipartPart), except
// the last one, must have the same size. The last one can be the same size
// or smaller. For example, suppose you want to upload a 16.2 MB file. If you
// initiate the multipart upload with a part size of 4 MB, you will upload four
// parts of 4 MB each and one part of 0.2 MB.
//
// You don't need to know the size of the archive when you start a multipart
// upload because Amazon Glacier does not require you to specify the overall
// archive size.
//
// After you complete the multipart upload, Amazon Glacier removes the multipart
// upload resource referenced by the ID. Amazon Glacier also removes the multipart
// upload resource if you cancel the multipart upload or it may be removed if
// there is no activity for a period of 24 hours.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Uploading Large Archives
// in Parts (Multipart Upload) (http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html)
// and Initiate Multipart Upload (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the InitiateMultipartUploadRequest method.
//    req := client.InitiateMultipartUploadRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) InitiateMultipartUploadRequest(input *InitiateMultipartUploadInput) InitiateMultipartUploadRequest {
	op := &aws.Operation{
		Name:       opInitiateMultipartUpload,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/multipart-uploads",
	}

	if input == nil {
		input = &InitiateMultipartUploadInput{}
	}

	output := &InitiateMultipartUploadOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return InitiateMultipartUploadRequest{Request: req, Input: input, Copy: c.InitiateMultipartUploadRequest}
}

const opInitiateVaultLock = "InitiateVaultLock"

// InitiateVaultLockRequest is a API request type for the InitiateVaultLock API operation.
type InitiateVaultLockRequest struct {
	*aws.Request
	Input *InitiateVaultLockInput
	Copy  func(*InitiateVaultLockInput) InitiateVaultLockRequest
}

// Send marshals and sends the InitiateVaultLock API request.
func (r InitiateVaultLockRequest) Send() (*InitiateVaultLockOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*InitiateVaultLockOutput), nil
}

// InitiateVaultLockRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation initiates the vault locking process by doing the following:
//
//    * Installing a vault lock policy on the specified vault.
//
//    * Setting the lock state of vault lock to InProgress.
//
//    * Returning a lock ID, which is used to complete the vault locking process.
//
// You can set one vault lock policy for each vault and this policy can be up
// to 20 KB in size. For more information about vault lock policies, see Amazon
// Glacier Access Control with Vault Lock Policies (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock-policy.html).
//
// You must complete the vault locking process within 24 hours after the vault
// lock enters the InProgress state. After the 24 hour window ends, the lock
// ID expires, the vault automatically exits the InProgress state, and the vault
// lock policy is removed from the vault. You call CompleteVaultLock to complete
// the vault locking process by setting the state of the vault lock to Locked.
//
// After a vault lock is in the Locked state, you cannot initiate a new vault
// lock for the vault.
//
// You can abort the vault locking process by calling AbortVaultLock. You can
// get the state of the vault lock by calling GetVaultLock. For more information
// about the vault locking process, Amazon Glacier Vault Lock (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock.html).
//
// If this operation is called when the vault lock is in the InProgress state,
// the operation returns an AccessDeniedException error. When the vault lock
// is in the InProgress state you must call AbortVaultLock before you can initiate
// a new vault lock policy.
//
//    // Example sending a request using the InitiateVaultLockRequest method.
//    req := client.InitiateVaultLockRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) InitiateVaultLockRequest(input *InitiateVaultLockInput) InitiateVaultLockRequest {
	op := &aws.Operation{
		Name:       opInitiateVaultLock,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/lock-policy",
	}

	if input == nil {
		input = &InitiateVaultLockInput{}
	}

	output := &InitiateVaultLockOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return InitiateVaultLockRequest{Request: req, Input: input, Copy: c.InitiateVaultLockRequest}
}

const opListJobs = "ListJobs"

// ListJobsRequest is a API request type for the ListJobs API operation.
type ListJobsRequest struct {
	*aws.Request
	Input *ListJobsInput
	Copy  func(*ListJobsInput) ListJobsRequest
}

// Send marshals and sends the ListJobs API request.
func (r ListJobsRequest) Send() (*ListJobsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListJobsOutput), nil
}

// ListJobsRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation lists jobs for a vault, including jobs that are in-progress
// and jobs that have recently finished. The List Job operation returns a list
// of these jobs sorted by job initiation time.
//
// Amazon Glacier retains recently completed jobs for a period before deleting
// them; however, it eventually removes completed jobs. The output of completed
// jobs can be retrieved. Retaining completed jobs for a period of time after
// they have completed enables you to get a job output in the event you miss
// the job completion notification or your first attempt to download it fails.
// For example, suppose you start an archive retrieval job to download an archive.
// After the job completes, you start to download the archive but encounter
// a network error. In this scenario, you can retry and download the archive
// while the job exists.
//
// The List Jobs operation supports pagination. You should always check the
// response Marker field. If there are no more jobs to list, the Marker field
// is set to null. If there are more jobs to list, the Marker field is set to
// a non-null value, which you can use to continue the pagination of the list.
// To return a list of jobs that begins at a specific job, set the marker request
// parameter to the Marker value for that job that you obtained from a previous
// List Jobs request.
//
// You can set a maximum limit for the number of jobs returned in the response
// by specifying the limit parameter in the request. The default limit is 1000.
// The number of jobs returned might be fewer than the limit, but the number
// of returned jobs never exceeds the limit.
//
// Additionally, you can filter the jobs list returned by specifying the optional
// statuscode parameter or completed parameter, or both. Using the statuscode
// parameter, you can specify to return only jobs that match either the InProgress,
// Succeeded, or Failed status. Using the completed parameter, you can specify
// to return only jobs that were completed (true) or jobs that were not completed
// (false).
//
// For more information about using this operation, see the documentation for
// the underlying REST API List Jobs (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-jobs-get.html).
//
//    // Example sending a request using the ListJobsRequest method.
//    req := client.ListJobsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) ListJobsRequest(input *ListJobsInput) ListJobsRequest {
	op := &aws.Operation{
		Name:       opListJobs,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/jobs",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"marker"},
			OutputTokens:    []string{"Marker"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListJobsInput{}
	}

	output := &ListJobsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListJobsRequest{Request: req, Input: input, Copy: c.ListJobsRequest}
}

// Paginate pages iterates over the pages of a ListJobsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListJobs operation.
//		req := client.ListJobsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListJobsRequest) Paginate(opts ...aws.Option) ListJobsPager {
	return ListJobsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListJobsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListJobsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListJobsPager struct {
	aws.Pager
}

func (p *ListJobsPager) CurrentPage() *ListJobsOutput {
	return p.Pager.CurrentPage().(*ListJobsOutput)
}

const opListMultipartUploads = "ListMultipartUploads"

// ListMultipartUploadsRequest is a API request type for the ListMultipartUploads API operation.
type ListMultipartUploadsRequest struct {
	*aws.Request
	Input *ListMultipartUploadsInput
	Copy  func(*ListMultipartUploadsInput) ListMultipartUploadsRequest
}

// Send marshals and sends the ListMultipartUploads API request.
func (r ListMultipartUploadsRequest) Send() (*ListMultipartUploadsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListMultipartUploadsOutput), nil
}

// ListMultipartUploadsRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation lists in-progress multipart uploads for the specified vault.
// An in-progress multipart upload is a multipart upload that has been initiated
// by an InitiateMultipartUpload request, but has not yet been completed or
// aborted. The list returned in the List Multipart Upload response has no guaranteed
// order.
//
// The List Multipart Uploads operation supports pagination. By default, this
// operation returns up to 1,000 multipart uploads in the response. You should
// always check the response for a marker at which to continue the list; if
// there are no more items the marker is null. To return a list of multipart
// uploads that begins at a specific upload, set the marker request parameter
// to the value you obtained from a previous List Multipart Upload request.
// You can also limit the number of uploads returned in the response by specifying
// the limit parameter in the request.
//
// Note the difference between this operation and listing parts (ListParts).
// The List Multipart Uploads operation lists all multipart uploads for a vault
// and does not require a multipart upload ID. The List Parts operation requires
// a multipart upload ID since parts are associated with a single upload.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and the underlying REST API, see Working with
// Archives in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html)
// and List Multipart Uploads  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-uploads.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the ListMultipartUploadsRequest method.
//    req := client.ListMultipartUploadsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) ListMultipartUploadsRequest(input *ListMultipartUploadsInput) ListMultipartUploadsRequest {
	op := &aws.Operation{
		Name:       opListMultipartUploads,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/multipart-uploads",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"marker"},
			OutputTokens:    []string{"Marker"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListMultipartUploadsInput{}
	}

	output := &ListMultipartUploadsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListMultipartUploadsRequest{Request: req, Input: input, Copy: c.ListMultipartUploadsRequest}
}

// Paginate pages iterates over the pages of a ListMultipartUploadsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListMultipartUploads operation.
//		req := client.ListMultipartUploadsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListMultipartUploadsRequest) Paginate(opts ...aws.Option) ListMultipartUploadsPager {
	return ListMultipartUploadsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListMultipartUploadsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListMultipartUploadsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListMultipartUploadsPager struct {
	aws.Pager
}

func (p *ListMultipartUploadsPager) CurrentPage() *ListMultipartUploadsOutput {
	return p.Pager.CurrentPage().(*ListMultipartUploadsOutput)
}

const opListParts = "ListParts"

// ListPartsRequest is a API request type for the ListParts API operation.
type ListPartsRequest struct {
	*aws.Request
	Input *ListPartsInput
	Copy  func(*ListPartsInput) ListPartsRequest
}

// Send marshals and sends the ListParts API request.
func (r ListPartsRequest) Send() (*ListPartsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListPartsOutput), nil
}

// ListPartsRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation lists the parts of an archive that have been uploaded in a
// specific multipart upload. You can make this request at any time during an
// in-progress multipart upload before you complete the upload (see CompleteMultipartUpload.
// List Parts returns an error for completed uploads. The list returned in the
// List Parts response is sorted by part range.
//
// The List Parts operation supports pagination. By default, this operation
// returns up to 1,000 uploaded parts in the response. You should always check
// the response for a marker at which to continue the list; if there are no
// more items the marker is null. To return a list of parts that begins at a
// specific part, set the marker request parameter to the value you obtained
// from a previous List Parts request. You can also limit the number of parts
// returned in the response by specifying the limit parameter in the request.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and the underlying REST API, see Working with
// Archives in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html)
// and List Parts (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-parts.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the ListPartsRequest method.
//    req := client.ListPartsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) ListPartsRequest(input *ListPartsInput) ListPartsRequest {
	op := &aws.Operation{
		Name:       opListParts,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"marker"},
			OutputTokens:    []string{"Marker"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListPartsInput{}
	}

	output := &ListPartsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListPartsRequest{Request: req, Input: input, Copy: c.ListPartsRequest}
}

// Paginate pages iterates over the pages of a ListPartsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListParts operation.
//		req := client.ListPartsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListPartsRequest) Paginate(opts ...aws.Option) ListPartsPager {
	return ListPartsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListPartsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListPartsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListPartsPager struct {
	aws.Pager
}

func (p *ListPartsPager) CurrentPage() *ListPartsOutput {
	return p.Pager.CurrentPage().(*ListPartsOutput)
}

const opListProvisionedCapacity = "ListProvisionedCapacity"

// ListProvisionedCapacityRequest is a API request type for the ListProvisionedCapacity API operation.
type ListProvisionedCapacityRequest struct {
	*aws.Request
	Input *ListProvisionedCapacityInput
	Copy  func(*ListProvisionedCapacityInput) ListProvisionedCapacityRequest
}

// Send marshals and sends the ListProvisionedCapacity API request.
func (r ListProvisionedCapacityRequest) Send() (*ListProvisionedCapacityOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListProvisionedCapacityOutput), nil
}

// ListProvisionedCapacityRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation lists the provisioned capacity units for the specified AWS
// account.
//
//    // Example sending a request using the ListProvisionedCapacityRequest method.
//    req := client.ListProvisionedCapacityRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) ListProvisionedCapacityRequest(input *ListProvisionedCapacityInput) ListProvisionedCapacityRequest {
	op := &aws.Operation{
		Name:       opListProvisionedCapacity,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/provisioned-capacity",
	}

	if input == nil {
		input = &ListProvisionedCapacityInput{}
	}

	output := &ListProvisionedCapacityOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListProvisionedCapacityRequest{Request: req, Input: input, Copy: c.ListProvisionedCapacityRequest}
}

const opListTagsForVault = "ListTagsForVault"

// ListTagsForVaultRequest is a API request type for the ListTagsForVault API operation.
type ListTagsForVaultRequest struct {
	*aws.Request
	Input *ListTagsForVaultInput
	Copy  func(*ListTagsForVaultInput) ListTagsForVaultRequest
}

// Send marshals and sends the ListTagsForVault API request.
func (r ListTagsForVaultRequest) Send() (*ListTagsForVaultOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTagsForVaultOutput), nil
}

// ListTagsForVaultRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation lists all the tags attached to a vault. The operation returns
// an empty map if there are no tags. For more information about tags, see Tagging
// Amazon Glacier Resources (http://docs.aws.amazon.com/amazonglacier/latest/dev/tagging.html).
//
//    // Example sending a request using the ListTagsForVaultRequest method.
//    req := client.ListTagsForVaultRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) ListTagsForVaultRequest(input *ListTagsForVaultInput) ListTagsForVaultRequest {
	op := &aws.Operation{
		Name:       opListTagsForVault,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/tags",
	}

	if input == nil {
		input = &ListTagsForVaultInput{}
	}

	output := &ListTagsForVaultOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTagsForVaultRequest{Request: req, Input: input, Copy: c.ListTagsForVaultRequest}
}

const opListVaults = "ListVaults"

// ListVaultsRequest is a API request type for the ListVaults API operation.
type ListVaultsRequest struct {
	*aws.Request
	Input *ListVaultsInput
	Copy  func(*ListVaultsInput) ListVaultsRequest
}

// Send marshals and sends the ListVaults API request.
func (r ListVaultsRequest) Send() (*ListVaultsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListVaultsOutput), nil
}

// ListVaultsRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation lists all vaults owned by the calling user's account. The
// list returned in the response is ASCII-sorted by vault name.
//
// By default, this operation returns up to 1,000 items. If there are more vaults
// to list, the response marker field contains the vault Amazon Resource Name
// (ARN) at which to continue the list with a new List Vaults request; otherwise,
// the marker field is null. To return a list of vaults that begins at a specific
// vault, set the marker request parameter to the vault ARN you obtained from
// a previous List Vaults request. You can also limit the number of vaults returned
// in the response by specifying the limit parameter in the request.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Retrieving Vault
// Metadata in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html)
// and List Vaults  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vaults-get.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the ListVaultsRequest method.
//    req := client.ListVaultsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) ListVaultsRequest(input *ListVaultsInput) ListVaultsRequest {
	op := &aws.Operation{
		Name:       opListVaults,
		HTTPMethod: "GET",
		HTTPPath:   "/{accountId}/vaults",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"marker"},
			OutputTokens:    []string{"Marker"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListVaultsInput{}
	}

	output := &ListVaultsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListVaultsRequest{Request: req, Input: input, Copy: c.ListVaultsRequest}
}

// Paginate pages iterates over the pages of a ListVaultsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListVaults operation.
//		req := client.ListVaultsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListVaultsRequest) Paginate(opts ...aws.Option) ListVaultsPager {
	return ListVaultsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListVaultsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListVaultsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListVaultsPager struct {
	aws.Pager
}

func (p *ListVaultsPager) CurrentPage() *ListVaultsOutput {
	return p.Pager.CurrentPage().(*ListVaultsOutput)
}

const opPurchaseProvisionedCapacity = "PurchaseProvisionedCapacity"

// PurchaseProvisionedCapacityRequest is a API request type for the PurchaseProvisionedCapacity API operation.
type PurchaseProvisionedCapacityRequest struct {
	*aws.Request
	Input *PurchaseProvisionedCapacityInput
	Copy  func(*PurchaseProvisionedCapacityInput) PurchaseProvisionedCapacityRequest
}

// Send marshals and sends the PurchaseProvisionedCapacity API request.
func (r PurchaseProvisionedCapacityRequest) Send() (*PurchaseProvisionedCapacityOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PurchaseProvisionedCapacityOutput), nil
}

// PurchaseProvisionedCapacityRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation purchases a provisioned capacity unit for an AWS account.
//
//    // Example sending a request using the PurchaseProvisionedCapacityRequest method.
//    req := client.PurchaseProvisionedCapacityRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) PurchaseProvisionedCapacityRequest(input *PurchaseProvisionedCapacityInput) PurchaseProvisionedCapacityRequest {
	op := &aws.Operation{
		Name:       opPurchaseProvisionedCapacity,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/provisioned-capacity",
	}

	if input == nil {
		input = &PurchaseProvisionedCapacityInput{}
	}

	output := &PurchaseProvisionedCapacityOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PurchaseProvisionedCapacityRequest{Request: req, Input: input, Copy: c.PurchaseProvisionedCapacityRequest}
}

const opRemoveTagsFromVault = "RemoveTagsFromVault"

// RemoveTagsFromVaultRequest is a API request type for the RemoveTagsFromVault API operation.
type RemoveTagsFromVaultRequest struct {
	*aws.Request
	Input *RemoveTagsFromVaultInput
	Copy  func(*RemoveTagsFromVaultInput) RemoveTagsFromVaultRequest
}

// Send marshals and sends the RemoveTagsFromVault API request.
func (r RemoveTagsFromVaultRequest) Send() (*RemoveTagsFromVaultOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RemoveTagsFromVaultOutput), nil
}

// RemoveTagsFromVaultRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation removes one or more tags from the set of tags attached to
// a vault. For more information about tags, see Tagging Amazon Glacier Resources
// (http://docs.aws.amazon.com/amazonglacier/latest/dev/tagging.html). This
// operation is idempotent. The operation will be successful, even if there
// are no tags attached to the vault.
//
//    // Example sending a request using the RemoveTagsFromVaultRequest method.
//    req := client.RemoveTagsFromVaultRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) RemoveTagsFromVaultRequest(input *RemoveTagsFromVaultInput) RemoveTagsFromVaultRequest {
	op := &aws.Operation{
		Name:       opRemoveTagsFromVault,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/tags?operation=remove",
	}

	if input == nil {
		input = &RemoveTagsFromVaultInput{}
	}

	output := &RemoveTagsFromVaultOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return RemoveTagsFromVaultRequest{Request: req, Input: input, Copy: c.RemoveTagsFromVaultRequest}
}

const opSetDataRetrievalPolicy = "SetDataRetrievalPolicy"

// SetDataRetrievalPolicyRequest is a API request type for the SetDataRetrievalPolicy API operation.
type SetDataRetrievalPolicyRequest struct {
	*aws.Request
	Input *SetDataRetrievalPolicyInput
	Copy  func(*SetDataRetrievalPolicyInput) SetDataRetrievalPolicyRequest
}

// Send marshals and sends the SetDataRetrievalPolicy API request.
func (r SetDataRetrievalPolicyRequest) Send() (*SetDataRetrievalPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SetDataRetrievalPolicyOutput), nil
}

// SetDataRetrievalPolicyRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation sets and then enacts a data retrieval policy in the region
// specified in the PUT request. You can set one policy per region for an AWS
// account. The policy is enacted within a few minutes of a successful PUT operation.
//
// The set policy operation does not affect retrieval jobs that were in progress
// before the policy was enacted. For more information about data retrieval
// policies, see Amazon Glacier Data Retrieval Policies (http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html).
//
//    // Example sending a request using the SetDataRetrievalPolicyRequest method.
//    req := client.SetDataRetrievalPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) SetDataRetrievalPolicyRequest(input *SetDataRetrievalPolicyInput) SetDataRetrievalPolicyRequest {
	op := &aws.Operation{
		Name:       opSetDataRetrievalPolicy,
		HTTPMethod: "PUT",
		HTTPPath:   "/{accountId}/policies/data-retrieval",
	}

	if input == nil {
		input = &SetDataRetrievalPolicyInput{}
	}

	output := &SetDataRetrievalPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return SetDataRetrievalPolicyRequest{Request: req, Input: input, Copy: c.SetDataRetrievalPolicyRequest}
}

const opSetVaultAccessPolicy = "SetVaultAccessPolicy"

// SetVaultAccessPolicyRequest is a API request type for the SetVaultAccessPolicy API operation.
type SetVaultAccessPolicyRequest struct {
	*aws.Request
	Input *SetVaultAccessPolicyInput
	Copy  func(*SetVaultAccessPolicyInput) SetVaultAccessPolicyRequest
}

// Send marshals and sends the SetVaultAccessPolicy API request.
func (r SetVaultAccessPolicyRequest) Send() (*SetVaultAccessPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SetVaultAccessPolicyOutput), nil
}

// SetVaultAccessPolicyRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation configures an access policy for a vault and will overwrite
// an existing policy. To configure a vault access policy, send a PUT request
// to the access-policy subresource of the vault. An access policy is specific
// to a vault and is also called a vault subresource. You can set one access
// policy per vault and the policy can be up to 20 KB in size. For more information
// about vault access policies, see Amazon Glacier Access Control with Vault
// Access Policies (http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html).
//
//    // Example sending a request using the SetVaultAccessPolicyRequest method.
//    req := client.SetVaultAccessPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) SetVaultAccessPolicyRequest(input *SetVaultAccessPolicyInput) SetVaultAccessPolicyRequest {
	op := &aws.Operation{
		Name:       opSetVaultAccessPolicy,
		HTTPMethod: "PUT",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/access-policy",
	}

	if input == nil {
		input = &SetVaultAccessPolicyInput{}
	}

	output := &SetVaultAccessPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return SetVaultAccessPolicyRequest{Request: req, Input: input, Copy: c.SetVaultAccessPolicyRequest}
}

const opSetVaultNotifications = "SetVaultNotifications"

// SetVaultNotificationsRequest is a API request type for the SetVaultNotifications API operation.
type SetVaultNotificationsRequest struct {
	*aws.Request
	Input *SetVaultNotificationsInput
	Copy  func(*SetVaultNotificationsInput) SetVaultNotificationsRequest
}

// Send marshals and sends the SetVaultNotifications API request.
func (r SetVaultNotificationsRequest) Send() (*SetVaultNotificationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SetVaultNotificationsOutput), nil
}

// SetVaultNotificationsRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation configures notifications that will be sent when specific events
// happen to a vault. By default, you don't get any notifications.
//
// To configure vault notifications, send a PUT request to the notification-configuration
// subresource of the vault. The request should include a JSON document that
// provides an Amazon SNS topic and specific events for which you want Amazon
// Glacier to send notifications to the topic.
//
// Amazon SNS topics must grant permission to the vault to be allowed to publish
// notifications to the topic. You can configure a vault to publish a notification
// for the following vault events:
//
//    * ArchiveRetrievalCompleted This event occurs when a job that was initiated
//    for an archive retrieval is completed (InitiateJob). The status of the
//    completed job can be "Succeeded" or "Failed". The notification sent to
//    the SNS topic is the same output as returned from DescribeJob.
//
//    * InventoryRetrievalCompleted This event occurs when a job that was initiated
//    for an inventory retrieval is completed (InitiateJob). The status of the
//    completed job can be "Succeeded" or "Failed". The notification sent to
//    the SNS topic is the same output as returned from DescribeJob.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Configuring Vault
// Notifications in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html)
// and Set Vault Notification Configuration  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-put.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the SetVaultNotificationsRequest method.
//    req := client.SetVaultNotificationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) SetVaultNotificationsRequest(input *SetVaultNotificationsInput) SetVaultNotificationsRequest {
	op := &aws.Operation{
		Name:       opSetVaultNotifications,
		HTTPMethod: "PUT",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/notification-configuration",
	}

	if input == nil {
		input = &SetVaultNotificationsInput{}
	}

	output := &SetVaultNotificationsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return SetVaultNotificationsRequest{Request: req, Input: input, Copy: c.SetVaultNotificationsRequest}
}

const opUploadArchive = "UploadArchive"

// UploadArchiveRequest is a API request type for the UploadArchive API operation.
type UploadArchiveRequest struct {
	*aws.Request
	Input *UploadArchiveInput
	Copy  func(*UploadArchiveInput) UploadArchiveRequest
}

// Send marshals and sends the UploadArchive API request.
func (r UploadArchiveRequest) Send() (*UploadArchiveOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UploadArchiveOutput), nil
}

// UploadArchiveRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation adds an archive to a vault. This is a synchronous operation,
// and for a successful upload, your data is durably persisted. Amazon Glacier
// returns the archive ID in the x-amz-archive-id header of the response.
//
// You must use the archive ID to access your data in Amazon Glacier. After
// you upload an archive, you should save the archive ID returned so that you
// can retrieve or delete the archive later. Besides saving the archive ID,
// you can also index it and give it a friendly name to allow for better searching.
// You can also use the optional archive description field to specify how the
// archive is referred to in an external index of archives, such as you might
// create in Amazon DynamoDB. You can also get the vault inventory to obtain
// a list of archive IDs in a vault. For more information, see InitiateJob.
//
// You must provide a SHA256 tree hash of the data you are uploading. For information
// about computing a SHA256 tree hash, see Computing Checksums (http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html).
//
// You can optionally specify an archive description of up to 1,024 printable
// ASCII characters. You can get the archive description when you either retrieve
// the archive or get the vault inventory. For more information, see InitiateJob.
// Amazon Glacier does not interpret the description in any way. An archive
// description does not need to be unique. You cannot use the description to
// retrieve or sort the archive list.
//
// Archives are immutable. After you upload an archive, you cannot edit the
// archive or its description.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Uploading an Archive
// in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-an-archive.html)
// and Upload Archive (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the UploadArchiveRequest method.
//    req := client.UploadArchiveRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) UploadArchiveRequest(input *UploadArchiveInput) UploadArchiveRequest {
	op := &aws.Operation{
		Name:       opUploadArchive,
		HTTPMethod: "POST",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/archives",
	}

	if input == nil {
		input = &UploadArchiveInput{}
	}

	output := &UploadArchiveOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UploadArchiveRequest{Request: req, Input: input, Copy: c.UploadArchiveRequest}
}

const opUploadMultipartPart = "UploadMultipartPart"

// UploadMultipartPartRequest is a API request type for the UploadMultipartPart API operation.
type UploadMultipartPartRequest struct {
	*aws.Request
	Input *UploadMultipartPartInput
	Copy  func(*UploadMultipartPartInput) UploadMultipartPartRequest
}

// Send marshals and sends the UploadMultipartPart API request.
func (r UploadMultipartPartRequest) Send() (*UploadMultipartPartOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UploadMultipartPartOutput), nil
}

// UploadMultipartPartRequest returns a request value for making API operation for
// Amazon Glacier.
//
// This operation uploads a part of an archive. You can upload archive parts
// in any order. You can also upload them in parallel. You can upload up to
// 10,000 parts for a multipart upload.
//
// Amazon Glacier rejects your upload part request if any of the following conditions
// is true:
//
//    * SHA256 tree hash does not matchTo ensure that part data is not corrupted
//    in transmission, you compute a SHA256 tree hash of the part and include
//    it in your request. Upon receiving the part data, Amazon Glacier also
//    computes a SHA256 tree hash. If these hash values don't match, the operation
//    fails. For information about computing a SHA256 tree hash, see Computing
//    Checksums (http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html).
//
//    * Part size does not matchThe size of each part except the last must match
//    the size specified in the corresponding InitiateMultipartUpload request.
//    The size of the last part must be the same size as, or smaller than, the
//    specified size.
//
// If you upload a part whose size is smaller than the part size you specified
//    in your initiate multipart upload request and that part is not the last
//    part, then the upload part request will succeed. However, the subsequent
//    Complete Multipart Upload request will fail.
//
//    * Range does not alignThe byte range value in the request does not align
//    with the part size specified in the corresponding initiate request. For
//    example, if you specify a part size of 4194304 bytes (4 MB), then 0 to
//    4194303 bytes (4 MB - 1) and 4194304 (4 MB) to 8388607 (8 MB - 1) are
//    valid part ranges. However, if you set a range value of 2 MB to 6 MB,
//    the range does not align with the part size and the upload will fail.
//
//
// This operation is idempotent. If you upload the same part multiple times,
// the data included in the most recent request overwrites the previously uploaded
// data.
//
// An AWS account has full permission to perform all operations (actions). However,
// AWS Identity and Access Management (IAM) users don't have any permissions
// by default. You must grant them explicit permission to perform specific actions.
// For more information, see Access Control Using AWS Identity and Access Management
// (IAM) (http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html).
//
// For conceptual information and underlying REST API, see Uploading Large Archives
// in Parts (Multipart Upload) (http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html)
// and Upload Part  (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-upload-part.html)
// in the Amazon Glacier Developer Guide.
//
//    // Example sending a request using the UploadMultipartPartRequest method.
//    req := client.UploadMultipartPartRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *Glacier) UploadMultipartPartRequest(input *UploadMultipartPartInput) UploadMultipartPartRequest {
	op := &aws.Operation{
		Name:       opUploadMultipartPart,
		HTTPMethod: "PUT",
		HTTPPath:   "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}",
	}

	if input == nil {
		input = &UploadMultipartPartInput{}
	}

	output := &UploadMultipartPartOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UploadMultipartPartRequest{Request: req, Input: input, Copy: c.UploadMultipartPartRequest}
}

// Provides options to abort a multipart upload identified by the upload ID.
//
// For information about the underlying REST API, see Abort Multipart Upload
// (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html).
// For conceptual information, see Working with Archives in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html).
type AbortMultipartUploadInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The upload ID of the multipart upload to delete.
	//
	// UploadId is a required field
	UploadId *string `location:"uri" locationName:"uploadId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s AbortMultipartUploadInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AbortMultipartUploadInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AbortMultipartUploadInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AbortMultipartUploadInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.UploadId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UploadId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AbortMultipartUploadInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UploadId != nil {
		v := *s.UploadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "uploadId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AbortMultipartUploadOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AbortMultipartUploadOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AbortMultipartUploadOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AbortMultipartUploadOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AbortMultipartUploadOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input values for AbortVaultLock.
type AbortVaultLockInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID. This value must match the AWS
	// account ID associated with the credentials used to sign the request. You
	// can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you specify your account ID, do
	// not include any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s AbortVaultLockInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AbortVaultLockInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AbortVaultLockInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AbortVaultLockInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AbortVaultLockInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AbortVaultLockOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AbortVaultLockOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AbortVaultLockOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AbortVaultLockOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AbortVaultLockOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input values for AddTagsToVault.
type AddTagsToVaultInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The tags to add to the vault. Each tag is composed of a key and a value.
	// The value can be an empty string.
	Tags map[string]string `type:"map"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s AddTagsToVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddTagsToVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AddTagsToVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AddTagsToVaultInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddTagsToVaultInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AddTagsToVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AddTagsToVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddTagsToVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AddTagsToVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddTagsToVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Contains information about the comma-separated value (CSV) file to select
// from.
type CSVInput struct {
	_ struct{} `type:"structure"`

	// A single character used to indicate that a row should be ignored when the
	// character is present at the start of that row.
	Comments *string `type:"string"`

	// A value used to separate individual fields from each other within a record.
	FieldDelimiter *string `type:"string"`

	// Describes the first line of input. Valid values are None, Ignore, and Use.
	FileHeaderInfo FileHeaderInfo `type:"string" enum:"true"`

	// A value used as an escape character where the field delimiter is part of
	// the value.
	QuoteCharacter *string `type:"string"`

	// A single character used for escaping the quotation-mark character inside
	// an already escaped value.
	QuoteEscapeCharacter *string `type:"string"`

	// A value used to separate individual records from each other.
	RecordDelimiter *string `type:"string"`
}

// String returns the string representation
func (s CSVInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CSVInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CSVInput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Comments != nil {
		v := *s.Comments

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Comments", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FieldDelimiter != nil {
		v := *s.FieldDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FieldDelimiter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.FileHeaderInfo) > 0 {
		v := s.FileHeaderInfo

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FileHeaderInfo", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.QuoteCharacter != nil {
		v := *s.QuoteCharacter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteCharacter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.QuoteEscapeCharacter != nil {
		v := *s.QuoteEscapeCharacter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteEscapeCharacter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecordDelimiter != nil {
		v := *s.RecordDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecordDelimiter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains information about the comma-separated value (CSV) file that the
// job results are stored in.
type CSVOutput struct {
	_ struct{} `type:"structure"`

	// A value used to separate individual fields from each other within a record.
	FieldDelimiter *string `type:"string"`

	// A value used as an escape character where the field delimiter is part of
	// the value.
	QuoteCharacter *string `type:"string"`

	// A single character used for escaping the quotation-mark character inside
	// an already escaped value.
	QuoteEscapeCharacter *string `type:"string"`

	// A value that indicates whether all output fields should be contained within
	// quotation marks.
	QuoteFields QuoteFields `type:"string" enum:"true"`

	// A value used to separate individual records from each other.
	RecordDelimiter *string `type:"string"`
}

// String returns the string representation
func (s CSVOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CSVOutput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CSVOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.FieldDelimiter != nil {
		v := *s.FieldDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FieldDelimiter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.QuoteCharacter != nil {
		v := *s.QuoteCharacter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteCharacter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.QuoteEscapeCharacter != nil {
		v := *s.QuoteEscapeCharacter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteEscapeCharacter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.QuoteFields) > 0 {
		v := s.QuoteFields

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "QuoteFields", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RecordDelimiter != nil {
		v := *s.RecordDelimiter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecordDelimiter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options to complete a multipart upload operation. This informs Amazon
// Glacier that all the archive parts have been uploaded and Amazon Glacier
// can now assemble the archive from the uploaded parts. After assembling and
// saving the archive to the vault, Amazon Glacier returns the URI path of the
// newly created archive resource.
type CompleteMultipartUploadInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The total size, in bytes, of the entire archive. This value should be the
	// sum of all the sizes of the individual parts that you uploaded.
	ArchiveSize *string `location:"header" locationName:"x-amz-archive-size" type:"string"`

	// The SHA256 tree hash of the entire archive. It is the tree hash of SHA256
	// tree hash of the individual parts. If the value you specify in the request
	// does not match the SHA256 tree hash of the final assembled archive as computed
	// by Amazon Glacier, Amazon Glacier returns an error and the request fails.
	Checksum *string `location:"header" locationName:"x-amz-sha256-tree-hash" type:"string"`

	// The upload ID of the multipart upload.
	//
	// UploadId is a required field
	UploadId *string `location:"uri" locationName:"uploadId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s CompleteMultipartUploadInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CompleteMultipartUploadInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CompleteMultipartUploadInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CompleteMultipartUploadInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.UploadId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UploadId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CompleteMultipartUploadInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ArchiveSize != nil {
		v := *s.ArchiveSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-archive-size", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-sha256-tree-hash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UploadId != nil {
		v := *s.UploadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "uploadId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input values for CompleteVaultLock.
type CompleteVaultLockInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID. This value must match the AWS
	// account ID associated with the credentials used to sign the request. You
	// can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you specify your account ID, do
	// not include any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The lockId value is the lock ID obtained from a InitiateVaultLock request.
	//
	// LockId is a required field
	LockId *string `location:"uri" locationName:"lockId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s CompleteVaultLockInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CompleteVaultLockInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CompleteVaultLockInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CompleteVaultLockInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.LockId == nil {
		invalidParams.Add(aws.NewErrParamRequired("LockId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CompleteVaultLockInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LockId != nil {
		v := *s.LockId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "lockId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CompleteVaultLockOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CompleteVaultLockOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CompleteVaultLockOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CompleteVaultLockOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CompleteVaultLockOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Provides options to create a vault.
type CreateVaultInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID. This value must match the AWS
	// account ID associated with the credentials used to sign the request. You
	// can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you specify your account ID, do
	// not include any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateVaultInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateVaultInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type CreateVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The URI of the vault that was created.
	Location *string `location:"header" locationName:"Location" type:"string"`
}

// String returns the string representation
func (s CreateVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Data retrieval policy.
type DataRetrievalPolicy struct {
	_ struct{} `type:"structure"`

	// The policy rule. Although this is a list type, currently there must be only
	// one rule, which contains a Strategy field and optionally a BytesPerHour field.
	Rules []DataRetrievalRule `type:"list"`
}

// String returns the string representation
func (s DataRetrievalPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DataRetrievalPolicy) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DataRetrievalPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Rules) > 0 {
		v := s.Rules

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Rules", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Data retrieval policy rule.
type DataRetrievalRule struct {
	_ struct{} `type:"structure"`

	// The maximum number of bytes that can be retrieved in an hour.
	//
	// This field is required only if the value of the Strategy field is BytesPerHour.
	// Your PUT operation will be rejected if the Strategy field is not set to BytesPerHour
	// and you set this field.
	BytesPerHour *int64 `type:"long"`

	// The type of data retrieval policy to set.
	//
	// Valid values: BytesPerHour|FreeTier|None
	Strategy *string `type:"string"`
}

// String returns the string representation
func (s DataRetrievalRule) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DataRetrievalRule) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DataRetrievalRule) MarshalFields(e protocol.FieldEncoder) error {
	if s.BytesPerHour != nil {
		v := *s.BytesPerHour

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BytesPerHour", protocol.Int64Value(v), metadata)
	}
	if s.Strategy != nil {
		v := *s.Strategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Strategy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for deleting an archive from an Amazon Glacier vault.
type DeleteArchiveInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The ID of the archive to delete.
	//
	// ArchiveId is a required field
	ArchiveId *string `location:"uri" locationName:"archiveId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteArchiveInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteArchiveInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteArchiveInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteArchiveInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.ArchiveId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ArchiveId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteArchiveInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ArchiveId != nil {
		v := *s.ArchiveId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "archiveId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteArchiveOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteArchiveOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteArchiveOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteArchiveOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteArchiveOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// DeleteVaultAccessPolicy input.
type DeleteVaultAccessPolicyInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteVaultAccessPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVaultAccessPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteVaultAccessPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteVaultAccessPolicyInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVaultAccessPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteVaultAccessPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteVaultAccessPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVaultAccessPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteVaultAccessPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVaultAccessPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Provides options for deleting a vault from Amazon Glacier.
type DeleteVaultInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteVaultInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVaultInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for deleting a vault notification configuration from an
// Amazon Glacier vault.
type DeleteVaultNotificationsInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteVaultNotificationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVaultNotificationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteVaultNotificationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteVaultNotificationsInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVaultNotificationsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteVaultNotificationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteVaultNotificationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVaultNotificationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteVaultNotificationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVaultNotificationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Provides options for retrieving a job description.
type DescribeJobInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The ID of the job to describe.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeJobInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the description of an Amazon Glacier job.
type DescribeJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The job type. This value is either ArchiveRetrieval, InventoryRetrieval,
	// or Select.
	Action ActionCode `type:"string" enum:"true"`

	// The archive ID requested for a select job or archive retrieval. Otherwise,
	// this field is null.
	ArchiveId *string `type:"string"`

	// The SHA256 tree hash of the entire archive for an archive retrieval. For
	// inventory retrieval or select jobs, this field is null.
	ArchiveSHA256TreeHash *string `type:"string"`

	// For an archive retrieval job, this value is the size in bytes of the archive
	// being requested for download. For an inventory retrieval or select job, this
	// value is null.
	ArchiveSizeInBytes *int64 `type:"long"`

	// The job status. When a job is completed, you get the job's output using Get
	// Job Output (GET output).
	Completed *bool `type:"boolean"`

	// The UTC time that the job request completed. While the job is in progress,
	// the value is null.
	CompletionDate *string `type:"string"`

	// The UTC date when the job was created. This value is a string representation
	// of ISO 8601 date format, for example "2012-03-20T17:03:43.221Z".
	CreationDate *string `type:"string"`

	// Parameters used for range inventory retrieval.
	InventoryRetrievalParameters *InventoryRetrievalJobDescription `type:"structure"`

	// For an inventory retrieval job, this value is the size in bytes of the inventory
	// requested for download. For an archive retrieval or select job, this value
	// is null.
	InventorySizeInBytes *int64 `type:"long"`

	// The job description provided when initiating the job.
	JobDescription *string `type:"string"`

	// An opaque string that identifies an Amazon Glacier job.
	JobId *string `type:"string"`

	// Contains the job output location.
	JobOutputPath *string `type:"string"`

	// Contains the location where the data from the select job is stored.
	OutputLocation *OutputLocation `type:"structure"`

	// The retrieved byte range for archive retrieval jobs in the form StartByteValue-EndByteValue.
	// If no range was specified in the archive retrieval, then the whole archive
	// is retrieved. In this case, StartByteValue equals 0 and EndByteValue equals
	// the size of the archive minus 1. For inventory retrieval or select jobs,
	// this field is null.
	RetrievalByteRange *string `type:"string"`

	// For an archive retrieval job, this value is the checksum of the archive.
	// Otherwise, this value is null.
	//
	// The SHA256 tree hash value for the requested range of an archive. If the
	// InitiateJob request for an archive specified a tree-hash aligned range, then
	// this field returns a value.
	//
	// If the whole archive is retrieved, this value is the same as the ArchiveSHA256TreeHash
	// value.
	//
	// This field is null for the following:
	//
	//    * Archive retrieval jobs that specify a range that is not tree-hash aligned
	//
	//    * Archival jobs that specify a range that is equal to the whole archive,
	//    when the job status is InProgress
	//
	//    * Inventory jobs
	//
	//    * Select jobs
	SHA256TreeHash *string `type:"string"`

	// An Amazon SNS topic that receives notification.
	SNSTopic *string `type:"string"`

	// Contains the parameters used for a select.
	SelectParameters *SelectParameters `type:"structure"`

	// The status code can be InProgress, Succeeded, or Failed, and indicates the
	// status of the job.
	StatusCode StatusCode `type:"string" enum:"true"`

	// A friendly message that describes the job status.
	StatusMessage *string `type:"string"`

	// The tier to use for a select or an archive retrieval. Valid values are Expedited,
	// Standard, or Bulk. Standard is the default.
	Tier *string `type:"string"`

	// The Amazon Resource Name (ARN) of the vault from which an archive retrieval
	// was requested.
	VaultARN *string `type:"string"`
}

// String returns the string representation
func (s DescribeJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Action) > 0 {
		v := s.Action

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Action", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ArchiveId != nil {
		v := *s.ArchiveId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ArchiveId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ArchiveSHA256TreeHash != nil {
		v := *s.ArchiveSHA256TreeHash

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ArchiveSHA256TreeHash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ArchiveSizeInBytes != nil {
		v := *s.ArchiveSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ArchiveSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.Completed != nil {
		v := *s.Completed

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Completed", protocol.BoolValue(v), metadata)
	}
	if s.CompletionDate != nil {
		v := *s.CompletionDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CompletionDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InventoryRetrievalParameters != nil {
		v := s.InventoryRetrievalParameters

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "InventoryRetrievalParameters", v, metadata)
	}
	if s.InventorySizeInBytes != nil {
		v := *s.InventorySizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InventorySizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.JobDescription != nil {
		v := *s.JobDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "JobDescription", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "JobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobOutputPath != nil {
		v := *s.JobOutputPath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "JobOutputPath", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OutputLocation != nil {
		v := s.OutputLocation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "OutputLocation", v, metadata)
	}
	if s.RetrievalByteRange != nil {
		v := *s.RetrievalByteRange

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RetrievalByteRange", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SHA256TreeHash != nil {
		v := *s.SHA256TreeHash

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SHA256TreeHash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SNSTopic != nil {
		v := *s.SNSTopic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SNSTopic", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SelectParameters != nil {
		v := s.SelectParameters

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SelectParameters", v, metadata)
	}
	if len(s.StatusCode) > 0 {
		v := s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StatusCode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusMessage != nil {
		v := *s.StatusMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StatusMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Tier != nil {
		v := *s.Tier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Tier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultARN != nil {
		v := *s.VaultARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VaultARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for retrieving metadata for a specific vault in Amazon Glacier.
type DescribeVaultInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeVaultInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeVaultInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type DescribeVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Universal Coordinated Time (UTC) date when the vault was created. This
	// value should be a string in the ISO 8601 date format, for example 2012-03-20T17:03:43.221Z.
	CreationDate *string `type:"string"`

	// The Universal Coordinated Time (UTC) date when Amazon Glacier completed the
	// last vault inventory. This value should be a string in the ISO 8601 date
	// format, for example 2012-03-20T17:03:43.221Z.
	LastInventoryDate *string `type:"string"`

	// The number of archives in the vault as of the last inventory date. This field
	// will return null if an inventory has not yet run on the vault, for example
	// if you just created the vault.
	NumberOfArchives *int64 `type:"long"`

	// Total size, in bytes, of the archives in the vault as of the last inventory
	// date. This field will return null if an inventory has not yet run on the
	// vault, for example if you just created the vault.
	SizeInBytes *int64 `type:"long"`

	// The Amazon Resource Name (ARN) of the vault.
	VaultARN *string `type:"string"`

	// The name of the vault.
	VaultName *string `type:"string"`
}

// String returns the string representation
func (s DescribeVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastInventoryDate != nil {
		v := *s.LastInventoryDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastInventoryDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NumberOfArchives != nil {
		v := *s.NumberOfArchives

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberOfArchives", protocol.Int64Value(v), metadata)
	}
	if s.SizeInBytes != nil {
		v := *s.SizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.VaultARN != nil {
		v := *s.VaultARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VaultARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains information about the encryption used to store the job results in
// Amazon S3.
type Encryption struct {
	_ struct{} `type:"structure"`

	// The server-side encryption algorithm used when storing job results in Amazon
	// S3, for example AES256 or aws:kms.
	EncryptionType EncryptionType `type:"string" enum:"true"`

	// Optional. If the encryption type is aws:kms, you can use this value to specify
	// the encryption context for the job results.
	KMSContext *string `type:"string"`

	// The AWS KMS key ID to use for object encryption. All GET and PUT requests
	// for an object protected by AWS KMS fail if not made by using Secure Sockets
	// Layer (SSL) or Signature Version 4.
	KMSKeyId *string `type:"string"`
}

// String returns the string representation
func (s Encryption) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Encryption) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Encryption) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.EncryptionType) > 0 {
		v := s.EncryptionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EncryptionType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.KMSContext != nil {
		v := *s.KMSContext

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KMSContext", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KMSKeyId != nil {
		v := *s.KMSKeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KMSKeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Input for GetDataRetrievalPolicy.
type GetDataRetrievalPolicyInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID. This value must match the AWS
	// account ID associated with the credentials used to sign the request. You
	// can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you specify your account ID, do
	// not include any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDataRetrievalPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDataRetrievalPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDataRetrievalPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDataRetrievalPolicyInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDataRetrievalPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to the GetDataRetrievalPolicy request.
type GetDataRetrievalPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Contains the returned data retrieval policy in JSON format.
	Policy *DataRetrievalPolicy `type:"structure"`
}

// String returns the string representation
func (s GetDataRetrievalPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDataRetrievalPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDataRetrievalPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDataRetrievalPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Policy != nil {
		v := s.Policy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Policy", v, metadata)
	}
	return nil
}

// Provides options for downloading output of an Amazon Glacier job.
type GetJobOutputInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The job ID whose data is downloaded.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" type:"string" required:"true"`

	// The range of bytes to retrieve from the output. For example, if you want
	// to download the first 1,048,576 bytes, specify the range as bytes=0-1048575.
	// By default, this operation downloads the entire output.
	//
	// If the job output is large, then you can use a range to retrieve a portion
	// of the output. This allows you to download the entire output in smaller chunks
	// of bytes. For example, suppose you have 1 GB of job output you want to download
	// and you decide to download 128 MB chunks of data at a time, which is a total
	// of eight Get Job Output requests. You use the following process to download
	// the job output:
	//
	// Download a 128 MB chunk of output by specifying the appropriate byte range.
	// Verify that all 128 MB of data was received.
	//
	// Along with the data, the response includes a SHA256 tree hash of the payload.
	// You compute the checksum of the payload on the client and compare it with
	// the checksum you received in the response to ensure you received all the
	// expected data.
	//
	// Repeat steps 1 and 2 for all the eight 128 MB chunks of output data, each
	// time specifying the appropriate byte range.
	//
	// After downloading all the parts of the job output, you have a list of eight
	// checksum values. Compute the tree hash of these values to find the checksum
	// of the entire output. Using the DescribeJob API, obtain job information of
	// the job that provided you the output. The response includes the checksum
	// of the entire archive stored in Amazon Glacier. You compare this value with
	// the checksum you computed to ensure you have downloaded the entire archive
	// content with no errors.
	Range *string `location:"header" locationName:"Range" type:"string"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetJobOutputInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetJobOutputInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetJobOutputInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetJobOutputInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetJobOutputInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Range != nil {
		v := *s.Range

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Range", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type GetJobOutputOutput struct {
	_ struct{} `type:"structure" payload:"Body"`

	responseMetadata aws.Response

	// Indicates the range units accepted. For more information, see RFC2616 (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html).
	AcceptRanges *string `location:"header" locationName:"Accept-Ranges" type:"string"`

	// The description of an archive.
	ArchiveDescription *string `location:"header" locationName:"x-amz-archive-description" type:"string"`

	// The job data, either archive data or inventory data.
	Body io.ReadCloser `locationName:"body" type:"blob"`

	// The checksum of the data in the response. This header is returned only when
	// retrieving the output for an archive retrieval job. Furthermore, this header
	// appears only under the following conditions:
	//
	//    * You get the entire range of the archive.
	//
	//    * You request a range to return of the archive that starts and ends on
	//    a multiple of 1 MB. For example, if you have an 3.1 MB archive and you
	//    specify a range to return that starts at 1 MB and ends at 2 MB, then the
	//    x-amz-sha256-tree-hash is returned as a response header.
	//
	//    * You request a range of the archive to return that starts on a multiple
	//    of 1 MB and goes to the end of the archive. For example, if you have a
	//    3.1 MB archive and you specify a range that starts at 2 MB and ends at
	//    3.1 MB (the end of the archive), then the x-amz-sha256-tree-hash is returned
	//    as a response header.
	Checksum *string `location:"header" locationName:"x-amz-sha256-tree-hash" type:"string"`

	// The range of bytes returned by Amazon Glacier. If only partial output is
	// downloaded, the response provides the range of bytes Amazon Glacier returned.
	// For example, bytes 0-1048575/8388608 returns the first 1 MB from 8 MB.
	ContentRange *string `location:"header" locationName:"Content-Range" type:"string"`

	// The Content-Type depends on whether the job output is an archive or a vault
	// inventory. For archive data, the Content-Type is application/octet-stream.
	// For vault inventory, if you requested CSV format when you initiated the job,
	// the Content-Type is text/csv. Otherwise, by default, vault inventory is returned
	// as JSON, and the Content-Type is application/json.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The HTTP response code for a job output request. The value depends on whether
	// a range was specified in the request.
	Status *int64 `location:"statusCode" locationName:"status" type:"integer"`
}

// String returns the string representation
func (s GetJobOutputOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetJobOutputOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetJobOutputOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetJobOutputOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AcceptRanges != nil {
		v := *s.AcceptRanges

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Accept-Ranges", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ArchiveDescription != nil {
		v := *s.ArchiveDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-archive-description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-sha256-tree-hash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ContentRange != nil {
		v := *s.ContentRange

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Content-Range", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	// Skipping Body Output type's body not valid.
	// ignoring invalid encode state, StatusCode. Status
	return nil
}

// Input for GetVaultAccessPolicy.
type GetVaultAccessPolicyInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetVaultAccessPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVaultAccessPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetVaultAccessPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetVaultAccessPolicyInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVaultAccessPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Output for GetVaultAccessPolicy.
type GetVaultAccessPolicyOutput struct {
	_ struct{} `type:"structure" payload:"Policy"`

	responseMetadata aws.Response

	// Contains the returned vault access policy as a JSON string.
	Policy *VaultAccessPolicy `locationName:"policy" type:"structure"`
}

// String returns the string representation
func (s GetVaultAccessPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVaultAccessPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetVaultAccessPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVaultAccessPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Policy != nil {
		v := s.Policy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "policy", v, metadata)
	}
	return nil
}

// The input values for GetVaultLock.
type GetVaultLockInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetVaultLockInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVaultLockInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetVaultLockInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetVaultLockInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVaultLockInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type GetVaultLockOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The UTC date and time at which the vault lock was put into the InProgress
	// state.
	CreationDate *string `type:"string"`

	// The UTC date and time at which the lock ID expires. This value can be null
	// if the vault lock is in a Locked state.
	ExpirationDate *string `type:"string"`

	// The vault lock policy as a JSON string, which uses "\" as an escape character.
	Policy *string `type:"string"`

	// The state of the vault lock. InProgress or Locked.
	State *string `type:"string"`
}

// String returns the string representation
func (s GetVaultLockOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVaultLockOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetVaultLockOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVaultLockOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ExpirationDate != nil {
		v := *s.ExpirationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpirationDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Policy != nil {
		v := *s.Policy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.State != nil {
		v := *s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for retrieving the notification configuration set on an
// Amazon Glacier vault.
type GetVaultNotificationsInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetVaultNotificationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVaultNotificationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetVaultNotificationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetVaultNotificationsInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVaultNotificationsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type GetVaultNotificationsOutput struct {
	_ struct{} `type:"structure" payload:"VaultNotificationConfig"`

	responseMetadata aws.Response

	// Returns the notification configuration set on the vault.
	VaultNotificationConfig *VaultNotificationConfig `locationName:"vaultNotificationConfig" type:"structure"`
}

// String returns the string representation
func (s GetVaultNotificationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVaultNotificationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetVaultNotificationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVaultNotificationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.VaultNotificationConfig != nil {
		v := s.VaultNotificationConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "vaultNotificationConfig", v, metadata)
	}
	return nil
}

// Contains information about a grant.
type Grant struct {
	_ struct{} `type:"structure"`

	// The grantee.
	Grantee *Grantee `type:"structure"`

	// Specifies the permission given to the grantee.
	Permission Permission `type:"string" enum:"true"`
}

// String returns the string representation
func (s Grant) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Grant) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Grant) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Grant"}
	if s.Grantee != nil {
		if err := s.Grantee.Validate(); err != nil {
			invalidParams.AddNested("Grantee", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Grant) MarshalFields(e protocol.FieldEncoder) error {
	if s.Grantee != nil {
		v := s.Grantee

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Grantee", v, metadata)
	}
	if len(s.Permission) > 0 {
		v := s.Permission

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Permission", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Contains information about the grantee.
type Grantee struct {
	_ struct{} `type:"structure"`

	// Screen name of the grantee.
	DisplayName *string `type:"string"`

	// Email address of the grantee.
	EmailAddress *string `type:"string"`

	// The canonical user ID of the grantee.
	ID *string `type:"string"`

	// Type of grantee
	//
	// Type is a required field
	Type Type `type:"string" required:"true" enum:"true"`

	// URI of the grantee group.
	URI *string `type:"string"`
}

// String returns the string representation
func (s Grantee) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Grantee) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Grantee) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Grantee"}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Grantee) MarshalFields(e protocol.FieldEncoder) error {
	if s.DisplayName != nil {
		v := *s.DisplayName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DisplayName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EmailAddress != nil {
		v := *s.EmailAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EmailAddress", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ID != nil {
		v := *s.ID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ID", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.URI != nil {
		v := *s.URI

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "URI", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for initiating an Amazon Glacier job.
type InitiateJobInput struct {
	_ struct{} `type:"structure" payload:"JobParameters"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// Provides options for specifying job information.
	JobParameters *JobParameters `locationName:"jobParameters" type:"structure"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s InitiateJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InitiateJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InitiateJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InitiateJobInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}
	if s.JobParameters != nil {
		if err := s.JobParameters.Validate(); err != nil {
			invalidParams.AddNested("JobParameters", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InitiateJobInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobParameters != nil {
		v := s.JobParameters

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "jobParameters", v, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type InitiateJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the job.
	JobId *string `location:"header" locationName:"x-amz-job-id" type:"string"`

	// The path to the location of where the select results are stored.
	JobOutputPath *string `location:"header" locationName:"x-amz-job-output-path" type:"string"`

	// The relative URI path of the job.
	Location *string `location:"header" locationName:"Location" type:"string"`
}

// String returns the string representation
func (s InitiateJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InitiateJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s InitiateJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InitiateJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-job-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobOutputPath != nil {
		v := *s.JobOutputPath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-job-output-path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for initiating a multipart upload to an Amazon Glacier vault.
type InitiateMultipartUploadInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The archive description that you are uploading in parts.
	//
	// The part size must be a megabyte (1024 KB) multiplied by a power of 2, for
	// example 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8 MB), and
	// so on. The minimum allowable part size is 1 MB, and the maximum is 4 GB (4096
	// MB).
	ArchiveDescription *string `location:"header" locationName:"x-amz-archive-description" type:"string"`

	// The size of each part except the last, in bytes. The last part can be smaller
	// than this part size.
	PartSize *string `location:"header" locationName:"x-amz-part-size" type:"string"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s InitiateMultipartUploadInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InitiateMultipartUploadInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InitiateMultipartUploadInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InitiateMultipartUploadInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InitiateMultipartUploadInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ArchiveDescription != nil {
		v := *s.ArchiveDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-archive-description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PartSize != nil {
		v := *s.PartSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-part-size", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The Amazon Glacier response to your request.
type InitiateMultipartUploadOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The relative URI path of the multipart upload ID Amazon Glacier created.
	Location *string `location:"header" locationName:"Location" type:"string"`

	// The ID of the multipart upload. This value is also included as part of the
	// location.
	UploadId *string `location:"header" locationName:"x-amz-multipart-upload-id" type:"string"`
}

// String returns the string representation
func (s InitiateMultipartUploadOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InitiateMultipartUploadOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s InitiateMultipartUploadOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InitiateMultipartUploadOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UploadId != nil {
		v := *s.UploadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-multipart-upload-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input values for InitiateVaultLock.
type InitiateVaultLockInput struct {
	_ struct{} `type:"structure" payload:"Policy"`

	// The AccountId value is the AWS account ID. This value must match the AWS
	// account ID associated with the credentials used to sign the request. You
	// can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you specify your account ID, do
	// not include any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The vault lock policy as a JSON string, which uses "\" as an escape character.
	Policy *VaultLockPolicy `locationName:"policy" type:"structure"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s InitiateVaultLockInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InitiateVaultLockInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InitiateVaultLockInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InitiateVaultLockInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InitiateVaultLockInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Policy != nil {
		v := s.Policy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "policy", v, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type InitiateVaultLockOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The lock ID, which is used to complete the vault locking process.
	LockId *string `location:"header" locationName:"x-amz-lock-id" type:"string"`
}

// String returns the string representation
func (s InitiateVaultLockOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InitiateVaultLockOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s InitiateVaultLockOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InitiateVaultLockOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.LockId != nil {
		v := *s.LockId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-lock-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes how the archive is serialized.
type InputSerialization struct {
	_ struct{} `type:"structure"`

	// Describes the serialization of a CSV-encoded object.
	Csv *CSVInput `locationName:"csv" type:"structure"`
}

// String returns the string representation
func (s InputSerialization) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InputSerialization) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InputSerialization) MarshalFields(e protocol.FieldEncoder) error {
	if s.Csv != nil {
		v := s.Csv

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "csv", v, metadata)
	}
	return nil
}

// Describes the options for a range inventory retrieval job.
type InventoryRetrievalJobDescription struct {
	_ struct{} `type:"structure"`

	// The end of the date range in UTC for vault inventory retrieval that includes
	// archives created before this date. This value should be a string in the ISO
	// 8601 date format, for example 2013-03-20T17:03:43Z.
	EndDate *string `type:"string"`

	// The output format for the vault inventory list, which is set by the InitiateJob
	// request when initiating a job to retrieve a vault inventory. Valid values
	// are CSV and JSON.
	Format *string `type:"string"`

	// The maximum number of inventory items returned per vault inventory retrieval
	// request. This limit is set when initiating the job with the a InitiateJob
	// request.
	Limit *string `type:"string"`

	// An opaque string that represents where to continue pagination of the vault
	// inventory retrieval results. You use the marker in a new InitiateJob request
	// to obtain additional inventory items. If there are no more inventory items,
	// this value is null. For more information, see  Range Inventory Retrieval
	// (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html#api-initiate-job-post-vault-inventory-list-filtering).
	Marker *string `type:"string"`

	// The start of the date range in Universal Coordinated Time (UTC) for vault
	// inventory retrieval that includes archives created on or after this date.
	// This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
	StartDate *string `type:"string"`
}

// String returns the string representation
func (s InventoryRetrievalJobDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InventoryRetrievalJobDescription) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InventoryRetrievalJobDescription) MarshalFields(e protocol.FieldEncoder) error {
	if s.EndDate != nil {
		v := *s.EndDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Format != nil {
		v := *s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Format", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Limit", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartDate != nil {
		v := *s.StartDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for specifying a range inventory retrieval job.
type InventoryRetrievalJobInput struct {
	_ struct{} `type:"structure"`

	// The end of the date range in UTC for vault inventory retrieval that includes
	// archives created before this date. This value should be a string in the ISO
	// 8601 date format, for example 2013-03-20T17:03:43Z.
	EndDate *string `type:"string"`

	// Specifies the maximum number of inventory items returned per vault inventory
	// retrieval request. Valid values are greater than or equal to 1.
	Limit *string `type:"string"`

	// An opaque string that represents where to continue pagination of the vault
	// inventory retrieval results. You use the marker in a new InitiateJob request
	// to obtain additional inventory items. If there are no more inventory items,
	// this value is null.
	Marker *string `type:"string"`

	// The start of the date range in UTC for vault inventory retrieval that includes
	// archives created on or after this date. This value should be a string in
	// the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
	StartDate *string `type:"string"`
}

// String returns the string representation
func (s InventoryRetrievalJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InventoryRetrievalJobInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InventoryRetrievalJobInput) MarshalFields(e protocol.FieldEncoder) error {
	if s.EndDate != nil {
		v := *s.EndDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Limit", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartDate != nil {
		v := *s.StartDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for defining a job.
type JobParameters struct {
	_ struct{} `type:"structure"`

	// The ID of the archive that you want to retrieve. This field is required only
	// if Type is set to select or archive-retrievalcode>. An error occurs if you
	// specify this request parameter for an inventory retrieval job request.
	ArchiveId *string `type:"string"`

	// The optional description for the job. The description must be less than or
	// equal to 1,024 bytes. The allowable characters are 7-bit ASCII without control
	// codes-specifically, ASCII values 32-126 decimal or 0x20-0x7E hexadecimal.
	Description *string `type:"string"`

	// When initiating a job to retrieve a vault inventory, you can optionally add
	// this parameter to your request to specify the output format. If you are initiating
	// an inventory job and do not specify a Format field, JSON is the default format.
	// Valid values are "CSV" and "JSON".
	Format *string `type:"string"`

	// Input parameters used for range inventory retrieval.
	InventoryRetrievalParameters *InventoryRetrievalJobInput `type:"structure"`

	// Contains information about the location where the select job results are
	// stored.
	OutputLocation *OutputLocation `type:"structure"`

	// The byte range to retrieve for an archive retrieval. in the form "StartByteValue-EndByteValue"
	// If not specified, the whole archive is retrieved. If specified, the byte
	// range must be megabyte (1024*1024) aligned which means that StartByteValue
	// must be divisible by 1 MB and EndByteValue plus 1 must be divisible by 1
	// MB or be the end of the archive specified as the archive byte size value
	// minus 1. If RetrievalByteRange is not megabyte aligned, this operation returns
	// a 400 response.
	//
	// An error occurs if you specify this field for an inventory retrieval job
	// request.
	RetrievalByteRange *string `type:"string"`

	// The Amazon SNS topic ARN to which Amazon Glacier sends a notification when
	// the job is completed and the output is ready for you to download. The specified
	// topic publishes the notification to its subscribers. The SNS topic must exist.
	SNSTopic *string `type:"string"`

	// Contains the parameters that define a job.
	SelectParameters *SelectParameters `type:"structure"`

	// The tier to use for a select or an archive retrieval job. Valid values are
	// Expedited, Standard, or Bulk. Standard is the default.
	Tier *string `type:"string"`

	// The job type. You can initiate a job to perform a select query on an archive,
	// retrieve an archive, or get an inventory of a vault. Valid values are "select",
	// "archive-retrieval" and "inventory-retrieval".
	Type *string `type:"string"`
}

// String returns the string representation
func (s JobParameters) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobParameters) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *JobParameters) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "JobParameters"}
	if s.OutputLocation != nil {
		if err := s.OutputLocation.Validate(); err != nil {
			invalidParams.AddNested("OutputLocation", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobParameters) MarshalFields(e protocol.FieldEncoder) error {
	if s.ArchiveId != nil {
		v := *s.ArchiveId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ArchiveId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Format != nil {
		v := *s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Format", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InventoryRetrievalParameters != nil {
		v := s.InventoryRetrievalParameters

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "InventoryRetrievalParameters", v, metadata)
	}
	if s.OutputLocation != nil {
		v := s.OutputLocation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "OutputLocation", v, metadata)
	}
	if s.RetrievalByteRange != nil {
		v := *s.RetrievalByteRange

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RetrievalByteRange", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SNSTopic != nil {
		v := *s.SNSTopic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SNSTopic", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SelectParameters != nil {
		v := s.SelectParameters

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SelectParameters", v, metadata)
	}
	if s.Tier != nil {
		v := *s.Tier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Tier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for retrieving a job list for an Amazon Glacier vault.
type ListJobsInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The state of the jobs to return. You can specify true or false.
	Completed *string `location:"querystring" locationName:"completed" type:"string"`

	// The maximum number of jobs to be returned. The default limit is 1000. The
	// number of jobs returned might be fewer than the specified limit, but the
	// number of returned jobs never exceeds the limit.
	Limit *string `location:"querystring" locationName:"limit" type:"string"`

	// An opaque string used for pagination. This value specifies the job at which
	// the listing of jobs should begin. Get the marker value from a previous List
	// Jobs response. You only need to include the marker if you are continuing
	// the pagination of results started in a previous List Jobs request.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The type of job status to return. You can specify the following values: InProgress,
	// Succeeded, or Failed.
	Statuscode *string `location:"querystring" locationName:"statuscode" type:"string"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s ListJobsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListJobsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListJobsInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Completed != nil {
		v := *s.Completed

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "completed", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Statuscode != nil {
		v := *s.Statuscode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "statuscode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type ListJobsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of job objects. Each job object contains metadata describing the job.
	JobList []DescribeJobOutput `type:"list"`

	// An opaque string used for pagination that specifies the job at which the
	// listing of jobs should begin. You get the marker value from a previous List
	// Jobs response. You only need to include the marker if you are continuing
	// the pagination of the results started in a previous List Jobs request.
	Marker *string `type:"string"`
}

// String returns the string representation
func (s ListJobsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListJobsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.JobList) > 0 {
		v := s.JobList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "JobList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options for retrieving list of in-progress multipart uploads for
// an Amazon Glacier vault.
type ListMultipartUploadsInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// Specifies the maximum number of uploads returned in the response body. If
	// this value is not specified, the List Uploads operation returns up to 1,000
	// uploads.
	Limit *string `location:"querystring" locationName:"limit" type:"string"`

	// An opaque string used for pagination. This value specifies the upload at
	// which the listing of uploads should begin. Get the marker value from a previous
	// List Uploads response. You need only include the marker if you are continuing
	// the pagination of results started in a previous List Uploads request.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s ListMultipartUploadsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListMultipartUploadsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListMultipartUploadsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListMultipartUploadsInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListMultipartUploadsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type ListMultipartUploadsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An opaque string that represents where to continue pagination of the results.
	// You use the marker in a new List Multipart Uploads request to obtain more
	// uploads in the list. If there are no more uploads, this value is null.
	Marker *string `type:"string"`

	// A list of in-progress multipart uploads.
	UploadsList []UploadListElement `type:"list"`
}

// String returns the string representation
func (s ListMultipartUploadsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListMultipartUploadsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListMultipartUploadsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListMultipartUploadsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.UploadsList) > 0 {
		v := s.UploadsList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UploadsList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Provides options for retrieving a list of parts of an archive that have been
// uploaded in a specific multipart upload.
type ListPartsInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The maximum number of parts to be returned. The default limit is 1000. The
	// number of parts returned might be fewer than the specified limit, but the
	// number of returned parts never exceeds the limit.
	Limit *string `location:"querystring" locationName:"limit" type:"string"`

	// An opaque string used for pagination. This value specifies the part at which
	// the listing of parts should begin. Get the marker value from the response
	// of a previous List Parts response. You need only include the marker if you
	// are continuing the pagination of results started in a previous List Parts
	// request.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The upload ID of the multipart upload.
	//
	// UploadId is a required field
	UploadId *string `location:"uri" locationName:"uploadId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s ListPartsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPartsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPartsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListPartsInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.UploadId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UploadId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPartsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UploadId != nil {
		v := *s.UploadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "uploadId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type ListPartsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The description of the archive that was specified in the Initiate Multipart
	// Upload request.
	ArchiveDescription *string `type:"string"`

	// The UTC time at which the multipart upload was initiated.
	CreationDate *string `type:"string"`

	// An opaque string that represents where to continue pagination of the results.
	// You use the marker in a new List Parts request to obtain more jobs in the
	// list. If there are no more parts, this value is null.
	Marker *string `type:"string"`

	// The ID of the upload to which the parts are associated.
	MultipartUploadId *string `type:"string"`

	// The part size in bytes. This is the same value that you specified in the
	// Initiate Multipart Upload request.
	PartSizeInBytes *int64 `type:"long"`

	// A list of the part sizes of the multipart upload. Each object in the array
	// contains a RangeBytes and sha256-tree-hash name/value pair.
	Parts []PartListElement `type:"list"`

	// The Amazon Resource Name (ARN) of the vault to which the multipart upload
	// was initiated.
	VaultARN *string `type:"string"`
}

// String returns the string representation
func (s ListPartsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPartsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListPartsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPartsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ArchiveDescription != nil {
		v := *s.ArchiveDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ArchiveDescription", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MultipartUploadId != nil {
		v := *s.MultipartUploadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MultipartUploadId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PartSizeInBytes != nil {
		v := *s.PartSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PartSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if len(s.Parts) > 0 {
		v := s.Parts

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Parts", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.VaultARN != nil {
		v := *s.VaultARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VaultARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListProvisionedCapacityInput struct {
	_ struct{} `type:"structure"`

	// The AWS account ID of the account that owns the vault. You can either specify
	// an AWS account ID or optionally a single '-' (hyphen), in which case Amazon
	// Glacier uses the AWS account ID associated with the credentials used to sign
	// the request. If you use an account ID, don't include any hyphens ('-') in
	// the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`
}

// String returns the string representation
func (s ListProvisionedCapacityInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListProvisionedCapacityInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListProvisionedCapacityInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListProvisionedCapacityInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListProvisionedCapacityInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListProvisionedCapacityOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The response body contains the following JSON fields.
	ProvisionedCapacityList []ProvisionedCapacityDescription `type:"list"`
}

// String returns the string representation
func (s ListProvisionedCapacityOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListProvisionedCapacityOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListProvisionedCapacityOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListProvisionedCapacityOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ProvisionedCapacityList) > 0 {
		v := s.ProvisionedCapacityList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ProvisionedCapacityList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The input value for ListTagsForVaultInput.
type ListTagsForVaultInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTagsForVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsForVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTagsForVaultInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsForVaultInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type ListTagsForVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The tags attached to the vault. Each tag is composed of a key and a value.
	Tags map[string]string `type:"map"`
}

// String returns the string representation
func (s ListTagsForVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTagsForVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsForVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Provides options to retrieve the vault list owned by the calling user's account.
// The list provides metadata information for each vault.
type ListVaultsInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID. This value must match the AWS
	// account ID associated with the credentials used to sign the request. You
	// can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you specify your account ID, do
	// not include any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The maximum number of vaults to be returned. The default limit is 1000. The
	// number of vaults returned might be fewer than the specified limit, but the
	// number of returned vaults never exceeds the limit.
	Limit *string `location:"querystring" locationName:"limit" type:"string"`

	// A string used for pagination. The marker specifies the vault ARN after which
	// the listing of vaults should begin.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`
}

// String returns the string representation
func (s ListVaultsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListVaultsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListVaultsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListVaultsInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListVaultsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type ListVaultsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The vault ARN at which to continue pagination of the results. You use the
	// marker in another List Vaults request to obtain more vaults in the list.
	Marker *string `type:"string"`

	// List of vaults.
	VaultList []DescribeVaultOutput `type:"list"`
}

// String returns the string representation
func (s ListVaultsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListVaultsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListVaultsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListVaultsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.VaultList) > 0 {
		v := s.VaultList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "VaultList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Contains information about the location where the select job results are
// stored.
type OutputLocation struct {
	_ struct{} `type:"structure"`

	// Describes an S3 location that will receive the results of the job request.
	S3 *S3Location `type:"structure"`
}

// String returns the string representation
func (s OutputLocation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OutputLocation) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *OutputLocation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "OutputLocation"}
	if s.S3 != nil {
		if err := s.S3.Validate(); err != nil {
			invalidParams.AddNested("S3", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OutputLocation) MarshalFields(e protocol.FieldEncoder) error {
	if s.S3 != nil {
		v := s.S3

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3", v, metadata)
	}
	return nil
}

// Describes how the select output is serialized.
type OutputSerialization struct {
	_ struct{} `type:"structure"`

	// Describes the serialization of CSV-encoded query results.
	Csv *CSVOutput `locationName:"csv" type:"structure"`
}

// String returns the string representation
func (s OutputSerialization) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OutputSerialization) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OutputSerialization) MarshalFields(e protocol.FieldEncoder) error {
	if s.Csv != nil {
		v := s.Csv

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "csv", v, metadata)
	}
	return nil
}

// A list of the part sizes of the multipart upload.
type PartListElement struct {
	_ struct{} `type:"structure"`

	// The byte range of a part, inclusive of the upper value of the range.
	RangeInBytes *string `type:"string"`

	// The SHA256 tree hash value that Amazon Glacier calculated for the part. This
	// field is never null.
	SHA256TreeHash *string `type:"string"`
}

// String returns the string representation
func (s PartListElement) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PartListElement) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PartListElement) MarshalFields(e protocol.FieldEncoder) error {
	if s.RangeInBytes != nil {
		v := *s.RangeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RangeInBytes", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SHA256TreeHash != nil {
		v := *s.SHA256TreeHash

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SHA256TreeHash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The definition for a provisioned capacity unit.
type ProvisionedCapacityDescription struct {
	_ struct{} `type:"structure"`

	// The ID that identifies the provisioned capacity unit.
	CapacityId *string `type:"string"`

	// The date that the provisioned capacity unit expires, in Universal Coordinated
	// Time (UTC).
	ExpirationDate *string `type:"string"`

	// The date that the provisioned capacity unit was purchased, in Universal Coordinated
	// Time (UTC).
	StartDate *string `type:"string"`
}

// String returns the string representation
func (s ProvisionedCapacityDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ProvisionedCapacityDescription) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ProvisionedCapacityDescription) MarshalFields(e protocol.FieldEncoder) error {
	if s.CapacityId != nil {
		v := *s.CapacityId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CapacityId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ExpirationDate != nil {
		v := *s.ExpirationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpirationDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartDate != nil {
		v := *s.StartDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type PurchaseProvisionedCapacityInput struct {
	_ struct{} `type:"structure"`

	// The AWS account ID of the account that owns the vault. You can either specify
	// an AWS account ID or optionally a single '-' (hyphen), in which case Amazon
	// Glacier uses the AWS account ID associated with the credentials used to sign
	// the request. If you use an account ID, don't include any hyphens ('-') in
	// the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`
}

// String returns the string representation
func (s PurchaseProvisionedCapacityInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PurchaseProvisionedCapacityInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PurchaseProvisionedCapacityInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PurchaseProvisionedCapacityInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PurchaseProvisionedCapacityInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type PurchaseProvisionedCapacityOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID that identifies the provisioned capacity unit.
	CapacityId *string `location:"header" locationName:"x-amz-capacity-id" type:"string"`
}

// String returns the string representation
func (s PurchaseProvisionedCapacityOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PurchaseProvisionedCapacityOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PurchaseProvisionedCapacityOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PurchaseProvisionedCapacityOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CapacityId != nil {
		v := *s.CapacityId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-capacity-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input value for RemoveTagsFromVaultInput.
type RemoveTagsFromVaultInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// A list of tag keys. Each corresponding tag is removed from the vault.
	TagKeys []string `type:"list"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s RemoveTagsFromVaultInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveTagsFromVaultInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RemoveTagsFromVaultInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RemoveTagsFromVaultInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveTagsFromVaultInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.TagKeys) > 0 {
		v := s.TagKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TagKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type RemoveTagsFromVaultOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s RemoveTagsFromVaultOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveTagsFromVaultOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RemoveTagsFromVaultOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveTagsFromVaultOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Contains information about the location in Amazon S3 where the select job
// results are stored.
type S3Location struct {
	_ struct{} `type:"structure"`

	// A list of grants that control access to the staged results.
	AccessControlList []Grant `type:"list"`

	// The name of the Amazon S3 bucket where the job results are stored.
	BucketName *string `type:"string"`

	// The canned access control list (ACL) to apply to the job results.
	CannedACL CannedACL `type:"string" enum:"true"`

	// Contains information about the encryption used to store the job results in
	// Amazon S3.
	Encryption *Encryption `type:"structure"`

	// The prefix that is prepended to the results for this request.
	Prefix *string `type:"string"`

	// The storage class used to store the job results.
	StorageClass StorageClass `type:"string" enum:"true"`

	// The tag-set that is applied to the job results.
	Tagging map[string]string `type:"map"`

	// A map of metadata to store with the job results in Amazon S3.
	UserMetadata map[string]string `type:"map"`
}

// String returns the string representation
func (s S3Location) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s S3Location) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Location) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Location"}
	if s.AccessControlList != nil {
		for i, v := range s.AccessControlList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AccessControlList", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Location) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AccessControlList) > 0 {
		v := s.AccessControlList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AccessControlList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.BucketName != nil {
		v := *s.BucketName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BucketName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.CannedACL) > 0 {
		v := s.CannedACL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CannedACL", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Encryption != nil {
		v := s.Encryption

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Encryption", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Tagging) > 0 {
		v := s.Tagging

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Tagging", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.UserMetadata) > 0 {
		v := s.UserMetadata

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "UserMetadata", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Contains information about the parameters used for a select.
type SelectParameters struct {
	_ struct{} `type:"structure"`

	// The expression that is used to select the object.
	Expression *string `type:"string"`

	// The type of the provided expression, for example SQL.
	ExpressionType ExpressionType `type:"string" enum:"true"`

	// Describes the serialization format of the object.
	InputSerialization *InputSerialization `type:"structure"`

	// Describes how the results of the select job are serialized.
	OutputSerialization *OutputSerialization `type:"structure"`
}

// String returns the string representation
func (s SelectParameters) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SelectParameters) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SelectParameters) MarshalFields(e protocol.FieldEncoder) error {
	if s.Expression != nil {
		v := *s.Expression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Expression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ExpressionType) > 0 {
		v := s.ExpressionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpressionType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.InputSerialization != nil {
		v := s.InputSerialization

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "InputSerialization", v, metadata)
	}
	if s.OutputSerialization != nil {
		v := s.OutputSerialization

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "OutputSerialization", v, metadata)
	}
	return nil
}

// SetDataRetrievalPolicy input.
type SetDataRetrievalPolicyInput struct {
	_ struct{} `type:"structure"`

	// The AccountId value is the AWS account ID. This value must match the AWS
	// account ID associated with the credentials used to sign the request. You
	// can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you specify your account ID, do
	// not include any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The data retrieval policy in JSON format.
	Policy *DataRetrievalPolicy `type:"structure"`
}

// String returns the string representation
func (s SetDataRetrievalPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetDataRetrievalPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SetDataRetrievalPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SetDataRetrievalPolicyInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetDataRetrievalPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Policy != nil {
		v := s.Policy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Policy", v, metadata)
	}
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type SetDataRetrievalPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s SetDataRetrievalPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetDataRetrievalPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SetDataRetrievalPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetDataRetrievalPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// SetVaultAccessPolicy input.
type SetVaultAccessPolicyInput struct {
	_ struct{} `type:"structure" payload:"Policy"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The vault access policy as a JSON string.
	Policy *VaultAccessPolicy `locationName:"policy" type:"structure"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s SetVaultAccessPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetVaultAccessPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SetVaultAccessPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SetVaultAccessPolicyInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetVaultAccessPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Policy != nil {
		v := s.Policy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "policy", v, metadata)
	}
	return nil
}

type SetVaultAccessPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s SetVaultAccessPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetVaultAccessPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SetVaultAccessPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetVaultAccessPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Provides options to configure notifications that will be sent when specific
// events happen to a vault.
type SetVaultNotificationsInput struct {
	_ struct{} `type:"structure" payload:"VaultNotificationConfig"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`

	// Provides options for specifying notification configuration.
	VaultNotificationConfig *VaultNotificationConfig `locationName:"vaultNotificationConfig" type:"structure"`
}

// String returns the string representation
func (s SetVaultNotificationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetVaultNotificationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SetVaultNotificationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SetVaultNotificationsInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetVaultNotificationsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultNotificationConfig != nil {
		v := s.VaultNotificationConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "vaultNotificationConfig", v, metadata)
	}
	return nil
}

type SetVaultNotificationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s SetVaultNotificationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetVaultNotificationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SetVaultNotificationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetVaultNotificationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Provides options to add an archive to a vault.
type UploadArchiveInput struct {
	_ struct{} `type:"structure" payload:"Body"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The optional description of the archive you are uploading.
	ArchiveDescription *string `location:"header" locationName:"x-amz-archive-description" type:"string"`

	// The data to upload.
	Body io.ReadSeeker `locationName:"body" type:"blob"`

	// The SHA256 tree hash of the data being uploaded.
	Checksum *string `location:"header" locationName:"x-amz-sha256-tree-hash" type:"string"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s UploadArchiveInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UploadArchiveInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UploadArchiveInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UploadArchiveInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UploadArchiveInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ArchiveDescription != nil {
		v := *s.ArchiveDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-archive-description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-sha256-tree-hash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Body != nil {
		v := s.Body

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "body", protocol.ReadSeekerStream{V: v}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
//
// For information about the underlying REST API, see Upload Archive (http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html).
// For conceptual information, see Working with Archives in Amazon Glacier (http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html).
type UploadArchiveOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the archive. This value is also included as part of the location.
	ArchiveId *string `location:"header" locationName:"x-amz-archive-id" type:"string"`

	// The checksum of the archive computed by Amazon Glacier.
	Checksum *string `location:"header" locationName:"x-amz-sha256-tree-hash" type:"string"`

	// The relative URI path of the newly added archive resource.
	Location *string `location:"header" locationName:"Location" type:"string"`
}

// String returns the string representation
func (s UploadArchiveOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UploadArchiveOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UploadArchiveOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UploadArchiveOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ArchiveId != nil {
		v := *s.ArchiveId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-archive-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-sha256-tree-hash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A list of in-progress multipart uploads for a vault.
type UploadListElement struct {
	_ struct{} `type:"structure"`

	// The description of the archive that was specified in the Initiate Multipart
	// Upload request.
	ArchiveDescription *string `type:"string"`

	// The UTC time at which the multipart upload was initiated.
	CreationDate *string `type:"string"`

	// The ID of a multipart upload.
	MultipartUploadId *string `type:"string"`

	// The part size, in bytes, specified in the Initiate Multipart Upload request.
	// This is the size of all the parts in the upload except the last part, which
	// may be smaller than this size.
	PartSizeInBytes *int64 `type:"long"`

	// The Amazon Resource Name (ARN) of the vault that contains the archive.
	VaultARN *string `type:"string"`
}

// String returns the string representation
func (s UploadListElement) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UploadListElement) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UploadListElement) MarshalFields(e protocol.FieldEncoder) error {
	if s.ArchiveDescription != nil {
		v := *s.ArchiveDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ArchiveDescription", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MultipartUploadId != nil {
		v := *s.MultipartUploadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MultipartUploadId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PartSizeInBytes != nil {
		v := *s.PartSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PartSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.VaultARN != nil {
		v := *s.VaultARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VaultARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides options to upload a part of an archive in a multipart upload operation.
type UploadMultipartPartInput struct {
	_ struct{} `type:"structure" payload:"Body"`

	// The AccountId value is the AWS account ID of the account that owns the vault.
	// You can either specify an AWS account ID or optionally a single '-' (hyphen),
	// in which case Amazon Glacier uses the AWS account ID associated with the
	// credentials used to sign the request. If you use an account ID, do not include
	// any hyphens ('-') in the ID.
	//
	// AccountId is a required field
	AccountId *string `location:"uri" locationName:"accountId" type:"string" required:"true"`

	// The data to upload.
	Body io.ReadSeeker `locationName:"body" type:"blob"`

	// The SHA256 tree hash of the data being uploaded.
	Checksum *string `location:"header" locationName:"x-amz-sha256-tree-hash" type:"string"`

	// Identifies the range of bytes in the assembled archive that will be uploaded
	// in this part. Amazon Glacier uses this information to assemble the archive
	// in the proper sequence. The format of this header follows RFC 2616. An example
	// header is Content-Range:bytes 0-4194303/*.
	Range *string `location:"header" locationName:"Content-Range" type:"string"`

	// The upload ID of the multipart upload.
	//
	// UploadId is a required field
	UploadId *string `location:"uri" locationName:"uploadId" type:"string" required:"true"`

	// The name of the vault.
	//
	// VaultName is a required field
	VaultName *string `location:"uri" locationName:"vaultName" type:"string" required:"true"`
}

// String returns the string representation
func (s UploadMultipartPartInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UploadMultipartPartInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UploadMultipartPartInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UploadMultipartPartInput"}

	if s.AccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AccountId"))
	}

	if s.UploadId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UploadId"))
	}

	if s.VaultName == nil {
		invalidParams.Add(aws.NewErrParamRequired("VaultName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UploadMultipartPartInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-sha256-tree-hash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Range != nil {
		v := *s.Range

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Content-Range", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "accountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UploadId != nil {
		v := *s.UploadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "uploadId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VaultName != nil {
		v := *s.VaultName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vaultName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Body != nil {
		v := s.Body

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "body", protocol.ReadSeekerStream{V: v}, metadata)
	}
	return nil
}

// Contains the Amazon Glacier response to your request.
type UploadMultipartPartOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The SHA256 tree hash that Amazon Glacier computed for the uploaded part.
	Checksum *string `location:"header" locationName:"x-amz-sha256-tree-hash" type:"string"`
}

// String returns the string representation
func (s UploadMultipartPartOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UploadMultipartPartOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UploadMultipartPartOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UploadMultipartPartOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Checksum != nil {
		v := *s.Checksum

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-sha256-tree-hash", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the vault access policy.
type VaultAccessPolicy struct {
	_ struct{} `type:"structure"`

	// The vault access policy.
	Policy *string `type:"string"`
}

// String returns the string representation
func (s VaultAccessPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VaultAccessPolicy) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VaultAccessPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.Policy != nil {
		v := *s.Policy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the vault lock policy.
type VaultLockPolicy struct {
	_ struct{} `type:"structure"`

	// The vault lock policy.
	Policy *string `type:"string"`
}

// String returns the string representation
func (s VaultLockPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VaultLockPolicy) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VaultLockPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.Policy != nil {
		v := *s.Policy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a vault's notification configuration.
type VaultNotificationConfig struct {
	_ struct{} `type:"structure"`

	// A list of one or more events for which Amazon Glacier will send a notification
	// to the specified Amazon SNS topic.
	Events []string `type:"list"`

	// The Amazon Simple Notification Service (Amazon SNS) topic Amazon Resource
	// Name (ARN).
	SNSTopic *string `type:"string"`
}

// String returns the string representation
func (s VaultNotificationConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VaultNotificationConfig) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VaultNotificationConfig) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Events) > 0 {
		v := s.Events

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Events", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.SNSTopic != nil {
		v := *s.SNSTopic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SNSTopic", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ActionCode string

// Enum values for ActionCode
const (
	ActionCodeArchiveRetrieval   ActionCode = "ArchiveRetrieval"
	ActionCodeInventoryRetrieval ActionCode = "InventoryRetrieval"
	ActionCodeSelect             ActionCode = "Select"
)

func (enum ActionCode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ActionCode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CannedACL string

// Enum values for CannedACL
const (
	CannedACLPrivate                CannedACL = "private"
	CannedACLPublicRead             CannedACL = "public-read"
	CannedACLPublicReadWrite        CannedACL = "public-read-write"
	CannedACLAwsExecRead            CannedACL = "aws-exec-read"
	CannedACLAuthenticatedRead      CannedACL = "authenticated-read"
	CannedACLBucketOwnerRead        CannedACL = "bucket-owner-read"
	CannedACLBucketOwnerFullControl CannedACL = "bucket-owner-full-control"
)

func (enum CannedACL) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CannedACL) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type EncryptionType string

// Enum values for EncryptionType
const (
	EncryptionTypeAwsKms EncryptionType = "aws:kms"
	EncryptionTypeAes256 EncryptionType = "AES256"
)

func (enum EncryptionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EncryptionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ExpressionType string

// Enum values for ExpressionType
const (
	ExpressionTypeSql ExpressionType = "SQL"
)

func (enum ExpressionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ExpressionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type FileHeaderInfo string

// Enum values for FileHeaderInfo
const (
	FileHeaderInfoUse    FileHeaderInfo = "USE"
	FileHeaderInfoIgnore FileHeaderInfo = "IGNORE"
	FileHeaderInfoNone   FileHeaderInfo = "NONE"
)

func (enum FileHeaderInfo) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum FileHeaderInfo) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Permission string

// Enum values for Permission
const (
	PermissionFullControl Permission = "FULL_CONTROL"
	PermissionWrite       Permission = "WRITE"
	PermissionWriteAcp    Permission = "WRITE_ACP"
	PermissionRead        Permission = "READ"
	PermissionReadAcp     Permission = "READ_ACP"
)

func (enum Permission) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Permission) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type QuoteFields string

// Enum values for QuoteFields
const (
	QuoteFieldsAlways   QuoteFields = "ALWAYS"
	QuoteFieldsAsneeded QuoteFields = "ASNEEDED"
)

func (enum QuoteFields) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum QuoteFields) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type StatusCode string

// Enum values for StatusCode
const (
	StatusCodeInProgress StatusCode = "InProgress"
	StatusCodeSucceeded  StatusCode = "Succeeded"
	StatusCodeFailed     StatusCode = "Failed"
)

func (enum StatusCode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum StatusCode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type StorageClass string

// Enum values for StorageClass
const (
	StorageClassStandard          StorageClass = "STANDARD"
	StorageClassReducedRedundancy StorageClass = "REDUCED_REDUNDANCY"
	StorageClassStandardIa        StorageClass = "STANDARD_IA"
)

func (enum StorageClass) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum StorageClass) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Type string

// Enum values for Type
const (
	TypeAmazonCustomerByEmail Type = "AmazonCustomerByEmail"
	TypeCanonicalUser         Type = "CanonicalUser"
	TypeGroup                 Type = "Group"
)

func (enum Type) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Type) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
