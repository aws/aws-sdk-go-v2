package customizations

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	"io"
)

const bufsize = 1024 * 1024

// AddTreeHashMiddleware adds middleware needed to automatically
// calculate Glacier's required checksum headers.
func AddTreeHashMiddleware(stack *middleware.Stack) {
	stack.Finalize.Add(&TreeHashMiddleware{}, middleware.Before)
}

// TreeHashMiddleware provides the middleware that will automatically
// set the sha256 and tree hash headers if they have not already been
// set.
type TreeHashMiddleware struct{}

// ID returns the middleware ID.
func (*TreeHashMiddleware) ID() string { return "Glacier:TreeHash" }

// HandleFinalize implements the finalize middleware handler method
func (*TreeHashMiddleware) HandleFinalize(
	ctx context.Context, input middleware.FinalizeInput, next middleware.FinalizeHandler,
) (
	output middleware.FinalizeOutput, metadata middleware.Metadata, err error,
) {
	req, ok := input.Request.(*smithyhttp.Request)
	if !ok {
		return output, metadata, &smithy.SerializationError{
			Err: fmt.Errorf("unknown request type %T", input.Request),
		}
	}

	if err := addChecksum(req); err != nil {
		return output, metadata, &smithy.SerializationError{Err: err}
	}

	return next.HandleFinalize(ctx, input)
}

func addChecksum(req *smithyhttp.Request) error {
	if req.GetStream() == nil || req.Header.Get("X-Amz-Sha256-Tree-Hash") != "" {
		return nil
	}

	h := computeHashes(req.GetStream())
	if err := req.RewindStream(); err != nil {
		return err
	}

	hstr := hex.EncodeToString(h.TreeHash)
	req.Header.Set("X-Amz-Sha256-Tree-Hash", hstr)

	hLstr := hex.EncodeToString(h.LinearHash)
	req.Header.Set("X-Amz-Content-Sha256", hLstr)

	return nil
}

// Hash contains information about the tree-hash and linear hash of a
// Glacier payload. This structure is generated by computeHashes().
type Hash struct {
	TreeHash   []byte
	LinearHash []byte
}

// ComputeHashes computes the tree-hash and linear hash of a reader r.
//
// See http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html for more information.
func ComputeHashes(r io.ReadSeeker) Hash {
	start, _ := r.Seek(0, io.SeekCurrent) // Read the whole stream
	defer r.Seek(start, io.SeekStart)     		// Rewind stream at end
	return computeHashes(r)
}

// computeHashes computes the tree-hash and linear hash of a reader r.
//
// Note that this does not perform seeks before or after, these must be done manually.
//
// See http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html for more information.
func computeHashes(r io.Reader) Hash {
	buf := make([]byte, bufsize)
	hashes := [][]byte{}
	hsh := sha256.New()

	for {
		// Build leaf nodes in 1MB chunks
		n, err := io.ReadAtLeast(r, buf, bufsize)
		if n == 0 {
			break
		}

		tmpHash := sha256.Sum256(buf[:n])
		hashes = append(hashes, tmpHash[:])
		hsh.Write(buf[:n]) // Track linear hash while we're at it

		if err != nil {
			break // This is the last chunk
		}
	}

	return Hash{
		LinearHash: hsh.Sum(nil),
		TreeHash:   ComputeTreeHash(hashes),
	}
}

// ComputeTreeHash builds a tree hash root node given a slice of
// hashes. Glacier tree hash to be derived from SHA256 hashes of 1MB
// chucks of the data.
//
// See http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html for more information.
func ComputeTreeHash(hashes [][]byte) []byte {
	if hashes == nil || len(hashes) == 0 {
		return nil
	}

	for len(hashes) > 1 {
		tmpHashes := [][]byte{}

		for i := 0; i < len(hashes); i += 2 {
			if i+1 <= len(hashes)-1 {
				tmpHash := append(append([]byte{}, hashes[i]...), hashes[i+1]...)
				tmpSum := sha256.Sum256(tmpHash)
				tmpHashes = append(tmpHashes, tmpSum[:])
			} else {
				tmpHashes = append(tmpHashes, hashes[i])
			}
		}

		hashes = tmpHashes
	}

	return hashes[0]
}
