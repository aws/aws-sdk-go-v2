// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package workdocs

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opAbortDocumentVersionUpload = "AbortDocumentVersionUpload"

// AbortDocumentVersionUploadRequest is a API request type for the AbortDocumentVersionUpload API operation.
type AbortDocumentVersionUploadRequest struct {
	*aws.Request
	Input *AbortDocumentVersionUploadInput
	Copy  func(*AbortDocumentVersionUploadInput) AbortDocumentVersionUploadRequest
}

// Send marshals and sends the AbortDocumentVersionUpload API request.
func (r AbortDocumentVersionUploadRequest) Send() (*AbortDocumentVersionUploadOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AbortDocumentVersionUploadOutput), nil
}

// AbortDocumentVersionUploadRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Aborts the upload of the specified document version that was previously initiated
// by InitiateDocumentVersionUpload. The client should make this call only when
// it no longer intends to upload the document version, or fails to do so.
//
//    // Example sending a request using the AbortDocumentVersionUploadRequest method.
//    req := client.AbortDocumentVersionUploadRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/AbortDocumentVersionUpload
func (c *WorkDocs) AbortDocumentVersionUploadRequest(input *AbortDocumentVersionUploadInput) AbortDocumentVersionUploadRequest {
	op := &aws.Operation{
		Name:       opAbortDocumentVersionUpload,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/documents/{DocumentId}/versions/{VersionId}",
	}

	if input == nil {
		input = &AbortDocumentVersionUploadInput{}
	}

	output := &AbortDocumentVersionUploadOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return AbortDocumentVersionUploadRequest{Request: req, Input: input, Copy: c.AbortDocumentVersionUploadRequest}
}

const opActivateUser = "ActivateUser"

// ActivateUserRequest is a API request type for the ActivateUser API operation.
type ActivateUserRequest struct {
	*aws.Request
	Input *ActivateUserInput
	Copy  func(*ActivateUserInput) ActivateUserRequest
}

// Send marshals and sends the ActivateUser API request.
func (r ActivateUserRequest) Send() (*ActivateUserOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ActivateUserOutput), nil
}

// ActivateUserRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Activates the specified user. Only active users can access Amazon WorkDocs.
//
//    // Example sending a request using the ActivateUserRequest method.
//    req := client.ActivateUserRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/ActivateUser
func (c *WorkDocs) ActivateUserRequest(input *ActivateUserInput) ActivateUserRequest {
	op := &aws.Operation{
		Name:       opActivateUser,
		HTTPMethod: "POST",
		HTTPPath:   "/api/v1/users/{UserId}/activation",
	}

	if input == nil {
		input = &ActivateUserInput{}
	}

	output := &ActivateUserOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ActivateUserRequest{Request: req, Input: input, Copy: c.ActivateUserRequest}
}

const opAddResourcePermissions = "AddResourcePermissions"

// AddResourcePermissionsRequest is a API request type for the AddResourcePermissions API operation.
type AddResourcePermissionsRequest struct {
	*aws.Request
	Input *AddResourcePermissionsInput
	Copy  func(*AddResourcePermissionsInput) AddResourcePermissionsRequest
}

// Send marshals and sends the AddResourcePermissions API request.
func (r AddResourcePermissionsRequest) Send() (*AddResourcePermissionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AddResourcePermissionsOutput), nil
}

// AddResourcePermissionsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Creates a set of permissions for the specified folder or document. The resource
// permissions are overwritten if the principals already have different permissions.
//
//    // Example sending a request using the AddResourcePermissionsRequest method.
//    req := client.AddResourcePermissionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/AddResourcePermissions
func (c *WorkDocs) AddResourcePermissionsRequest(input *AddResourcePermissionsInput) AddResourcePermissionsRequest {
	op := &aws.Operation{
		Name:       opAddResourcePermissions,
		HTTPMethod: "POST",
		HTTPPath:   "/api/v1/resources/{ResourceId}/permissions",
	}

	if input == nil {
		input = &AddResourcePermissionsInput{}
	}

	output := &AddResourcePermissionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AddResourcePermissionsRequest{Request: req, Input: input, Copy: c.AddResourcePermissionsRequest}
}

const opCreateComment = "CreateComment"

// CreateCommentRequest is a API request type for the CreateComment API operation.
type CreateCommentRequest struct {
	*aws.Request
	Input *CreateCommentInput
	Copy  func(*CreateCommentInput) CreateCommentRequest
}

// Send marshals and sends the CreateComment API request.
func (r CreateCommentRequest) Send() (*CreateCommentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateCommentOutput), nil
}

// CreateCommentRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Adds a new comment to the specified document version.
//
//    // Example sending a request using the CreateCommentRequest method.
//    req := client.CreateCommentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateComment
func (c *WorkDocs) CreateCommentRequest(input *CreateCommentInput) CreateCommentRequest {
	op := &aws.Operation{
		Name:       opCreateComment,
		HTTPMethod: "POST",
		HTTPPath:   "/api/v1/documents/{DocumentId}/versions/{VersionId}/comment",
	}

	if input == nil {
		input = &CreateCommentInput{}
	}

	output := &CreateCommentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateCommentRequest{Request: req, Input: input, Copy: c.CreateCommentRequest}
}

const opCreateCustomMetadata = "CreateCustomMetadata"

// CreateCustomMetadataRequest is a API request type for the CreateCustomMetadata API operation.
type CreateCustomMetadataRequest struct {
	*aws.Request
	Input *CreateCustomMetadataInput
	Copy  func(*CreateCustomMetadataInput) CreateCustomMetadataRequest
}

// Send marshals and sends the CreateCustomMetadata API request.
func (r CreateCustomMetadataRequest) Send() (*CreateCustomMetadataOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateCustomMetadataOutput), nil
}

// CreateCustomMetadataRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Adds one or more custom properties to the specified resource (a folder, document,
// or version).
//
//    // Example sending a request using the CreateCustomMetadataRequest method.
//    req := client.CreateCustomMetadataRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateCustomMetadata
func (c *WorkDocs) CreateCustomMetadataRequest(input *CreateCustomMetadataInput) CreateCustomMetadataRequest {
	op := &aws.Operation{
		Name:       opCreateCustomMetadata,
		HTTPMethod: "PUT",
		HTTPPath:   "/api/v1/resources/{ResourceId}/customMetadata",
	}

	if input == nil {
		input = &CreateCustomMetadataInput{}
	}

	output := &CreateCustomMetadataOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateCustomMetadataRequest{Request: req, Input: input, Copy: c.CreateCustomMetadataRequest}
}

const opCreateFolder = "CreateFolder"

// CreateFolderRequest is a API request type for the CreateFolder API operation.
type CreateFolderRequest struct {
	*aws.Request
	Input *CreateFolderInput
	Copy  func(*CreateFolderInput) CreateFolderRequest
}

// Send marshals and sends the CreateFolder API request.
func (r CreateFolderRequest) Send() (*CreateFolderOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateFolderOutput), nil
}

// CreateFolderRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Creates a folder with the specified name and parent folder.
//
//    // Example sending a request using the CreateFolderRequest method.
//    req := client.CreateFolderRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateFolder
func (c *WorkDocs) CreateFolderRequest(input *CreateFolderInput) CreateFolderRequest {
	op := &aws.Operation{
		Name:       opCreateFolder,
		HTTPMethod: "POST",
		HTTPPath:   "/api/v1/folders",
	}

	if input == nil {
		input = &CreateFolderInput{}
	}

	output := &CreateFolderOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateFolderRequest{Request: req, Input: input, Copy: c.CreateFolderRequest}
}

const opCreateLabels = "CreateLabels"

// CreateLabelsRequest is a API request type for the CreateLabels API operation.
type CreateLabelsRequest struct {
	*aws.Request
	Input *CreateLabelsInput
	Copy  func(*CreateLabelsInput) CreateLabelsRequest
}

// Send marshals and sends the CreateLabels API request.
func (r CreateLabelsRequest) Send() (*CreateLabelsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateLabelsOutput), nil
}

// CreateLabelsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Adds the specified list of labels to the given resource (a document or folder)
//
//    // Example sending a request using the CreateLabelsRequest method.
//    req := client.CreateLabelsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateLabels
func (c *WorkDocs) CreateLabelsRequest(input *CreateLabelsInput) CreateLabelsRequest {
	op := &aws.Operation{
		Name:       opCreateLabels,
		HTTPMethod: "PUT",
		HTTPPath:   "/api/v1/resources/{ResourceId}/labels",
	}

	if input == nil {
		input = &CreateLabelsInput{}
	}

	output := &CreateLabelsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateLabelsRequest{Request: req, Input: input, Copy: c.CreateLabelsRequest}
}

const opCreateNotificationSubscription = "CreateNotificationSubscription"

// CreateNotificationSubscriptionRequest is a API request type for the CreateNotificationSubscription API operation.
type CreateNotificationSubscriptionRequest struct {
	*aws.Request
	Input *CreateNotificationSubscriptionInput
	Copy  func(*CreateNotificationSubscriptionInput) CreateNotificationSubscriptionRequest
}

// Send marshals and sends the CreateNotificationSubscription API request.
func (r CreateNotificationSubscriptionRequest) Send() (*CreateNotificationSubscriptionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateNotificationSubscriptionOutput), nil
}

// CreateNotificationSubscriptionRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Configure WorkDocs to use Amazon SNS notifications.
//
// The endpoint receives a confirmation message, and must confirm the subscription.
// For more information, see Confirm the Subscription (http://docs.aws.amazon.com/sns/latest/dg/SendMessageToHttp.html#SendMessageToHttp.confirm)
// in the Amazon Simple Notification Service Developer Guide.
//
//    // Example sending a request using the CreateNotificationSubscriptionRequest method.
//    req := client.CreateNotificationSubscriptionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateNotificationSubscription
func (c *WorkDocs) CreateNotificationSubscriptionRequest(input *CreateNotificationSubscriptionInput) CreateNotificationSubscriptionRequest {
	op := &aws.Operation{
		Name:       opCreateNotificationSubscription,
		HTTPMethod: "POST",
		HTTPPath:   "/api/v1/organizations/{OrganizationId}/subscriptions",
	}

	if input == nil {
		input = &CreateNotificationSubscriptionInput{}
	}

	output := &CreateNotificationSubscriptionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateNotificationSubscriptionRequest{Request: req, Input: input, Copy: c.CreateNotificationSubscriptionRequest}
}

const opCreateUser = "CreateUser"

// CreateUserRequest is a API request type for the CreateUser API operation.
type CreateUserRequest struct {
	*aws.Request
	Input *CreateUserInput
	Copy  func(*CreateUserInput) CreateUserRequest
}

// Send marshals and sends the CreateUser API request.
func (r CreateUserRequest) Send() (*CreateUserOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateUserOutput), nil
}

// CreateUserRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Creates a user in a Simple AD or Microsoft AD directory. The status of a
// newly created user is "ACTIVE". New users can access Amazon WorkDocs.
//
//    // Example sending a request using the CreateUserRequest method.
//    req := client.CreateUserRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateUser
func (c *WorkDocs) CreateUserRequest(input *CreateUserInput) CreateUserRequest {
	op := &aws.Operation{
		Name:       opCreateUser,
		HTTPMethod: "POST",
		HTTPPath:   "/api/v1/users",
	}

	if input == nil {
		input = &CreateUserInput{}
	}

	output := &CreateUserOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateUserRequest{Request: req, Input: input, Copy: c.CreateUserRequest}
}

const opDeactivateUser = "DeactivateUser"

// DeactivateUserRequest is a API request type for the DeactivateUser API operation.
type DeactivateUserRequest struct {
	*aws.Request
	Input *DeactivateUserInput
	Copy  func(*DeactivateUserInput) DeactivateUserRequest
}

// Send marshals and sends the DeactivateUser API request.
func (r DeactivateUserRequest) Send() (*DeactivateUserOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeactivateUserOutput), nil
}

// DeactivateUserRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Deactivates the specified user, which revokes the user's access to Amazon
// WorkDocs.
//
//    // Example sending a request using the DeactivateUserRequest method.
//    req := client.DeactivateUserRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeactivateUser
func (c *WorkDocs) DeactivateUserRequest(input *DeactivateUserInput) DeactivateUserRequest {
	op := &aws.Operation{
		Name:       opDeactivateUser,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/users/{UserId}/activation",
	}

	if input == nil {
		input = &DeactivateUserInput{}
	}

	output := &DeactivateUserOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeactivateUserRequest{Request: req, Input: input, Copy: c.DeactivateUserRequest}
}

const opDeleteComment = "DeleteComment"

// DeleteCommentRequest is a API request type for the DeleteComment API operation.
type DeleteCommentRequest struct {
	*aws.Request
	Input *DeleteCommentInput
	Copy  func(*DeleteCommentInput) DeleteCommentRequest
}

// Send marshals and sends the DeleteComment API request.
func (r DeleteCommentRequest) Send() (*DeleteCommentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteCommentOutput), nil
}

// DeleteCommentRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Deletes the specified comment from the document version.
//
//    // Example sending a request using the DeleteCommentRequest method.
//    req := client.DeleteCommentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteComment
func (c *WorkDocs) DeleteCommentRequest(input *DeleteCommentInput) DeleteCommentRequest {
	op := &aws.Operation{
		Name:       opDeleteComment,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/documents/{DocumentId}/versions/{VersionId}/comment/{CommentId}",
	}

	if input == nil {
		input = &DeleteCommentInput{}
	}

	output := &DeleteCommentOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteCommentRequest{Request: req, Input: input, Copy: c.DeleteCommentRequest}
}

const opDeleteCustomMetadata = "DeleteCustomMetadata"

// DeleteCustomMetadataRequest is a API request type for the DeleteCustomMetadata API operation.
type DeleteCustomMetadataRequest struct {
	*aws.Request
	Input *DeleteCustomMetadataInput
	Copy  func(*DeleteCustomMetadataInput) DeleteCustomMetadataRequest
}

// Send marshals and sends the DeleteCustomMetadata API request.
func (r DeleteCustomMetadataRequest) Send() (*DeleteCustomMetadataOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteCustomMetadataOutput), nil
}

// DeleteCustomMetadataRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Deletes custom metadata from the specified resource.
//
//    // Example sending a request using the DeleteCustomMetadataRequest method.
//    req := client.DeleteCustomMetadataRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteCustomMetadata
func (c *WorkDocs) DeleteCustomMetadataRequest(input *DeleteCustomMetadataInput) DeleteCustomMetadataRequest {
	op := &aws.Operation{
		Name:       opDeleteCustomMetadata,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/resources/{ResourceId}/customMetadata",
	}

	if input == nil {
		input = &DeleteCustomMetadataInput{}
	}

	output := &DeleteCustomMetadataOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteCustomMetadataRequest{Request: req, Input: input, Copy: c.DeleteCustomMetadataRequest}
}

const opDeleteDocument = "DeleteDocument"

// DeleteDocumentRequest is a API request type for the DeleteDocument API operation.
type DeleteDocumentRequest struct {
	*aws.Request
	Input *DeleteDocumentInput
	Copy  func(*DeleteDocumentInput) DeleteDocumentRequest
}

// Send marshals and sends the DeleteDocument API request.
func (r DeleteDocumentRequest) Send() (*DeleteDocumentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteDocumentOutput), nil
}

// DeleteDocumentRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Permanently deletes the specified document and its associated metadata.
//
//    // Example sending a request using the DeleteDocumentRequest method.
//    req := client.DeleteDocumentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteDocument
func (c *WorkDocs) DeleteDocumentRequest(input *DeleteDocumentInput) DeleteDocumentRequest {
	op := &aws.Operation{
		Name:       opDeleteDocument,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/documents/{DocumentId}",
	}

	if input == nil {
		input = &DeleteDocumentInput{}
	}

	output := &DeleteDocumentOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteDocumentRequest{Request: req, Input: input, Copy: c.DeleteDocumentRequest}
}

const opDeleteFolder = "DeleteFolder"

// DeleteFolderRequest is a API request type for the DeleteFolder API operation.
type DeleteFolderRequest struct {
	*aws.Request
	Input *DeleteFolderInput
	Copy  func(*DeleteFolderInput) DeleteFolderRequest
}

// Send marshals and sends the DeleteFolder API request.
func (r DeleteFolderRequest) Send() (*DeleteFolderOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteFolderOutput), nil
}

// DeleteFolderRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Permanently deletes the specified folder and its contents.
//
//    // Example sending a request using the DeleteFolderRequest method.
//    req := client.DeleteFolderRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteFolder
func (c *WorkDocs) DeleteFolderRequest(input *DeleteFolderInput) DeleteFolderRequest {
	op := &aws.Operation{
		Name:       opDeleteFolder,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/folders/{FolderId}",
	}

	if input == nil {
		input = &DeleteFolderInput{}
	}

	output := &DeleteFolderOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteFolderRequest{Request: req, Input: input, Copy: c.DeleteFolderRequest}
}

const opDeleteFolderContents = "DeleteFolderContents"

// DeleteFolderContentsRequest is a API request type for the DeleteFolderContents API operation.
type DeleteFolderContentsRequest struct {
	*aws.Request
	Input *DeleteFolderContentsInput
	Copy  func(*DeleteFolderContentsInput) DeleteFolderContentsRequest
}

// Send marshals and sends the DeleteFolderContents API request.
func (r DeleteFolderContentsRequest) Send() (*DeleteFolderContentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteFolderContentsOutput), nil
}

// DeleteFolderContentsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Deletes the contents of the specified folder.
//
//    // Example sending a request using the DeleteFolderContentsRequest method.
//    req := client.DeleteFolderContentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteFolderContents
func (c *WorkDocs) DeleteFolderContentsRequest(input *DeleteFolderContentsInput) DeleteFolderContentsRequest {
	op := &aws.Operation{
		Name:       opDeleteFolderContents,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/folders/{FolderId}/contents",
	}

	if input == nil {
		input = &DeleteFolderContentsInput{}
	}

	output := &DeleteFolderContentsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteFolderContentsRequest{Request: req, Input: input, Copy: c.DeleteFolderContentsRequest}
}

const opDeleteLabels = "DeleteLabels"

// DeleteLabelsRequest is a API request type for the DeleteLabels API operation.
type DeleteLabelsRequest struct {
	*aws.Request
	Input *DeleteLabelsInput
	Copy  func(*DeleteLabelsInput) DeleteLabelsRequest
}

// Send marshals and sends the DeleteLabels API request.
func (r DeleteLabelsRequest) Send() (*DeleteLabelsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteLabelsOutput), nil
}

// DeleteLabelsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Deletes the specified list of labels from a resource.
//
//    // Example sending a request using the DeleteLabelsRequest method.
//    req := client.DeleteLabelsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteLabels
func (c *WorkDocs) DeleteLabelsRequest(input *DeleteLabelsInput) DeleteLabelsRequest {
	op := &aws.Operation{
		Name:       opDeleteLabels,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/resources/{ResourceId}/labels",
	}

	if input == nil {
		input = &DeleteLabelsInput{}
	}

	output := &DeleteLabelsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteLabelsRequest{Request: req, Input: input, Copy: c.DeleteLabelsRequest}
}

const opDeleteNotificationSubscription = "DeleteNotificationSubscription"

// DeleteNotificationSubscriptionRequest is a API request type for the DeleteNotificationSubscription API operation.
type DeleteNotificationSubscriptionRequest struct {
	*aws.Request
	Input *DeleteNotificationSubscriptionInput
	Copy  func(*DeleteNotificationSubscriptionInput) DeleteNotificationSubscriptionRequest
}

// Send marshals and sends the DeleteNotificationSubscription API request.
func (r DeleteNotificationSubscriptionRequest) Send() (*DeleteNotificationSubscriptionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteNotificationSubscriptionOutput), nil
}

// DeleteNotificationSubscriptionRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Deletes the specified subscription from the specified organization.
//
//    // Example sending a request using the DeleteNotificationSubscriptionRequest method.
//    req := client.DeleteNotificationSubscriptionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteNotificationSubscription
func (c *WorkDocs) DeleteNotificationSubscriptionRequest(input *DeleteNotificationSubscriptionInput) DeleteNotificationSubscriptionRequest {
	op := &aws.Operation{
		Name:       opDeleteNotificationSubscription,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/organizations/{OrganizationId}/subscriptions/{SubscriptionId}",
	}

	if input == nil {
		input = &DeleteNotificationSubscriptionInput{}
	}

	output := &DeleteNotificationSubscriptionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteNotificationSubscriptionRequest{Request: req, Input: input, Copy: c.DeleteNotificationSubscriptionRequest}
}

const opDeleteUser = "DeleteUser"

// DeleteUserRequest is a API request type for the DeleteUser API operation.
type DeleteUserRequest struct {
	*aws.Request
	Input *DeleteUserInput
	Copy  func(*DeleteUserInput) DeleteUserRequest
}

// Send marshals and sends the DeleteUser API request.
func (r DeleteUserRequest) Send() (*DeleteUserOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteUserOutput), nil
}

// DeleteUserRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Deletes the specified user from a Simple AD or Microsoft AD directory.
//
//    // Example sending a request using the DeleteUserRequest method.
//    req := client.DeleteUserRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteUser
func (c *WorkDocs) DeleteUserRequest(input *DeleteUserInput) DeleteUserRequest {
	op := &aws.Operation{
		Name:       opDeleteUser,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/users/{UserId}",
	}

	if input == nil {
		input = &DeleteUserInput{}
	}

	output := &DeleteUserOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteUserRequest{Request: req, Input: input, Copy: c.DeleteUserRequest}
}

const opDescribeActivities = "DescribeActivities"

// DescribeActivitiesRequest is a API request type for the DescribeActivities API operation.
type DescribeActivitiesRequest struct {
	*aws.Request
	Input *DescribeActivitiesInput
	Copy  func(*DescribeActivitiesInput) DescribeActivitiesRequest
}

// Send marshals and sends the DescribeActivities API request.
func (r DescribeActivitiesRequest) Send() (*DescribeActivitiesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeActivitiesOutput), nil
}

// DescribeActivitiesRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Describes the user activities in a specified time period.
//
//    // Example sending a request using the DescribeActivitiesRequest method.
//    req := client.DescribeActivitiesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeActivities
func (c *WorkDocs) DescribeActivitiesRequest(input *DescribeActivitiesInput) DescribeActivitiesRequest {
	op := &aws.Operation{
		Name:       opDescribeActivities,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/activities",
	}

	if input == nil {
		input = &DescribeActivitiesInput{}
	}

	output := &DescribeActivitiesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeActivitiesRequest{Request: req, Input: input, Copy: c.DescribeActivitiesRequest}
}

const opDescribeComments = "DescribeComments"

// DescribeCommentsRequest is a API request type for the DescribeComments API operation.
type DescribeCommentsRequest struct {
	*aws.Request
	Input *DescribeCommentsInput
	Copy  func(*DescribeCommentsInput) DescribeCommentsRequest
}

// Send marshals and sends the DescribeComments API request.
func (r DescribeCommentsRequest) Send() (*DescribeCommentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeCommentsOutput), nil
}

// DescribeCommentsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// List all the comments for the specified document version.
//
//    // Example sending a request using the DescribeCommentsRequest method.
//    req := client.DescribeCommentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeComments
func (c *WorkDocs) DescribeCommentsRequest(input *DescribeCommentsInput) DescribeCommentsRequest {
	op := &aws.Operation{
		Name:       opDescribeComments,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/documents/{DocumentId}/versions/{VersionId}/comments",
	}

	if input == nil {
		input = &DescribeCommentsInput{}
	}

	output := &DescribeCommentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeCommentsRequest{Request: req, Input: input, Copy: c.DescribeCommentsRequest}
}

const opDescribeDocumentVersions = "DescribeDocumentVersions"

// DescribeDocumentVersionsRequest is a API request type for the DescribeDocumentVersions API operation.
type DescribeDocumentVersionsRequest struct {
	*aws.Request
	Input *DescribeDocumentVersionsInput
	Copy  func(*DescribeDocumentVersionsInput) DescribeDocumentVersionsRequest
}

// Send marshals and sends the DescribeDocumentVersions API request.
func (r DescribeDocumentVersionsRequest) Send() (*DescribeDocumentVersionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeDocumentVersionsOutput), nil
}

// DescribeDocumentVersionsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Retrieves the document versions for the specified document.
//
// By default, only active versions are returned.
//
//    // Example sending a request using the DescribeDocumentVersionsRequest method.
//    req := client.DescribeDocumentVersionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeDocumentVersions
func (c *WorkDocs) DescribeDocumentVersionsRequest(input *DescribeDocumentVersionsInput) DescribeDocumentVersionsRequest {
	op := &aws.Operation{
		Name:       opDescribeDocumentVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/documents/{DocumentId}/versions",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"Marker"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeDocumentVersionsInput{}
	}

	output := &DescribeDocumentVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeDocumentVersionsRequest{Request: req, Input: input, Copy: c.DescribeDocumentVersionsRequest}
}

// Paginate pages iterates over the pages of a DescribeDocumentVersionsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeDocumentVersions operation.
//		req := client.DescribeDocumentVersionsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeDocumentVersionsRequest) Paginate(opts ...aws.Option) DescribeDocumentVersionsPager {
	return DescribeDocumentVersionsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *DescribeDocumentVersionsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// DescribeDocumentVersionsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeDocumentVersionsPager struct {
	aws.Pager
}

func (p *DescribeDocumentVersionsPager) CurrentPage() *DescribeDocumentVersionsOutput {
	return p.Pager.CurrentPage().(*DescribeDocumentVersionsOutput)
}

const opDescribeFolderContents = "DescribeFolderContents"

// DescribeFolderContentsRequest is a API request type for the DescribeFolderContents API operation.
type DescribeFolderContentsRequest struct {
	*aws.Request
	Input *DescribeFolderContentsInput
	Copy  func(*DescribeFolderContentsInput) DescribeFolderContentsRequest
}

// Send marshals and sends the DescribeFolderContents API request.
func (r DescribeFolderContentsRequest) Send() (*DescribeFolderContentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeFolderContentsOutput), nil
}

// DescribeFolderContentsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Describes the contents of the specified folder, including its documents and
// subfolders.
//
// By default, Amazon WorkDocs returns the first 100 active document and folder
// metadata items. If there are more results, the response includes a marker
// that you can use to request the next set of results. You can also request
// initialized documents.
//
//    // Example sending a request using the DescribeFolderContentsRequest method.
//    req := client.DescribeFolderContentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeFolderContents
func (c *WorkDocs) DescribeFolderContentsRequest(input *DescribeFolderContentsInput) DescribeFolderContentsRequest {
	op := &aws.Operation{
		Name:       opDescribeFolderContents,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/folders/{FolderId}/contents",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"Marker"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeFolderContentsInput{}
	}

	output := &DescribeFolderContentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeFolderContentsRequest{Request: req, Input: input, Copy: c.DescribeFolderContentsRequest}
}

// Paginate pages iterates over the pages of a DescribeFolderContentsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeFolderContents operation.
//		req := client.DescribeFolderContentsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeFolderContentsRequest) Paginate(opts ...aws.Option) DescribeFolderContentsPager {
	return DescribeFolderContentsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *DescribeFolderContentsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// DescribeFolderContentsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeFolderContentsPager struct {
	aws.Pager
}

func (p *DescribeFolderContentsPager) CurrentPage() *DescribeFolderContentsOutput {
	return p.Pager.CurrentPage().(*DescribeFolderContentsOutput)
}

const opDescribeGroups = "DescribeGroups"

// DescribeGroupsRequest is a API request type for the DescribeGroups API operation.
type DescribeGroupsRequest struct {
	*aws.Request
	Input *DescribeGroupsInput
	Copy  func(*DescribeGroupsInput) DescribeGroupsRequest
}

// Send marshals and sends the DescribeGroups API request.
func (r DescribeGroupsRequest) Send() (*DescribeGroupsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeGroupsOutput), nil
}

// DescribeGroupsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Describes the groups specified by query.
//
//    // Example sending a request using the DescribeGroupsRequest method.
//    req := client.DescribeGroupsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeGroups
func (c *WorkDocs) DescribeGroupsRequest(input *DescribeGroupsInput) DescribeGroupsRequest {
	op := &aws.Operation{
		Name:       opDescribeGroups,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/groups",
	}

	if input == nil {
		input = &DescribeGroupsInput{}
	}

	output := &DescribeGroupsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeGroupsRequest{Request: req, Input: input, Copy: c.DescribeGroupsRequest}
}

const opDescribeNotificationSubscriptions = "DescribeNotificationSubscriptions"

// DescribeNotificationSubscriptionsRequest is a API request type for the DescribeNotificationSubscriptions API operation.
type DescribeNotificationSubscriptionsRequest struct {
	*aws.Request
	Input *DescribeNotificationSubscriptionsInput
	Copy  func(*DescribeNotificationSubscriptionsInput) DescribeNotificationSubscriptionsRequest
}

// Send marshals and sends the DescribeNotificationSubscriptions API request.
func (r DescribeNotificationSubscriptionsRequest) Send() (*DescribeNotificationSubscriptionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeNotificationSubscriptionsOutput), nil
}

// DescribeNotificationSubscriptionsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Lists the specified notification subscriptions.
//
//    // Example sending a request using the DescribeNotificationSubscriptionsRequest method.
//    req := client.DescribeNotificationSubscriptionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeNotificationSubscriptions
func (c *WorkDocs) DescribeNotificationSubscriptionsRequest(input *DescribeNotificationSubscriptionsInput) DescribeNotificationSubscriptionsRequest {
	op := &aws.Operation{
		Name:       opDescribeNotificationSubscriptions,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/organizations/{OrganizationId}/subscriptions",
	}

	if input == nil {
		input = &DescribeNotificationSubscriptionsInput{}
	}

	output := &DescribeNotificationSubscriptionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeNotificationSubscriptionsRequest{Request: req, Input: input, Copy: c.DescribeNotificationSubscriptionsRequest}
}

const opDescribeResourcePermissions = "DescribeResourcePermissions"

// DescribeResourcePermissionsRequest is a API request type for the DescribeResourcePermissions API operation.
type DescribeResourcePermissionsRequest struct {
	*aws.Request
	Input *DescribeResourcePermissionsInput
	Copy  func(*DescribeResourcePermissionsInput) DescribeResourcePermissionsRequest
}

// Send marshals and sends the DescribeResourcePermissions API request.
func (r DescribeResourcePermissionsRequest) Send() (*DescribeResourcePermissionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeResourcePermissionsOutput), nil
}

// DescribeResourcePermissionsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Describes the permissions of a specified resource.
//
//    // Example sending a request using the DescribeResourcePermissionsRequest method.
//    req := client.DescribeResourcePermissionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeResourcePermissions
func (c *WorkDocs) DescribeResourcePermissionsRequest(input *DescribeResourcePermissionsInput) DescribeResourcePermissionsRequest {
	op := &aws.Operation{
		Name:       opDescribeResourcePermissions,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/resources/{ResourceId}/permissions",
	}

	if input == nil {
		input = &DescribeResourcePermissionsInput{}
	}

	output := &DescribeResourcePermissionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeResourcePermissionsRequest{Request: req, Input: input, Copy: c.DescribeResourcePermissionsRequest}
}

const opDescribeRootFolders = "DescribeRootFolders"

// DescribeRootFoldersRequest is a API request type for the DescribeRootFolders API operation.
type DescribeRootFoldersRequest struct {
	*aws.Request
	Input *DescribeRootFoldersInput
	Copy  func(*DescribeRootFoldersInput) DescribeRootFoldersRequest
}

// Send marshals and sends the DescribeRootFolders API request.
func (r DescribeRootFoldersRequest) Send() (*DescribeRootFoldersOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeRootFoldersOutput), nil
}

// DescribeRootFoldersRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Describes the current user's special folders; the RootFolder and the RecycleBin.
// RootFolder is the root of user's files and folders and RecycleBin is the
// root of recycled items. This is not a valid action for SigV4 (administrative
// API) clients.
//
//    // Example sending a request using the DescribeRootFoldersRequest method.
//    req := client.DescribeRootFoldersRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeRootFolders
func (c *WorkDocs) DescribeRootFoldersRequest(input *DescribeRootFoldersInput) DescribeRootFoldersRequest {
	op := &aws.Operation{
		Name:       opDescribeRootFolders,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/me/root",
	}

	if input == nil {
		input = &DescribeRootFoldersInput{}
	}

	output := &DescribeRootFoldersOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeRootFoldersRequest{Request: req, Input: input, Copy: c.DescribeRootFoldersRequest}
}

const opDescribeUsers = "DescribeUsers"

// DescribeUsersRequest is a API request type for the DescribeUsers API operation.
type DescribeUsersRequest struct {
	*aws.Request
	Input *DescribeUsersInput
	Copy  func(*DescribeUsersInput) DescribeUsersRequest
}

// Send marshals and sends the DescribeUsers API request.
func (r DescribeUsersRequest) Send() (*DescribeUsersOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeUsersOutput), nil
}

// DescribeUsersRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Describes the specified users. You can describe all users or filter the results
// (for example, by status or organization).
//
// By default, Amazon WorkDocs returns the first 24 active or pending users.
// If there are more results, the response includes a marker that you can use
// to request the next set of results.
//
//    // Example sending a request using the DescribeUsersRequest method.
//    req := client.DescribeUsersRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeUsers
func (c *WorkDocs) DescribeUsersRequest(input *DescribeUsersInput) DescribeUsersRequest {
	op := &aws.Operation{
		Name:       opDescribeUsers,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/users",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"Marker"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeUsersInput{}
	}

	output := &DescribeUsersOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeUsersRequest{Request: req, Input: input, Copy: c.DescribeUsersRequest}
}

// Paginate pages iterates over the pages of a DescribeUsersRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeUsers operation.
//		req := client.DescribeUsersRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeUsersRequest) Paginate(opts ...aws.Option) DescribeUsersPager {
	return DescribeUsersPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *DescribeUsersInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// DescribeUsersPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeUsersPager struct {
	aws.Pager
}

func (p *DescribeUsersPager) CurrentPage() *DescribeUsersOutput {
	return p.Pager.CurrentPage().(*DescribeUsersOutput)
}

const opGetCurrentUser = "GetCurrentUser"

// GetCurrentUserRequest is a API request type for the GetCurrentUser API operation.
type GetCurrentUserRequest struct {
	*aws.Request
	Input *GetCurrentUserInput
	Copy  func(*GetCurrentUserInput) GetCurrentUserRequest
}

// Send marshals and sends the GetCurrentUser API request.
func (r GetCurrentUserRequest) Send() (*GetCurrentUserOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetCurrentUserOutput), nil
}

// GetCurrentUserRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Retrieves details of the current user for whom the authentication token was
// generated. This is not a valid action for SigV4 (administrative API) clients.
//
//    // Example sending a request using the GetCurrentUserRequest method.
//    req := client.GetCurrentUserRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetCurrentUser
func (c *WorkDocs) GetCurrentUserRequest(input *GetCurrentUserInput) GetCurrentUserRequest {
	op := &aws.Operation{
		Name:       opGetCurrentUser,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/me",
	}

	if input == nil {
		input = &GetCurrentUserInput{}
	}

	output := &GetCurrentUserOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetCurrentUserRequest{Request: req, Input: input, Copy: c.GetCurrentUserRequest}
}

const opGetDocument = "GetDocument"

// GetDocumentRequest is a API request type for the GetDocument API operation.
type GetDocumentRequest struct {
	*aws.Request
	Input *GetDocumentInput
	Copy  func(*GetDocumentInput) GetDocumentRequest
}

// Send marshals and sends the GetDocument API request.
func (r GetDocumentRequest) Send() (*GetDocumentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDocumentOutput), nil
}

// GetDocumentRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Retrieves details of a document.
//
//    // Example sending a request using the GetDocumentRequest method.
//    req := client.GetDocumentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocument
func (c *WorkDocs) GetDocumentRequest(input *GetDocumentInput) GetDocumentRequest {
	op := &aws.Operation{
		Name:       opGetDocument,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/documents/{DocumentId}",
	}

	if input == nil {
		input = &GetDocumentInput{}
	}

	output := &GetDocumentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDocumentRequest{Request: req, Input: input, Copy: c.GetDocumentRequest}
}

const opGetDocumentPath = "GetDocumentPath"

// GetDocumentPathRequest is a API request type for the GetDocumentPath API operation.
type GetDocumentPathRequest struct {
	*aws.Request
	Input *GetDocumentPathInput
	Copy  func(*GetDocumentPathInput) GetDocumentPathRequest
}

// Send marshals and sends the GetDocumentPath API request.
func (r GetDocumentPathRequest) Send() (*GetDocumentPathOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDocumentPathOutput), nil
}

// GetDocumentPathRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Retrieves the path information (the hierarchy from the root folder) for the
// requested document.
//
// By default, Amazon WorkDocs returns a maximum of 100 levels upwards from
// the requested document and only includes the IDs of the parent folders in
// the path. You can limit the maximum number of levels. You can also request
// the names of the parent folders.
//
//    // Example sending a request using the GetDocumentPathRequest method.
//    req := client.GetDocumentPathRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocumentPath
func (c *WorkDocs) GetDocumentPathRequest(input *GetDocumentPathInput) GetDocumentPathRequest {
	op := &aws.Operation{
		Name:       opGetDocumentPath,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/documents/{DocumentId}/path",
	}

	if input == nil {
		input = &GetDocumentPathInput{}
	}

	output := &GetDocumentPathOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDocumentPathRequest{Request: req, Input: input, Copy: c.GetDocumentPathRequest}
}

const opGetDocumentVersion = "GetDocumentVersion"

// GetDocumentVersionRequest is a API request type for the GetDocumentVersion API operation.
type GetDocumentVersionRequest struct {
	*aws.Request
	Input *GetDocumentVersionInput
	Copy  func(*GetDocumentVersionInput) GetDocumentVersionRequest
}

// Send marshals and sends the GetDocumentVersion API request.
func (r GetDocumentVersionRequest) Send() (*GetDocumentVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDocumentVersionOutput), nil
}

// GetDocumentVersionRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Retrieves version metadata for the specified document.
//
//    // Example sending a request using the GetDocumentVersionRequest method.
//    req := client.GetDocumentVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocumentVersion
func (c *WorkDocs) GetDocumentVersionRequest(input *GetDocumentVersionInput) GetDocumentVersionRequest {
	op := &aws.Operation{
		Name:       opGetDocumentVersion,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/documents/{DocumentId}/versions/{VersionId}",
	}

	if input == nil {
		input = &GetDocumentVersionInput{}
	}

	output := &GetDocumentVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDocumentVersionRequest{Request: req, Input: input, Copy: c.GetDocumentVersionRequest}
}

const opGetFolder = "GetFolder"

// GetFolderRequest is a API request type for the GetFolder API operation.
type GetFolderRequest struct {
	*aws.Request
	Input *GetFolderInput
	Copy  func(*GetFolderInput) GetFolderRequest
}

// Send marshals and sends the GetFolder API request.
func (r GetFolderRequest) Send() (*GetFolderOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetFolderOutput), nil
}

// GetFolderRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Retrieves the metadata of the specified folder.
//
//    // Example sending a request using the GetFolderRequest method.
//    req := client.GetFolderRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetFolder
func (c *WorkDocs) GetFolderRequest(input *GetFolderInput) GetFolderRequest {
	op := &aws.Operation{
		Name:       opGetFolder,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/folders/{FolderId}",
	}

	if input == nil {
		input = &GetFolderInput{}
	}

	output := &GetFolderOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetFolderRequest{Request: req, Input: input, Copy: c.GetFolderRequest}
}

const opGetFolderPath = "GetFolderPath"

// GetFolderPathRequest is a API request type for the GetFolderPath API operation.
type GetFolderPathRequest struct {
	*aws.Request
	Input *GetFolderPathInput
	Copy  func(*GetFolderPathInput) GetFolderPathRequest
}

// Send marshals and sends the GetFolderPath API request.
func (r GetFolderPathRequest) Send() (*GetFolderPathOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetFolderPathOutput), nil
}

// GetFolderPathRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Retrieves the path information (the hierarchy from the root folder) for the
// specified folder.
//
// By default, Amazon WorkDocs returns a maximum of 100 levels upwards from
// the requested folder and only includes the IDs of the parent folders in the
// path. You can limit the maximum number of levels. You can also request the
// parent folder names.
//
//    // Example sending a request using the GetFolderPathRequest method.
//    req := client.GetFolderPathRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetFolderPath
func (c *WorkDocs) GetFolderPathRequest(input *GetFolderPathInput) GetFolderPathRequest {
	op := &aws.Operation{
		Name:       opGetFolderPath,
		HTTPMethod: "GET",
		HTTPPath:   "/api/v1/folders/{FolderId}/path",
	}

	if input == nil {
		input = &GetFolderPathInput{}
	}

	output := &GetFolderPathOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetFolderPathRequest{Request: req, Input: input, Copy: c.GetFolderPathRequest}
}

const opInitiateDocumentVersionUpload = "InitiateDocumentVersionUpload"

// InitiateDocumentVersionUploadRequest is a API request type for the InitiateDocumentVersionUpload API operation.
type InitiateDocumentVersionUploadRequest struct {
	*aws.Request
	Input *InitiateDocumentVersionUploadInput
	Copy  func(*InitiateDocumentVersionUploadInput) InitiateDocumentVersionUploadRequest
}

// Send marshals and sends the InitiateDocumentVersionUpload API request.
func (r InitiateDocumentVersionUploadRequest) Send() (*InitiateDocumentVersionUploadOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*InitiateDocumentVersionUploadOutput), nil
}

// InitiateDocumentVersionUploadRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Creates a new document object and version object.
//
// The client specifies the parent folder ID and name of the document to upload.
// The ID is optionally specified when creating a new version of an existing
// document. This is the first step to upload a document. Next, upload the document
// to the URL returned from the call, and then call UpdateDocumentVersion.
//
// To cancel the document upload, call AbortDocumentVersionUpload.
//
//    // Example sending a request using the InitiateDocumentVersionUploadRequest method.
//    req := client.InitiateDocumentVersionUploadRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/InitiateDocumentVersionUpload
func (c *WorkDocs) InitiateDocumentVersionUploadRequest(input *InitiateDocumentVersionUploadInput) InitiateDocumentVersionUploadRequest {
	op := &aws.Operation{
		Name:       opInitiateDocumentVersionUpload,
		HTTPMethod: "POST",
		HTTPPath:   "/api/v1/documents",
	}

	if input == nil {
		input = &InitiateDocumentVersionUploadInput{}
	}

	output := &InitiateDocumentVersionUploadOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return InitiateDocumentVersionUploadRequest{Request: req, Input: input, Copy: c.InitiateDocumentVersionUploadRequest}
}

const opRemoveAllResourcePermissions = "RemoveAllResourcePermissions"

// RemoveAllResourcePermissionsRequest is a API request type for the RemoveAllResourcePermissions API operation.
type RemoveAllResourcePermissionsRequest struct {
	*aws.Request
	Input *RemoveAllResourcePermissionsInput
	Copy  func(*RemoveAllResourcePermissionsInput) RemoveAllResourcePermissionsRequest
}

// Send marshals and sends the RemoveAllResourcePermissions API request.
func (r RemoveAllResourcePermissionsRequest) Send() (*RemoveAllResourcePermissionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RemoveAllResourcePermissionsOutput), nil
}

// RemoveAllResourcePermissionsRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Removes all the permissions from the specified resource.
//
//    // Example sending a request using the RemoveAllResourcePermissionsRequest method.
//    req := client.RemoveAllResourcePermissionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/RemoveAllResourcePermissions
func (c *WorkDocs) RemoveAllResourcePermissionsRequest(input *RemoveAllResourcePermissionsInput) RemoveAllResourcePermissionsRequest {
	op := &aws.Operation{
		Name:       opRemoveAllResourcePermissions,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/resources/{ResourceId}/permissions",
	}

	if input == nil {
		input = &RemoveAllResourcePermissionsInput{}
	}

	output := &RemoveAllResourcePermissionsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return RemoveAllResourcePermissionsRequest{Request: req, Input: input, Copy: c.RemoveAllResourcePermissionsRequest}
}

const opRemoveResourcePermission = "RemoveResourcePermission"

// RemoveResourcePermissionRequest is a API request type for the RemoveResourcePermission API operation.
type RemoveResourcePermissionRequest struct {
	*aws.Request
	Input *RemoveResourcePermissionInput
	Copy  func(*RemoveResourcePermissionInput) RemoveResourcePermissionRequest
}

// Send marshals and sends the RemoveResourcePermission API request.
func (r RemoveResourcePermissionRequest) Send() (*RemoveResourcePermissionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RemoveResourcePermissionOutput), nil
}

// RemoveResourcePermissionRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Removes the permission for the specified principal from the specified resource.
//
//    // Example sending a request using the RemoveResourcePermissionRequest method.
//    req := client.RemoveResourcePermissionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/RemoveResourcePermission
func (c *WorkDocs) RemoveResourcePermissionRequest(input *RemoveResourcePermissionInput) RemoveResourcePermissionRequest {
	op := &aws.Operation{
		Name:       opRemoveResourcePermission,
		HTTPMethod: "DELETE",
		HTTPPath:   "/api/v1/resources/{ResourceId}/permissions/{PrincipalId}",
	}

	if input == nil {
		input = &RemoveResourcePermissionInput{}
	}

	output := &RemoveResourcePermissionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return RemoveResourcePermissionRequest{Request: req, Input: input, Copy: c.RemoveResourcePermissionRequest}
}

const opUpdateDocument = "UpdateDocument"

// UpdateDocumentRequest is a API request type for the UpdateDocument API operation.
type UpdateDocumentRequest struct {
	*aws.Request
	Input *UpdateDocumentInput
	Copy  func(*UpdateDocumentInput) UpdateDocumentRequest
}

// Send marshals and sends the UpdateDocument API request.
func (r UpdateDocumentRequest) Send() (*UpdateDocumentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDocumentOutput), nil
}

// UpdateDocumentRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Updates the specified attributes of a document. The user must have access
// to both the document and its parent folder, if applicable.
//
//    // Example sending a request using the UpdateDocumentRequest method.
//    req := client.UpdateDocumentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateDocument
func (c *WorkDocs) UpdateDocumentRequest(input *UpdateDocumentInput) UpdateDocumentRequest {
	op := &aws.Operation{
		Name:       opUpdateDocument,
		HTTPMethod: "PATCH",
		HTTPPath:   "/api/v1/documents/{DocumentId}",
	}

	if input == nil {
		input = &UpdateDocumentInput{}
	}

	output := &UpdateDocumentOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateDocumentRequest{Request: req, Input: input, Copy: c.UpdateDocumentRequest}
}

const opUpdateDocumentVersion = "UpdateDocumentVersion"

// UpdateDocumentVersionRequest is a API request type for the UpdateDocumentVersion API operation.
type UpdateDocumentVersionRequest struct {
	*aws.Request
	Input *UpdateDocumentVersionInput
	Copy  func(*UpdateDocumentVersionInput) UpdateDocumentVersionRequest
}

// Send marshals and sends the UpdateDocumentVersion API request.
func (r UpdateDocumentVersionRequest) Send() (*UpdateDocumentVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDocumentVersionOutput), nil
}

// UpdateDocumentVersionRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Changes the status of the document version to ACTIVE.
//
// Amazon WorkDocs also sets its document container to ACTIVE. This is the last
// step in a document upload, after the client uploads the document to an S3-presigned
// URL returned by InitiateDocumentVersionUpload.
//
//    // Example sending a request using the UpdateDocumentVersionRequest method.
//    req := client.UpdateDocumentVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateDocumentVersion
func (c *WorkDocs) UpdateDocumentVersionRequest(input *UpdateDocumentVersionInput) UpdateDocumentVersionRequest {
	op := &aws.Operation{
		Name:       opUpdateDocumentVersion,
		HTTPMethod: "PATCH",
		HTTPPath:   "/api/v1/documents/{DocumentId}/versions/{VersionId}",
	}

	if input == nil {
		input = &UpdateDocumentVersionInput{}
	}

	output := &UpdateDocumentVersionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateDocumentVersionRequest{Request: req, Input: input, Copy: c.UpdateDocumentVersionRequest}
}

const opUpdateFolder = "UpdateFolder"

// UpdateFolderRequest is a API request type for the UpdateFolder API operation.
type UpdateFolderRequest struct {
	*aws.Request
	Input *UpdateFolderInput
	Copy  func(*UpdateFolderInput) UpdateFolderRequest
}

// Send marshals and sends the UpdateFolder API request.
func (r UpdateFolderRequest) Send() (*UpdateFolderOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateFolderOutput), nil
}

// UpdateFolderRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Updates the specified attributes of the specified folder. The user must have
// access to both the folder and its parent folder, if applicable.
//
//    // Example sending a request using the UpdateFolderRequest method.
//    req := client.UpdateFolderRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateFolder
func (c *WorkDocs) UpdateFolderRequest(input *UpdateFolderInput) UpdateFolderRequest {
	op := &aws.Operation{
		Name:       opUpdateFolder,
		HTTPMethod: "PATCH",
		HTTPPath:   "/api/v1/folders/{FolderId}",
	}

	if input == nil {
		input = &UpdateFolderInput{}
	}

	output := &UpdateFolderOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateFolderRequest{Request: req, Input: input, Copy: c.UpdateFolderRequest}
}

const opUpdateUser = "UpdateUser"

// UpdateUserRequest is a API request type for the UpdateUser API operation.
type UpdateUserRequest struct {
	*aws.Request
	Input *UpdateUserInput
	Copy  func(*UpdateUserInput) UpdateUserRequest
}

// Send marshals and sends the UpdateUser API request.
func (r UpdateUserRequest) Send() (*UpdateUserOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateUserOutput), nil
}

// UpdateUserRequest returns a request value for making API operation for
// Amazon WorkDocs.
//
// Updates the specified attributes of the specified user, and grants or revokes
// administrative privileges to the Amazon WorkDocs site.
//
//    // Example sending a request using the UpdateUserRequest method.
//    req := client.UpdateUserRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateUser
func (c *WorkDocs) UpdateUserRequest(input *UpdateUserInput) UpdateUserRequest {
	op := &aws.Operation{
		Name:       opUpdateUser,
		HTTPMethod: "PATCH",
		HTTPPath:   "/api/v1/users/{UserId}",
	}

	if input == nil {
		input = &UpdateUserInput{}
	}

	output := &UpdateUserOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateUserRequest{Request: req, Input: input, Copy: c.UpdateUserRequest}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/AbortDocumentVersionUploadRequest
type AbortDocumentVersionUploadInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// The ID of the version.
	//
	// VersionId is a required field
	VersionId *string `location:"uri" locationName:"VersionId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s AbortDocumentVersionUploadInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AbortDocumentVersionUploadInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AbortDocumentVersionUploadInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AbortDocumentVersionUploadInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}

	if s.VersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VersionId"))
	}
	if s.VersionId != nil && len(*s.VersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AbortDocumentVersionUploadInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/AbortDocumentVersionUploadOutput
type AbortDocumentVersionUploadOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AbortDocumentVersionUploadOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AbortDocumentVersionUploadOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AbortDocumentVersionUploadOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AbortDocumentVersionUploadOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/ActivateUserRequest
type ActivateUserInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the user.
	//
	// UserId is a required field
	UserId *string `location:"uri" locationName:"UserId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ActivateUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ActivateUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ActivateUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ActivateUserInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.UserId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UserId"))
	}
	if s.UserId != nil && len(*s.UserId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("UserId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ActivateUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserId != nil {
		v := *s.UserId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "UserId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/ActivateUserResponse
type ActivateUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The user information.
	User *User `type:"structure"`
}

// String returns the string representation
func (s ActivateUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ActivateUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ActivateUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ActivateUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.User != nil {
		v := s.User

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "User", v, metadata)
	}
	return nil
}

// Describes the activity information.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/Activity
type Activity struct {
	_ struct{} `type:"structure"`

	// Metadata of the commenting activity. This is an optional field and is filled
	// for commenting activities.
	CommentMetadata *CommentMetadata `type:"structure"`

	// The user who performed the action.
	Initiator *UserMetadata `type:"structure"`

	// The ID of the organization.
	OrganizationId *string `min:"1" type:"string"`

	// The original parent of the resource. This is an optional field and is filled
	// for move activities.
	OriginalParent *ResourceMetadata `type:"structure"`

	// The list of users or groups impacted by this action. This is an optional
	// field and is filled for the following sharing activities: DOCUMENT_SHARED,
	// DOCUMENT_SHARED, DOCUMENT_UNSHARED, FOLDER_SHARED, FOLDER_UNSHARED.
	Participants *Participants `type:"structure"`

	// The metadata of the resource involved in the user action.
	ResourceMetadata *ResourceMetadata `type:"structure"`

	// The timestamp when the action was performed.
	TimeStamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The activity type.
	Type ActivityType `type:"string" enum:"true"`
}

// String returns the string representation
func (s Activity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Activity) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Activity) MarshalFields(e protocol.FieldEncoder) error {
	if s.CommentMetadata != nil {
		v := s.CommentMetadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CommentMetadata", v, metadata)
	}
	if s.Initiator != nil {
		v := s.Initiator

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Initiator", v, metadata)
	}
	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OrganizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OriginalParent != nil {
		v := s.OriginalParent

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "OriginalParent", v, metadata)
	}
	if s.Participants != nil {
		v := s.Participants

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Participants", v, metadata)
	}
	if s.ResourceMetadata != nil {
		v := s.ResourceMetadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ResourceMetadata", v, metadata)
	}
	if s.TimeStamp != nil {
		v := *s.TimeStamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TimeStamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/AddResourcePermissionsRequest
type AddResourcePermissionsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The notification options.
	NotificationOptions *NotificationOptions `type:"structure"`

	// The users, groups, or organization being granted permission.
	//
	// Principals is a required field
	Principals []SharePrincipal `type:"list" required:"true"`

	// The ID of the resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s AddResourcePermissionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddResourcePermissionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AddResourcePermissionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AddResourcePermissionsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.Principals == nil {
		invalidParams.Add(aws.NewErrParamRequired("Principals"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}
	if s.Principals != nil {
		for i, v := range s.Principals {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Principals", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddResourcePermissionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.NotificationOptions != nil {
		v := s.NotificationOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "NotificationOptions", v, metadata)
	}
	if len(s.Principals) > 0 {
		v := s.Principals

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Principals", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/AddResourcePermissionsResponse
type AddResourcePermissionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The share results.
	ShareResults []ShareResult `type:"list"`
}

// String returns the string representation
func (s AddResourcePermissionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddResourcePermissionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AddResourcePermissionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddResourcePermissionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ShareResults) > 0 {
		v := s.ShareResults

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ShareResults", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Describes a comment.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/Comment
type Comment struct {
	_ struct{} `type:"structure"`

	// The ID of the comment.
	//
	// CommentId is a required field
	CommentId *string `min:"1" type:"string" required:"true"`

	// The details of the user who made the comment.
	Contributor *User `type:"structure"`

	// The time that the comment was created.
	CreatedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the parent comment.
	ParentId *string `min:"1" type:"string"`

	// If the comment is a reply to another user's comment, this field contains
	// the user ID of the user being replied to.
	RecipientId *string `min:"1" type:"string"`

	// The status of the comment.
	Status CommentStatusType `type:"string" enum:"true"`

	// The text of the comment.
	Text *string `min:"1" type:"string"`

	// The ID of the root comment in the thread.
	ThreadId *string `min:"1" type:"string"`

	// The visibility of the comment. Options are either PRIVATE, where the comment
	// is visible only to the comment author and document owner and co-owners, or
	// PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
	Visibility CommentVisibilityType `type:"string" enum:"true"`
}

// String returns the string representation
func (s Comment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Comment) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Comment) MarshalFields(e protocol.FieldEncoder) error {
	if s.CommentId != nil {
		v := *s.CommentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CommentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Contributor != nil {
		v := s.Contributor

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Contributor", v, metadata)
	}
	if s.CreatedTimestamp != nil {
		v := *s.CreatedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ParentId != nil {
		v := *s.ParentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecipientId != nil {
		v := *s.RecipientId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecipientId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Text != nil {
		v := *s.Text

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Text", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThreadId != nil {
		v := *s.ThreadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ThreadId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Visibility) > 0 {
		v := s.Visibility

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Visibility", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes the metadata of a comment.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CommentMetadata
type CommentMetadata struct {
	_ struct{} `type:"structure"`

	// The ID of the comment.
	CommentId *string `min:"1" type:"string"`

	// The status of the comment.
	CommentStatus CommentStatusType `type:"string" enum:"true"`

	// The user who made the comment.
	Contributor *User `type:"structure"`

	// The timestamp that the comment was created.
	CreatedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the user being replied to.
	RecipientId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CommentMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CommentMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CommentId != nil {
		v := *s.CommentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CommentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.CommentStatus) > 0 {
		v := s.CommentStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CommentStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Contributor != nil {
		v := s.Contributor

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Contributor", v, metadata)
	}
	if s.CreatedTimestamp != nil {
		v := *s.CreatedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.RecipientId != nil {
		v := *s.RecipientId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecipientId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateCommentRequest
type CreateCommentInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// Set this parameter to TRUE to send an email out to the document collaborators
	// after the comment is created.
	NotifyCollaborators *bool `type:"boolean"`

	// The ID of the parent comment.
	ParentId *string `min:"1" type:"string"`

	// The text of the comment.
	//
	// Text is a required field
	Text *string `min:"1" type:"string" required:"true"`

	// The ID of the root comment in the thread.
	ThreadId *string `min:"1" type:"string"`

	// The ID of the document version.
	//
	// VersionId is a required field
	VersionId *string `location:"uri" locationName:"VersionId" min:"1" type:"string" required:"true"`

	// The visibility of the comment. Options are either PRIVATE, where the comment
	// is visible only to the comment author and document owner and co-owners, or
	// PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
	Visibility CommentVisibilityType `type:"string" enum:"true"`
}

// String returns the string representation
func (s CreateCommentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCommentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateCommentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateCommentInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}
	if s.ParentId != nil && len(*s.ParentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ParentId", 1))
	}

	if s.Text == nil {
		invalidParams.Add(aws.NewErrParamRequired("Text"))
	}
	if s.Text != nil && len(*s.Text) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Text", 1))
	}
	if s.ThreadId != nil && len(*s.ThreadId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThreadId", 1))
	}

	if s.VersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VersionId"))
	}
	if s.VersionId != nil && len(*s.VersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateCommentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.NotifyCollaborators != nil {
		v := *s.NotifyCollaborators

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NotifyCollaborators", protocol.BoolValue(v), metadata)
	}
	if s.ParentId != nil {
		v := *s.ParentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Text != nil {
		v := *s.Text

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Text", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThreadId != nil {
		v := *s.ThreadId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ThreadId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Visibility) > 0 {
		v := s.Visibility

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Visibility", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateCommentResponse
type CreateCommentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The comment that has been created.
	Comment *Comment `type:"structure"`
}

// String returns the string representation
func (s CreateCommentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCommentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateCommentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateCommentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Comment != nil {
		v := s.Comment

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Comment", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateCustomMetadataRequest
type CreateCustomMetadataInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// Custom metadata in the form of name-value pairs.
	//
	// CustomMetadata is a required field
	CustomMetadata map[string]string `min:"1" type:"map" required:"true"`

	// The ID of the resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" min:"1" type:"string" required:"true"`

	// The ID of the version, if the custom metadata is being added to a document
	// version.
	VersionId *string `location:"querystring" locationName:"versionid" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateCustomMetadataInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCustomMetadataInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateCustomMetadataInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateCustomMetadataInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.CustomMetadata == nil {
		invalidParams.Add(aws.NewErrParamRequired("CustomMetadata"))
	}
	if s.CustomMetadata != nil && len(s.CustomMetadata) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CustomMetadata", 1))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}
	if s.VersionId != nil && len(*s.VersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateCustomMetadataInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.CustomMetadata) > 0 {
		v := s.CustomMetadata

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "CustomMetadata", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "versionid", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateCustomMetadataResponse
type CreateCustomMetadataOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateCustomMetadataOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCustomMetadataOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateCustomMetadataOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateCustomMetadataOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateFolderRequest
type CreateFolderInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The name of the new folder.
	Name *string `min:"1" type:"string"`

	// The ID of the parent folder.
	//
	// ParentFolderId is a required field
	ParentFolderId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateFolderInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFolderInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateFolderInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateFolderInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.ParentFolderId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ParentFolderId"))
	}
	if s.ParentFolderId != nil && len(*s.ParentFolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ParentFolderId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateFolderInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentFolderId != nil {
		v := *s.ParentFolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentFolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateFolderResponse
type CreateFolderOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The metadata of the folder.
	Metadata *FolderMetadata `type:"structure"`
}

// String returns the string representation
func (s CreateFolderOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFolderOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateFolderOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateFolderOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Metadata != nil {
		v := s.Metadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Metadata", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateLabelsRequest
type CreateLabelsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// List of labels to add to the resource.
	//
	// Labels is a required field
	Labels []string `type:"list" required:"true"`

	// The ID of the resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateLabelsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateLabelsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateLabelsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateLabelsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.Labels == nil {
		invalidParams.Add(aws.NewErrParamRequired("Labels"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateLabelsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.Labels) > 0 {
		v := s.Labels

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Labels", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateLabelsResponse
type CreateLabelsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateLabelsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateLabelsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateLabelsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateLabelsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateNotificationSubscriptionRequest
type CreateNotificationSubscriptionInput struct {
	_ struct{} `type:"structure"`

	// The endpoint to receive the notifications. If the protocol is HTTPS, the
	// endpoint is a URL that begins with "https://".
	//
	// Endpoint is a required field
	Endpoint *string `min:"1" type:"string" required:"true"`

	// The ID of the organization.
	//
	// OrganizationId is a required field
	OrganizationId *string `location:"uri" locationName:"OrganizationId" min:"1" type:"string" required:"true"`

	// The protocol to use. The supported value is https, which delivers JSON-encoded
	// messages using HTTPS POST.
	//
	// Protocol is a required field
	Protocol SubscriptionProtocolType `type:"string" required:"true" enum:"true"`

	// The notification type.
	//
	// SubscriptionType is a required field
	SubscriptionType SubscriptionType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s CreateNotificationSubscriptionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateNotificationSubscriptionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateNotificationSubscriptionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateNotificationSubscriptionInput"}

	if s.Endpoint == nil {
		invalidParams.Add(aws.NewErrParamRequired("Endpoint"))
	}
	if s.Endpoint != nil && len(*s.Endpoint) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Endpoint", 1))
	}

	if s.OrganizationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("OrganizationId"))
	}
	if s.OrganizationId != nil && len(*s.OrganizationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OrganizationId", 1))
	}
	if len(s.Protocol) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Protocol"))
	}
	if len(s.SubscriptionType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("SubscriptionType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateNotificationSubscriptionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Endpoint != nil {
		v := *s.Endpoint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Endpoint", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Protocol) > 0 {
		v := s.Protocol

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Protocol", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.SubscriptionType) > 0 {
		v := s.SubscriptionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubscriptionType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "OrganizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateNotificationSubscriptionResponse
type CreateNotificationSubscriptionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The subscription.
	Subscription *Subscription `type:"structure"`
}

// String returns the string representation
func (s CreateNotificationSubscriptionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateNotificationSubscriptionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateNotificationSubscriptionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateNotificationSubscriptionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Subscription != nil {
		v := s.Subscription

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Subscription", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateUserRequest
type CreateUserInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The email address of the user.
	EmailAddress *string `min:"1" type:"string"`

	// The given name of the user.
	//
	// GivenName is a required field
	GivenName *string `min:"1" type:"string" required:"true"`

	// The ID of the organization.
	OrganizationId *string `min:"1" type:"string"`

	// The password of the user.
	//
	// Password is a required field
	Password *string `min:"4" type:"string" required:"true"`

	// The amount of storage for the user.
	StorageRule *StorageRuleType `type:"structure"`

	// The surname of the user.
	//
	// Surname is a required field
	Surname *string `min:"1" type:"string" required:"true"`

	// The time zone ID of the user.
	TimeZoneId *string `min:"1" type:"string"`

	// The login name of the user.
	//
	// Username is a required field
	Username *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateUserInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.EmailAddress != nil && len(*s.EmailAddress) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("EmailAddress", 1))
	}

	if s.GivenName == nil {
		invalidParams.Add(aws.NewErrParamRequired("GivenName"))
	}
	if s.GivenName != nil && len(*s.GivenName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GivenName", 1))
	}
	if s.OrganizationId != nil && len(*s.OrganizationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OrganizationId", 1))
	}

	if s.Password == nil {
		invalidParams.Add(aws.NewErrParamRequired("Password"))
	}
	if s.Password != nil && len(*s.Password) < 4 {
		invalidParams.Add(aws.NewErrParamMinLen("Password", 4))
	}

	if s.Surname == nil {
		invalidParams.Add(aws.NewErrParamRequired("Surname"))
	}
	if s.Surname != nil && len(*s.Surname) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Surname", 1))
	}
	if s.TimeZoneId != nil && len(*s.TimeZoneId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TimeZoneId", 1))
	}

	if s.Username == nil {
		invalidParams.Add(aws.NewErrParamRequired("Username"))
	}
	if s.Username != nil && len(*s.Username) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Username", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.EmailAddress != nil {
		v := *s.EmailAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EmailAddress", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GivenName != nil {
		v := *s.GivenName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GivenName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OrganizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Password != nil {
		v := *s.Password

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Password", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StorageRule != nil {
		v := s.StorageRule

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "StorageRule", v, metadata)
	}
	if s.Surname != nil {
		v := *s.Surname

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Surname", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TimeZoneId != nil {
		v := *s.TimeZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TimeZoneId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/CreateUserResponse
type CreateUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The user information.
	User *User `type:"structure"`
}

// String returns the string representation
func (s CreateUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.User != nil {
		v := s.User

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "User", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeactivateUserRequest
type DeactivateUserInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the user.
	//
	// UserId is a required field
	UserId *string `location:"uri" locationName:"UserId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeactivateUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeactivateUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeactivateUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeactivateUserInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.UserId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UserId"))
	}
	if s.UserId != nil && len(*s.UserId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("UserId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeactivateUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserId != nil {
		v := *s.UserId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "UserId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeactivateUserOutput
type DeactivateUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeactivateUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeactivateUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeactivateUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeactivateUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteCommentRequest
type DeleteCommentInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the comment.
	//
	// CommentId is a required field
	CommentId *string `location:"uri" locationName:"CommentId" min:"1" type:"string" required:"true"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// The ID of the document version.
	//
	// VersionId is a required field
	VersionId *string `location:"uri" locationName:"VersionId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteCommentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCommentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteCommentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteCommentInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.CommentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CommentId"))
	}
	if s.CommentId != nil && len(*s.CommentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CommentId", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}

	if s.VersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VersionId"))
	}
	if s.VersionId != nil && len(*s.VersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteCommentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CommentId != nil {
		v := *s.CommentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "CommentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteCommentOutput
type DeleteCommentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteCommentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCommentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteCommentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteCommentOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteCustomMetadataRequest
type DeleteCustomMetadataInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// Flag to indicate removal of all custom metadata properties from the specified
	// resource.
	DeleteAll *bool `location:"querystring" locationName:"deleteAll" type:"boolean"`

	// List of properties to remove.
	Keys []string `location:"querystring" locationName:"keys" type:"list"`

	// The ID of the resource, either a document or folder.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" min:"1" type:"string" required:"true"`

	// The ID of the version, if the custom metadata is being deleted from a document
	// version.
	VersionId *string `location:"querystring" locationName:"versionId" min:"1" type:"string"`
}

// String returns the string representation
func (s DeleteCustomMetadataInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCustomMetadataInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteCustomMetadataInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteCustomMetadataInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}
	if s.VersionId != nil && len(*s.VersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteCustomMetadataInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DeleteAll != nil {
		v := *s.DeleteAll

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "deleteAll", protocol.BoolValue(v), metadata)
	}
	if len(s.Keys) > 0 {
		v := s.Keys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.QueryTarget, "keys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "versionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteCustomMetadataResponse
type DeleteCustomMetadataOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteCustomMetadataOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCustomMetadataOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteCustomMetadataOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteCustomMetadataOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteDocumentRequest
type DeleteDocumentInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDocumentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDocumentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteDocumentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteDocumentInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDocumentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteDocumentOutput
type DeleteDocumentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteDocumentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDocumentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteDocumentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDocumentOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteFolderContentsRequest
type DeleteFolderContentsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the folder.
	//
	// FolderId is a required field
	FolderId *string `location:"uri" locationName:"FolderId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteFolderContentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFolderContentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteFolderContentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteFolderContentsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.FolderId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FolderId"))
	}
	if s.FolderId != nil && len(*s.FolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FolderId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteFolderContentsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FolderId != nil {
		v := *s.FolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteFolderContentsOutput
type DeleteFolderContentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteFolderContentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFolderContentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteFolderContentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteFolderContentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteFolderRequest
type DeleteFolderInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the folder.
	//
	// FolderId is a required field
	FolderId *string `location:"uri" locationName:"FolderId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteFolderInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFolderInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteFolderInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteFolderInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.FolderId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FolderId"))
	}
	if s.FolderId != nil && len(*s.FolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FolderId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteFolderInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FolderId != nil {
		v := *s.FolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteFolderOutput
type DeleteFolderOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteFolderOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFolderOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteFolderOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteFolderOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteLabelsRequest
type DeleteLabelsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// Flag to request removal of all labels from the specified resource.
	DeleteAll *bool `location:"querystring" locationName:"deleteAll" type:"boolean"`

	// List of labels to delete from the resource.
	Labels []string `location:"querystring" locationName:"labels" type:"list"`

	// The ID of the resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteLabelsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteLabelsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteLabelsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteLabelsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteLabelsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DeleteAll != nil {
		v := *s.DeleteAll

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "deleteAll", protocol.BoolValue(v), metadata)
	}
	if len(s.Labels) > 0 {
		v := s.Labels

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.QueryTarget, "labels", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteLabelsResponse
type DeleteLabelsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteLabelsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteLabelsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteLabelsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteLabelsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteNotificationSubscriptionRequest
type DeleteNotificationSubscriptionInput struct {
	_ struct{} `type:"structure"`

	// The ID of the organization.
	//
	// OrganizationId is a required field
	OrganizationId *string `location:"uri" locationName:"OrganizationId" min:"1" type:"string" required:"true"`

	// The ID of the subscription.
	//
	// SubscriptionId is a required field
	SubscriptionId *string `location:"uri" locationName:"SubscriptionId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteNotificationSubscriptionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteNotificationSubscriptionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteNotificationSubscriptionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteNotificationSubscriptionInput"}

	if s.OrganizationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("OrganizationId"))
	}
	if s.OrganizationId != nil && len(*s.OrganizationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OrganizationId", 1))
	}

	if s.SubscriptionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("SubscriptionId"))
	}
	if s.SubscriptionId != nil && len(*s.SubscriptionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SubscriptionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteNotificationSubscriptionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "OrganizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SubscriptionId != nil {
		v := *s.SubscriptionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "SubscriptionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteNotificationSubscriptionOutput
type DeleteNotificationSubscriptionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteNotificationSubscriptionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteNotificationSubscriptionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteNotificationSubscriptionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteNotificationSubscriptionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteUserRequest
type DeleteUserInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the user.
	//
	// UserId is a required field
	UserId *string `location:"uri" locationName:"UserId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteUserInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.UserId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UserId"))
	}
	if s.UserId != nil && len(*s.UserId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("UserId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserId != nil {
		v := *s.UserId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "UserId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DeleteUserOutput
type DeleteUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeActivitiesRequest
type DescribeActivitiesInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The timestamp that determines the end time of the activities. The response
	// includes the activities performed before the specified timestamp.
	EndTime *time.Time `location:"querystring" locationName:"endTime" type:"timestamp" timestampFormat:"unix"`

	// The maximum number of items to return.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results.
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`

	// The ID of the organization. This is a mandatory parameter when using administrative
	// API (SigV4) requests.
	OrganizationId *string `location:"querystring" locationName:"organizationId" min:"1" type:"string"`

	// The timestamp that determines the starting time of the activities. The response
	// includes the activities performed after the specified timestamp.
	StartTime *time.Time `location:"querystring" locationName:"startTime" type:"timestamp" timestampFormat:"unix"`

	// The ID of the user who performed the action. The response includes activities
	// pertaining to this user. This is an optional parameter and is only applicable
	// for administrative API (SigV4) requests.
	UserId *string `location:"querystring" locationName:"userId" min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeActivitiesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeActivitiesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeActivitiesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeActivitiesInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}
	if s.OrganizationId != nil && len(*s.OrganizationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OrganizationId", 1))
	}
	if s.UserId != nil && len(*s.UserId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("UserId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeActivitiesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "endTime", protocol.TimeValue{V: v, Format: protocol.RFC822TimeFromat}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "organizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "startTime", protocol.TimeValue{V: v, Format: protocol.RFC822TimeFromat}, metadata)
	}
	if s.UserId != nil {
		v := *s.UserId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "userId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeActivitiesResponse
type DescribeActivitiesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The marker for the next set of results.
	Marker *string `min:"1" type:"string"`

	// The list of activities for the specified user and time period.
	UserActivities []Activity `type:"list"`
}

// String returns the string representation
func (s DescribeActivitiesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeActivitiesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeActivitiesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeActivitiesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.UserActivities) > 0 {
		v := s.UserActivities

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UserActivities", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeCommentsRequest
type DescribeCommentsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// The maximum number of items to return.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results. This marker was received from a previous
	// call.
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`

	// The ID of the document version.
	//
	// VersionId is a required field
	VersionId *string `location:"uri" locationName:"VersionId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeCommentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeCommentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeCommentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeCommentsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}

	if s.VersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VersionId"))
	}
	if s.VersionId != nil && len(*s.VersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeCommentsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeCommentsResponse
type DescribeCommentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The list of comments for the specified document version.
	Comments []Comment `type:"list"`

	// The marker for the next set of results. This marker was received from a previous
	// call.
	Marker *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeCommentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeCommentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeCommentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeCommentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Comments) > 0 {
		v := s.Comments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Comments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeDocumentVersionsRequest
type DescribeDocumentVersionsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// Specify "SOURCE" to include initialized versions and a URL for the source
	// document.
	Fields *string `location:"querystring" locationName:"fields" min:"1" type:"string"`

	// A comma-separated list of values. Specify "INITIALIZED" to include incomplete
	// versions.
	Include *string `location:"querystring" locationName:"include" min:"1" type:"string"`

	// The maximum number of versions to return with this call.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results. (You received this marker from a
	// previous call.)
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeDocumentVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeDocumentVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeDocumentVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeDocumentVersionsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}
	if s.Fields != nil && len(*s.Fields) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Fields", 1))
	}
	if s.Include != nil && len(*s.Include) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Include", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeDocumentVersionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Fields != nil {
		v := *s.Fields

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "fields", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Include != nil {
		v := *s.Include

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "include", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeDocumentVersionsResponse
type DescribeDocumentVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The document versions.
	DocumentVersions []DocumentVersionMetadata `type:"list"`

	// The marker to use when requesting the next set of results. If there are no
	// additional results, the string is empty.
	Marker *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeDocumentVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeDocumentVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeDocumentVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeDocumentVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DocumentVersions) > 0 {
		v := s.DocumentVersions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "DocumentVersions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeFolderContentsRequest
type DescribeFolderContentsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the folder.
	//
	// FolderId is a required field
	FolderId *string `location:"uri" locationName:"FolderId" min:"1" type:"string" required:"true"`

	// The contents to include. Specify "INITIALIZED" to include initialized documents.
	Include *string `location:"querystring" locationName:"include" min:"1" type:"string"`

	// The maximum number of items to return with this call.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results. This marker was received from a previous
	// call.
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`

	// The order for the contents of the folder.
	Order OrderType `location:"querystring" locationName:"order" type:"string" enum:"true"`

	// The sorting criteria.
	Sort ResourceSortType `location:"querystring" locationName:"sort" type:"string" enum:"true"`

	// The type of items.
	Type FolderContentType `location:"querystring" locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s DescribeFolderContentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFolderContentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeFolderContentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeFolderContentsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.FolderId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FolderId"))
	}
	if s.FolderId != nil && len(*s.FolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FolderId", 1))
	}
	if s.Include != nil && len(*s.Include) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Include", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeFolderContentsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FolderId != nil {
		v := *s.FolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Include != nil {
		v := *s.Include

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "include", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Order) > 0 {
		v := s.Order

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "order", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Sort) > 0 {
		v := s.Sort

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "sort", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeFolderContentsResponse
type DescribeFolderContentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The documents in the specified folder.
	Documents []DocumentMetadata `type:"list"`

	// The subfolders in the specified folder.
	Folders []FolderMetadata `type:"list"`

	// The marker to use when requesting the next set of results. If there are no
	// additional results, the string is empty.
	Marker *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeFolderContentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFolderContentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeFolderContentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeFolderContentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Documents) > 0 {
		v := s.Documents

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Documents", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Folders) > 0 {
		v := s.Folders

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Folders", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeGroupsRequest
type DescribeGroupsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The maximum number of items to return with this call.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results. (You received this marker from a
	// previous call.)
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`

	// The ID of the organization.
	OrganizationId *string `location:"querystring" locationName:"organizationId" min:"1" type:"string"`

	// A query to describe groups by group name.
	//
	// SearchQuery is a required field
	SearchQuery *string `location:"querystring" locationName:"searchQuery" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeGroupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGroupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeGroupsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeGroupsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}
	if s.OrganizationId != nil && len(*s.OrganizationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OrganizationId", 1))
	}

	if s.SearchQuery == nil {
		invalidParams.Add(aws.NewErrParamRequired("SearchQuery"))
	}
	if s.SearchQuery != nil && len(*s.SearchQuery) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SearchQuery", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeGroupsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "organizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SearchQuery != nil {
		v := *s.SearchQuery

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "searchQuery", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeGroupsResponse
type DescribeGroupsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The list of groups.
	Groups []GroupMetadata `type:"list"`

	// The marker to use when requesting the next set of results. If there are no
	// additional results, the string is empty.
	Marker *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeGroupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGroupsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeGroupsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeGroupsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Groups) > 0 {
		v := s.Groups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Groups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeNotificationSubscriptionsRequest
type DescribeNotificationSubscriptionsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of items to return with this call.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results. (You received this marker from a
	// previous call.)
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`

	// The ID of the organization.
	//
	// OrganizationId is a required field
	OrganizationId *string `location:"uri" locationName:"OrganizationId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeNotificationSubscriptionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeNotificationSubscriptionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeNotificationSubscriptionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeNotificationSubscriptionsInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}

	if s.OrganizationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("OrganizationId"))
	}
	if s.OrganizationId != nil && len(*s.OrganizationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OrganizationId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeNotificationSubscriptionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "OrganizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeNotificationSubscriptionsResponse
type DescribeNotificationSubscriptionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The marker to use when requesting the next set of results. If there are no
	// additional results, the string is empty.
	Marker *string `min:"1" type:"string"`

	// The subscriptions.
	Subscriptions []Subscription `type:"list"`
}

// String returns the string representation
func (s DescribeNotificationSubscriptionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeNotificationSubscriptionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeNotificationSubscriptionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeNotificationSubscriptionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Subscriptions) > 0 {
		v := s.Subscriptions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Subscriptions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeResourcePermissionsRequest
type DescribeResourcePermissionsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The maximum number of items to return with this call.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results. (You received this marker from a
	// previous call)
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`

	// The ID of the principal to filter permissions by.
	PrincipalId *string `location:"querystring" locationName:"principalId" min:"1" type:"string"`

	// The ID of the resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeResourcePermissionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeResourcePermissionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeResourcePermissionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeResourcePermissionsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}
	if s.PrincipalId != nil && len(*s.PrincipalId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PrincipalId", 1))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeResourcePermissionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PrincipalId != nil {
		v := *s.PrincipalId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "principalId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeResourcePermissionsResponse
type DescribeResourcePermissionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The marker to use when requesting the next set of results. If there are no
	// additional results, the string is empty.
	Marker *string `min:"1" type:"string"`

	// The principals.
	Principals []Principal `type:"list"`
}

// String returns the string representation
func (s DescribeResourcePermissionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeResourcePermissionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeResourcePermissionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeResourcePermissionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Principals) > 0 {
		v := s.Principals

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Principals", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeRootFoldersRequest
type DescribeRootFoldersInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	//
	// AuthenticationToken is a required field
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string" required:"true"`

	// The maximum number of items to return.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results. (You received this marker from a
	// previous call.)
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeRootFoldersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRootFoldersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeRootFoldersInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeRootFoldersInput"}

	if s.AuthenticationToken == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthenticationToken"))
	}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeRootFoldersInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeRootFoldersResponse
type DescribeRootFoldersOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The user's special folders.
	Folders []FolderMetadata `type:"list"`

	// The marker for the next set of results.
	Marker *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeRootFoldersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRootFoldersOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeRootFoldersOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeRootFoldersOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Folders) > 0 {
		v := s.Folders

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Folders", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeUsersRequest
type DescribeUsersInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// A comma-separated list of values. Specify "STORAGE_METADATA" to include the
	// user storage quota and utilization information.
	Fields *string `location:"querystring" locationName:"fields" min:"1" type:"string"`

	// The state of the users. Specify "ALL" to include inactive users.
	Include UserFilterType `location:"querystring" locationName:"include" type:"string" enum:"true"`

	// The maximum number of items to return.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// The marker for the next set of results. (You received this marker from a
	// previous call.)
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`

	// The order for the results.
	Order OrderType `location:"querystring" locationName:"order" type:"string" enum:"true"`

	// The ID of the organization.
	OrganizationId *string `location:"querystring" locationName:"organizationId" min:"1" type:"string"`

	// A query to filter users by user name.
	Query *string `location:"querystring" locationName:"query" min:"1" type:"string"`

	// The sorting criteria.
	Sort UserSortType `location:"querystring" locationName:"sort" type:"string" enum:"true"`

	// The IDs of the users.
	UserIds *string `location:"querystring" locationName:"userIds" min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeUsersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeUsersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeUsersInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeUsersInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.Fields != nil && len(*s.Fields) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Fields", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}
	if s.OrganizationId != nil && len(*s.OrganizationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OrganizationId", 1))
	}
	if s.Query != nil && len(*s.Query) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Query", 1))
	}
	if s.UserIds != nil && len(*s.UserIds) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("UserIds", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeUsersInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Fields != nil {
		v := *s.Fields

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "fields", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Include) > 0 {
		v := s.Include

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "include", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Order) > 0 {
		v := s.Order

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "order", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "organizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Query != nil {
		v := *s.Query

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "query", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Sort) > 0 {
		v := s.Sort

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "sort", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.UserIds != nil {
		v := *s.UserIds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "userIds", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DescribeUsersResponse
type DescribeUsersOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The marker to use when requesting the next set of results. If there are no
	// additional results, the string is empty.
	Marker *string `min:"1" type:"string"`

	// The total number of users included in the results.
	TotalNumberOfUsers *int64 `deprecated:"true" type:"long"`

	// The users.
	Users []User `type:"list"`
}

// String returns the string representation
func (s DescribeUsersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeUsersOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeUsersOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeUsersOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TotalNumberOfUsers != nil {
		v := *s.TotalNumberOfUsers

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalNumberOfUsers", protocol.Int64Value(v), metadata)
	}
	if len(s.Users) > 0 {
		v := s.Users

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Users", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Describes the document.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DocumentMetadata
type DocumentMetadata struct {
	_ struct{} `type:"structure"`

	// The time when the document was created.
	CreatedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the creator.
	CreatorId *string `min:"1" type:"string"`

	// The ID of the document.
	Id *string `min:"1" type:"string"`

	// List of labels on the document.
	Labels []string `type:"list"`

	// The latest version of the document.
	LatestVersionMetadata *DocumentVersionMetadata `type:"structure"`

	// The time when the document was updated.
	ModifiedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the parent folder.
	ParentFolderId *string `min:"1" type:"string"`

	// The resource state.
	ResourceState ResourceStateType `type:"string" enum:"true"`
}

// String returns the string representation
func (s DocumentMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DocumentMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DocumentMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedTimestamp != nil {
		v := *s.CreatedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorId != nil {
		v := *s.CreatorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Labels) > 0 {
		v := s.Labels

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Labels", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.LatestVersionMetadata != nil {
		v := s.LatestVersionMetadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LatestVersionMetadata", v, metadata)
	}
	if s.ModifiedTimestamp != nil {
		v := *s.ModifiedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ModifiedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ParentFolderId != nil {
		v := *s.ParentFolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentFolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceState) > 0 {
		v := s.ResourceState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes a version of a document.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/DocumentVersionMetadata
type DocumentVersionMetadata struct {
	_ struct{} `type:"structure"`

	// The timestamp when the content of the document was originally created.
	ContentCreatedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The timestamp when the content of the document was modified.
	ContentModifiedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The content type of the document.
	ContentType *string `min:"1" type:"string"`

	// The timestamp when the document was first uploaded.
	CreatedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the creator.
	CreatorId *string `min:"1" type:"string"`

	// The ID of the version.
	Id *string `min:"1" type:"string"`

	// The timestamp when the document was last uploaded.
	ModifiedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The name of the version.
	Name *string `min:"1" type:"string"`

	// The signature of the document.
	Signature *string `type:"string"`

	// The size of the document, in bytes.
	Size *int64 `type:"long"`

	// The source of the document.
	Source map[string]string `type:"map"`

	// The status of the document.
	Status DocumentStatusType `type:"string" enum:"true"`

	// The thumbnail of the document.
	Thumbnail map[string]string `type:"map"`
}

// String returns the string representation
func (s DocumentVersionMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DocumentVersionMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DocumentVersionMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContentCreatedTimestamp != nil {
		v := *s.ContentCreatedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentCreatedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ContentModifiedTimestamp != nil {
		v := *s.ContentModifiedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentModifiedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedTimestamp != nil {
		v := *s.CreatedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorId != nil {
		v := *s.CreatorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ModifiedTimestamp != nil {
		v := *s.ModifiedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ModifiedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Signature != nil {
		v := *s.Signature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Signature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Size", protocol.Int64Value(v), metadata)
	}
	if len(s.Source) > 0 {
		v := s.Source

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Source", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Thumbnail) > 0 {
		v := s.Thumbnail

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Thumbnail", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Describes a folder.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/FolderMetadata
type FolderMetadata struct {
	_ struct{} `type:"structure"`

	// The time when the folder was created.
	CreatedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the creator.
	CreatorId *string `min:"1" type:"string"`

	// The ID of the folder.
	Id *string `min:"1" type:"string"`

	// List of labels on the folder.
	Labels []string `type:"list"`

	// The size of the latest version of the folder metadata.
	LatestVersionSize *int64 `type:"long"`

	// The time when the folder was updated.
	ModifiedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The name of the folder.
	Name *string `min:"1" type:"string"`

	// The ID of the parent folder.
	ParentFolderId *string `min:"1" type:"string"`

	// The resource state of the folder.
	ResourceState ResourceStateType `type:"string" enum:"true"`

	// The unique identifier created from the subfolders and documents of the folder.
	Signature *string `type:"string"`

	// The size of the folder metadata.
	Size *int64 `type:"long"`
}

// String returns the string representation
func (s FolderMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FolderMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FolderMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedTimestamp != nil {
		v := *s.CreatedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatorId != nil {
		v := *s.CreatorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatorId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Labels) > 0 {
		v := s.Labels

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Labels", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.LatestVersionSize != nil {
		v := *s.LatestVersionSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LatestVersionSize", protocol.Int64Value(v), metadata)
	}
	if s.ModifiedTimestamp != nil {
		v := *s.ModifiedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ModifiedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentFolderId != nil {
		v := *s.ParentFolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentFolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceState) > 0 {
		v := s.ResourceState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Signature != nil {
		v := *s.Signature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Signature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Size", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetCurrentUserRequest
type GetCurrentUserInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	//
	// AuthenticationToken is a required field
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetCurrentUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCurrentUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetCurrentUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetCurrentUserInput"}

	if s.AuthenticationToken == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthenticationToken"))
	}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetCurrentUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetCurrentUserResponse
type GetCurrentUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Metadata of the user.
	User *User `type:"structure"`
}

// String returns the string representation
func (s GetCurrentUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCurrentUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetCurrentUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetCurrentUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.User != nil {
		v := s.User

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "User", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocumentRequest
type GetDocumentInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// Set this to TRUE to include custom metadata in the response.
	IncludeCustomMetadata *bool `location:"querystring" locationName:"includeCustomMetadata" type:"boolean"`
}

// String returns the string representation
func (s GetDocumentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDocumentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDocumentInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IncludeCustomMetadata != nil {
		v := *s.IncludeCustomMetadata

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "includeCustomMetadata", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocumentResponse
type GetDocumentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The custom metadata on the document.
	CustomMetadata map[string]string `min:"1" type:"map"`

	// The metadata details of the document.
	Metadata *DocumentMetadata `type:"structure"`
}

// String returns the string representation
func (s GetDocumentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDocumentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.CustomMetadata) > 0 {
		v := s.CustomMetadata

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "CustomMetadata", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Metadata != nil {
		v := s.Metadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Metadata", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocumentPathRequest
type GetDocumentPathInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// A comma-separated list of values. Specify NAME to include the names of the
	// parent folders.
	Fields *string `location:"querystring" locationName:"fields" min:"1" type:"string"`

	// The maximum number of levels in the hierarchy to return.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// This value is not supported.
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`
}

// String returns the string representation
func (s GetDocumentPathInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentPathInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDocumentPathInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDocumentPathInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}
	if s.Fields != nil && len(*s.Fields) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Fields", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentPathInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Fields != nil {
		v := *s.Fields

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "fields", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocumentPathResponse
type GetDocumentPathOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The path information.
	Path *ResourcePath `type:"structure"`
}

// String returns the string representation
func (s GetDocumentPathOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentPathOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDocumentPathOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentPathOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Path != nil {
		v := s.Path

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Path", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocumentVersionRequest
type GetDocumentVersionInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// A comma-separated list of values. Specify "SOURCE" to include a URL for the
	// source document.
	Fields *string `location:"querystring" locationName:"fields" min:"1" type:"string"`

	// Set this to TRUE to include custom metadata in the response.
	IncludeCustomMetadata *bool `location:"querystring" locationName:"includeCustomMetadata" type:"boolean"`

	// The version ID of the document.
	//
	// VersionId is a required field
	VersionId *string `location:"uri" locationName:"VersionId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDocumentVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDocumentVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDocumentVersionInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}
	if s.Fields != nil && len(*s.Fields) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Fields", 1))
	}

	if s.VersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VersionId"))
	}
	if s.VersionId != nil && len(*s.VersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentVersionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Fields != nil {
		v := *s.Fields

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "fields", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IncludeCustomMetadata != nil {
		v := *s.IncludeCustomMetadata

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "includeCustomMetadata", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetDocumentVersionResponse
type GetDocumentVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The custom metadata on the document version.
	CustomMetadata map[string]string `min:"1" type:"map"`

	// The version metadata.
	Metadata *DocumentVersionMetadata `type:"structure"`
}

// String returns the string representation
func (s GetDocumentVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDocumentVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.CustomMetadata) > 0 {
		v := s.CustomMetadata

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "CustomMetadata", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Metadata != nil {
		v := s.Metadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Metadata", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetFolderRequest
type GetFolderInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the folder.
	//
	// FolderId is a required field
	FolderId *string `location:"uri" locationName:"FolderId" min:"1" type:"string" required:"true"`

	// Set to TRUE to include custom metadata in the response.
	IncludeCustomMetadata *bool `location:"querystring" locationName:"includeCustomMetadata" type:"boolean"`
}

// String returns the string representation
func (s GetFolderInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFolderInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetFolderInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetFolderInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.FolderId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FolderId"))
	}
	if s.FolderId != nil && len(*s.FolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FolderId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetFolderInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FolderId != nil {
		v := *s.FolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IncludeCustomMetadata != nil {
		v := *s.IncludeCustomMetadata

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "includeCustomMetadata", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetFolderResponse
type GetFolderOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The custom metadata on the folder.
	CustomMetadata map[string]string `min:"1" type:"map"`

	// The metadata of the folder.
	Metadata *FolderMetadata `type:"structure"`
}

// String returns the string representation
func (s GetFolderOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFolderOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetFolderOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetFolderOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.CustomMetadata) > 0 {
		v := s.CustomMetadata

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "CustomMetadata", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Metadata != nil {
		v := s.Metadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Metadata", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetFolderPathRequest
type GetFolderPathInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// A comma-separated list of values. Specify "NAME" to include the names of
	// the parent folders.
	Fields *string `location:"querystring" locationName:"fields" min:"1" type:"string"`

	// The ID of the folder.
	//
	// FolderId is a required field
	FolderId *string `location:"uri" locationName:"FolderId" min:"1" type:"string" required:"true"`

	// The maximum number of levels in the hierarchy to return.
	Limit *int64 `location:"querystring" locationName:"limit" min:"1" type:"integer"`

	// This value is not supported.
	Marker *string `location:"querystring" locationName:"marker" min:"1" type:"string"`
}

// String returns the string representation
func (s GetFolderPathInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFolderPathInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetFolderPathInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetFolderPathInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.Fields != nil && len(*s.Fields) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Fields", 1))
	}

	if s.FolderId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FolderId"))
	}
	if s.FolderId != nil && len(*s.FolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FolderId", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Marker != nil && len(*s.Marker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Marker", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetFolderPathInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FolderId != nil {
		v := *s.FolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Fields != nil {
		v := *s.Fields

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "fields", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GetFolderPathResponse
type GetFolderPathOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The path information.
	Path *ResourcePath `type:"structure"`
}

// String returns the string representation
func (s GetFolderPathOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFolderPathOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetFolderPathOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetFolderPathOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Path != nil {
		v := s.Path

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Path", v, metadata)
	}
	return nil
}

// Describes the metadata of a user group.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/GroupMetadata
type GroupMetadata struct {
	_ struct{} `type:"structure"`

	// The ID of the user group.
	Id *string `min:"1" type:"string"`

	// The name of the group.
	Name *string `type:"string"`
}

// String returns the string representation
func (s GroupMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GroupMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GroupMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/InitiateDocumentVersionUploadRequest
type InitiateDocumentVersionUploadInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The timestamp when the content of the document was originally created.
	ContentCreatedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The timestamp when the content of the document was modified.
	ContentModifiedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The content type of the document.
	ContentType *string `min:"1" type:"string"`

	// The size of the document, in bytes.
	DocumentSizeInBytes *int64 `type:"long"`

	// The ID of the document.
	Id *string `min:"1" type:"string"`

	// The name of the document.
	Name *string `min:"1" type:"string"`

	// The ID of the parent folder.
	//
	// ParentFolderId is a required field
	ParentFolderId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s InitiateDocumentVersionUploadInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InitiateDocumentVersionUploadInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *InitiateDocumentVersionUploadInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "InitiateDocumentVersionUploadInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.ContentType != nil && len(*s.ContentType) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ContentType", 1))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.ParentFolderId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ParentFolderId"))
	}
	if s.ParentFolderId != nil && len(*s.ParentFolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ParentFolderId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InitiateDocumentVersionUploadInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ContentCreatedTimestamp != nil {
		v := *s.ContentCreatedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentCreatedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ContentModifiedTimestamp != nil {
		v := *s.ContentModifiedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentModifiedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentSizeInBytes != nil {
		v := *s.DocumentSizeInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DocumentSizeInBytes", protocol.Int64Value(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentFolderId != nil {
		v := *s.ParentFolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentFolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/InitiateDocumentVersionUploadResponse
type InitiateDocumentVersionUploadOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The document metadata.
	Metadata *DocumentMetadata `type:"structure"`

	// The upload metadata.
	UploadMetadata *UploadMetadata `type:"structure"`
}

// String returns the string representation
func (s InitiateDocumentVersionUploadOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InitiateDocumentVersionUploadOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s InitiateDocumentVersionUploadOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InitiateDocumentVersionUploadOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Metadata != nil {
		v := s.Metadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Metadata", v, metadata)
	}
	if s.UploadMetadata != nil {
		v := s.UploadMetadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "UploadMetadata", v, metadata)
	}
	return nil
}

// Set of options which defines notification preferences of given action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/NotificationOptions
type NotificationOptions struct {
	_ struct{} `type:"structure"`

	// Text value to be included in the email body.
	EmailMessage *string `type:"string"`

	// Boolean value to indicate an email notification should be sent to the receipients.
	SendEmail *bool `type:"boolean"`
}

// String returns the string representation
func (s NotificationOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s NotificationOptions) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NotificationOptions) MarshalFields(e protocol.FieldEncoder) error {
	if s.EmailMessage != nil {
		v := *s.EmailMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EmailMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SendEmail != nil {
		v := *s.SendEmail

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SendEmail", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Describes the users or user groups.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/Participants
type Participants struct {
	_ struct{} `type:"structure"`

	// The list of user groups.
	Groups []GroupMetadata `type:"list"`

	// The list of users.
	Users []UserMetadata `type:"list"`
}

// String returns the string representation
func (s Participants) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Participants) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Participants) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Groups) > 0 {
		v := s.Groups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Groups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Users) > 0 {
		v := s.Users

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Users", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Describes the permissions.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/PermissionInfo
type PermissionInfo struct {
	_ struct{} `type:"structure"`

	// The role of the user.
	Role RoleType `type:"string" enum:"true"`

	// The type of permissions.
	Type RolePermissionType `type:"string" enum:"true"`
}

// String returns the string representation
func (s PermissionInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PermissionInfo) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PermissionInfo) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Role) > 0 {
		v := s.Role

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Role", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes a resource.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/Principal
type Principal struct {
	_ struct{} `type:"structure"`

	// The ID of the resource.
	Id *string `min:"1" type:"string"`

	// The permission information for the resource.
	Roles []PermissionInfo `type:"list"`

	// The type of resource.
	Type PrincipalType `type:"string" enum:"true"`
}

// String returns the string representation
func (s Principal) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Principal) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Principal) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Roles) > 0 {
		v := s.Roles

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Roles", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/RemoveAllResourcePermissionsRequest
type RemoveAllResourcePermissionsInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RemoveAllResourcePermissionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveAllResourcePermissionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RemoveAllResourcePermissionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RemoveAllResourcePermissionsInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveAllResourcePermissionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/RemoveAllResourcePermissionsOutput
type RemoveAllResourcePermissionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s RemoveAllResourcePermissionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveAllResourcePermissionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RemoveAllResourcePermissionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveAllResourcePermissionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/RemoveResourcePermissionRequest
type RemoveResourcePermissionInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The principal ID of the resource.
	//
	// PrincipalId is a required field
	PrincipalId *string `location:"uri" locationName:"PrincipalId" min:"1" type:"string" required:"true"`

	// The principal type of the resource.
	PrincipalType PrincipalType `location:"querystring" locationName:"type" type:"string" enum:"true"`

	// The ID of the resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RemoveResourcePermissionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveResourcePermissionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RemoveResourcePermissionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RemoveResourcePermissionInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.PrincipalId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PrincipalId"))
	}
	if s.PrincipalId != nil && len(*s.PrincipalId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PrincipalId", 1))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveResourcePermissionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PrincipalId != nil {
		v := *s.PrincipalId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "PrincipalId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PrincipalType) > 0 {
		v := s.PrincipalType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/RemoveResourcePermissionOutput
type RemoveResourcePermissionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s RemoveResourcePermissionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveResourcePermissionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RemoveResourcePermissionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveResourcePermissionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes the metadata of a resource.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/ResourceMetadata
type ResourceMetadata struct {
	_ struct{} `type:"structure"`

	// The ID of the resource.
	Id *string `min:"1" type:"string"`

	// The name of the resource.
	Name *string `min:"1" type:"string"`

	// The original name of the resource before a rename operation.
	OriginalName *string `min:"1" type:"string"`

	// The owner of the resource.
	Owner *UserMetadata `type:"structure"`

	// The parent ID of the resource before a rename operation.
	ParentId *string `min:"1" type:"string"`

	// The type of resource.
	Type ResourceType `type:"string" enum:"true"`

	// The version ID of the resource. This is an optional field and is filled for
	// action on document version.
	VersionId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s ResourceMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourceMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourceMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OriginalName != nil {
		v := *s.OriginalName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OriginalName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Owner != nil {
		v := s.Owner

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Owner", v, metadata)
	}
	if s.ParentId != nil {
		v := *s.ParentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes the path information of a resource.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/ResourcePath
type ResourcePath struct {
	_ struct{} `type:"structure"`

	// The components of the resource path.
	Components []ResourcePathComponent `type:"list"`
}

// String returns the string representation
func (s ResourcePath) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourcePath) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourcePath) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Components) > 0 {
		v := s.Components

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Components", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Describes the resource path.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/ResourcePathComponent
type ResourcePathComponent struct {
	_ struct{} `type:"structure"`

	// The ID of the resource path.
	Id *string `min:"1" type:"string"`

	// The name of the resource path.
	Name *string `min:"1" type:"string"`
}

// String returns the string representation
func (s ResourcePathComponent) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourcePathComponent) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourcePathComponent) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes the recipient type and ID, if available.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/SharePrincipal
type SharePrincipal struct {
	_ struct{} `type:"structure"`

	// The ID of the recipient.
	//
	// Id is a required field
	Id *string `min:"1" type:"string" required:"true"`

	// The role of the recipient.
	//
	// Role is a required field
	Role RoleType `type:"string" required:"true" enum:"true"`

	// The type of the recipient.
	//
	// Type is a required field
	Type PrincipalType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s SharePrincipal) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SharePrincipal) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SharePrincipal) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SharePrincipal"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}
	if len(s.Role) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Role"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SharePrincipal) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Role) > 0 {
		v := s.Role

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Role", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes the share results of a resource.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/ShareResult
type ShareResult struct {
	_ struct{} `type:"structure"`

	// The ID of the principal.
	PrincipalId *string `min:"1" type:"string"`

	// The role.
	Role RoleType `type:"string" enum:"true"`

	// The ID of the resource that was shared.
	ShareId *string `min:"1" type:"string"`

	// The status.
	Status ShareStatusType `type:"string" enum:"true"`

	// The status message.
	StatusMessage *string `type:"string"`
}

// String returns the string representation
func (s ShareResult) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ShareResult) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ShareResult) MarshalFields(e protocol.FieldEncoder) error {
	if s.PrincipalId != nil {
		v := *s.PrincipalId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PrincipalId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Role) > 0 {
		v := s.Role

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Role", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ShareId != nil {
		v := *s.ShareId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ShareId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusMessage != nil {
		v := *s.StatusMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StatusMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes the storage for a user.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/StorageRuleType
type StorageRuleType struct {
	_ struct{} `type:"structure"`

	// The amount of storage allocated, in bytes.
	StorageAllocatedInBytes *int64 `type:"long"`

	// The type of storage.
	StorageType StorageType `type:"string" enum:"true"`
}

// String returns the string representation
func (s StorageRuleType) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StorageRuleType) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StorageRuleType) MarshalFields(e protocol.FieldEncoder) error {
	if s.StorageAllocatedInBytes != nil {
		v := *s.StorageAllocatedInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageAllocatedInBytes", protocol.Int64Value(v), metadata)
	}
	if len(s.StorageType) > 0 {
		v := s.StorageType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes a subscription.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/Subscription
type Subscription struct {
	_ struct{} `type:"structure"`

	// The endpoint of the subscription.
	EndPoint *string `min:"1" type:"string"`

	// The protocol of the subscription.
	Protocol SubscriptionProtocolType `type:"string" enum:"true"`

	// The ID of the subscription.
	SubscriptionId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s Subscription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Subscription) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Subscription) MarshalFields(e protocol.FieldEncoder) error {
	if s.EndPoint != nil {
		v := *s.EndPoint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndPoint", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Protocol) > 0 {
		v := s.Protocol

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Protocol", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SubscriptionId != nil {
		v := *s.SubscriptionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubscriptionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateDocumentRequest
type UpdateDocumentInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// The name of the document.
	Name *string `min:"1" type:"string"`

	// The ID of the parent folder.
	ParentFolderId *string `min:"1" type:"string"`

	// The resource state of the document. Only ACTIVE and RECYCLED are supported.
	ResourceState ResourceStateType `type:"string" enum:"true"`
}

// String returns the string representation
func (s UpdateDocumentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDocumentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDocumentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateDocumentInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.ParentFolderId != nil && len(*s.ParentFolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ParentFolderId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDocumentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentFolderId != nil {
		v := *s.ParentFolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentFolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceState) > 0 {
		v := s.ResourceState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateDocumentOutput
type UpdateDocumentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateDocumentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDocumentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateDocumentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDocumentOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateDocumentVersionRequest
type UpdateDocumentVersionInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the document.
	//
	// DocumentId is a required field
	DocumentId *string `location:"uri" locationName:"DocumentId" min:"1" type:"string" required:"true"`

	// The version ID of the document.
	//
	// VersionId is a required field
	VersionId *string `location:"uri" locationName:"VersionId" min:"1" type:"string" required:"true"`

	// The status of the version.
	VersionStatus DocumentVersionStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s UpdateDocumentVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDocumentVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDocumentVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateDocumentVersionInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.DocumentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentId"))
	}
	if s.DocumentId != nil && len(*s.DocumentId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentId", 1))
	}

	if s.VersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VersionId"))
	}
	if s.VersionId != nil && len(*s.VersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDocumentVersionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.VersionStatus) > 0 {
		v := s.VersionStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VersionStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentId != nil {
		v := *s.DocumentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DocumentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "VersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateDocumentVersionOutput
type UpdateDocumentVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateDocumentVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDocumentVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateDocumentVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDocumentVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateFolderRequest
type UpdateFolderInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The ID of the folder.
	//
	// FolderId is a required field
	FolderId *string `location:"uri" locationName:"FolderId" min:"1" type:"string" required:"true"`

	// The name of the folder.
	Name *string `min:"1" type:"string"`

	// The ID of the parent folder.
	ParentFolderId *string `min:"1" type:"string"`

	// The resource state of the folder. Only ACTIVE and RECYCLED are accepted values
	// from the API.
	ResourceState ResourceStateType `type:"string" enum:"true"`
}

// String returns the string representation
func (s UpdateFolderInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFolderInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateFolderInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateFolderInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}

	if s.FolderId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FolderId"))
	}
	if s.FolderId != nil && len(*s.FolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FolderId", 1))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.ParentFolderId != nil && len(*s.ParentFolderId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ParentFolderId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateFolderInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentFolderId != nil {
		v := *s.ParentFolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ParentFolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceState) > 0 {
		v := s.ResourceState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FolderId != nil {
		v := *s.FolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateFolderOutput
type UpdateFolderOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateFolderOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFolderOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateFolderOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateFolderOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateUserRequest
type UpdateUserInput struct {
	_ struct{} `type:"structure"`

	// Amazon WorkDocs authentication token. Do not set this field when using administrative
	// API actions, as in accessing the API using AWS credentials.
	AuthenticationToken *string `location:"header" locationName:"Authentication" min:"1" type:"string"`

	// The given name of the user.
	GivenName *string `min:"1" type:"string"`

	// Boolean value to determine whether the user is granted Poweruser privileges.
	GrantPoweruserPrivileges BooleanEnumType `type:"string" enum:"true"`

	// The locale of the user.
	Locale LocaleType `type:"string" enum:"true"`

	// The amount of storage for the user.
	StorageRule *StorageRuleType `type:"structure"`

	// The surname of the user.
	Surname *string `min:"1" type:"string"`

	// The time zone ID of the user.
	TimeZoneId *string `min:"1" type:"string"`

	// The type of the user.
	Type UserType `type:"string" enum:"true"`

	// The ID of the user.
	//
	// UserId is a required field
	UserId *string `location:"uri" locationName:"UserId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateUserInput"}
	if s.AuthenticationToken != nil && len(*s.AuthenticationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthenticationToken", 1))
	}
	if s.GivenName != nil && len(*s.GivenName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GivenName", 1))
	}
	if s.Surname != nil && len(*s.Surname) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Surname", 1))
	}
	if s.TimeZoneId != nil && len(*s.TimeZoneId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TimeZoneId", 1))
	}

	if s.UserId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UserId"))
	}
	if s.UserId != nil && len(*s.UserId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("UserId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.GivenName != nil {
		v := *s.GivenName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GivenName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.GrantPoweruserPrivileges) > 0 {
		v := s.GrantPoweruserPrivileges

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GrantPoweruserPrivileges", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Locale) > 0 {
		v := s.Locale

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Locale", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StorageRule != nil {
		v := s.StorageRule

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "StorageRule", v, metadata)
	}
	if s.Surname != nil {
		v := *s.Surname

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Surname", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TimeZoneId != nil {
		v := *s.TimeZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TimeZoneId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.AuthenticationToken != nil {
		v := *s.AuthenticationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Authentication", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserId != nil {
		v := *s.UserId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "UserId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UpdateUserResponse
type UpdateUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The user information.
	User *User `type:"structure"`
}

// String returns the string representation
func (s UpdateUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.User != nil {
		v := s.User

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "User", v, metadata)
	}
	return nil
}

// Describes the upload.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UploadMetadata
type UploadMetadata struct {
	_ struct{} `type:"structure"`

	// The signed headers.
	SignedHeaders map[string]string `type:"map"`

	// The URL of the upload.
	UploadUrl *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UploadMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UploadMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UploadMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.SignedHeaders) > 0 {
		v := s.SignedHeaders

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "SignedHeaders", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.UploadUrl != nil {
		v := *s.UploadUrl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UploadUrl", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a user.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/User
type User struct {
	_ struct{} `type:"structure"`

	// The time when the user was created.
	CreatedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The email address of the user.
	EmailAddress *string `min:"1" type:"string"`

	// The given name of the user.
	GivenName *string `min:"1" type:"string"`

	// The ID of the user.
	Id *string `min:"1" type:"string"`

	// The locale of the user.
	Locale LocaleType `type:"string" enum:"true"`

	// The time when the user was modified.
	ModifiedTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the organization.
	OrganizationId *string `min:"1" type:"string"`

	// The ID of the recycle bin folder.
	RecycleBinFolderId *string `min:"1" type:"string"`

	// The ID of the root folder.
	RootFolderId *string `min:"1" type:"string"`

	// The status of the user.
	Status UserStatusType `type:"string" enum:"true"`

	// The storage for the user.
	Storage *UserStorageMetadata `type:"structure"`

	// The surname of the user.
	Surname *string `min:"1" type:"string"`

	// The time zone ID of the user.
	TimeZoneId *string `min:"1" type:"string"`

	// The type of user.
	Type UserType `type:"string" enum:"true"`

	// The login name of the user.
	Username *string `min:"1" type:"string"`
}

// String returns the string representation
func (s User) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s User) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s User) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedTimestamp != nil {
		v := *s.CreatedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.EmailAddress != nil {
		v := *s.EmailAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EmailAddress", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GivenName != nil {
		v := *s.GivenName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GivenName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Locale) > 0 {
		v := s.Locale

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Locale", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ModifiedTimestamp != nil {
		v := *s.ModifiedTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ModifiedTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.OrganizationId != nil {
		v := *s.OrganizationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OrganizationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RecycleBinFolderId != nil {
		v := *s.RecycleBinFolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecycleBinFolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RootFolderId != nil {
		v := *s.RootFolderId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RootFolderId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Storage != nil {
		v := s.Storage

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Storage", v, metadata)
	}
	if s.Surname != nil {
		v := *s.Surname

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Surname", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TimeZoneId != nil {
		v := *s.TimeZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TimeZoneId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes the metadata of the user.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UserMetadata
type UserMetadata struct {
	_ struct{} `type:"structure"`

	// The email address of the user.
	EmailAddress *string `min:"1" type:"string"`

	// The given name of the user before a rename operation.
	GivenName *string `min:"1" type:"string"`

	// The ID of the user.
	Id *string `min:"1" type:"string"`

	// The surname of the user.
	Surname *string `min:"1" type:"string"`

	// The name of the user.
	Username *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UserMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UserMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UserMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.EmailAddress != nil {
		v := *s.EmailAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EmailAddress", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GivenName != nil {
		v := *s.GivenName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GivenName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Surname != nil {
		v := *s.Surname

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Surname", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes the storage for a user.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/workdocs-2016-05-01/UserStorageMetadata
type UserStorageMetadata struct {
	_ struct{} `type:"structure"`

	// The storage for a user.
	StorageRule *StorageRuleType `type:"structure"`

	// The amount of storage used, in bytes.
	StorageUtilizedInBytes *int64 `type:"long"`
}

// String returns the string representation
func (s UserStorageMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UserStorageMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UserStorageMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.StorageRule != nil {
		v := s.StorageRule

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "StorageRule", v, metadata)
	}
	if s.StorageUtilizedInBytes != nil {
		v := *s.StorageUtilizedInBytes

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageUtilizedInBytes", protocol.Int64Value(v), metadata)
	}
	return nil
}

type ActivityType string

// Enum values for ActivityType
const (
	ActivityTypeDocumentCheckedIn                      ActivityType = "DOCUMENT_CHECKED_IN"
	ActivityTypeDocumentCheckedOut                     ActivityType = "DOCUMENT_CHECKED_OUT"
	ActivityTypeDocumentRenamed                        ActivityType = "DOCUMENT_RENAMED"
	ActivityTypeDocumentVersionUploaded                ActivityType = "DOCUMENT_VERSION_UPLOADED"
	ActivityTypeDocumentVersionDeleted                 ActivityType = "DOCUMENT_VERSION_DELETED"
	ActivityTypeDocumentRecycled                       ActivityType = "DOCUMENT_RECYCLED"
	ActivityTypeDocumentRestored                       ActivityType = "DOCUMENT_RESTORED"
	ActivityTypeDocumentReverted                       ActivityType = "DOCUMENT_REVERTED"
	ActivityTypeDocumentShared                         ActivityType = "DOCUMENT_SHARED"
	ActivityTypeDocumentUnshared                       ActivityType = "DOCUMENT_UNSHARED"
	ActivityTypeDocumentSharePermissionChanged         ActivityType = "DOCUMENT_SHARE_PERMISSION_CHANGED"
	ActivityTypeDocumentShareableLinkCreated           ActivityType = "DOCUMENT_SHAREABLE_LINK_CREATED"
	ActivityTypeDocumentShareableLinkRemoved           ActivityType = "DOCUMENT_SHAREABLE_LINK_REMOVED"
	ActivityTypeDocumentShareableLinkPermissionChanged ActivityType = "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED"
	ActivityTypeDocumentMoved                          ActivityType = "DOCUMENT_MOVED"
	ActivityTypeDocumentCommentAdded                   ActivityType = "DOCUMENT_COMMENT_ADDED"
	ActivityTypeDocumentCommentDeleted                 ActivityType = "DOCUMENT_COMMENT_DELETED"
	ActivityTypeDocumentAnnotationAdded                ActivityType = "DOCUMENT_ANNOTATION_ADDED"
	ActivityTypeDocumentAnnotationDeleted              ActivityType = "DOCUMENT_ANNOTATION_DELETED"
	ActivityTypeFolderCreated                          ActivityType = "FOLDER_CREATED"
	ActivityTypeFolderDeleted                          ActivityType = "FOLDER_DELETED"
	ActivityTypeFolderRenamed                          ActivityType = "FOLDER_RENAMED"
	ActivityTypeFolderRecycled                         ActivityType = "FOLDER_RECYCLED"
	ActivityTypeFolderRestored                         ActivityType = "FOLDER_RESTORED"
	ActivityTypeFolderShared                           ActivityType = "FOLDER_SHARED"
	ActivityTypeFolderUnshared                         ActivityType = "FOLDER_UNSHARED"
	ActivityTypeFolderSharePermissionChanged           ActivityType = "FOLDER_SHARE_PERMISSION_CHANGED"
	ActivityTypeFolderShareableLinkCreated             ActivityType = "FOLDER_SHAREABLE_LINK_CREATED"
	ActivityTypeFolderShareableLinkRemoved             ActivityType = "FOLDER_SHAREABLE_LINK_REMOVED"
	ActivityTypeFolderShareableLinkPermissionChanged   ActivityType = "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED"
	ActivityTypeFolderMoved                            ActivityType = "FOLDER_MOVED"
)

func (enum ActivityType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ActivityType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type BooleanEnumType string

// Enum values for BooleanEnumType
const (
	BooleanEnumTypeTrue  BooleanEnumType = "TRUE"
	BooleanEnumTypeFalse BooleanEnumType = "FALSE"
)

func (enum BooleanEnumType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BooleanEnumType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CommentStatusType string

// Enum values for CommentStatusType
const (
	CommentStatusTypeDraft     CommentStatusType = "DRAFT"
	CommentStatusTypePublished CommentStatusType = "PUBLISHED"
	CommentStatusTypeDeleted   CommentStatusType = "DELETED"
)

func (enum CommentStatusType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CommentStatusType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CommentVisibilityType string

// Enum values for CommentVisibilityType
const (
	CommentVisibilityTypePublic  CommentVisibilityType = "PUBLIC"
	CommentVisibilityTypePrivate CommentVisibilityType = "PRIVATE"
)

func (enum CommentVisibilityType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CommentVisibilityType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DocumentSourceType string

// Enum values for DocumentSourceType
const (
	DocumentSourceTypeOriginal     DocumentSourceType = "ORIGINAL"
	DocumentSourceTypeWithComments DocumentSourceType = "WITH_COMMENTS"
)

func (enum DocumentSourceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DocumentSourceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DocumentStatusType string

// Enum values for DocumentStatusType
const (
	DocumentStatusTypeInitialized DocumentStatusType = "INITIALIZED"
	DocumentStatusTypeActive      DocumentStatusType = "ACTIVE"
)

func (enum DocumentStatusType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DocumentStatusType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DocumentThumbnailType string

// Enum values for DocumentThumbnailType
const (
	DocumentThumbnailTypeSmall   DocumentThumbnailType = "SMALL"
	DocumentThumbnailTypeSmallHq DocumentThumbnailType = "SMALL_HQ"
	DocumentThumbnailTypeLarge   DocumentThumbnailType = "LARGE"
)

func (enum DocumentThumbnailType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DocumentThumbnailType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DocumentVersionStatus string

// Enum values for DocumentVersionStatus
const (
	DocumentVersionStatusActive DocumentVersionStatus = "ACTIVE"
)

func (enum DocumentVersionStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DocumentVersionStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type FolderContentType string

// Enum values for FolderContentType
const (
	FolderContentTypeAll      FolderContentType = "ALL"
	FolderContentTypeDocument FolderContentType = "DOCUMENT"
	FolderContentTypeFolder   FolderContentType = "FOLDER"
)

func (enum FolderContentType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum FolderContentType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type LocaleType string

// Enum values for LocaleType
const (
	LocaleTypeEn      LocaleType = "en"
	LocaleTypeFr      LocaleType = "fr"
	LocaleTypeKo      LocaleType = "ko"
	LocaleTypeDe      LocaleType = "de"
	LocaleTypeEs      LocaleType = "es"
	LocaleTypeJa      LocaleType = "ja"
	LocaleTypeRu      LocaleType = "ru"
	LocaleTypeZhCn    LocaleType = "zh_CN"
	LocaleTypeZhTw    LocaleType = "zh_TW"
	LocaleTypePtBr    LocaleType = "pt_BR"
	LocaleTypeDefault LocaleType = "default"
)

func (enum LocaleType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum LocaleType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type OrderType string

// Enum values for OrderType
const (
	OrderTypeAscending  OrderType = "ASCENDING"
	OrderTypeDescending OrderType = "DESCENDING"
)

func (enum OrderType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum OrderType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type PrincipalType string

// Enum values for PrincipalType
const (
	PrincipalTypeUser         PrincipalType = "USER"
	PrincipalTypeGroup        PrincipalType = "GROUP"
	PrincipalTypeInvite       PrincipalType = "INVITE"
	PrincipalTypeAnonymous    PrincipalType = "ANONYMOUS"
	PrincipalTypeOrganization PrincipalType = "ORGANIZATION"
)

func (enum PrincipalType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum PrincipalType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ResourceSortType string

// Enum values for ResourceSortType
const (
	ResourceSortTypeDate ResourceSortType = "DATE"
	ResourceSortTypeName ResourceSortType = "NAME"
)

func (enum ResourceSortType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ResourceSortType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ResourceStateType string

// Enum values for ResourceStateType
const (
	ResourceStateTypeActive    ResourceStateType = "ACTIVE"
	ResourceStateTypeRestoring ResourceStateType = "RESTORING"
	ResourceStateTypeRecycling ResourceStateType = "RECYCLING"
	ResourceStateTypeRecycled  ResourceStateType = "RECYCLED"
)

func (enum ResourceStateType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ResourceStateType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ResourceType string

// Enum values for ResourceType
const (
	ResourceTypeFolder   ResourceType = "FOLDER"
	ResourceTypeDocument ResourceType = "DOCUMENT"
)

func (enum ResourceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ResourceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RolePermissionType string

// Enum values for RolePermissionType
const (
	RolePermissionTypeDirect    RolePermissionType = "DIRECT"
	RolePermissionTypeInherited RolePermissionType = "INHERITED"
)

func (enum RolePermissionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RolePermissionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RoleType string

// Enum values for RoleType
const (
	RoleTypeViewer      RoleType = "VIEWER"
	RoleTypeContributor RoleType = "CONTRIBUTOR"
	RoleTypeOwner       RoleType = "OWNER"
	RoleTypeCoowner     RoleType = "COOWNER"
)

func (enum RoleType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RoleType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ShareStatusType string

// Enum values for ShareStatusType
const (
	ShareStatusTypeSuccess ShareStatusType = "SUCCESS"
	ShareStatusTypeFailure ShareStatusType = "FAILURE"
)

func (enum ShareStatusType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ShareStatusType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type StorageType string

// Enum values for StorageType
const (
	StorageTypeUnlimited StorageType = "UNLIMITED"
	StorageTypeQuota     StorageType = "QUOTA"
)

func (enum StorageType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum StorageType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SubscriptionProtocolType string

// Enum values for SubscriptionProtocolType
const (
	SubscriptionProtocolTypeHttps SubscriptionProtocolType = "HTTPS"
)

func (enum SubscriptionProtocolType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SubscriptionProtocolType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SubscriptionType string

// Enum values for SubscriptionType
const (
	SubscriptionTypeAll SubscriptionType = "ALL"
)

func (enum SubscriptionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SubscriptionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type UserFilterType string

// Enum values for UserFilterType
const (
	UserFilterTypeAll           UserFilterType = "ALL"
	UserFilterTypeActivePending UserFilterType = "ACTIVE_PENDING"
)

func (enum UserFilterType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum UserFilterType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type UserSortType string

// Enum values for UserSortType
const (
	UserSortTypeUserName     UserSortType = "USER_NAME"
	UserSortTypeFullName     UserSortType = "FULL_NAME"
	UserSortTypeStorageLimit UserSortType = "STORAGE_LIMIT"
	UserSortTypeUserStatus   UserSortType = "USER_STATUS"
	UserSortTypeStorageUsed  UserSortType = "STORAGE_USED"
)

func (enum UserSortType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum UserSortType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type UserStatusType string

// Enum values for UserStatusType
const (
	UserStatusTypeActive   UserStatusType = "ACTIVE"
	UserStatusTypeInactive UserStatusType = "INACTIVE"
	UserStatusTypePending  UserStatusType = "PENDING"
)

func (enum UserStatusType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum UserStatusType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type UserType string

// Enum values for UserType
const (
	UserTypeUser           UserType = "USER"
	UserTypeAdmin          UserType = "ADMIN"
	UserTypePoweruser      UserType = "POWERUSER"
	UserTypeMinimaluser    UserType = "MINIMALUSER"
	UserTypeWorkspacesuser UserType = "WORKSPACESUSER"
)

func (enum UserType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum UserType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
