// Code generated by smithy-go-codegen DO NOT EDIT.
package lexruntimeservice

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws/protocol/restjson"
	"github.com/aws/aws-sdk-go-v2/service/lexruntimeservice/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	"io"
	"strings"
)

type awsRestjson1_deserializeOpPostContent struct {
}

func (*awsRestjson1_deserializeOpPostContent) ID() string {
	return "awsRestjson1_deserializeOpPostContent"
}

func (m *awsRestjson1_deserializeOpPostContent) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBuffer bytes.Buffer
		defer response.Body.Close()
		_, err := io.Copy(&errorBuffer, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		errorBody := bytes.NewReader(errorBuffer.Bytes())
		decoder := json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 409:
				errorType = "ConflictException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 406:
				errorType = "NotAcceptableException"
			case 404:
				errorType = "NotFoundException"
			case 408:
				errorType = "RequestTimeoutException"
			case 415:
				errorType = "UnsupportedMediaTypeException"
			case 502:
				errorType = "BadGatewayException"
			case 424:
				errorType = "DependencyFailedException"
			case 508:
				errorType = "LoopDetectedException"
			}
		}

		// reset the ring buffer
		ringBuffer.Reset()
		// seek start of error body
		errorBody.Seek(0, io.SeekStart)

		decoder = json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "ConflictException" {
			errResult := &types.ConflictException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentConflictException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotAcceptableException" {
			errResult := &types.NotAcceptableException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotAcceptableException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "RequestTimeoutException" {
			errResult := &types.RequestTimeoutException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentRequestTimeoutException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "UnsupportedMediaTypeException" {
			errResult := &types.UnsupportedMediaTypeException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentUnsupportedMediaTypeException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "BadGatewayException" {
			errResult := &types.BadGatewayException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadGatewayException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "DependencyFailedException" {
			errResult := &types.DependencyFailedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentDependencyFailedException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LoopDetectedException" {
			errResult := &types.LoopDetectedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentLoopDetectedException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &PostContentOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsPostContentOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestjson1_deserializeOpDocumentPostContentOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsPostContentOutput(v *PostContentOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Content-Type"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.ContentType = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-dialog-state"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.DialogState = types.DialogState(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-input-transcript"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.InputTranscript = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-intent-name"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.IntentName = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-message"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Message = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-message-format"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.MessageFormat = types.MessageFormatType(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-sentiment"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.SentimentResponse = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-session-attributes"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.SessionAttributes = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-session-id"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.SessionId = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-slot-to-elicit"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.SlotToElicit = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-slots"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Slots = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestjson1_deserializeOpDocumentPostContentOutput(v *PostContentOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	v.AudioStream = body
	return nil
}

type awsRestjson1_deserializeOpGetSession struct {
}

func (*awsRestjson1_deserializeOpGetSession) ID() string {
	return "awsRestjson1_deserializeOpGetSession"
}

func (m *awsRestjson1_deserializeOpGetSession) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBuffer bytes.Buffer
		defer response.Body.Close()
		_, err := io.Copy(&errorBuffer, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		errorBody := bytes.NewReader(errorBuffer.Bytes())
		decoder := json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 404:
				errorType = "NotFoundException"
			}
		}

		// reset the ring buffer
		ringBuffer.Reset()
		// seek start of error body
		errorBody.Seek(0, io.SeekStart)

		decoder = json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &GetSessionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentGetSessionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentGetSessionOutput(v **GetSessionOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetSessionOutput
	if *v == nil {
		sv = &GetSessionOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "dialogAction":
			var val *types.DialogAction
			if err := awsRestjson1_deserializeDocumentDialogAction(&val, decoder); err != nil {
				return err
			}
			sv.DialogAction = val

		case "recentIntentSummaryView":
			var col []*types.IntentSummary
			if err := awsRestjson1_deserializeDocumentIntentSummaryList(&col, decoder); err != nil {
				return err
			}
			sv.RecentIntentSummaryView = col

		case "sessionAttributes":
			var col map[string]*string
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			sv.SessionAttributes = col

		case "sessionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SessionId to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SessionId = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

type awsRestjson1_deserializeOpPutSession struct {
}

func (*awsRestjson1_deserializeOpPutSession) ID() string {
	return "awsRestjson1_deserializeOpPutSession"
}

func (m *awsRestjson1_deserializeOpPutSession) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBuffer bytes.Buffer
		defer response.Body.Close()
		_, err := io.Copy(&errorBuffer, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		errorBody := bytes.NewReader(errorBuffer.Bytes())
		decoder := json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 409:
				errorType = "ConflictException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 406:
				errorType = "NotAcceptableException"
			case 404:
				errorType = "NotFoundException"
			case 502:
				errorType = "BadGatewayException"
			case 424:
				errorType = "DependencyFailedException"
			}
		}

		// reset the ring buffer
		ringBuffer.Reset()
		// seek start of error body
		errorBody.Seek(0, io.SeekStart)

		decoder = json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "ConflictException" {
			errResult := &types.ConflictException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentConflictException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotAcceptableException" {
			errResult := &types.NotAcceptableException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotAcceptableException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "BadGatewayException" {
			errResult := &types.BadGatewayException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadGatewayException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "DependencyFailedException" {
			errResult := &types.DependencyFailedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentDependencyFailedException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &PutSessionOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsPutSessionOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestjson1_deserializeOpDocumentPutSessionOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsPutSessionOutput(v *PutSessionOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Content-Type"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.ContentType = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-dialog-state"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.DialogState = types.DialogState(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-intent-name"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.IntentName = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-message"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Message = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-message-format"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.MessageFormat = types.MessageFormatType(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-session-attributes"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.SessionAttributes = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-session-id"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.SessionId = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-slot-to-elicit"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.SlotToElicit = ptr.String(headerValues[0])
	}

	if headerValues := response.Header.Values("x-amz-lex-slots"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Slots = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestjson1_deserializeOpDocumentPutSessionOutput(v *PutSessionOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	v.AudioStream = body
	return nil
}

type awsRestjson1_deserializeOpPostText struct {
}

func (*awsRestjson1_deserializeOpPostText) ID() string {
	return "awsRestjson1_deserializeOpPostText"
}

func (m *awsRestjson1_deserializeOpPostText) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBuffer bytes.Buffer
		defer response.Body.Close()
		_, err := io.Copy(&errorBuffer, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		errorBody := bytes.NewReader(errorBuffer.Bytes())
		decoder := json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 409:
				errorType = "ConflictException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 404:
				errorType = "NotFoundException"
			case 502:
				errorType = "BadGatewayException"
			case 424:
				errorType = "DependencyFailedException"
			case 508:
				errorType = "LoopDetectedException"
			}
		}

		// reset the ring buffer
		ringBuffer.Reset()
		// seek start of error body
		errorBody.Seek(0, io.SeekStart)

		decoder = json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "ConflictException" {
			errResult := &types.ConflictException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentConflictException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "BadGatewayException" {
			errResult := &types.BadGatewayException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadGatewayException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "DependencyFailedException" {
			errResult := &types.DependencyFailedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentDependencyFailedException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LoopDetectedException" {
			errResult := &types.LoopDetectedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentLoopDetectedException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &PostTextOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentPostTextOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentPostTextOutput(v **PostTextOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *PostTextOutput
	if *v == nil {
		sv = &PostTextOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "dialogState":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.DialogState
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected DialogState to be of type string, got %T instead", val)
				}
				ev = types.DialogState(jtv)
			}
			sv.DialogState = ev

		case "intentName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected IntentName to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.IntentName = st

		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		case "messageFormat":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.MessageFormatType
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected MessageFormat to be of type string, got %T instead", val)
				}
				ev = types.MessageFormatType(jtv)
			}
			sv.MessageFormat = ev

		case "responseCard":
			var val *types.ResponseCard
			if err := awsRestjson1_deserializeDocumentResponseCard(&val, decoder); err != nil {
				return err
			}
			sv.ResponseCard = val

		case "sentimentResponse":
			var val *types.SentimentResponse
			if err := awsRestjson1_deserializeDocumentSentimentResponse(&val, decoder); err != nil {
				return err
			}
			sv.SentimentResponse = val

		case "sessionAttributes":
			var col map[string]*string
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			sv.SessionAttributes = col

		case "sessionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SessionId to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SessionId = st

		case "slotToElicit":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SlotToElicit to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SlotToElicit = st

		case "slots":
			var col map[string]*string
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			sv.Slots = col

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

type awsRestjson1_deserializeOpDeleteSession struct {
}

func (*awsRestjson1_deserializeOpDeleteSession) ID() string {
	return "awsRestjson1_deserializeOpDeleteSession"
}

func (m *awsRestjson1_deserializeOpDeleteSession) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBuffer bytes.Buffer
		defer response.Body.Close()
		_, err := io.Copy(&errorBuffer, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		errorBody := bytes.NewReader(errorBuffer.Bytes())
		decoder := json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 409:
				errorType = "ConflictException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 404:
				errorType = "NotFoundException"
			}
		}

		// reset the ring buffer
		ringBuffer.Reset()
		// seek start of error body
		errorBody.Seek(0, io.SeekStart)

		decoder = json.NewDecoder(io.TeeReader(errorBody, ringBuffer))
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "ConflictException" {
			errResult := &types.ConflictException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentConflictException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(&output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &DeleteSessionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentDeleteSessionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentDeleteSessionOutput(v **DeleteSessionOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DeleteSessionOutput
	if *v == nil {
		sv = &DeleteSessionOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "botAlias":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected BotAlias to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.BotAlias = st

		case "botName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected BotName to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.BotName = st

		case "sessionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SessionId to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SessionId = st

		case "userId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected UserId to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.UserId = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentBadRequestException(v **types.BadRequestException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BadRequestException
	if *v == nil {
		sv = &types.BadRequestException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentConflictException(v **types.ConflictException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ConflictException
	if *v == nil {
		sv = &types.ConflictException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentInternalFailureException(v **types.InternalFailureException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InternalFailureException
	if *v == nil {
		sv = &types.InternalFailureException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeHttpBindingsLimitExceededException(v *types.LimitExceededException, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Retry-After"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.RetryAfterSeconds = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestjson1_deserializeDocumentLimitExceededException(v **types.LimitExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.LimitExceededException
	if *v == nil {
		sv = &types.LimitExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentNotAcceptableException(v **types.NotAcceptableException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.NotAcceptableException
	if *v == nil {
		sv = &types.NotAcceptableException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentNotFoundException(v **types.NotFoundException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.NotFoundException
	if *v == nil {
		sv = &types.NotFoundException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentRequestTimeoutException(v **types.RequestTimeoutException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RequestTimeoutException
	if *v == nil {
		sv = &types.RequestTimeoutException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentUnsupportedMediaTypeException(v **types.UnsupportedMediaTypeException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.UnsupportedMediaTypeException
	if *v == nil {
		sv = &types.UnsupportedMediaTypeException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentBadGatewayException(v **types.BadGatewayException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BadGatewayException
	if *v == nil {
		sv = &types.BadGatewayException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentDependencyFailedException(v **types.DependencyFailedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.DependencyFailedException
	if *v == nil {
		sv = &types.DependencyFailedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentLoopDetectedException(v **types.LoopDetectedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.LoopDetectedException
	if *v == nil {
		sv = &types.LoopDetectedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentDialogAction(v **types.DialogAction, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.DialogAction
	if *v == nil {
		sv = &types.DialogAction{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "fulfillmentState":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.FulfillmentState
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FulfillmentState to be of type string, got %T instead", val)
				}
				ev = types.FulfillmentState(jtv)
			}
			sv.FulfillmentState = ev

		case "intentName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected IntentName to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.IntentName = st

		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Message = st

		case "messageFormat":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.MessageFormatType
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected MessageFormat to be of type string, got %T instead", val)
				}
				ev = types.MessageFormatType(jtv)
			}
			sv.MessageFormat = ev

		case "slotToElicit":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SlotToElicit to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SlotToElicit = st

		case "slots":
			var col map[string]*string
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			sv.Slots = col

		case "type":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.DialogActionType
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Type to be of type string, got %T instead", val)
				}
				ev = types.DialogActionType(jtv)
			}
			sv.Type = ev

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentIntentSummary(v **types.IntentSummary, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.IntentSummary
	if *v == nil {
		sv = &types.IntentSummary{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "checkpointLabel":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CheckpointLabel to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.CheckpointLabel = st

		case "confirmationStatus":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.ConfirmationStatus
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ConfirmationStatus to be of type string, got %T instead", val)
				}
				ev = types.ConfirmationStatus(jtv)
			}
			sv.ConfirmationStatus = ev

		case "dialogActionType":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.DialogActionType
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected DialogActionType to be of type string, got %T instead", val)
				}
				ev = types.DialogActionType(jtv)
			}
			sv.DialogActionType = ev

		case "fulfillmentState":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.FulfillmentState
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FulfillmentState to be of type string, got %T instead", val)
				}
				ev = types.FulfillmentState(jtv)
			}
			sv.FulfillmentState = ev

		case "intentName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected IntentName to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.IntentName = st

		case "slotToElicit":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SlotToElicit to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SlotToElicit = st

		case "slots":
			var col map[string]*string
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			sv.Slots = col

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentIntentSummaryList(vp *[]*types.IntentSummary, decoder *json.Decoder) error {
	if vp == nil {
		return fmt.Errorf("unexpected nil of type %T", vp)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.IntentSummary
	if *vp == nil {
		cv = []*types.IntentSummary{}
	} else {
		cv = *vp
	}

	for decoder.More() {
		var val *types.IntentSummary
		if err := awsRestjson1_deserializeDocumentIntentSummary(&val, decoder); err != nil {
			return err
		}
		cv = append(cv, val)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}
	*vp = cv

	return nil
}

func awsRestjson1_deserializeDocumentSentimentResponse(v **types.SentimentResponse, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.SentimentResponse
	if *v == nil {
		sv = &types.SentimentResponse{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "sentimentLabel":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SentimentLabel to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SentimentLabel = st

		case "sentimentScore":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SentimentScore to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SentimentScore = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentStringMap(vp *map[string]*string, decoder *json.Decoder) error {
	if vp == nil {
		return fmt.Errorf("unexpected nil of type %T", vp)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var mv map[string]*string
	if *vp == nil {
		mv = map[string]*string{}
	} else {
		mv = *vp
	}

	for decoder.More() {
		token, err := decoder.Token()
		if err != nil {
			return err
		}

		key, ok := token.(string)
		if !ok {
			return fmt.Errorf("expected map-key of type string, found type %T", token)
		}

		val, err := decoder.Token()
		if err != nil {
			return err
		}
		var st *string
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Value to be of type string, got %T instead", val)
			}
			st = &jtv
		}
		mv[key] = st

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*vp = mv

	return nil
}

func awsRestjson1_deserializeDocumentButton(v **types.Button, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Button
	if *v == nil {
		sv = &types.Button{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "text":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Text to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Text = st

		case "value":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Value to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Value = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentGenericAttachment(v **types.GenericAttachment, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.GenericAttachment
	if *v == nil {
		sv = &types.GenericAttachment{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "attachmentLinkUrl":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected AttachmentLinkUrl to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.AttachmentLinkUrl = st

		case "buttons":
			var col []*types.Button
			if err := awsRestjson1_deserializeDocumentListOfButtons(&col, decoder); err != nil {
				return err
			}
			sv.Buttons = col

		case "imageUrl":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ImageUrl to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.ImageUrl = st

		case "subTitle":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected SubTitle to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.SubTitle = st

		case "title":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Title to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Title = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}

func awsRestjson1_deserializeDocumentGenericAttachmentList(vp *[]*types.GenericAttachment, decoder *json.Decoder) error {
	if vp == nil {
		return fmt.Errorf("unexpected nil of type %T", vp)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.GenericAttachment
	if *vp == nil {
		cv = []*types.GenericAttachment{}
	} else {
		cv = *vp
	}

	for decoder.More() {
		var val *types.GenericAttachment
		if err := awsRestjson1_deserializeDocumentGenericAttachment(&val, decoder); err != nil {
			return err
		}
		cv = append(cv, val)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}
	*vp = cv

	return nil
}

func awsRestjson1_deserializeDocumentListOfButtons(vp *[]*types.Button, decoder *json.Decoder) error {
	if vp == nil {
		return fmt.Errorf("unexpected nil of type %T", vp)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.Button
	if *vp == nil {
		cv = []*types.Button{}
	} else {
		cv = *vp
	}

	for decoder.More() {
		var val *types.Button
		if err := awsRestjson1_deserializeDocumentButton(&val, decoder); err != nil {
			return err
		}
		cv = append(cv, val)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}
	*vp = cv

	return nil
}

func awsRestjson1_deserializeDocumentResponseCard(v **types.ResponseCard, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ResponseCard
	if *v == nil {
		sv = &types.ResponseCard{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "contentType":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var ev types.ContentType
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ContentType to be of type string, got %T instead", val)
				}
				ev = types.ContentType(jtv)
			}
			sv.ContentType = ev

		case "genericAttachments":
			var col []*types.GenericAttachment
			if err := awsRestjson1_deserializeDocumentGenericAttachmentList(&col, decoder); err != nil {
				return err
			}
			sv.GenericAttachments = col

		case "version":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			var st *string
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Version to be of type string, got %T instead", val)
				}
				st = &jtv
			}
			sv.Version = st

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}
	*v = sv

	return nil
}
