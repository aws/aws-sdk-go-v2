// Code generated by smithy-go-codegen DO NOT EDIT.
package lexruntimeservice

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws/protocol/restjson"
	"github.com/aws/aws-sdk-go-v2/service/lexruntimeservice/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	"io"
)

type awsRestjson1_deserializeOpDeleteSession struct {
}

func (*awsRestjson1_deserializeOpDeleteSession) ID() string {
	return "awsRestjson1_deserializeOpDeleteSession"
}

func (m *awsRestjson1_deserializeOpDeleteSession) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBody bytes.Buffer
		_, err := io.Copy(&errorBody, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		body := io.TeeReader(response.Body, ringBuffer)
		defer response.Body.Close()

		decoder := json.NewDecoder(body)
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 409:
				errorType = "ConflictException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 404:
				errorType = "NotFoundException"
			}
		}

		body = io.TeeReader(&errorBody, ringBuffer)
		decoder = json.NewDecoder(&errorBody)
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "ConflictException" {
			errResult := &types.ConflictException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentConflictException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &DeleteSessionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentDeleteSessionOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentDeleteSessionOutput(v *DeleteSessionOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "botAlias":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected BotAlias to be of type *string, got %T instead", val)
			}
			v.BotAlias = ptr.String(st)

		case "botName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected BotName to be of type *string, got %T instead", val)
			}
			v.BotName = ptr.String(st)

		case "sessionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SessionId to be of type *string, got %T instead", val)
			}
			v.SessionId = ptr.String(st)

		case "userId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected UserId to be of type *string, got %T instead", val)
			}
			v.UserId = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpPostText struct {
}

func (*awsRestjson1_deserializeOpPostText) ID() string {
	return "awsRestjson1_deserializeOpPostText"
}

func (m *awsRestjson1_deserializeOpPostText) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBody bytes.Buffer
		_, err := io.Copy(&errorBody, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		body := io.TeeReader(response.Body, ringBuffer)
		defer response.Body.Close()

		decoder := json.NewDecoder(body)
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 409:
				errorType = "ConflictException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 404:
				errorType = "NotFoundException"
			case 502:
				errorType = "BadGatewayException"
			case 424:
				errorType = "DependencyFailedException"
			case 508:
				errorType = "LoopDetectedException"
			}
		}

		body = io.TeeReader(&errorBody, ringBuffer)
		decoder = json.NewDecoder(&errorBody)
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "ConflictException" {
			errResult := &types.ConflictException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentConflictException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "BadGatewayException" {
			errResult := &types.BadGatewayException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadGatewayException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "DependencyFailedException" {
			errResult := &types.DependencyFailedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentDependencyFailedException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LoopDetectedException" {
			errResult := &types.LoopDetectedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentLoopDetectedException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &PostTextOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentPostTextOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentPostTextOutput(v *PostTextOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "dialogState":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected DialogState to be of type types.DialogState, got %T instead", val)
			}
			v.DialogState = types.DialogState(st)

		case "intentName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected IntentName to be of type *string, got %T instead", val)
			}
			v.IntentName = ptr.String(st)

		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		case "messageFormat":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected MessageFormat to be of type types.MessageFormatType, got %T instead", val)
			}
			v.MessageFormat = types.MessageFormatType(st)

		case "responseCard":
			val := types.ResponseCard{}
			if err := awsRestjson1_deserializeDocumentResponseCard(&val, decoder); err != nil {
				return err
			}
			v.ResponseCard = &val

		case "sentimentResponse":
			val := types.SentimentResponse{}
			if err := awsRestjson1_deserializeDocumentSentimentResponse(&val, decoder); err != nil {
				return err
			}
			v.SentimentResponse = &val

		case "sessionAttributes":
			col := map[string]*string{}
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			v.SessionAttributes = col

		case "sessionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SessionId to be of type *string, got %T instead", val)
			}
			v.SessionId = ptr.String(st)

		case "slotToElicit":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SlotToElicit to be of type *string, got %T instead", val)
			}
			v.SlotToElicit = ptr.String(st)

		case "slots":
			col := map[string]*string{}
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			v.Slots = col

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpGetSession struct {
}

func (*awsRestjson1_deserializeOpGetSession) ID() string {
	return "awsRestjson1_deserializeOpGetSession"
}

func (m *awsRestjson1_deserializeOpGetSession) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBody bytes.Buffer
		_, err := io.Copy(&errorBody, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		body := io.TeeReader(response.Body, ringBuffer)
		defer response.Body.Close()

		decoder := json.NewDecoder(body)
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 404:
				errorType = "NotFoundException"
			}
		}

		body = io.TeeReader(&errorBody, ringBuffer)
		decoder = json.NewDecoder(&errorBody)
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &GetSessionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	defer response.Body.Close()

	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsRestjson1_deserializeOpDocumentGetSessionOutput(output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeOpDocumentGetSessionOutput(v *GetSessionOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "dialogAction":
			val := types.DialogAction{}
			if err := awsRestjson1_deserializeDocumentDialogAction(&val, decoder); err != nil {
				return err
			}
			v.DialogAction = &val

		case "recentIntentSummaryView":
			col := []*types.IntentSummary{}
			if err := awsRestjson1_deserializeDocumentIntentSummaryList(&col, decoder); err != nil {
				return err
			}
			v.RecentIntentSummaryView = col

		case "sessionAttributes":
			col := map[string]*string{}
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			v.SessionAttributes = col

		case "sessionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SessionId to be of type *string, got %T instead", val)
			}
			v.SessionId = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

type awsRestjson1_deserializeOpPutSession struct {
}

func (*awsRestjson1_deserializeOpPutSession) ID() string {
	return "awsRestjson1_deserializeOpPutSession"
}

func (m *awsRestjson1_deserializeOpPutSession) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBody bytes.Buffer
		_, err := io.Copy(&errorBody, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		body := io.TeeReader(response.Body, ringBuffer)
		defer response.Body.Close()

		decoder := json.NewDecoder(body)
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 409:
				errorType = "ConflictException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 406:
				errorType = "NotAcceptableException"
			case 404:
				errorType = "NotFoundException"
			case 502:
				errorType = "BadGatewayException"
			case 424:
				errorType = "DependencyFailedException"
			}
		}

		body = io.TeeReader(&errorBody, ringBuffer)
		decoder = json.NewDecoder(&errorBody)
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "ConflictException" {
			errResult := &types.ConflictException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentConflictException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotAcceptableException" {
			errResult := &types.NotAcceptableException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotAcceptableException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "BadGatewayException" {
			errResult := &types.BadGatewayException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadGatewayException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "DependencyFailedException" {
			errResult := &types.DependencyFailedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentDependencyFailedException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &PutSessionOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsPutSessionOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestjson1_deserializeOpDocumentPutSessionOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsPutSessionOutput(v *PutSessionOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("Content-Type"); val != "" {
		v.ContentType = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-dialog-state"); val != "" {
		v.DialogState = types.DialogState(val)
	}

	if val := response.Header.Get("x-amz-lex-intent-name"); val != "" {
		v.IntentName = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-message"); val != "" {
		v.Message = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-message-format"); val != "" {
		v.MessageFormat = types.MessageFormatType(val)
	}

	if val := response.Header.Get("x-amz-lex-session-attributes"); val != "" {
		v.SessionAttributes = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-session-id"); val != "" {
		v.SessionId = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-slot-to-elicit"); val != "" {
		v.SlotToElicit = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-slots"); val != "" {
		v.Slots = ptr.String(val)
	}

	return nil
}
func awsRestjson1_deserializeOpDocumentPutSessionOutput(v *PutSessionOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	v.AudioStream = body
	return nil
}

type awsRestjson1_deserializeOpPostContent struct {
}

func (*awsRestjson1_deserializeOpPostContent) ID() string {
	return "awsRestjson1_deserializeOpPostContent"
}

func (m *awsRestjson1_deserializeOpPostContent) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		errorType := response.Header.Get("X-Amzn-Errortype")
		errorType = restjson.SanitizeErrorCode(errorType)

		buff := make([]byte, 1024)
		ringBuffer := smithyio.NewRingBuffer(buff)

		var errorBody bytes.Buffer
		_, err := io.Copy(&errorBody, response.Body)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
		}

		body := io.TeeReader(response.Body, ringBuffer)
		defer response.Body.Close()

		decoder := json.NewDecoder(body)
		decoder.UseNumber()

		var errorMessage string
		if len(errorType) == 0 {
			errorType, errorMessage, err = restjson.GetErrorInfo(decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response error with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
		}

		if len(errorType) == 0 {
			switch response.StatusCode {
			case 400:
				errorType = "BadRequestException"
			case 409:
				errorType = "ConflictException"
			case 500:
				errorType = "InternalFailureException"
			case 429:
				errorType = "LimitExceededException"
			case 406:
				errorType = "NotAcceptableException"
			case 404:
				errorType = "NotFoundException"
			case 408:
				errorType = "RequestTimeoutException"
			case 415:
				errorType = "UnsupportedMediaTypeException"
			case 502:
				errorType = "BadGatewayException"
			case 424:
				errorType = "DependencyFailedException"
			case 508:
				errorType = "LoopDetectedException"
			}
		}

		body = io.TeeReader(&errorBody, ringBuffer)
		decoder = json.NewDecoder(&errorBody)
		decoder.UseNumber()

		if errorType == "BadRequestException" {
			errResult := &types.BadRequestException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadRequestException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "ConflictException" {
			errResult := &types.ConflictException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentConflictException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "InternalFailureException" {
			errResult := &types.InternalFailureException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentInternalFailureException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LimitExceededException" {
			errResult := &types.LimitExceededException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeHttpBindingsLimitExceededException(output, response)
			if err != nil {
				return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response error with invalid Http bindings, %w", err)}
			}

			err = awsRestjson1_deserializeDocumentLimitExceededException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotAcceptableException" {
			errResult := &types.NotAcceptableException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotAcceptableException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "NotFoundException" {
			errResult := &types.NotFoundException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentNotFoundException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "RequestTimeoutException" {
			errResult := &types.RequestTimeoutException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentRequestTimeoutException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "UnsupportedMediaTypeException" {
			errResult := &types.UnsupportedMediaTypeException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentUnsupportedMediaTypeException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "BadGatewayException" {
			errResult := &types.BadGatewayException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentBadGatewayException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "DependencyFailedException" {
			errResult := &types.DependencyFailedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentDependencyFailedException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if errorType == "LoopDetectedException" {
			errResult := &types.LoopDetectedException{}
			output := errResult
			_ = output

			err = awsRestjson1_deserializeDocumentLoopDetectedException(output, decoder)
			if err != nil {
				var snapshot bytes.Buffer
				io.Copy(&snapshot, ringBuffer)
				return out, metadata, &smithy.DeserializationError{
					Err:      fmt.Errorf("failed to decode response body with invalid JSON, %w", err),
					Snapshot: snapshot.Bytes(),
				}
			}
			return out, metadata, errResult
		}

		if len(errorMessage) != 0 {
			genericError := &smithy.GenericAPIError{
				Code:    errorType,
				Message: errorMessage,
			}

			return out, metadata, genericError
		}

		genericError, err := restjson.GetSmithyGenericAPIError(decoder, errorType)
		if err != nil {
			return out, metadata, &smithy.DeserializationError{Err: err}
		}

		return out, metadata, genericError
	}

	output := &PostContentOutput{}
	out.Result = output

	err = awsRestjson1_deserializeHttpBindingsPostContentOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	err = awsRestjson1_deserializeOpDocumentPostContentOutput(output, response.Body)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to deserialize response payload, %w", err)}
	}

	return out, metadata, err
}

func awsRestjson1_deserializeHttpBindingsPostContentOutput(v *PostContentOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("Content-Type"); val != "" {
		v.ContentType = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-dialog-state"); val != "" {
		v.DialogState = types.DialogState(val)
	}

	if val := response.Header.Get("x-amz-lex-input-transcript"); val != "" {
		v.InputTranscript = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-intent-name"); val != "" {
		v.IntentName = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-message"); val != "" {
		v.Message = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-message-format"); val != "" {
		v.MessageFormat = types.MessageFormatType(val)
	}

	if val := response.Header.Get("x-amz-lex-sentiment"); val != "" {
		v.SentimentResponse = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-session-attributes"); val != "" {
		v.SessionAttributes = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-session-id"); val != "" {
		v.SessionId = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-slot-to-elicit"); val != "" {
		v.SlotToElicit = ptr.String(val)
	}

	if val := response.Header.Get("x-amz-lex-slots"); val != "" {
		v.Slots = ptr.String(val)
	}

	return nil
}
func awsRestjson1_deserializeOpDocumentPostContentOutput(v *PostContentOutput, body io.ReadCloser) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	v.AudioStream = body
	return nil
}

func awsRestjson1_deserializeDocumentBadRequestException(v *types.BadRequestException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentConflictException(v *types.ConflictException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentInternalFailureException(v *types.InternalFailureException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeHttpBindingsLimitExceededException(v *types.LimitExceededException, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if val := response.Header.Get("Retry-After"); val != "" {
		v.RetryAfterSeconds = ptr.String(val)
	}

	return nil
}
func awsRestjson1_deserializeDocumentLimitExceededException(v *types.LimitExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentNotAcceptableException(v *types.NotAcceptableException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentNotFoundException(v *types.NotFoundException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentRequestTimeoutException(v *types.RequestTimeoutException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentUnsupportedMediaTypeException(v *types.UnsupportedMediaTypeException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentBadGatewayException(v *types.BadGatewayException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentDependencyFailedException(v *types.DependencyFailedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentLoopDetectedException(v *types.LoopDetectedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "Message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentDialogAction(v *types.DialogAction, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "fulfillmentState":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected FulfillmentState to be of type types.FulfillmentState, got %T instead", val)
			}
			v.FulfillmentState = types.FulfillmentState(st)

		case "intentName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected IntentName to be of type *string, got %T instead", val)
			}
			v.IntentName = ptr.String(st)

		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Message to be of type *string, got %T instead", val)
			}
			v.Message = ptr.String(st)

		case "messageFormat":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected MessageFormat to be of type types.MessageFormatType, got %T instead", val)
			}
			v.MessageFormat = types.MessageFormatType(st)

		case "slotToElicit":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SlotToElicit to be of type *string, got %T instead", val)
			}
			v.SlotToElicit = ptr.String(st)

		case "slots":
			col := map[string]*string{}
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			v.Slots = col

		case "type":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Type to be of type types.DialogActionType, got %T instead", val)
			}
			v.Type = types.DialogActionType(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentIntentSummary(v *types.IntentSummary, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "checkpointLabel":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected CheckpointLabel to be of type *string, got %T instead", val)
			}
			v.CheckpointLabel = ptr.String(st)

		case "confirmationStatus":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected ConfirmationStatus to be of type types.ConfirmationStatus, got %T instead", val)
			}
			v.ConfirmationStatus = types.ConfirmationStatus(st)

		case "dialogActionType":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected DialogActionType to be of type types.DialogActionType, got %T instead", val)
			}
			v.DialogActionType = types.DialogActionType(st)

		case "fulfillmentState":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected FulfillmentState to be of type types.FulfillmentState, got %T instead", val)
			}
			v.FulfillmentState = types.FulfillmentState(st)

		case "intentName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected IntentName to be of type *string, got %T instead", val)
			}
			v.IntentName = ptr.String(st)

		case "slotToElicit":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SlotToElicit to be of type *string, got %T instead", val)
			}
			v.SlotToElicit = ptr.String(st)

		case "slots":
			col := map[string]*string{}
			if err := awsRestjson1_deserializeDocumentStringMap(&col, decoder); err != nil {
				return err
			}
			v.Slots = col

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentIntentSummaryList(vp *[]*types.IntentSummary, decoder *json.Decoder) error {
	v := []*types.IntentSummary{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val := types.IntentSummary{}
		if err := awsRestjson1_deserializeDocumentIntentSummary(&val, decoder); err != nil {
			return err
		}
		v = append(v, &val)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentSentimentResponse(v *types.SentimentResponse, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "sentimentLabel":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SentimentLabel to be of type *string, got %T instead", val)
			}
			v.SentimentLabel = ptr.String(st)

		case "sentimentScore":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SentimentScore to be of type *string, got %T instead", val)
			}
			v.SentimentScore = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentStringMap(vp *map[string]*string, decoder *json.Decoder) error {
	v := map[string]*string{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		token, err := decoder.Token()
		if err != nil {
			return err
		}

		key, ok := token.(string)
		if !ok {
			return fmt.Errorf("expected map-key of type string, found type %T", token)
		}

		val, err := decoder.Token()
		if err != nil {
			return err
		}
		st, ok := val.(string)
		if !ok {
			return fmt.Errorf("expected Value to be of type *string, got %T instead", val)
		}
		v[key] = ptr.String(st)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentButton(v *types.Button, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "text":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Text to be of type *string, got %T instead", val)
			}
			v.Text = ptr.String(st)

		case "value":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Value to be of type *string, got %T instead", val)
			}
			v.Value = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentGenericAttachment(v *types.GenericAttachment, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "attachmentLinkUrl":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected AttachmentLinkUrl to be of type *string, got %T instead", val)
			}
			v.AttachmentLinkUrl = ptr.String(st)

		case "buttons":
			col := []*types.Button{}
			if err := awsRestjson1_deserializeDocumentListOfButtons(&col, decoder); err != nil {
				return err
			}
			v.Buttons = col

		case "imageUrl":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected ImageUrl to be of type *string, got %T instead", val)
			}
			v.ImageUrl = ptr.String(st)

		case "subTitle":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected SubTitle to be of type *string, got %T instead", val)
			}
			v.SubTitle = ptr.String(st)

		case "title":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Title to be of type *string, got %T instead", val)
			}
			v.Title = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}

func awsRestjson1_deserializeDocumentGenericAttachmentList(vp *[]*types.GenericAttachment, decoder *json.Decoder) error {
	v := []*types.GenericAttachment{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val := types.GenericAttachment{}
		if err := awsRestjson1_deserializeDocumentGenericAttachment(&val, decoder); err != nil {
			return err
		}
		v = append(v, &val)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentListOfButtons(vp *[]*types.Button, decoder *json.Decoder) error {
	v := []*types.Button{}
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "[" {
		return fmt.Errorf("expect `[` as start token")
	}

	for decoder.More() {
		val := types.Button{}
		if err := awsRestjson1_deserializeDocumentButton(&val, decoder); err != nil {
			return err
		}
		v = append(v, &val)

	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "]" {
		return fmt.Errorf("expect `]` as end token")
	}

	*vp = v
	return nil
}

func awsRestjson1_deserializeDocumentResponseCard(v *types.ResponseCard, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization of nil %T", v)
	}

	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if t, ok := startToken.(json.Delim); !ok || t.String() != "{" {
		return fmt.Errorf("expect `{` as start token")
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "contentType":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected ContentType to be of type types.ContentType, got %T instead", val)
			}
			v.ContentType = types.ContentType(st)

		case "genericAttachments":
			col := []*types.GenericAttachment{}
			if err := awsRestjson1_deserializeDocumentGenericAttachmentList(&col, decoder); err != nil {
				return err
			}
			v.GenericAttachments = col

		case "version":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			st, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Version to be of type *string, got %T instead", val)
			}
			v.Version = ptr.String(st)

		default:
			err := restjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}

	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t.String() != "}" {
		return fmt.Errorf("expect `}` as end token")
	}

	return nil
}
