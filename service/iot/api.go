// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package iot

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opAcceptCertificateTransfer = "AcceptCertificateTransfer"

// AcceptCertificateTransferRequest is a API request type for the AcceptCertificateTransfer API operation.
type AcceptCertificateTransferRequest struct {
	*aws.Request
	Input *AcceptCertificateTransferInput
	Copy  func(*AcceptCertificateTransferInput) AcceptCertificateTransferRequest
}

// Send marshals and sends the AcceptCertificateTransfer API request.
func (r AcceptCertificateTransferRequest) Send() (*AcceptCertificateTransferOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AcceptCertificateTransferOutput), nil
}

// AcceptCertificateTransferRequest returns a request value for making API operation for
// AWS IoT.
//
// Accepts a pending certificate transfer. The default state of the certificate
// is INACTIVE.
//
// To check for pending certificate transfers, call ListCertificates to enumerate
// your certificates.
//
//    // Example sending a request using the AcceptCertificateTransferRequest method.
//    req := client.AcceptCertificateTransferRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) AcceptCertificateTransferRequest(input *AcceptCertificateTransferInput) AcceptCertificateTransferRequest {
	op := &aws.Operation{
		Name:       opAcceptCertificateTransfer,
		HTTPMethod: "PATCH",
		HTTPPath:   "/accept-certificate-transfer/{certificateId}",
	}

	if input == nil {
		input = &AcceptCertificateTransferInput{}
	}

	output := &AcceptCertificateTransferOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return AcceptCertificateTransferRequest{Request: req, Input: input, Copy: c.AcceptCertificateTransferRequest}
}

const opAddThingToThingGroup = "AddThingToThingGroup"

// AddThingToThingGroupRequest is a API request type for the AddThingToThingGroup API operation.
type AddThingToThingGroupRequest struct {
	*aws.Request
	Input *AddThingToThingGroupInput
	Copy  func(*AddThingToThingGroupInput) AddThingToThingGroupRequest
}

// Send marshals and sends the AddThingToThingGroup API request.
func (r AddThingToThingGroupRequest) Send() (*AddThingToThingGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AddThingToThingGroupOutput), nil
}

// AddThingToThingGroupRequest returns a request value for making API operation for
// AWS IoT.
//
// Adds a thing to a thing group.
//
//    // Example sending a request using the AddThingToThingGroupRequest method.
//    req := client.AddThingToThingGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) AddThingToThingGroupRequest(input *AddThingToThingGroupInput) AddThingToThingGroupRequest {
	op := &aws.Operation{
		Name:       opAddThingToThingGroup,
		HTTPMethod: "PUT",
		HTTPPath:   "/thing-groups/addThingToThingGroup",
	}

	if input == nil {
		input = &AddThingToThingGroupInput{}
	}

	output := &AddThingToThingGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AddThingToThingGroupRequest{Request: req, Input: input, Copy: c.AddThingToThingGroupRequest}
}

const opAssociateTargetsWithJob = "AssociateTargetsWithJob"

// AssociateTargetsWithJobRequest is a API request type for the AssociateTargetsWithJob API operation.
type AssociateTargetsWithJobRequest struct {
	*aws.Request
	Input *AssociateTargetsWithJobInput
	Copy  func(*AssociateTargetsWithJobInput) AssociateTargetsWithJobRequest
}

// Send marshals and sends the AssociateTargetsWithJob API request.
func (r AssociateTargetsWithJobRequest) Send() (*AssociateTargetsWithJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AssociateTargetsWithJobOutput), nil
}

// AssociateTargetsWithJobRequest returns a request value for making API operation for
// AWS IoT.
//
// Associates a group with a continuous job. The following criteria must be
// met:
//
//    * The job must have been created with the targetSelection field set to
//    "CONTINUOUS".
//
//    * The job status must currently be "IN_PROGRESS".
//
//    * The total number of targets associated with a job must not exceed 100.
//
//    // Example sending a request using the AssociateTargetsWithJobRequest method.
//    req := client.AssociateTargetsWithJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) AssociateTargetsWithJobRequest(input *AssociateTargetsWithJobInput) AssociateTargetsWithJobRequest {
	op := &aws.Operation{
		Name:       opAssociateTargetsWithJob,
		HTTPMethod: "POST",
		HTTPPath:   "/jobs/{jobId}/targets",
	}

	if input == nil {
		input = &AssociateTargetsWithJobInput{}
	}

	output := &AssociateTargetsWithJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AssociateTargetsWithJobRequest{Request: req, Input: input, Copy: c.AssociateTargetsWithJobRequest}
}

const opAttachPolicy = "AttachPolicy"

// AttachPolicyRequest is a API request type for the AttachPolicy API operation.
type AttachPolicyRequest struct {
	*aws.Request
	Input *AttachPolicyInput
	Copy  func(*AttachPolicyInput) AttachPolicyRequest
}

// Send marshals and sends the AttachPolicy API request.
func (r AttachPolicyRequest) Send() (*AttachPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AttachPolicyOutput), nil
}

// AttachPolicyRequest returns a request value for making API operation for
// AWS IoT.
//
// Attaches a policy to the specified target.
//
//    // Example sending a request using the AttachPolicyRequest method.
//    req := client.AttachPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) AttachPolicyRequest(input *AttachPolicyInput) AttachPolicyRequest {
	op := &aws.Operation{
		Name:       opAttachPolicy,
		HTTPMethod: "PUT",
		HTTPPath:   "/target-policies/{policyName}",
	}

	if input == nil {
		input = &AttachPolicyInput{}
	}

	output := &AttachPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return AttachPolicyRequest{Request: req, Input: input, Copy: c.AttachPolicyRequest}
}

const opAttachPrincipalPolicy = "AttachPrincipalPolicy"

// AttachPrincipalPolicyRequest is a API request type for the AttachPrincipalPolicy API operation.
type AttachPrincipalPolicyRequest struct {
	*aws.Request
	Input *AttachPrincipalPolicyInput
	Copy  func(*AttachPrincipalPolicyInput) AttachPrincipalPolicyRequest
}

// Send marshals and sends the AttachPrincipalPolicy API request.
func (r AttachPrincipalPolicyRequest) Send() (*AttachPrincipalPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AttachPrincipalPolicyOutput), nil
}

// AttachPrincipalPolicyRequest returns a request value for making API operation for
// AWS IoT.
//
// Attaches the specified policy to the specified principal (certificate or
// other credential).
//
// Note: This API is deprecated. Please use AttachPolicy instead.
//
//    // Example sending a request using the AttachPrincipalPolicyRequest method.
//    req := client.AttachPrincipalPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) AttachPrincipalPolicyRequest(input *AttachPrincipalPolicyInput) AttachPrincipalPolicyRequest {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, AttachPrincipalPolicy, has been deprecated")
	}
	op := &aws.Operation{
		Name:       opAttachPrincipalPolicy,
		HTTPMethod: "PUT",
		HTTPPath:   "/principal-policies/{policyName}",
	}

	if input == nil {
		input = &AttachPrincipalPolicyInput{}
	}

	output := &AttachPrincipalPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return AttachPrincipalPolicyRequest{Request: req, Input: input, Copy: c.AttachPrincipalPolicyRequest}
}

const opAttachThingPrincipal = "AttachThingPrincipal"

// AttachThingPrincipalRequest is a API request type for the AttachThingPrincipal API operation.
type AttachThingPrincipalRequest struct {
	*aws.Request
	Input *AttachThingPrincipalInput
	Copy  func(*AttachThingPrincipalInput) AttachThingPrincipalRequest
}

// Send marshals and sends the AttachThingPrincipal API request.
func (r AttachThingPrincipalRequest) Send() (*AttachThingPrincipalOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AttachThingPrincipalOutput), nil
}

// AttachThingPrincipalRequest returns a request value for making API operation for
// AWS IoT.
//
// Attaches the specified principal to the specified thing.
//
//    // Example sending a request using the AttachThingPrincipalRequest method.
//    req := client.AttachThingPrincipalRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) AttachThingPrincipalRequest(input *AttachThingPrincipalInput) AttachThingPrincipalRequest {
	op := &aws.Operation{
		Name:       opAttachThingPrincipal,
		HTTPMethod: "PUT",
		HTTPPath:   "/things/{thingName}/principals",
	}

	if input == nil {
		input = &AttachThingPrincipalInput{}
	}

	output := &AttachThingPrincipalOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AttachThingPrincipalRequest{Request: req, Input: input, Copy: c.AttachThingPrincipalRequest}
}

const opCancelCertificateTransfer = "CancelCertificateTransfer"

// CancelCertificateTransferRequest is a API request type for the CancelCertificateTransfer API operation.
type CancelCertificateTransferRequest struct {
	*aws.Request
	Input *CancelCertificateTransferInput
	Copy  func(*CancelCertificateTransferInput) CancelCertificateTransferRequest
}

// Send marshals and sends the CancelCertificateTransfer API request.
func (r CancelCertificateTransferRequest) Send() (*CancelCertificateTransferOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CancelCertificateTransferOutput), nil
}

// CancelCertificateTransferRequest returns a request value for making API operation for
// AWS IoT.
//
// Cancels a pending transfer for the specified certificate.
//
// Note Only the transfer source account can use this operation to cancel a
// transfer. (Transfer destinations can use RejectCertificateTransfer instead.)
// After transfer, AWS IoT returns the certificate to the source account in
// the INACTIVE state. After the destination account has accepted the transfer,
// the transfer cannot be cancelled.
//
// After a certificate transfer is cancelled, the status of the certificate
// changes from PENDING_TRANSFER to INACTIVE.
//
//    // Example sending a request using the CancelCertificateTransferRequest method.
//    req := client.CancelCertificateTransferRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CancelCertificateTransferRequest(input *CancelCertificateTransferInput) CancelCertificateTransferRequest {
	op := &aws.Operation{
		Name:       opCancelCertificateTransfer,
		HTTPMethod: "PATCH",
		HTTPPath:   "/cancel-certificate-transfer/{certificateId}",
	}

	if input == nil {
		input = &CancelCertificateTransferInput{}
	}

	output := &CancelCertificateTransferOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return CancelCertificateTransferRequest{Request: req, Input: input, Copy: c.CancelCertificateTransferRequest}
}

const opCancelJob = "CancelJob"

// CancelJobRequest is a API request type for the CancelJob API operation.
type CancelJobRequest struct {
	*aws.Request
	Input *CancelJobInput
	Copy  func(*CancelJobInput) CancelJobRequest
}

// Send marshals and sends the CancelJob API request.
func (r CancelJobRequest) Send() (*CancelJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CancelJobOutput), nil
}

// CancelJobRequest returns a request value for making API operation for
// AWS IoT.
//
// Cancels a job.
//
//    // Example sending a request using the CancelJobRequest method.
//    req := client.CancelJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CancelJobRequest(input *CancelJobInput) CancelJobRequest {
	op := &aws.Operation{
		Name:       opCancelJob,
		HTTPMethod: "PUT",
		HTTPPath:   "/jobs/{jobId}/cancel",
	}

	if input == nil {
		input = &CancelJobInput{}
	}

	output := &CancelJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CancelJobRequest{Request: req, Input: input, Copy: c.CancelJobRequest}
}

const opCancelJobExecution = "CancelJobExecution"

// CancelJobExecutionRequest is a API request type for the CancelJobExecution API operation.
type CancelJobExecutionRequest struct {
	*aws.Request
	Input *CancelJobExecutionInput
	Copy  func(*CancelJobExecutionInput) CancelJobExecutionRequest
}

// Send marshals and sends the CancelJobExecution API request.
func (r CancelJobExecutionRequest) Send() (*CancelJobExecutionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CancelJobExecutionOutput), nil
}

// CancelJobExecutionRequest returns a request value for making API operation for
// AWS IoT.
//
// Cancels the execution of a job for a given thing.
//
//    // Example sending a request using the CancelJobExecutionRequest method.
//    req := client.CancelJobExecutionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CancelJobExecutionRequest(input *CancelJobExecutionInput) CancelJobExecutionRequest {
	op := &aws.Operation{
		Name:       opCancelJobExecution,
		HTTPMethod: "PUT",
		HTTPPath:   "/things/{thingName}/jobs/{jobId}/cancel",
	}

	if input == nil {
		input = &CancelJobExecutionInput{}
	}

	output := &CancelJobExecutionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return CancelJobExecutionRequest{Request: req, Input: input, Copy: c.CancelJobExecutionRequest}
}

const opClearDefaultAuthorizer = "ClearDefaultAuthorizer"

// ClearDefaultAuthorizerRequest is a API request type for the ClearDefaultAuthorizer API operation.
type ClearDefaultAuthorizerRequest struct {
	*aws.Request
	Input *ClearDefaultAuthorizerInput
	Copy  func(*ClearDefaultAuthorizerInput) ClearDefaultAuthorizerRequest
}

// Send marshals and sends the ClearDefaultAuthorizer API request.
func (r ClearDefaultAuthorizerRequest) Send() (*ClearDefaultAuthorizerOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ClearDefaultAuthorizerOutput), nil
}

// ClearDefaultAuthorizerRequest returns a request value for making API operation for
// AWS IoT.
//
// Clears the default authorizer.
//
//    // Example sending a request using the ClearDefaultAuthorizerRequest method.
//    req := client.ClearDefaultAuthorizerRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ClearDefaultAuthorizerRequest(input *ClearDefaultAuthorizerInput) ClearDefaultAuthorizerRequest {
	op := &aws.Operation{
		Name:       opClearDefaultAuthorizer,
		HTTPMethod: "DELETE",
		HTTPPath:   "/default-authorizer",
	}

	if input == nil {
		input = &ClearDefaultAuthorizerInput{}
	}

	output := &ClearDefaultAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ClearDefaultAuthorizerRequest{Request: req, Input: input, Copy: c.ClearDefaultAuthorizerRequest}
}

const opCreateAuthorizer = "CreateAuthorizer"

// CreateAuthorizerRequest is a API request type for the CreateAuthorizer API operation.
type CreateAuthorizerRequest struct {
	*aws.Request
	Input *CreateAuthorizerInput
	Copy  func(*CreateAuthorizerInput) CreateAuthorizerRequest
}

// Send marshals and sends the CreateAuthorizer API request.
func (r CreateAuthorizerRequest) Send() (*CreateAuthorizerOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateAuthorizerOutput), nil
}

// CreateAuthorizerRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates an authorizer.
//
//    // Example sending a request using the CreateAuthorizerRequest method.
//    req := client.CreateAuthorizerRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateAuthorizerRequest(input *CreateAuthorizerInput) CreateAuthorizerRequest {
	op := &aws.Operation{
		Name:       opCreateAuthorizer,
		HTTPMethod: "POST",
		HTTPPath:   "/authorizer/{authorizerName}",
	}

	if input == nil {
		input = &CreateAuthorizerInput{}
	}

	output := &CreateAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateAuthorizerRequest{Request: req, Input: input, Copy: c.CreateAuthorizerRequest}
}

const opCreateCertificateFromCsr = "CreateCertificateFromCsr"

// CreateCertificateFromCsrRequest is a API request type for the CreateCertificateFromCsr API operation.
type CreateCertificateFromCsrRequest struct {
	*aws.Request
	Input *CreateCertificateFromCsrInput
	Copy  func(*CreateCertificateFromCsrInput) CreateCertificateFromCsrRequest
}

// Send marshals and sends the CreateCertificateFromCsr API request.
func (r CreateCertificateFromCsrRequest) Send() (*CreateCertificateFromCsrOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateCertificateFromCsrOutput), nil
}

// CreateCertificateFromCsrRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates an X.509 certificate using the specified certificate signing request.
//
// Note: The CSR must include a public key that is either an RSA key with a
// length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384
// curves.
//
// Note: Reusing the same certificate signing request (CSR) results in a distinct
// certificate.
//
// You can create multiple certificates in a batch by creating a directory,
// copying multiple .csr files into that directory, and then specifying that
// directory on the command line. The following commands show how to create
// a batch of certificates given a batch of CSRs.
//
// Assuming a set of CSRs are located inside of the directory my-csr-directory:
//
// On Linux and OS X, the command is:
//
// $ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr
// --certificate-signing-request file://my-csr-directory/{}
//
// This command lists all of the CSRs in my-csr-directory and pipes each CSR
// file name to the aws iot create-certificate-from-csr AWS CLI command to create
// a certificate for the corresponding CSR.
//
// The aws iot create-certificate-from-csr part of the command can also be run
// in parallel to speed up the certificate creation process:
//
// $ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr
// --certificate-signing-request file://my-csr-directory/{}
//
// On Windows PowerShell, the command to create certificates for all CSRs in
// my-csr-directory is:
//
// > ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request
// file://my-csr-directory/$_}
//
// On a Windows command prompt, the command to create certificates for all CSRs
// in my-csr-directory is:
//
// > forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr
// --certificate-signing-request file://@path"
//
//    // Example sending a request using the CreateCertificateFromCsrRequest method.
//    req := client.CreateCertificateFromCsrRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateCertificateFromCsrRequest(input *CreateCertificateFromCsrInput) CreateCertificateFromCsrRequest {
	op := &aws.Operation{
		Name:       opCreateCertificateFromCsr,
		HTTPMethod: "POST",
		HTTPPath:   "/certificates",
	}

	if input == nil {
		input = &CreateCertificateFromCsrInput{}
	}

	output := &CreateCertificateFromCsrOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateCertificateFromCsrRequest{Request: req, Input: input, Copy: c.CreateCertificateFromCsrRequest}
}

const opCreateJob = "CreateJob"

// CreateJobRequest is a API request type for the CreateJob API operation.
type CreateJobRequest struct {
	*aws.Request
	Input *CreateJobInput
	Copy  func(*CreateJobInput) CreateJobRequest
}

// Send marshals and sends the CreateJob API request.
func (r CreateJobRequest) Send() (*CreateJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateJobOutput), nil
}

// CreateJobRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a job.
//
//    // Example sending a request using the CreateJobRequest method.
//    req := client.CreateJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateJobRequest(input *CreateJobInput) CreateJobRequest {
	op := &aws.Operation{
		Name:       opCreateJob,
		HTTPMethod: "PUT",
		HTTPPath:   "/jobs/{jobId}",
	}

	if input == nil {
		input = &CreateJobInput{}
	}

	output := &CreateJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateJobRequest{Request: req, Input: input, Copy: c.CreateJobRequest}
}

const opCreateKeysAndCertificate = "CreateKeysAndCertificate"

// CreateKeysAndCertificateRequest is a API request type for the CreateKeysAndCertificate API operation.
type CreateKeysAndCertificateRequest struct {
	*aws.Request
	Input *CreateKeysAndCertificateInput
	Copy  func(*CreateKeysAndCertificateInput) CreateKeysAndCertificateRequest
}

// Send marshals and sends the CreateKeysAndCertificate API request.
func (r CreateKeysAndCertificateRequest) Send() (*CreateKeysAndCertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateKeysAndCertificateOutput), nil
}

// CreateKeysAndCertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a 2048-bit RSA key pair and issues an X.509 certificate using the
// issued public key.
//
// Note This is the only time AWS IoT issues the private key for this certificate,
// so it is important to keep it in a secure location.
//
//    // Example sending a request using the CreateKeysAndCertificateRequest method.
//    req := client.CreateKeysAndCertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateKeysAndCertificateRequest(input *CreateKeysAndCertificateInput) CreateKeysAndCertificateRequest {
	op := &aws.Operation{
		Name:       opCreateKeysAndCertificate,
		HTTPMethod: "POST",
		HTTPPath:   "/keys-and-certificate",
	}

	if input == nil {
		input = &CreateKeysAndCertificateInput{}
	}

	output := &CreateKeysAndCertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateKeysAndCertificateRequest{Request: req, Input: input, Copy: c.CreateKeysAndCertificateRequest}
}

const opCreateOTAUpdate = "CreateOTAUpdate"

// CreateOTAUpdateRequest is a API request type for the CreateOTAUpdate API operation.
type CreateOTAUpdateRequest struct {
	*aws.Request
	Input *CreateOTAUpdateInput
	Copy  func(*CreateOTAUpdateInput) CreateOTAUpdateRequest
}

// Send marshals and sends the CreateOTAUpdate API request.
func (r CreateOTAUpdateRequest) Send() (*CreateOTAUpdateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateOTAUpdateOutput), nil
}

// CreateOTAUpdateRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates an AWS IoT OTAUpdate on a target group of things or groups.
//
//    // Example sending a request using the CreateOTAUpdateRequest method.
//    req := client.CreateOTAUpdateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateOTAUpdateRequest(input *CreateOTAUpdateInput) CreateOTAUpdateRequest {
	op := &aws.Operation{
		Name:       opCreateOTAUpdate,
		HTTPMethod: "POST",
		HTTPPath:   "/otaUpdates/{otaUpdateId}",
	}

	if input == nil {
		input = &CreateOTAUpdateInput{}
	}

	output := &CreateOTAUpdateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateOTAUpdateRequest{Request: req, Input: input, Copy: c.CreateOTAUpdateRequest}
}

const opCreatePolicy = "CreatePolicy"

// CreatePolicyRequest is a API request type for the CreatePolicy API operation.
type CreatePolicyRequest struct {
	*aws.Request
	Input *CreatePolicyInput
	Copy  func(*CreatePolicyInput) CreatePolicyRequest
}

// Send marshals and sends the CreatePolicy API request.
func (r CreatePolicyRequest) Send() (*CreatePolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreatePolicyOutput), nil
}

// CreatePolicyRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates an AWS IoT policy.
//
// The created policy is the default version for the policy. This operation
// creates a policy version with a version identifier of 1 and sets 1 as the
// policy's default version.
//
//    // Example sending a request using the CreatePolicyRequest method.
//    req := client.CreatePolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreatePolicyRequest(input *CreatePolicyInput) CreatePolicyRequest {
	op := &aws.Operation{
		Name:       opCreatePolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/policies/{policyName}",
	}

	if input == nil {
		input = &CreatePolicyInput{}
	}

	output := &CreatePolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreatePolicyRequest{Request: req, Input: input, Copy: c.CreatePolicyRequest}
}

const opCreatePolicyVersion = "CreatePolicyVersion"

// CreatePolicyVersionRequest is a API request type for the CreatePolicyVersion API operation.
type CreatePolicyVersionRequest struct {
	*aws.Request
	Input *CreatePolicyVersionInput
	Copy  func(*CreatePolicyVersionInput) CreatePolicyVersionRequest
}

// Send marshals and sends the CreatePolicyVersion API request.
func (r CreatePolicyVersionRequest) Send() (*CreatePolicyVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreatePolicyVersionOutput), nil
}

// CreatePolicyVersionRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a new version of the specified AWS IoT policy. To update a policy,
// create a new policy version. A managed policy can have up to five versions.
// If the policy has five versions, you must use DeletePolicyVersion to delete
// an existing version before you create a new one.
//
// Optionally, you can set the new version as the policy's default version.
// The default version is the operative version (that is, the version that is
// in effect for the certificates to which the policy is attached).
//
//    // Example sending a request using the CreatePolicyVersionRequest method.
//    req := client.CreatePolicyVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreatePolicyVersionRequest(input *CreatePolicyVersionInput) CreatePolicyVersionRequest {
	op := &aws.Operation{
		Name:       opCreatePolicyVersion,
		HTTPMethod: "POST",
		HTTPPath:   "/policies/{policyName}/version",
	}

	if input == nil {
		input = &CreatePolicyVersionInput{}
	}

	output := &CreatePolicyVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreatePolicyVersionRequest{Request: req, Input: input, Copy: c.CreatePolicyVersionRequest}
}

const opCreateRoleAlias = "CreateRoleAlias"

// CreateRoleAliasRequest is a API request type for the CreateRoleAlias API operation.
type CreateRoleAliasRequest struct {
	*aws.Request
	Input *CreateRoleAliasInput
	Copy  func(*CreateRoleAliasInput) CreateRoleAliasRequest
}

// Send marshals and sends the CreateRoleAlias API request.
func (r CreateRoleAliasRequest) Send() (*CreateRoleAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateRoleAliasOutput), nil
}

// CreateRoleAliasRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a role alias.
//
//    // Example sending a request using the CreateRoleAliasRequest method.
//    req := client.CreateRoleAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateRoleAliasRequest(input *CreateRoleAliasInput) CreateRoleAliasRequest {
	op := &aws.Operation{
		Name:       opCreateRoleAlias,
		HTTPMethod: "POST",
		HTTPPath:   "/role-aliases/{roleAlias}",
	}

	if input == nil {
		input = &CreateRoleAliasInput{}
	}

	output := &CreateRoleAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateRoleAliasRequest{Request: req, Input: input, Copy: c.CreateRoleAliasRequest}
}

const opCreateStream = "CreateStream"

// CreateStreamRequest is a API request type for the CreateStream API operation.
type CreateStreamRequest struct {
	*aws.Request
	Input *CreateStreamInput
	Copy  func(*CreateStreamInput) CreateStreamRequest
}

// Send marshals and sends the CreateStream API request.
func (r CreateStreamRequest) Send() (*CreateStreamOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateStreamOutput), nil
}

// CreateStreamRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a stream for delivering one or more large files in chunks over MQTT.
// A stream transports data bytes in chunks or blocks packaged as MQTT messages
// from a source like S3. You can have one or more files associated with a stream.
// The total size of a file associated with the stream cannot exceed more than
// 2 MB. The stream will be created with version 0. If a stream is created with
// the same streamID as a stream that existed and was deleted within last 90
// days, we will resurrect that old stream by incrementing the version by 1.
//
//    // Example sending a request using the CreateStreamRequest method.
//    req := client.CreateStreamRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateStreamRequest(input *CreateStreamInput) CreateStreamRequest {
	op := &aws.Operation{
		Name:       opCreateStream,
		HTTPMethod: "POST",
		HTTPPath:   "/streams/{streamId}",
	}

	if input == nil {
		input = &CreateStreamInput{}
	}

	output := &CreateStreamOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateStreamRequest{Request: req, Input: input, Copy: c.CreateStreamRequest}
}

const opCreateThing = "CreateThing"

// CreateThingRequest is a API request type for the CreateThing API operation.
type CreateThingRequest struct {
	*aws.Request
	Input *CreateThingInput
	Copy  func(*CreateThingInput) CreateThingRequest
}

// Send marshals and sends the CreateThing API request.
func (r CreateThingRequest) Send() (*CreateThingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateThingOutput), nil
}

// CreateThingRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a thing record in the registry.
//
//    // Example sending a request using the CreateThingRequest method.
//    req := client.CreateThingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateThingRequest(input *CreateThingInput) CreateThingRequest {
	op := &aws.Operation{
		Name:       opCreateThing,
		HTTPMethod: "POST",
		HTTPPath:   "/things/{thingName}",
	}

	if input == nil {
		input = &CreateThingInput{}
	}

	output := &CreateThingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateThingRequest{Request: req, Input: input, Copy: c.CreateThingRequest}
}

const opCreateThingGroup = "CreateThingGroup"

// CreateThingGroupRequest is a API request type for the CreateThingGroup API operation.
type CreateThingGroupRequest struct {
	*aws.Request
	Input *CreateThingGroupInput
	Copy  func(*CreateThingGroupInput) CreateThingGroupRequest
}

// Send marshals and sends the CreateThingGroup API request.
func (r CreateThingGroupRequest) Send() (*CreateThingGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateThingGroupOutput), nil
}

// CreateThingGroupRequest returns a request value for making API operation for
// AWS IoT.
//
// Create a thing group.
//
//    // Example sending a request using the CreateThingGroupRequest method.
//    req := client.CreateThingGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateThingGroupRequest(input *CreateThingGroupInput) CreateThingGroupRequest {
	op := &aws.Operation{
		Name:       opCreateThingGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/thing-groups/{thingGroupName}",
	}

	if input == nil {
		input = &CreateThingGroupInput{}
	}

	output := &CreateThingGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateThingGroupRequest{Request: req, Input: input, Copy: c.CreateThingGroupRequest}
}

const opCreateThingType = "CreateThingType"

// CreateThingTypeRequest is a API request type for the CreateThingType API operation.
type CreateThingTypeRequest struct {
	*aws.Request
	Input *CreateThingTypeInput
	Copy  func(*CreateThingTypeInput) CreateThingTypeRequest
}

// Send marshals and sends the CreateThingType API request.
func (r CreateThingTypeRequest) Send() (*CreateThingTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateThingTypeOutput), nil
}

// CreateThingTypeRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a new thing type.
//
//    // Example sending a request using the CreateThingTypeRequest method.
//    req := client.CreateThingTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateThingTypeRequest(input *CreateThingTypeInput) CreateThingTypeRequest {
	op := &aws.Operation{
		Name:       opCreateThingType,
		HTTPMethod: "POST",
		HTTPPath:   "/thing-types/{thingTypeName}",
	}

	if input == nil {
		input = &CreateThingTypeInput{}
	}

	output := &CreateThingTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateThingTypeRequest{Request: req, Input: input, Copy: c.CreateThingTypeRequest}
}

const opCreateTopicRule = "CreateTopicRule"

// CreateTopicRuleRequest is a API request type for the CreateTopicRule API operation.
type CreateTopicRuleRequest struct {
	*aws.Request
	Input *CreateTopicRuleInput
	Copy  func(*CreateTopicRuleInput) CreateTopicRuleRequest
}

// Send marshals and sends the CreateTopicRule API request.
func (r CreateTopicRuleRequest) Send() (*CreateTopicRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTopicRuleOutput), nil
}

// CreateTopicRuleRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a rule. Creating rules is an administrator-level action. Any user
// who has permission to create rules will be able to access data processed
// by the rule.
//
//    // Example sending a request using the CreateTopicRuleRequest method.
//    req := client.CreateTopicRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) CreateTopicRuleRequest(input *CreateTopicRuleInput) CreateTopicRuleRequest {
	op := &aws.Operation{
		Name:       opCreateTopicRule,
		HTTPMethod: "POST",
		HTTPPath:   "/rules/{ruleName}",
	}

	if input == nil {
		input = &CreateTopicRuleInput{}
	}

	output := &CreateTopicRuleOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTopicRuleRequest{Request: req, Input: input, Copy: c.CreateTopicRuleRequest}
}

const opDeleteAuthorizer = "DeleteAuthorizer"

// DeleteAuthorizerRequest is a API request type for the DeleteAuthorizer API operation.
type DeleteAuthorizerRequest struct {
	*aws.Request
	Input *DeleteAuthorizerInput
	Copy  func(*DeleteAuthorizerInput) DeleteAuthorizerRequest
}

// Send marshals and sends the DeleteAuthorizer API request.
func (r DeleteAuthorizerRequest) Send() (*DeleteAuthorizerOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteAuthorizerOutput), nil
}

// DeleteAuthorizerRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes an authorizer.
//
//    // Example sending a request using the DeleteAuthorizerRequest method.
//    req := client.DeleteAuthorizerRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteAuthorizerRequest(input *DeleteAuthorizerInput) DeleteAuthorizerRequest {
	op := &aws.Operation{
		Name:       opDeleteAuthorizer,
		HTTPMethod: "DELETE",
		HTTPPath:   "/authorizer/{authorizerName}",
	}

	if input == nil {
		input = &DeleteAuthorizerInput{}
	}

	output := &DeleteAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteAuthorizerRequest{Request: req, Input: input, Copy: c.DeleteAuthorizerRequest}
}

const opDeleteCACertificate = "DeleteCACertificate"

// DeleteCACertificateRequest is a API request type for the DeleteCACertificate API operation.
type DeleteCACertificateRequest struct {
	*aws.Request
	Input *DeleteCACertificateInput
	Copy  func(*DeleteCACertificateInput) DeleteCACertificateRequest
}

// Send marshals and sends the DeleteCACertificate API request.
func (r DeleteCACertificateRequest) Send() (*DeleteCACertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteCACertificateOutput), nil
}

// DeleteCACertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes a registered CA certificate.
//
//    // Example sending a request using the DeleteCACertificateRequest method.
//    req := client.DeleteCACertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteCACertificateRequest(input *DeleteCACertificateInput) DeleteCACertificateRequest {
	op := &aws.Operation{
		Name:       opDeleteCACertificate,
		HTTPMethod: "DELETE",
		HTTPPath:   "/cacertificate/{caCertificateId}",
	}

	if input == nil {
		input = &DeleteCACertificateInput{}
	}

	output := &DeleteCACertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteCACertificateRequest{Request: req, Input: input, Copy: c.DeleteCACertificateRequest}
}

const opDeleteCertificate = "DeleteCertificate"

// DeleteCertificateRequest is a API request type for the DeleteCertificate API operation.
type DeleteCertificateRequest struct {
	*aws.Request
	Input *DeleteCertificateInput
	Copy  func(*DeleteCertificateInput) DeleteCertificateRequest
}

// Send marshals and sends the DeleteCertificate API request.
func (r DeleteCertificateRequest) Send() (*DeleteCertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteCertificateOutput), nil
}

// DeleteCertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes the specified certificate.
//
// A certificate cannot be deleted if it has a policy attached to it or if its
// status is set to ACTIVE. To delete a certificate, first use the DetachPrincipalPolicy
// API to detach all policies. Next, use the UpdateCertificate API to set the
// certificate to the INACTIVE status.
//
//    // Example sending a request using the DeleteCertificateRequest method.
//    req := client.DeleteCertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteCertificateRequest(input *DeleteCertificateInput) DeleteCertificateRequest {
	op := &aws.Operation{
		Name:       opDeleteCertificate,
		HTTPMethod: "DELETE",
		HTTPPath:   "/certificates/{certificateId}",
	}

	if input == nil {
		input = &DeleteCertificateInput{}
	}

	output := &DeleteCertificateOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteCertificateRequest{Request: req, Input: input, Copy: c.DeleteCertificateRequest}
}

const opDeleteJob = "DeleteJob"

// DeleteJobRequest is a API request type for the DeleteJob API operation.
type DeleteJobRequest struct {
	*aws.Request
	Input *DeleteJobInput
	Copy  func(*DeleteJobInput) DeleteJobRequest
}

// Send marshals and sends the DeleteJob API request.
func (r DeleteJobRequest) Send() (*DeleteJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteJobOutput), nil
}

// DeleteJobRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes a job and its related job executions.
//
// Deleting a job may take time, depending on the number of job executions created
// for the job and various other factors. While the job is being deleted, the
// status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to
// delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will
// result in an error.
//
// Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or
// a LimitExceededException will occur.
//
//    // Example sending a request using the DeleteJobRequest method.
//    req := client.DeleteJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteJobRequest(input *DeleteJobInput) DeleteJobRequest {
	op := &aws.Operation{
		Name:       opDeleteJob,
		HTTPMethod: "DELETE",
		HTTPPath:   "/jobs/{jobId}",
	}

	if input == nil {
		input = &DeleteJobInput{}
	}

	output := &DeleteJobOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteJobRequest{Request: req, Input: input, Copy: c.DeleteJobRequest}
}

const opDeleteJobExecution = "DeleteJobExecution"

// DeleteJobExecutionRequest is a API request type for the DeleteJobExecution API operation.
type DeleteJobExecutionRequest struct {
	*aws.Request
	Input *DeleteJobExecutionInput
	Copy  func(*DeleteJobExecutionInput) DeleteJobExecutionRequest
}

// Send marshals and sends the DeleteJobExecution API request.
func (r DeleteJobExecutionRequest) Send() (*DeleteJobExecutionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteJobExecutionOutput), nil
}

// DeleteJobExecutionRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes a job execution.
//
//    // Example sending a request using the DeleteJobExecutionRequest method.
//    req := client.DeleteJobExecutionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteJobExecutionRequest(input *DeleteJobExecutionInput) DeleteJobExecutionRequest {
	op := &aws.Operation{
		Name:       opDeleteJobExecution,
		HTTPMethod: "DELETE",
		HTTPPath:   "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
	}

	if input == nil {
		input = &DeleteJobExecutionInput{}
	}

	output := &DeleteJobExecutionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteJobExecutionRequest{Request: req, Input: input, Copy: c.DeleteJobExecutionRequest}
}

const opDeleteOTAUpdate = "DeleteOTAUpdate"

// DeleteOTAUpdateRequest is a API request type for the DeleteOTAUpdate API operation.
type DeleteOTAUpdateRequest struct {
	*aws.Request
	Input *DeleteOTAUpdateInput
	Copy  func(*DeleteOTAUpdateInput) DeleteOTAUpdateRequest
}

// Send marshals and sends the DeleteOTAUpdate API request.
func (r DeleteOTAUpdateRequest) Send() (*DeleteOTAUpdateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteOTAUpdateOutput), nil
}

// DeleteOTAUpdateRequest returns a request value for making API operation for
// AWS IoT.
//
// Delete an OTA update.
//
//    // Example sending a request using the DeleteOTAUpdateRequest method.
//    req := client.DeleteOTAUpdateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteOTAUpdateRequest(input *DeleteOTAUpdateInput) DeleteOTAUpdateRequest {
	op := &aws.Operation{
		Name:       opDeleteOTAUpdate,
		HTTPMethod: "DELETE",
		HTTPPath:   "/otaUpdates/{otaUpdateId}",
	}

	if input == nil {
		input = &DeleteOTAUpdateInput{}
	}

	output := &DeleteOTAUpdateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteOTAUpdateRequest{Request: req, Input: input, Copy: c.DeleteOTAUpdateRequest}
}

const opDeletePolicy = "DeletePolicy"

// DeletePolicyRequest is a API request type for the DeletePolicy API operation.
type DeletePolicyRequest struct {
	*aws.Request
	Input *DeletePolicyInput
	Copy  func(*DeletePolicyInput) DeletePolicyRequest
}

// Send marshals and sends the DeletePolicy API request.
func (r DeletePolicyRequest) Send() (*DeletePolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeletePolicyOutput), nil
}

// DeletePolicyRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes the specified policy.
//
// A policy cannot be deleted if it has non-default versions or it is attached
// to any certificate.
//
// To delete a policy, use the DeletePolicyVersion API to delete all non-default
// versions of the policy; use the DetachPrincipalPolicy API to detach the policy
// from any certificate; and then use the DeletePolicy API to delete the policy.
//
// When a policy is deleted using DeletePolicy, its default version is deleted
// with it.
//
//    // Example sending a request using the DeletePolicyRequest method.
//    req := client.DeletePolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeletePolicyRequest(input *DeletePolicyInput) DeletePolicyRequest {
	op := &aws.Operation{
		Name:       opDeletePolicy,
		HTTPMethod: "DELETE",
		HTTPPath:   "/policies/{policyName}",
	}

	if input == nil {
		input = &DeletePolicyInput{}
	}

	output := &DeletePolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeletePolicyRequest{Request: req, Input: input, Copy: c.DeletePolicyRequest}
}

const opDeletePolicyVersion = "DeletePolicyVersion"

// DeletePolicyVersionRequest is a API request type for the DeletePolicyVersion API operation.
type DeletePolicyVersionRequest struct {
	*aws.Request
	Input *DeletePolicyVersionInput
	Copy  func(*DeletePolicyVersionInput) DeletePolicyVersionRequest
}

// Send marshals and sends the DeletePolicyVersion API request.
func (r DeletePolicyVersionRequest) Send() (*DeletePolicyVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeletePolicyVersionOutput), nil
}

// DeletePolicyVersionRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes the specified version of the specified policy. You cannot delete
// the default version of a policy using this API. To delete the default version
// of a policy, use DeletePolicy. To find out which version of a policy is marked
// as the default version, use ListPolicyVersions.
//
//    // Example sending a request using the DeletePolicyVersionRequest method.
//    req := client.DeletePolicyVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeletePolicyVersionRequest(input *DeletePolicyVersionInput) DeletePolicyVersionRequest {
	op := &aws.Operation{
		Name:       opDeletePolicyVersion,
		HTTPMethod: "DELETE",
		HTTPPath:   "/policies/{policyName}/version/{policyVersionId}",
	}

	if input == nil {
		input = &DeletePolicyVersionInput{}
	}

	output := &DeletePolicyVersionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeletePolicyVersionRequest{Request: req, Input: input, Copy: c.DeletePolicyVersionRequest}
}

const opDeleteRegistrationCode = "DeleteRegistrationCode"

// DeleteRegistrationCodeRequest is a API request type for the DeleteRegistrationCode API operation.
type DeleteRegistrationCodeRequest struct {
	*aws.Request
	Input *DeleteRegistrationCodeInput
	Copy  func(*DeleteRegistrationCodeInput) DeleteRegistrationCodeRequest
}

// Send marshals and sends the DeleteRegistrationCode API request.
func (r DeleteRegistrationCodeRequest) Send() (*DeleteRegistrationCodeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteRegistrationCodeOutput), nil
}

// DeleteRegistrationCodeRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes a CA certificate registration code.
//
//    // Example sending a request using the DeleteRegistrationCodeRequest method.
//    req := client.DeleteRegistrationCodeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteRegistrationCodeRequest(input *DeleteRegistrationCodeInput) DeleteRegistrationCodeRequest {
	op := &aws.Operation{
		Name:       opDeleteRegistrationCode,
		HTTPMethod: "DELETE",
		HTTPPath:   "/registrationcode",
	}

	if input == nil {
		input = &DeleteRegistrationCodeInput{}
	}

	output := &DeleteRegistrationCodeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteRegistrationCodeRequest{Request: req, Input: input, Copy: c.DeleteRegistrationCodeRequest}
}

const opDeleteRoleAlias = "DeleteRoleAlias"

// DeleteRoleAliasRequest is a API request type for the DeleteRoleAlias API operation.
type DeleteRoleAliasRequest struct {
	*aws.Request
	Input *DeleteRoleAliasInput
	Copy  func(*DeleteRoleAliasInput) DeleteRoleAliasRequest
}

// Send marshals and sends the DeleteRoleAlias API request.
func (r DeleteRoleAliasRequest) Send() (*DeleteRoleAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteRoleAliasOutput), nil
}

// DeleteRoleAliasRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes a role alias
//
//    // Example sending a request using the DeleteRoleAliasRequest method.
//    req := client.DeleteRoleAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteRoleAliasRequest(input *DeleteRoleAliasInput) DeleteRoleAliasRequest {
	op := &aws.Operation{
		Name:       opDeleteRoleAlias,
		HTTPMethod: "DELETE",
		HTTPPath:   "/role-aliases/{roleAlias}",
	}

	if input == nil {
		input = &DeleteRoleAliasInput{}
	}

	output := &DeleteRoleAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteRoleAliasRequest{Request: req, Input: input, Copy: c.DeleteRoleAliasRequest}
}

const opDeleteStream = "DeleteStream"

// DeleteStreamRequest is a API request type for the DeleteStream API operation.
type DeleteStreamRequest struct {
	*aws.Request
	Input *DeleteStreamInput
	Copy  func(*DeleteStreamInput) DeleteStreamRequest
}

// Send marshals and sends the DeleteStream API request.
func (r DeleteStreamRequest) Send() (*DeleteStreamOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteStreamOutput), nil
}

// DeleteStreamRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes a stream.
//
//    // Example sending a request using the DeleteStreamRequest method.
//    req := client.DeleteStreamRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteStreamRequest(input *DeleteStreamInput) DeleteStreamRequest {
	op := &aws.Operation{
		Name:       opDeleteStream,
		HTTPMethod: "DELETE",
		HTTPPath:   "/streams/{streamId}",
	}

	if input == nil {
		input = &DeleteStreamInput{}
	}

	output := &DeleteStreamOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteStreamRequest{Request: req, Input: input, Copy: c.DeleteStreamRequest}
}

const opDeleteThing = "DeleteThing"

// DeleteThingRequest is a API request type for the DeleteThing API operation.
type DeleteThingRequest struct {
	*aws.Request
	Input *DeleteThingInput
	Copy  func(*DeleteThingInput) DeleteThingRequest
}

// Send marshals and sends the DeleteThing API request.
func (r DeleteThingRequest) Send() (*DeleteThingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteThingOutput), nil
}

// DeleteThingRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes the specified thing.
//
//    // Example sending a request using the DeleteThingRequest method.
//    req := client.DeleteThingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteThingRequest(input *DeleteThingInput) DeleteThingRequest {
	op := &aws.Operation{
		Name:       opDeleteThing,
		HTTPMethod: "DELETE",
		HTTPPath:   "/things/{thingName}",
	}

	if input == nil {
		input = &DeleteThingInput{}
	}

	output := &DeleteThingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteThingRequest{Request: req, Input: input, Copy: c.DeleteThingRequest}
}

const opDeleteThingGroup = "DeleteThingGroup"

// DeleteThingGroupRequest is a API request type for the DeleteThingGroup API operation.
type DeleteThingGroupRequest struct {
	*aws.Request
	Input *DeleteThingGroupInput
	Copy  func(*DeleteThingGroupInput) DeleteThingGroupRequest
}

// Send marshals and sends the DeleteThingGroup API request.
func (r DeleteThingGroupRequest) Send() (*DeleteThingGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteThingGroupOutput), nil
}

// DeleteThingGroupRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes a thing group.
//
//    // Example sending a request using the DeleteThingGroupRequest method.
//    req := client.DeleteThingGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteThingGroupRequest(input *DeleteThingGroupInput) DeleteThingGroupRequest {
	op := &aws.Operation{
		Name:       opDeleteThingGroup,
		HTTPMethod: "DELETE",
		HTTPPath:   "/thing-groups/{thingGroupName}",
	}

	if input == nil {
		input = &DeleteThingGroupInput{}
	}

	output := &DeleteThingGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteThingGroupRequest{Request: req, Input: input, Copy: c.DeleteThingGroupRequest}
}

const opDeleteThingType = "DeleteThingType"

// DeleteThingTypeRequest is a API request type for the DeleteThingType API operation.
type DeleteThingTypeRequest struct {
	*aws.Request
	Input *DeleteThingTypeInput
	Copy  func(*DeleteThingTypeInput) DeleteThingTypeRequest
}

// Send marshals and sends the DeleteThingType API request.
func (r DeleteThingTypeRequest) Send() (*DeleteThingTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteThingTypeOutput), nil
}

// DeleteThingTypeRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes the specified thing type . You cannot delete a thing type if it has
// things associated with it. To delete a thing type, first mark it as deprecated
// by calling DeprecateThingType, then remove any associated things by calling
// UpdateThing to change the thing type on any associated thing, and finally
// use DeleteThingType to delete the thing type.
//
//    // Example sending a request using the DeleteThingTypeRequest method.
//    req := client.DeleteThingTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteThingTypeRequest(input *DeleteThingTypeInput) DeleteThingTypeRequest {
	op := &aws.Operation{
		Name:       opDeleteThingType,
		HTTPMethod: "DELETE",
		HTTPPath:   "/thing-types/{thingTypeName}",
	}

	if input == nil {
		input = &DeleteThingTypeInput{}
	}

	output := &DeleteThingTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteThingTypeRequest{Request: req, Input: input, Copy: c.DeleteThingTypeRequest}
}

const opDeleteTopicRule = "DeleteTopicRule"

// DeleteTopicRuleRequest is a API request type for the DeleteTopicRule API operation.
type DeleteTopicRuleRequest struct {
	*aws.Request
	Input *DeleteTopicRuleInput
	Copy  func(*DeleteTopicRuleInput) DeleteTopicRuleRequest
}

// Send marshals and sends the DeleteTopicRule API request.
func (r DeleteTopicRuleRequest) Send() (*DeleteTopicRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTopicRuleOutput), nil
}

// DeleteTopicRuleRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes the rule.
//
//    // Example sending a request using the DeleteTopicRuleRequest method.
//    req := client.DeleteTopicRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteTopicRuleRequest(input *DeleteTopicRuleInput) DeleteTopicRuleRequest {
	op := &aws.Operation{
		Name:       opDeleteTopicRule,
		HTTPMethod: "DELETE",
		HTTPPath:   "/rules/{ruleName}",
	}

	if input == nil {
		input = &DeleteTopicRuleInput{}
	}

	output := &DeleteTopicRuleOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTopicRuleRequest{Request: req, Input: input, Copy: c.DeleteTopicRuleRequest}
}

const opDeleteV2LoggingLevel = "DeleteV2LoggingLevel"

// DeleteV2LoggingLevelRequest is a API request type for the DeleteV2LoggingLevel API operation.
type DeleteV2LoggingLevelRequest struct {
	*aws.Request
	Input *DeleteV2LoggingLevelInput
	Copy  func(*DeleteV2LoggingLevelInput) DeleteV2LoggingLevelRequest
}

// Send marshals and sends the DeleteV2LoggingLevel API request.
func (r DeleteV2LoggingLevelRequest) Send() (*DeleteV2LoggingLevelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteV2LoggingLevelOutput), nil
}

// DeleteV2LoggingLevelRequest returns a request value for making API operation for
// AWS IoT.
//
// Deletes a logging level.
//
//    // Example sending a request using the DeleteV2LoggingLevelRequest method.
//    req := client.DeleteV2LoggingLevelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeleteV2LoggingLevelRequest(input *DeleteV2LoggingLevelInput) DeleteV2LoggingLevelRequest {
	op := &aws.Operation{
		Name:       opDeleteV2LoggingLevel,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v2LoggingLevel",
	}

	if input == nil {
		input = &DeleteV2LoggingLevelInput{}
	}

	output := &DeleteV2LoggingLevelOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteV2LoggingLevelRequest{Request: req, Input: input, Copy: c.DeleteV2LoggingLevelRequest}
}

const opDeprecateThingType = "DeprecateThingType"

// DeprecateThingTypeRequest is a API request type for the DeprecateThingType API operation.
type DeprecateThingTypeRequest struct {
	*aws.Request
	Input *DeprecateThingTypeInput
	Copy  func(*DeprecateThingTypeInput) DeprecateThingTypeRequest
}

// Send marshals and sends the DeprecateThingType API request.
func (r DeprecateThingTypeRequest) Send() (*DeprecateThingTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeprecateThingTypeOutput), nil
}

// DeprecateThingTypeRequest returns a request value for making API operation for
// AWS IoT.
//
// Deprecates a thing type. You can not associate new things with deprecated
// thing type.
//
//    // Example sending a request using the DeprecateThingTypeRequest method.
//    req := client.DeprecateThingTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DeprecateThingTypeRequest(input *DeprecateThingTypeInput) DeprecateThingTypeRequest {
	op := &aws.Operation{
		Name:       opDeprecateThingType,
		HTTPMethod: "POST",
		HTTPPath:   "/thing-types/{thingTypeName}/deprecate",
	}

	if input == nil {
		input = &DeprecateThingTypeInput{}
	}

	output := &DeprecateThingTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeprecateThingTypeRequest{Request: req, Input: input, Copy: c.DeprecateThingTypeRequest}
}

const opDescribeAuthorizer = "DescribeAuthorizer"

// DescribeAuthorizerRequest is a API request type for the DescribeAuthorizer API operation.
type DescribeAuthorizerRequest struct {
	*aws.Request
	Input *DescribeAuthorizerInput
	Copy  func(*DescribeAuthorizerInput) DescribeAuthorizerRequest
}

// Send marshals and sends the DescribeAuthorizer API request.
func (r DescribeAuthorizerRequest) Send() (*DescribeAuthorizerOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeAuthorizerOutput), nil
}

// DescribeAuthorizerRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes an authorizer.
//
//    // Example sending a request using the DescribeAuthorizerRequest method.
//    req := client.DescribeAuthorizerRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeAuthorizerRequest(input *DescribeAuthorizerInput) DescribeAuthorizerRequest {
	op := &aws.Operation{
		Name:       opDescribeAuthorizer,
		HTTPMethod: "GET",
		HTTPPath:   "/authorizer/{authorizerName}",
	}

	if input == nil {
		input = &DescribeAuthorizerInput{}
	}

	output := &DescribeAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeAuthorizerRequest{Request: req, Input: input, Copy: c.DescribeAuthorizerRequest}
}

const opDescribeCACertificate = "DescribeCACertificate"

// DescribeCACertificateRequest is a API request type for the DescribeCACertificate API operation.
type DescribeCACertificateRequest struct {
	*aws.Request
	Input *DescribeCACertificateInput
	Copy  func(*DescribeCACertificateInput) DescribeCACertificateRequest
}

// Send marshals and sends the DescribeCACertificate API request.
func (r DescribeCACertificateRequest) Send() (*DescribeCACertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeCACertificateOutput), nil
}

// DescribeCACertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes a registered CA certificate.
//
//    // Example sending a request using the DescribeCACertificateRequest method.
//    req := client.DescribeCACertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeCACertificateRequest(input *DescribeCACertificateInput) DescribeCACertificateRequest {
	op := &aws.Operation{
		Name:       opDescribeCACertificate,
		HTTPMethod: "GET",
		HTTPPath:   "/cacertificate/{caCertificateId}",
	}

	if input == nil {
		input = &DescribeCACertificateInput{}
	}

	output := &DescribeCACertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeCACertificateRequest{Request: req, Input: input, Copy: c.DescribeCACertificateRequest}
}

const opDescribeCertificate = "DescribeCertificate"

// DescribeCertificateRequest is a API request type for the DescribeCertificate API operation.
type DescribeCertificateRequest struct {
	*aws.Request
	Input *DescribeCertificateInput
	Copy  func(*DescribeCertificateInput) DescribeCertificateRequest
}

// Send marshals and sends the DescribeCertificate API request.
func (r DescribeCertificateRequest) Send() (*DescribeCertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeCertificateOutput), nil
}

// DescribeCertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets information about the specified certificate.
//
//    // Example sending a request using the DescribeCertificateRequest method.
//    req := client.DescribeCertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeCertificateRequest(input *DescribeCertificateInput) DescribeCertificateRequest {
	op := &aws.Operation{
		Name:       opDescribeCertificate,
		HTTPMethod: "GET",
		HTTPPath:   "/certificates/{certificateId}",
	}

	if input == nil {
		input = &DescribeCertificateInput{}
	}

	output := &DescribeCertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeCertificateRequest{Request: req, Input: input, Copy: c.DescribeCertificateRequest}
}

const opDescribeDefaultAuthorizer = "DescribeDefaultAuthorizer"

// DescribeDefaultAuthorizerRequest is a API request type for the DescribeDefaultAuthorizer API operation.
type DescribeDefaultAuthorizerRequest struct {
	*aws.Request
	Input *DescribeDefaultAuthorizerInput
	Copy  func(*DescribeDefaultAuthorizerInput) DescribeDefaultAuthorizerRequest
}

// Send marshals and sends the DescribeDefaultAuthorizer API request.
func (r DescribeDefaultAuthorizerRequest) Send() (*DescribeDefaultAuthorizerOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeDefaultAuthorizerOutput), nil
}

// DescribeDefaultAuthorizerRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes the default authorizer.
//
//    // Example sending a request using the DescribeDefaultAuthorizerRequest method.
//    req := client.DescribeDefaultAuthorizerRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeDefaultAuthorizerRequest(input *DescribeDefaultAuthorizerInput) DescribeDefaultAuthorizerRequest {
	op := &aws.Operation{
		Name:       opDescribeDefaultAuthorizer,
		HTTPMethod: "GET",
		HTTPPath:   "/default-authorizer",
	}

	if input == nil {
		input = &DescribeDefaultAuthorizerInput{}
	}

	output := &DescribeDefaultAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeDefaultAuthorizerRequest{Request: req, Input: input, Copy: c.DescribeDefaultAuthorizerRequest}
}

const opDescribeEndpoint = "DescribeEndpoint"

// DescribeEndpointRequest is a API request type for the DescribeEndpoint API operation.
type DescribeEndpointRequest struct {
	*aws.Request
	Input *DescribeEndpointInput
	Copy  func(*DescribeEndpointInput) DescribeEndpointRequest
}

// Send marshals and sends the DescribeEndpoint API request.
func (r DescribeEndpointRequest) Send() (*DescribeEndpointOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeEndpointOutput), nil
}

// DescribeEndpointRequest returns a request value for making API operation for
// AWS IoT.
//
// Returns a unique endpoint specific to the AWS account making the call.
//
//    // Example sending a request using the DescribeEndpointRequest method.
//    req := client.DescribeEndpointRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeEndpointRequest(input *DescribeEndpointInput) DescribeEndpointRequest {
	op := &aws.Operation{
		Name:       opDescribeEndpoint,
		HTTPMethod: "GET",
		HTTPPath:   "/endpoint",
	}

	if input == nil {
		input = &DescribeEndpointInput{}
	}

	output := &DescribeEndpointOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeEndpointRequest{Request: req, Input: input, Copy: c.DescribeEndpointRequest}
}

const opDescribeEventConfigurations = "DescribeEventConfigurations"

// DescribeEventConfigurationsRequest is a API request type for the DescribeEventConfigurations API operation.
type DescribeEventConfigurationsRequest struct {
	*aws.Request
	Input *DescribeEventConfigurationsInput
	Copy  func(*DescribeEventConfigurationsInput) DescribeEventConfigurationsRequest
}

// Send marshals and sends the DescribeEventConfigurations API request.
func (r DescribeEventConfigurationsRequest) Send() (*DescribeEventConfigurationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeEventConfigurationsOutput), nil
}

// DescribeEventConfigurationsRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes event configurations.
//
//    // Example sending a request using the DescribeEventConfigurationsRequest method.
//    req := client.DescribeEventConfigurationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeEventConfigurationsRequest(input *DescribeEventConfigurationsInput) DescribeEventConfigurationsRequest {
	op := &aws.Operation{
		Name:       opDescribeEventConfigurations,
		HTTPMethod: "GET",
		HTTPPath:   "/event-configurations",
	}

	if input == nil {
		input = &DescribeEventConfigurationsInput{}
	}

	output := &DescribeEventConfigurationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeEventConfigurationsRequest{Request: req, Input: input, Copy: c.DescribeEventConfigurationsRequest}
}

const opDescribeIndex = "DescribeIndex"

// DescribeIndexRequest is a API request type for the DescribeIndex API operation.
type DescribeIndexRequest struct {
	*aws.Request
	Input *DescribeIndexInput
	Copy  func(*DescribeIndexInput) DescribeIndexRequest
}

// Send marshals and sends the DescribeIndex API request.
func (r DescribeIndexRequest) Send() (*DescribeIndexOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeIndexOutput), nil
}

// DescribeIndexRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes a search index.
//
//    // Example sending a request using the DescribeIndexRequest method.
//    req := client.DescribeIndexRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeIndexRequest(input *DescribeIndexInput) DescribeIndexRequest {
	op := &aws.Operation{
		Name:       opDescribeIndex,
		HTTPMethod: "GET",
		HTTPPath:   "/indices/{indexName}",
	}

	if input == nil {
		input = &DescribeIndexInput{}
	}

	output := &DescribeIndexOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeIndexRequest{Request: req, Input: input, Copy: c.DescribeIndexRequest}
}

const opDescribeJob = "DescribeJob"

// DescribeJobRequest is a API request type for the DescribeJob API operation.
type DescribeJobRequest struct {
	*aws.Request
	Input *DescribeJobInput
	Copy  func(*DescribeJobInput) DescribeJobRequest
}

// Send marshals and sends the DescribeJob API request.
func (r DescribeJobRequest) Send() (*DescribeJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeJobOutput), nil
}

// DescribeJobRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes a job.
//
//    // Example sending a request using the DescribeJobRequest method.
//    req := client.DescribeJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeJobRequest(input *DescribeJobInput) DescribeJobRequest {
	op := &aws.Operation{
		Name:       opDescribeJob,
		HTTPMethod: "GET",
		HTTPPath:   "/jobs/{jobId}",
	}

	if input == nil {
		input = &DescribeJobInput{}
	}

	output := &DescribeJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeJobRequest{Request: req, Input: input, Copy: c.DescribeJobRequest}
}

const opDescribeJobExecution = "DescribeJobExecution"

// DescribeJobExecutionRequest is a API request type for the DescribeJobExecution API operation.
type DescribeJobExecutionRequest struct {
	*aws.Request
	Input *DescribeJobExecutionInput
	Copy  func(*DescribeJobExecutionInput) DescribeJobExecutionRequest
}

// Send marshals and sends the DescribeJobExecution API request.
func (r DescribeJobExecutionRequest) Send() (*DescribeJobExecutionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeJobExecutionOutput), nil
}

// DescribeJobExecutionRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes a job execution.
//
//    // Example sending a request using the DescribeJobExecutionRequest method.
//    req := client.DescribeJobExecutionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeJobExecutionRequest(input *DescribeJobExecutionInput) DescribeJobExecutionRequest {
	op := &aws.Operation{
		Name:       opDescribeJobExecution,
		HTTPMethod: "GET",
		HTTPPath:   "/things/{thingName}/jobs/{jobId}",
	}

	if input == nil {
		input = &DescribeJobExecutionInput{}
	}

	output := &DescribeJobExecutionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeJobExecutionRequest{Request: req, Input: input, Copy: c.DescribeJobExecutionRequest}
}

const opDescribeRoleAlias = "DescribeRoleAlias"

// DescribeRoleAliasRequest is a API request type for the DescribeRoleAlias API operation.
type DescribeRoleAliasRequest struct {
	*aws.Request
	Input *DescribeRoleAliasInput
	Copy  func(*DescribeRoleAliasInput) DescribeRoleAliasRequest
}

// Send marshals and sends the DescribeRoleAlias API request.
func (r DescribeRoleAliasRequest) Send() (*DescribeRoleAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeRoleAliasOutput), nil
}

// DescribeRoleAliasRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes a role alias.
//
//    // Example sending a request using the DescribeRoleAliasRequest method.
//    req := client.DescribeRoleAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeRoleAliasRequest(input *DescribeRoleAliasInput) DescribeRoleAliasRequest {
	op := &aws.Operation{
		Name:       opDescribeRoleAlias,
		HTTPMethod: "GET",
		HTTPPath:   "/role-aliases/{roleAlias}",
	}

	if input == nil {
		input = &DescribeRoleAliasInput{}
	}

	output := &DescribeRoleAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeRoleAliasRequest{Request: req, Input: input, Copy: c.DescribeRoleAliasRequest}
}

const opDescribeStream = "DescribeStream"

// DescribeStreamRequest is a API request type for the DescribeStream API operation.
type DescribeStreamRequest struct {
	*aws.Request
	Input *DescribeStreamInput
	Copy  func(*DescribeStreamInput) DescribeStreamRequest
}

// Send marshals and sends the DescribeStream API request.
func (r DescribeStreamRequest) Send() (*DescribeStreamOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeStreamOutput), nil
}

// DescribeStreamRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets information about a stream.
//
//    // Example sending a request using the DescribeStreamRequest method.
//    req := client.DescribeStreamRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeStreamRequest(input *DescribeStreamInput) DescribeStreamRequest {
	op := &aws.Operation{
		Name:       opDescribeStream,
		HTTPMethod: "GET",
		HTTPPath:   "/streams/{streamId}",
	}

	if input == nil {
		input = &DescribeStreamInput{}
	}

	output := &DescribeStreamOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeStreamRequest{Request: req, Input: input, Copy: c.DescribeStreamRequest}
}

const opDescribeThing = "DescribeThing"

// DescribeThingRequest is a API request type for the DescribeThing API operation.
type DescribeThingRequest struct {
	*aws.Request
	Input *DescribeThingInput
	Copy  func(*DescribeThingInput) DescribeThingRequest
}

// Send marshals and sends the DescribeThing API request.
func (r DescribeThingRequest) Send() (*DescribeThingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeThingOutput), nil
}

// DescribeThingRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets information about the specified thing.
//
//    // Example sending a request using the DescribeThingRequest method.
//    req := client.DescribeThingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeThingRequest(input *DescribeThingInput) DescribeThingRequest {
	op := &aws.Operation{
		Name:       opDescribeThing,
		HTTPMethod: "GET",
		HTTPPath:   "/things/{thingName}",
	}

	if input == nil {
		input = &DescribeThingInput{}
	}

	output := &DescribeThingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeThingRequest{Request: req, Input: input, Copy: c.DescribeThingRequest}
}

const opDescribeThingGroup = "DescribeThingGroup"

// DescribeThingGroupRequest is a API request type for the DescribeThingGroup API operation.
type DescribeThingGroupRequest struct {
	*aws.Request
	Input *DescribeThingGroupInput
	Copy  func(*DescribeThingGroupInput) DescribeThingGroupRequest
}

// Send marshals and sends the DescribeThingGroup API request.
func (r DescribeThingGroupRequest) Send() (*DescribeThingGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeThingGroupOutput), nil
}

// DescribeThingGroupRequest returns a request value for making API operation for
// AWS IoT.
//
// Describe a thing group.
//
//    // Example sending a request using the DescribeThingGroupRequest method.
//    req := client.DescribeThingGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeThingGroupRequest(input *DescribeThingGroupInput) DescribeThingGroupRequest {
	op := &aws.Operation{
		Name:       opDescribeThingGroup,
		HTTPMethod: "GET",
		HTTPPath:   "/thing-groups/{thingGroupName}",
	}

	if input == nil {
		input = &DescribeThingGroupInput{}
	}

	output := &DescribeThingGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeThingGroupRequest{Request: req, Input: input, Copy: c.DescribeThingGroupRequest}
}

const opDescribeThingRegistrationTask = "DescribeThingRegistrationTask"

// DescribeThingRegistrationTaskRequest is a API request type for the DescribeThingRegistrationTask API operation.
type DescribeThingRegistrationTaskRequest struct {
	*aws.Request
	Input *DescribeThingRegistrationTaskInput
	Copy  func(*DescribeThingRegistrationTaskInput) DescribeThingRegistrationTaskRequest
}

// Send marshals and sends the DescribeThingRegistrationTask API request.
func (r DescribeThingRegistrationTaskRequest) Send() (*DescribeThingRegistrationTaskOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeThingRegistrationTaskOutput), nil
}

// DescribeThingRegistrationTaskRequest returns a request value for making API operation for
// AWS IoT.
//
// Describes a bulk thing provisioning task.
//
//    // Example sending a request using the DescribeThingRegistrationTaskRequest method.
//    req := client.DescribeThingRegistrationTaskRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeThingRegistrationTaskRequest(input *DescribeThingRegistrationTaskInput) DescribeThingRegistrationTaskRequest {
	op := &aws.Operation{
		Name:       opDescribeThingRegistrationTask,
		HTTPMethod: "GET",
		HTTPPath:   "/thing-registration-tasks/{taskId}",
	}

	if input == nil {
		input = &DescribeThingRegistrationTaskInput{}
	}

	output := &DescribeThingRegistrationTaskOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeThingRegistrationTaskRequest{Request: req, Input: input, Copy: c.DescribeThingRegistrationTaskRequest}
}

const opDescribeThingType = "DescribeThingType"

// DescribeThingTypeRequest is a API request type for the DescribeThingType API operation.
type DescribeThingTypeRequest struct {
	*aws.Request
	Input *DescribeThingTypeInput
	Copy  func(*DescribeThingTypeInput) DescribeThingTypeRequest
}

// Send marshals and sends the DescribeThingType API request.
func (r DescribeThingTypeRequest) Send() (*DescribeThingTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeThingTypeOutput), nil
}

// DescribeThingTypeRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets information about the specified thing type.
//
//    // Example sending a request using the DescribeThingTypeRequest method.
//    req := client.DescribeThingTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DescribeThingTypeRequest(input *DescribeThingTypeInput) DescribeThingTypeRequest {
	op := &aws.Operation{
		Name:       opDescribeThingType,
		HTTPMethod: "GET",
		HTTPPath:   "/thing-types/{thingTypeName}",
	}

	if input == nil {
		input = &DescribeThingTypeInput{}
	}

	output := &DescribeThingTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeThingTypeRequest{Request: req, Input: input, Copy: c.DescribeThingTypeRequest}
}

const opDetachPolicy = "DetachPolicy"

// DetachPolicyRequest is a API request type for the DetachPolicy API operation.
type DetachPolicyRequest struct {
	*aws.Request
	Input *DetachPolicyInput
	Copy  func(*DetachPolicyInput) DetachPolicyRequest
}

// Send marshals and sends the DetachPolicy API request.
func (r DetachPolicyRequest) Send() (*DetachPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DetachPolicyOutput), nil
}

// DetachPolicyRequest returns a request value for making API operation for
// AWS IoT.
//
// Detaches a policy from the specified target.
//
//    // Example sending a request using the DetachPolicyRequest method.
//    req := client.DetachPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DetachPolicyRequest(input *DetachPolicyInput) DetachPolicyRequest {
	op := &aws.Operation{
		Name:       opDetachPolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/target-policies/{policyName}",
	}

	if input == nil {
		input = &DetachPolicyInput{}
	}

	output := &DetachPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DetachPolicyRequest{Request: req, Input: input, Copy: c.DetachPolicyRequest}
}

const opDetachPrincipalPolicy = "DetachPrincipalPolicy"

// DetachPrincipalPolicyRequest is a API request type for the DetachPrincipalPolicy API operation.
type DetachPrincipalPolicyRequest struct {
	*aws.Request
	Input *DetachPrincipalPolicyInput
	Copy  func(*DetachPrincipalPolicyInput) DetachPrincipalPolicyRequest
}

// Send marshals and sends the DetachPrincipalPolicy API request.
func (r DetachPrincipalPolicyRequest) Send() (*DetachPrincipalPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DetachPrincipalPolicyOutput), nil
}

// DetachPrincipalPolicyRequest returns a request value for making API operation for
// AWS IoT.
//
// Removes the specified policy from the specified certificate.
//
// Note: This API is deprecated. Please use DetachPolicy instead.
//
//    // Example sending a request using the DetachPrincipalPolicyRequest method.
//    req := client.DetachPrincipalPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DetachPrincipalPolicyRequest(input *DetachPrincipalPolicyInput) DetachPrincipalPolicyRequest {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, DetachPrincipalPolicy, has been deprecated")
	}
	op := &aws.Operation{
		Name:       opDetachPrincipalPolicy,
		HTTPMethod: "DELETE",
		HTTPPath:   "/principal-policies/{policyName}",
	}

	if input == nil {
		input = &DetachPrincipalPolicyInput{}
	}

	output := &DetachPrincipalPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DetachPrincipalPolicyRequest{Request: req, Input: input, Copy: c.DetachPrincipalPolicyRequest}
}

const opDetachThingPrincipal = "DetachThingPrincipal"

// DetachThingPrincipalRequest is a API request type for the DetachThingPrincipal API operation.
type DetachThingPrincipalRequest struct {
	*aws.Request
	Input *DetachThingPrincipalInput
	Copy  func(*DetachThingPrincipalInput) DetachThingPrincipalRequest
}

// Send marshals and sends the DetachThingPrincipal API request.
func (r DetachThingPrincipalRequest) Send() (*DetachThingPrincipalOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DetachThingPrincipalOutput), nil
}

// DetachThingPrincipalRequest returns a request value for making API operation for
// AWS IoT.
//
// Detaches the specified principal from the specified thing.
//
//    // Example sending a request using the DetachThingPrincipalRequest method.
//    req := client.DetachThingPrincipalRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DetachThingPrincipalRequest(input *DetachThingPrincipalInput) DetachThingPrincipalRequest {
	op := &aws.Operation{
		Name:       opDetachThingPrincipal,
		HTTPMethod: "DELETE",
		HTTPPath:   "/things/{thingName}/principals",
	}

	if input == nil {
		input = &DetachThingPrincipalInput{}
	}

	output := &DetachThingPrincipalOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DetachThingPrincipalRequest{Request: req, Input: input, Copy: c.DetachThingPrincipalRequest}
}

const opDisableTopicRule = "DisableTopicRule"

// DisableTopicRuleRequest is a API request type for the DisableTopicRule API operation.
type DisableTopicRuleRequest struct {
	*aws.Request
	Input *DisableTopicRuleInput
	Copy  func(*DisableTopicRuleInput) DisableTopicRuleRequest
}

// Send marshals and sends the DisableTopicRule API request.
func (r DisableTopicRuleRequest) Send() (*DisableTopicRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DisableTopicRuleOutput), nil
}

// DisableTopicRuleRequest returns a request value for making API operation for
// AWS IoT.
//
// Disables the rule.
//
//    // Example sending a request using the DisableTopicRuleRequest method.
//    req := client.DisableTopicRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) DisableTopicRuleRequest(input *DisableTopicRuleInput) DisableTopicRuleRequest {
	op := &aws.Operation{
		Name:       opDisableTopicRule,
		HTTPMethod: "POST",
		HTTPPath:   "/rules/{ruleName}/disable",
	}

	if input == nil {
		input = &DisableTopicRuleInput{}
	}

	output := &DisableTopicRuleOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DisableTopicRuleRequest{Request: req, Input: input, Copy: c.DisableTopicRuleRequest}
}

const opEnableTopicRule = "EnableTopicRule"

// EnableTopicRuleRequest is a API request type for the EnableTopicRule API operation.
type EnableTopicRuleRequest struct {
	*aws.Request
	Input *EnableTopicRuleInput
	Copy  func(*EnableTopicRuleInput) EnableTopicRuleRequest
}

// Send marshals and sends the EnableTopicRule API request.
func (r EnableTopicRuleRequest) Send() (*EnableTopicRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*EnableTopicRuleOutput), nil
}

// EnableTopicRuleRequest returns a request value for making API operation for
// AWS IoT.
//
// Enables the rule.
//
//    // Example sending a request using the EnableTopicRuleRequest method.
//    req := client.EnableTopicRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) EnableTopicRuleRequest(input *EnableTopicRuleInput) EnableTopicRuleRequest {
	op := &aws.Operation{
		Name:       opEnableTopicRule,
		HTTPMethod: "POST",
		HTTPPath:   "/rules/{ruleName}/enable",
	}

	if input == nil {
		input = &EnableTopicRuleInput{}
	}

	output := &EnableTopicRuleOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return EnableTopicRuleRequest{Request: req, Input: input, Copy: c.EnableTopicRuleRequest}
}

const opGetEffectivePolicies = "GetEffectivePolicies"

// GetEffectivePoliciesRequest is a API request type for the GetEffectivePolicies API operation.
type GetEffectivePoliciesRequest struct {
	*aws.Request
	Input *GetEffectivePoliciesInput
	Copy  func(*GetEffectivePoliciesInput) GetEffectivePoliciesRequest
}

// Send marshals and sends the GetEffectivePolicies API request.
func (r GetEffectivePoliciesRequest) Send() (*GetEffectivePoliciesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetEffectivePoliciesOutput), nil
}

// GetEffectivePoliciesRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets a list of the policies that have an effect on the authorization behavior
// of the specified device when it connects to the AWS IoT device gateway.
//
//    // Example sending a request using the GetEffectivePoliciesRequest method.
//    req := client.GetEffectivePoliciesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetEffectivePoliciesRequest(input *GetEffectivePoliciesInput) GetEffectivePoliciesRequest {
	op := &aws.Operation{
		Name:       opGetEffectivePolicies,
		HTTPMethod: "POST",
		HTTPPath:   "/effective-policies",
	}

	if input == nil {
		input = &GetEffectivePoliciesInput{}
	}

	output := &GetEffectivePoliciesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetEffectivePoliciesRequest{Request: req, Input: input, Copy: c.GetEffectivePoliciesRequest}
}

const opGetIndexingConfiguration = "GetIndexingConfiguration"

// GetIndexingConfigurationRequest is a API request type for the GetIndexingConfiguration API operation.
type GetIndexingConfigurationRequest struct {
	*aws.Request
	Input *GetIndexingConfigurationInput
	Copy  func(*GetIndexingConfigurationInput) GetIndexingConfigurationRequest
}

// Send marshals and sends the GetIndexingConfiguration API request.
func (r GetIndexingConfigurationRequest) Send() (*GetIndexingConfigurationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetIndexingConfigurationOutput), nil
}

// GetIndexingConfigurationRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets the search configuration.
//
//    // Example sending a request using the GetIndexingConfigurationRequest method.
//    req := client.GetIndexingConfigurationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetIndexingConfigurationRequest(input *GetIndexingConfigurationInput) GetIndexingConfigurationRequest {
	op := &aws.Operation{
		Name:       opGetIndexingConfiguration,
		HTTPMethod: "GET",
		HTTPPath:   "/indexing/config",
	}

	if input == nil {
		input = &GetIndexingConfigurationInput{}
	}

	output := &GetIndexingConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetIndexingConfigurationRequest{Request: req, Input: input, Copy: c.GetIndexingConfigurationRequest}
}

const opGetJobDocument = "GetJobDocument"

// GetJobDocumentRequest is a API request type for the GetJobDocument API operation.
type GetJobDocumentRequest struct {
	*aws.Request
	Input *GetJobDocumentInput
	Copy  func(*GetJobDocumentInput) GetJobDocumentRequest
}

// Send marshals and sends the GetJobDocument API request.
func (r GetJobDocumentRequest) Send() (*GetJobDocumentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetJobDocumentOutput), nil
}

// GetJobDocumentRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets a job document.
//
//    // Example sending a request using the GetJobDocumentRequest method.
//    req := client.GetJobDocumentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetJobDocumentRequest(input *GetJobDocumentInput) GetJobDocumentRequest {
	op := &aws.Operation{
		Name:       opGetJobDocument,
		HTTPMethod: "GET",
		HTTPPath:   "/jobs/{jobId}/job-document",
	}

	if input == nil {
		input = &GetJobDocumentInput{}
	}

	output := &GetJobDocumentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetJobDocumentRequest{Request: req, Input: input, Copy: c.GetJobDocumentRequest}
}

const opGetLoggingOptions = "GetLoggingOptions"

// GetLoggingOptionsRequest is a API request type for the GetLoggingOptions API operation.
type GetLoggingOptionsRequest struct {
	*aws.Request
	Input *GetLoggingOptionsInput
	Copy  func(*GetLoggingOptionsInput) GetLoggingOptionsRequest
}

// Send marshals and sends the GetLoggingOptions API request.
func (r GetLoggingOptionsRequest) Send() (*GetLoggingOptionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetLoggingOptionsOutput), nil
}

// GetLoggingOptionsRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets the logging options.
//
//    // Example sending a request using the GetLoggingOptionsRequest method.
//    req := client.GetLoggingOptionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetLoggingOptionsRequest(input *GetLoggingOptionsInput) GetLoggingOptionsRequest {
	op := &aws.Operation{
		Name:       opGetLoggingOptions,
		HTTPMethod: "GET",
		HTTPPath:   "/loggingOptions",
	}

	if input == nil {
		input = &GetLoggingOptionsInput{}
	}

	output := &GetLoggingOptionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetLoggingOptionsRequest{Request: req, Input: input, Copy: c.GetLoggingOptionsRequest}
}

const opGetOTAUpdate = "GetOTAUpdate"

// GetOTAUpdateRequest is a API request type for the GetOTAUpdate API operation.
type GetOTAUpdateRequest struct {
	*aws.Request
	Input *GetOTAUpdateInput
	Copy  func(*GetOTAUpdateInput) GetOTAUpdateRequest
}

// Send marshals and sends the GetOTAUpdate API request.
func (r GetOTAUpdateRequest) Send() (*GetOTAUpdateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetOTAUpdateOutput), nil
}

// GetOTAUpdateRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets an OTA update.
//
//    // Example sending a request using the GetOTAUpdateRequest method.
//    req := client.GetOTAUpdateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetOTAUpdateRequest(input *GetOTAUpdateInput) GetOTAUpdateRequest {
	op := &aws.Operation{
		Name:       opGetOTAUpdate,
		HTTPMethod: "GET",
		HTTPPath:   "/otaUpdates/{otaUpdateId}",
	}

	if input == nil {
		input = &GetOTAUpdateInput{}
	}

	output := &GetOTAUpdateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetOTAUpdateRequest{Request: req, Input: input, Copy: c.GetOTAUpdateRequest}
}

const opGetPolicy = "GetPolicy"

// GetPolicyRequest is a API request type for the GetPolicy API operation.
type GetPolicyRequest struct {
	*aws.Request
	Input *GetPolicyInput
	Copy  func(*GetPolicyInput) GetPolicyRequest
}

// Send marshals and sends the GetPolicy API request.
func (r GetPolicyRequest) Send() (*GetPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetPolicyOutput), nil
}

// GetPolicyRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets information about the specified policy with the policy document of the
// default version.
//
//    // Example sending a request using the GetPolicyRequest method.
//    req := client.GetPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetPolicyRequest(input *GetPolicyInput) GetPolicyRequest {
	op := &aws.Operation{
		Name:       opGetPolicy,
		HTTPMethod: "GET",
		HTTPPath:   "/policies/{policyName}",
	}

	if input == nil {
		input = &GetPolicyInput{}
	}

	output := &GetPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetPolicyRequest{Request: req, Input: input, Copy: c.GetPolicyRequest}
}

const opGetPolicyVersion = "GetPolicyVersion"

// GetPolicyVersionRequest is a API request type for the GetPolicyVersion API operation.
type GetPolicyVersionRequest struct {
	*aws.Request
	Input *GetPolicyVersionInput
	Copy  func(*GetPolicyVersionInput) GetPolicyVersionRequest
}

// Send marshals and sends the GetPolicyVersion API request.
func (r GetPolicyVersionRequest) Send() (*GetPolicyVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetPolicyVersionOutput), nil
}

// GetPolicyVersionRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets information about the specified policy version.
//
//    // Example sending a request using the GetPolicyVersionRequest method.
//    req := client.GetPolicyVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetPolicyVersionRequest(input *GetPolicyVersionInput) GetPolicyVersionRequest {
	op := &aws.Operation{
		Name:       opGetPolicyVersion,
		HTTPMethod: "GET",
		HTTPPath:   "/policies/{policyName}/version/{policyVersionId}",
	}

	if input == nil {
		input = &GetPolicyVersionInput{}
	}

	output := &GetPolicyVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetPolicyVersionRequest{Request: req, Input: input, Copy: c.GetPolicyVersionRequest}
}

const opGetRegistrationCode = "GetRegistrationCode"

// GetRegistrationCodeRequest is a API request type for the GetRegistrationCode API operation.
type GetRegistrationCodeRequest struct {
	*aws.Request
	Input *GetRegistrationCodeInput
	Copy  func(*GetRegistrationCodeInput) GetRegistrationCodeRequest
}

// Send marshals and sends the GetRegistrationCode API request.
func (r GetRegistrationCodeRequest) Send() (*GetRegistrationCodeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetRegistrationCodeOutput), nil
}

// GetRegistrationCodeRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets a registration code used to register a CA certificate with AWS IoT.
//
//    // Example sending a request using the GetRegistrationCodeRequest method.
//    req := client.GetRegistrationCodeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetRegistrationCodeRequest(input *GetRegistrationCodeInput) GetRegistrationCodeRequest {
	op := &aws.Operation{
		Name:       opGetRegistrationCode,
		HTTPMethod: "GET",
		HTTPPath:   "/registrationcode",
	}

	if input == nil {
		input = &GetRegistrationCodeInput{}
	}

	output := &GetRegistrationCodeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetRegistrationCodeRequest{Request: req, Input: input, Copy: c.GetRegistrationCodeRequest}
}

const opGetTopicRule = "GetTopicRule"

// GetTopicRuleRequest is a API request type for the GetTopicRule API operation.
type GetTopicRuleRequest struct {
	*aws.Request
	Input *GetTopicRuleInput
	Copy  func(*GetTopicRuleInput) GetTopicRuleRequest
}

// Send marshals and sends the GetTopicRule API request.
func (r GetTopicRuleRequest) Send() (*GetTopicRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTopicRuleOutput), nil
}

// GetTopicRuleRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets information about the rule.
//
//    // Example sending a request using the GetTopicRuleRequest method.
//    req := client.GetTopicRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetTopicRuleRequest(input *GetTopicRuleInput) GetTopicRuleRequest {
	op := &aws.Operation{
		Name:       opGetTopicRule,
		HTTPMethod: "GET",
		HTTPPath:   "/rules/{ruleName}",
	}

	if input == nil {
		input = &GetTopicRuleInput{}
	}

	output := &GetTopicRuleOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTopicRuleRequest{Request: req, Input: input, Copy: c.GetTopicRuleRequest}
}

const opGetV2LoggingOptions = "GetV2LoggingOptions"

// GetV2LoggingOptionsRequest is a API request type for the GetV2LoggingOptions API operation.
type GetV2LoggingOptionsRequest struct {
	*aws.Request
	Input *GetV2LoggingOptionsInput
	Copy  func(*GetV2LoggingOptionsInput) GetV2LoggingOptionsRequest
}

// Send marshals and sends the GetV2LoggingOptions API request.
func (r GetV2LoggingOptionsRequest) Send() (*GetV2LoggingOptionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetV2LoggingOptionsOutput), nil
}

// GetV2LoggingOptionsRequest returns a request value for making API operation for
// AWS IoT.
//
// Gets the fine grained logging options.
//
//    // Example sending a request using the GetV2LoggingOptionsRequest method.
//    req := client.GetV2LoggingOptionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) GetV2LoggingOptionsRequest(input *GetV2LoggingOptionsInput) GetV2LoggingOptionsRequest {
	op := &aws.Operation{
		Name:       opGetV2LoggingOptions,
		HTTPMethod: "GET",
		HTTPPath:   "/v2LoggingOptions",
	}

	if input == nil {
		input = &GetV2LoggingOptionsInput{}
	}

	output := &GetV2LoggingOptionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetV2LoggingOptionsRequest{Request: req, Input: input, Copy: c.GetV2LoggingOptionsRequest}
}

const opListAttachedPolicies = "ListAttachedPolicies"

// ListAttachedPoliciesRequest is a API request type for the ListAttachedPolicies API operation.
type ListAttachedPoliciesRequest struct {
	*aws.Request
	Input *ListAttachedPoliciesInput
	Copy  func(*ListAttachedPoliciesInput) ListAttachedPoliciesRequest
}

// Send marshals and sends the ListAttachedPolicies API request.
func (r ListAttachedPoliciesRequest) Send() (*ListAttachedPoliciesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListAttachedPoliciesOutput), nil
}

// ListAttachedPoliciesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the policies attached to the specified thing group.
//
//    // Example sending a request using the ListAttachedPoliciesRequest method.
//    req := client.ListAttachedPoliciesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListAttachedPoliciesRequest(input *ListAttachedPoliciesInput) ListAttachedPoliciesRequest {
	op := &aws.Operation{
		Name:       opListAttachedPolicies,
		HTTPMethod: "POST",
		HTTPPath:   "/attached-policies/{target}",
	}

	if input == nil {
		input = &ListAttachedPoliciesInput{}
	}

	output := &ListAttachedPoliciesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListAttachedPoliciesRequest{Request: req, Input: input, Copy: c.ListAttachedPoliciesRequest}
}

const opListAuthorizers = "ListAuthorizers"

// ListAuthorizersRequest is a API request type for the ListAuthorizers API operation.
type ListAuthorizersRequest struct {
	*aws.Request
	Input *ListAuthorizersInput
	Copy  func(*ListAuthorizersInput) ListAuthorizersRequest
}

// Send marshals and sends the ListAuthorizers API request.
func (r ListAuthorizersRequest) Send() (*ListAuthorizersOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListAuthorizersOutput), nil
}

// ListAuthorizersRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the authorizers registered in your account.
//
//    // Example sending a request using the ListAuthorizersRequest method.
//    req := client.ListAuthorizersRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListAuthorizersRequest(input *ListAuthorizersInput) ListAuthorizersRequest {
	op := &aws.Operation{
		Name:       opListAuthorizers,
		HTTPMethod: "GET",
		HTTPPath:   "/authorizers/",
	}

	if input == nil {
		input = &ListAuthorizersInput{}
	}

	output := &ListAuthorizersOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListAuthorizersRequest{Request: req, Input: input, Copy: c.ListAuthorizersRequest}
}

const opListCACertificates = "ListCACertificates"

// ListCACertificatesRequest is a API request type for the ListCACertificates API operation.
type ListCACertificatesRequest struct {
	*aws.Request
	Input *ListCACertificatesInput
	Copy  func(*ListCACertificatesInput) ListCACertificatesRequest
}

// Send marshals and sends the ListCACertificates API request.
func (r ListCACertificatesRequest) Send() (*ListCACertificatesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListCACertificatesOutput), nil
}

// ListCACertificatesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the CA certificates registered for your AWS account.
//
// The results are paginated with a default page size of 25. You can use the
// returned marker to retrieve additional results.
//
//    // Example sending a request using the ListCACertificatesRequest method.
//    req := client.ListCACertificatesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListCACertificatesRequest(input *ListCACertificatesInput) ListCACertificatesRequest {
	op := &aws.Operation{
		Name:       opListCACertificates,
		HTTPMethod: "GET",
		HTTPPath:   "/cacertificates",
	}

	if input == nil {
		input = &ListCACertificatesInput{}
	}

	output := &ListCACertificatesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListCACertificatesRequest{Request: req, Input: input, Copy: c.ListCACertificatesRequest}
}

const opListCertificates = "ListCertificates"

// ListCertificatesRequest is a API request type for the ListCertificates API operation.
type ListCertificatesRequest struct {
	*aws.Request
	Input *ListCertificatesInput
	Copy  func(*ListCertificatesInput) ListCertificatesRequest
}

// Send marshals and sends the ListCertificates API request.
func (r ListCertificatesRequest) Send() (*ListCertificatesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListCertificatesOutput), nil
}

// ListCertificatesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the certificates registered in your AWS account.
//
// The results are paginated with a default page size of 25. You can use the
// returned marker to retrieve additional results.
//
//    // Example sending a request using the ListCertificatesRequest method.
//    req := client.ListCertificatesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListCertificatesRequest(input *ListCertificatesInput) ListCertificatesRequest {
	op := &aws.Operation{
		Name:       opListCertificates,
		HTTPMethod: "GET",
		HTTPPath:   "/certificates",
	}

	if input == nil {
		input = &ListCertificatesInput{}
	}

	output := &ListCertificatesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListCertificatesRequest{Request: req, Input: input, Copy: c.ListCertificatesRequest}
}

const opListCertificatesByCA = "ListCertificatesByCA"

// ListCertificatesByCARequest is a API request type for the ListCertificatesByCA API operation.
type ListCertificatesByCARequest struct {
	*aws.Request
	Input *ListCertificatesByCAInput
	Copy  func(*ListCertificatesByCAInput) ListCertificatesByCARequest
}

// Send marshals and sends the ListCertificatesByCA API request.
func (r ListCertificatesByCARequest) Send() (*ListCertificatesByCAOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListCertificatesByCAOutput), nil
}

// ListCertificatesByCARequest returns a request value for making API operation for
// AWS IoT.
//
// List the device certificates signed by the specified CA certificate.
//
//    // Example sending a request using the ListCertificatesByCARequest method.
//    req := client.ListCertificatesByCARequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListCertificatesByCARequest(input *ListCertificatesByCAInput) ListCertificatesByCARequest {
	op := &aws.Operation{
		Name:       opListCertificatesByCA,
		HTTPMethod: "GET",
		HTTPPath:   "/certificates-by-ca/{caCertificateId}",
	}

	if input == nil {
		input = &ListCertificatesByCAInput{}
	}

	output := &ListCertificatesByCAOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListCertificatesByCARequest{Request: req, Input: input, Copy: c.ListCertificatesByCARequest}
}

const opListIndices = "ListIndices"

// ListIndicesRequest is a API request type for the ListIndices API operation.
type ListIndicesRequest struct {
	*aws.Request
	Input *ListIndicesInput
	Copy  func(*ListIndicesInput) ListIndicesRequest
}

// Send marshals and sends the ListIndices API request.
func (r ListIndicesRequest) Send() (*ListIndicesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListIndicesOutput), nil
}

// ListIndicesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the search indices.
//
//    // Example sending a request using the ListIndicesRequest method.
//    req := client.ListIndicesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListIndicesRequest(input *ListIndicesInput) ListIndicesRequest {
	op := &aws.Operation{
		Name:       opListIndices,
		HTTPMethod: "GET",
		HTTPPath:   "/indices",
	}

	if input == nil {
		input = &ListIndicesInput{}
	}

	output := &ListIndicesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListIndicesRequest{Request: req, Input: input, Copy: c.ListIndicesRequest}
}

const opListJobExecutionsForJob = "ListJobExecutionsForJob"

// ListJobExecutionsForJobRequest is a API request type for the ListJobExecutionsForJob API operation.
type ListJobExecutionsForJobRequest struct {
	*aws.Request
	Input *ListJobExecutionsForJobInput
	Copy  func(*ListJobExecutionsForJobInput) ListJobExecutionsForJobRequest
}

// Send marshals and sends the ListJobExecutionsForJob API request.
func (r ListJobExecutionsForJobRequest) Send() (*ListJobExecutionsForJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListJobExecutionsForJobOutput), nil
}

// ListJobExecutionsForJobRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the job executions for a job.
//
//    // Example sending a request using the ListJobExecutionsForJobRequest method.
//    req := client.ListJobExecutionsForJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListJobExecutionsForJobRequest(input *ListJobExecutionsForJobInput) ListJobExecutionsForJobRequest {
	op := &aws.Operation{
		Name:       opListJobExecutionsForJob,
		HTTPMethod: "GET",
		HTTPPath:   "/jobs/{jobId}/things",
	}

	if input == nil {
		input = &ListJobExecutionsForJobInput{}
	}

	output := &ListJobExecutionsForJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListJobExecutionsForJobRequest{Request: req, Input: input, Copy: c.ListJobExecutionsForJobRequest}
}

const opListJobExecutionsForThing = "ListJobExecutionsForThing"

// ListJobExecutionsForThingRequest is a API request type for the ListJobExecutionsForThing API operation.
type ListJobExecutionsForThingRequest struct {
	*aws.Request
	Input *ListJobExecutionsForThingInput
	Copy  func(*ListJobExecutionsForThingInput) ListJobExecutionsForThingRequest
}

// Send marshals and sends the ListJobExecutionsForThing API request.
func (r ListJobExecutionsForThingRequest) Send() (*ListJobExecutionsForThingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListJobExecutionsForThingOutput), nil
}

// ListJobExecutionsForThingRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the job executions for the specified thing.
//
//    // Example sending a request using the ListJobExecutionsForThingRequest method.
//    req := client.ListJobExecutionsForThingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListJobExecutionsForThingRequest(input *ListJobExecutionsForThingInput) ListJobExecutionsForThingRequest {
	op := &aws.Operation{
		Name:       opListJobExecutionsForThing,
		HTTPMethod: "GET",
		HTTPPath:   "/things/{thingName}/jobs",
	}

	if input == nil {
		input = &ListJobExecutionsForThingInput{}
	}

	output := &ListJobExecutionsForThingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListJobExecutionsForThingRequest{Request: req, Input: input, Copy: c.ListJobExecutionsForThingRequest}
}

const opListJobs = "ListJobs"

// ListJobsRequest is a API request type for the ListJobs API operation.
type ListJobsRequest struct {
	*aws.Request
	Input *ListJobsInput
	Copy  func(*ListJobsInput) ListJobsRequest
}

// Send marshals and sends the ListJobs API request.
func (r ListJobsRequest) Send() (*ListJobsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListJobsOutput), nil
}

// ListJobsRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists jobs.
//
//    // Example sending a request using the ListJobsRequest method.
//    req := client.ListJobsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListJobsRequest(input *ListJobsInput) ListJobsRequest {
	op := &aws.Operation{
		Name:       opListJobs,
		HTTPMethod: "GET",
		HTTPPath:   "/jobs",
	}

	if input == nil {
		input = &ListJobsInput{}
	}

	output := &ListJobsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListJobsRequest{Request: req, Input: input, Copy: c.ListJobsRequest}
}

const opListOTAUpdates = "ListOTAUpdates"

// ListOTAUpdatesRequest is a API request type for the ListOTAUpdates API operation.
type ListOTAUpdatesRequest struct {
	*aws.Request
	Input *ListOTAUpdatesInput
	Copy  func(*ListOTAUpdatesInput) ListOTAUpdatesRequest
}

// Send marshals and sends the ListOTAUpdates API request.
func (r ListOTAUpdatesRequest) Send() (*ListOTAUpdatesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListOTAUpdatesOutput), nil
}

// ListOTAUpdatesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists OTA updates.
//
//    // Example sending a request using the ListOTAUpdatesRequest method.
//    req := client.ListOTAUpdatesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListOTAUpdatesRequest(input *ListOTAUpdatesInput) ListOTAUpdatesRequest {
	op := &aws.Operation{
		Name:       opListOTAUpdates,
		HTTPMethod: "GET",
		HTTPPath:   "/otaUpdates",
	}

	if input == nil {
		input = &ListOTAUpdatesInput{}
	}

	output := &ListOTAUpdatesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListOTAUpdatesRequest{Request: req, Input: input, Copy: c.ListOTAUpdatesRequest}
}

const opListOutgoingCertificates = "ListOutgoingCertificates"

// ListOutgoingCertificatesRequest is a API request type for the ListOutgoingCertificates API operation.
type ListOutgoingCertificatesRequest struct {
	*aws.Request
	Input *ListOutgoingCertificatesInput
	Copy  func(*ListOutgoingCertificatesInput) ListOutgoingCertificatesRequest
}

// Send marshals and sends the ListOutgoingCertificates API request.
func (r ListOutgoingCertificatesRequest) Send() (*ListOutgoingCertificatesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListOutgoingCertificatesOutput), nil
}

// ListOutgoingCertificatesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists certificates that are being transferred but not yet accepted.
//
//    // Example sending a request using the ListOutgoingCertificatesRequest method.
//    req := client.ListOutgoingCertificatesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListOutgoingCertificatesRequest(input *ListOutgoingCertificatesInput) ListOutgoingCertificatesRequest {
	op := &aws.Operation{
		Name:       opListOutgoingCertificates,
		HTTPMethod: "GET",
		HTTPPath:   "/certificates-out-going",
	}

	if input == nil {
		input = &ListOutgoingCertificatesInput{}
	}

	output := &ListOutgoingCertificatesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListOutgoingCertificatesRequest{Request: req, Input: input, Copy: c.ListOutgoingCertificatesRequest}
}

const opListPolicies = "ListPolicies"

// ListPoliciesRequest is a API request type for the ListPolicies API operation.
type ListPoliciesRequest struct {
	*aws.Request
	Input *ListPoliciesInput
	Copy  func(*ListPoliciesInput) ListPoliciesRequest
}

// Send marshals and sends the ListPolicies API request.
func (r ListPoliciesRequest) Send() (*ListPoliciesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListPoliciesOutput), nil
}

// ListPoliciesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists your policies.
//
//    // Example sending a request using the ListPoliciesRequest method.
//    req := client.ListPoliciesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListPoliciesRequest(input *ListPoliciesInput) ListPoliciesRequest {
	op := &aws.Operation{
		Name:       opListPolicies,
		HTTPMethod: "GET",
		HTTPPath:   "/policies",
	}

	if input == nil {
		input = &ListPoliciesInput{}
	}

	output := &ListPoliciesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListPoliciesRequest{Request: req, Input: input, Copy: c.ListPoliciesRequest}
}

const opListPolicyPrincipals = "ListPolicyPrincipals"

// ListPolicyPrincipalsRequest is a API request type for the ListPolicyPrincipals API operation.
type ListPolicyPrincipalsRequest struct {
	*aws.Request
	Input *ListPolicyPrincipalsInput
	Copy  func(*ListPolicyPrincipalsInput) ListPolicyPrincipalsRequest
}

// Send marshals and sends the ListPolicyPrincipals API request.
func (r ListPolicyPrincipalsRequest) Send() (*ListPolicyPrincipalsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListPolicyPrincipalsOutput), nil
}

// ListPolicyPrincipalsRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the principals associated with the specified policy.
//
// Note: This API is deprecated. Please use ListTargetsForPolicy instead.
//
//    // Example sending a request using the ListPolicyPrincipalsRequest method.
//    req := client.ListPolicyPrincipalsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListPolicyPrincipalsRequest(input *ListPolicyPrincipalsInput) ListPolicyPrincipalsRequest {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, ListPolicyPrincipals, has been deprecated")
	}
	op := &aws.Operation{
		Name:       opListPolicyPrincipals,
		HTTPMethod: "GET",
		HTTPPath:   "/policy-principals",
	}

	if input == nil {
		input = &ListPolicyPrincipalsInput{}
	}

	output := &ListPolicyPrincipalsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListPolicyPrincipalsRequest{Request: req, Input: input, Copy: c.ListPolicyPrincipalsRequest}
}

const opListPolicyVersions = "ListPolicyVersions"

// ListPolicyVersionsRequest is a API request type for the ListPolicyVersions API operation.
type ListPolicyVersionsRequest struct {
	*aws.Request
	Input *ListPolicyVersionsInput
	Copy  func(*ListPolicyVersionsInput) ListPolicyVersionsRequest
}

// Send marshals and sends the ListPolicyVersions API request.
func (r ListPolicyVersionsRequest) Send() (*ListPolicyVersionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListPolicyVersionsOutput), nil
}

// ListPolicyVersionsRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the versions of the specified policy and identifies the default version.
//
//    // Example sending a request using the ListPolicyVersionsRequest method.
//    req := client.ListPolicyVersionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListPolicyVersionsRequest(input *ListPolicyVersionsInput) ListPolicyVersionsRequest {
	op := &aws.Operation{
		Name:       opListPolicyVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/policies/{policyName}/version",
	}

	if input == nil {
		input = &ListPolicyVersionsInput{}
	}

	output := &ListPolicyVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListPolicyVersionsRequest{Request: req, Input: input, Copy: c.ListPolicyVersionsRequest}
}

const opListPrincipalPolicies = "ListPrincipalPolicies"

// ListPrincipalPoliciesRequest is a API request type for the ListPrincipalPolicies API operation.
type ListPrincipalPoliciesRequest struct {
	*aws.Request
	Input *ListPrincipalPoliciesInput
	Copy  func(*ListPrincipalPoliciesInput) ListPrincipalPoliciesRequest
}

// Send marshals and sends the ListPrincipalPolicies API request.
func (r ListPrincipalPoliciesRequest) Send() (*ListPrincipalPoliciesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListPrincipalPoliciesOutput), nil
}

// ListPrincipalPoliciesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the policies attached to the specified principal. If you use an Cognito
// identity, the ID must be in AmazonCognito Identity format (http://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax).
//
// Note: This API is deprecated. Please use ListAttachedPolicies instead.
//
//    // Example sending a request using the ListPrincipalPoliciesRequest method.
//    req := client.ListPrincipalPoliciesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListPrincipalPoliciesRequest(input *ListPrincipalPoliciesInput) ListPrincipalPoliciesRequest {
	if c.Client.Config.Logger != nil {
		c.Client.Config.Logger.Log("This operation, ListPrincipalPolicies, has been deprecated")
	}
	op := &aws.Operation{
		Name:       opListPrincipalPolicies,
		HTTPMethod: "GET",
		HTTPPath:   "/principal-policies",
	}

	if input == nil {
		input = &ListPrincipalPoliciesInput{}
	}

	output := &ListPrincipalPoliciesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListPrincipalPoliciesRequest{Request: req, Input: input, Copy: c.ListPrincipalPoliciesRequest}
}

const opListPrincipalThings = "ListPrincipalThings"

// ListPrincipalThingsRequest is a API request type for the ListPrincipalThings API operation.
type ListPrincipalThingsRequest struct {
	*aws.Request
	Input *ListPrincipalThingsInput
	Copy  func(*ListPrincipalThingsInput) ListPrincipalThingsRequest
}

// Send marshals and sends the ListPrincipalThings API request.
func (r ListPrincipalThingsRequest) Send() (*ListPrincipalThingsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListPrincipalThingsOutput), nil
}

// ListPrincipalThingsRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the things associated with the specified principal.
//
//    // Example sending a request using the ListPrincipalThingsRequest method.
//    req := client.ListPrincipalThingsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListPrincipalThingsRequest(input *ListPrincipalThingsInput) ListPrincipalThingsRequest {
	op := &aws.Operation{
		Name:       opListPrincipalThings,
		HTTPMethod: "GET",
		HTTPPath:   "/principals/things",
	}

	if input == nil {
		input = &ListPrincipalThingsInput{}
	}

	output := &ListPrincipalThingsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListPrincipalThingsRequest{Request: req, Input: input, Copy: c.ListPrincipalThingsRequest}
}

const opListRoleAliases = "ListRoleAliases"

// ListRoleAliasesRequest is a API request type for the ListRoleAliases API operation.
type ListRoleAliasesRequest struct {
	*aws.Request
	Input *ListRoleAliasesInput
	Copy  func(*ListRoleAliasesInput) ListRoleAliasesRequest
}

// Send marshals and sends the ListRoleAliases API request.
func (r ListRoleAliasesRequest) Send() (*ListRoleAliasesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListRoleAliasesOutput), nil
}

// ListRoleAliasesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the role aliases registered in your account.
//
//    // Example sending a request using the ListRoleAliasesRequest method.
//    req := client.ListRoleAliasesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListRoleAliasesRequest(input *ListRoleAliasesInput) ListRoleAliasesRequest {
	op := &aws.Operation{
		Name:       opListRoleAliases,
		HTTPMethod: "GET",
		HTTPPath:   "/role-aliases",
	}

	if input == nil {
		input = &ListRoleAliasesInput{}
	}

	output := &ListRoleAliasesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListRoleAliasesRequest{Request: req, Input: input, Copy: c.ListRoleAliasesRequest}
}

const opListStreams = "ListStreams"

// ListStreamsRequest is a API request type for the ListStreams API operation.
type ListStreamsRequest struct {
	*aws.Request
	Input *ListStreamsInput
	Copy  func(*ListStreamsInput) ListStreamsRequest
}

// Send marshals and sends the ListStreams API request.
func (r ListStreamsRequest) Send() (*ListStreamsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListStreamsOutput), nil
}

// ListStreamsRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists all of the streams in your AWS account.
//
//    // Example sending a request using the ListStreamsRequest method.
//    req := client.ListStreamsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListStreamsRequest(input *ListStreamsInput) ListStreamsRequest {
	op := &aws.Operation{
		Name:       opListStreams,
		HTTPMethod: "GET",
		HTTPPath:   "/streams",
	}

	if input == nil {
		input = &ListStreamsInput{}
	}

	output := &ListStreamsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListStreamsRequest{Request: req, Input: input, Copy: c.ListStreamsRequest}
}

const opListTargetsForPolicy = "ListTargetsForPolicy"

// ListTargetsForPolicyRequest is a API request type for the ListTargetsForPolicy API operation.
type ListTargetsForPolicyRequest struct {
	*aws.Request
	Input *ListTargetsForPolicyInput
	Copy  func(*ListTargetsForPolicyInput) ListTargetsForPolicyRequest
}

// Send marshals and sends the ListTargetsForPolicy API request.
func (r ListTargetsForPolicyRequest) Send() (*ListTargetsForPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTargetsForPolicyOutput), nil
}

// ListTargetsForPolicyRequest returns a request value for making API operation for
// AWS IoT.
//
// List targets for the specified policy.
//
//    // Example sending a request using the ListTargetsForPolicyRequest method.
//    req := client.ListTargetsForPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListTargetsForPolicyRequest(input *ListTargetsForPolicyInput) ListTargetsForPolicyRequest {
	op := &aws.Operation{
		Name:       opListTargetsForPolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/policy-targets/{policyName}",
	}

	if input == nil {
		input = &ListTargetsForPolicyInput{}
	}

	output := &ListTargetsForPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTargetsForPolicyRequest{Request: req, Input: input, Copy: c.ListTargetsForPolicyRequest}
}

const opListThingGroups = "ListThingGroups"

// ListThingGroupsRequest is a API request type for the ListThingGroups API operation.
type ListThingGroupsRequest struct {
	*aws.Request
	Input *ListThingGroupsInput
	Copy  func(*ListThingGroupsInput) ListThingGroupsRequest
}

// Send marshals and sends the ListThingGroups API request.
func (r ListThingGroupsRequest) Send() (*ListThingGroupsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListThingGroupsOutput), nil
}

// ListThingGroupsRequest returns a request value for making API operation for
// AWS IoT.
//
// List the thing groups in your account.
//
//    // Example sending a request using the ListThingGroupsRequest method.
//    req := client.ListThingGroupsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListThingGroupsRequest(input *ListThingGroupsInput) ListThingGroupsRequest {
	op := &aws.Operation{
		Name:       opListThingGroups,
		HTTPMethod: "GET",
		HTTPPath:   "/thing-groups",
	}

	if input == nil {
		input = &ListThingGroupsInput{}
	}

	output := &ListThingGroupsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListThingGroupsRequest{Request: req, Input: input, Copy: c.ListThingGroupsRequest}
}

const opListThingGroupsForThing = "ListThingGroupsForThing"

// ListThingGroupsForThingRequest is a API request type for the ListThingGroupsForThing API operation.
type ListThingGroupsForThingRequest struct {
	*aws.Request
	Input *ListThingGroupsForThingInput
	Copy  func(*ListThingGroupsForThingInput) ListThingGroupsForThingRequest
}

// Send marshals and sends the ListThingGroupsForThing API request.
func (r ListThingGroupsForThingRequest) Send() (*ListThingGroupsForThingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListThingGroupsForThingOutput), nil
}

// ListThingGroupsForThingRequest returns a request value for making API operation for
// AWS IoT.
//
// List the thing groups to which the specified thing belongs.
//
//    // Example sending a request using the ListThingGroupsForThingRequest method.
//    req := client.ListThingGroupsForThingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListThingGroupsForThingRequest(input *ListThingGroupsForThingInput) ListThingGroupsForThingRequest {
	op := &aws.Operation{
		Name:       opListThingGroupsForThing,
		HTTPMethod: "GET",
		HTTPPath:   "/things/{thingName}/thing-groups",
	}

	if input == nil {
		input = &ListThingGroupsForThingInput{}
	}

	output := &ListThingGroupsForThingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListThingGroupsForThingRequest{Request: req, Input: input, Copy: c.ListThingGroupsForThingRequest}
}

const opListThingPrincipals = "ListThingPrincipals"

// ListThingPrincipalsRequest is a API request type for the ListThingPrincipals API operation.
type ListThingPrincipalsRequest struct {
	*aws.Request
	Input *ListThingPrincipalsInput
	Copy  func(*ListThingPrincipalsInput) ListThingPrincipalsRequest
}

// Send marshals and sends the ListThingPrincipals API request.
func (r ListThingPrincipalsRequest) Send() (*ListThingPrincipalsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListThingPrincipalsOutput), nil
}

// ListThingPrincipalsRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the principals associated with the specified thing.
//
//    // Example sending a request using the ListThingPrincipalsRequest method.
//    req := client.ListThingPrincipalsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListThingPrincipalsRequest(input *ListThingPrincipalsInput) ListThingPrincipalsRequest {
	op := &aws.Operation{
		Name:       opListThingPrincipals,
		HTTPMethod: "GET",
		HTTPPath:   "/things/{thingName}/principals",
	}

	if input == nil {
		input = &ListThingPrincipalsInput{}
	}

	output := &ListThingPrincipalsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListThingPrincipalsRequest{Request: req, Input: input, Copy: c.ListThingPrincipalsRequest}
}

const opListThingRegistrationTaskReports = "ListThingRegistrationTaskReports"

// ListThingRegistrationTaskReportsRequest is a API request type for the ListThingRegistrationTaskReports API operation.
type ListThingRegistrationTaskReportsRequest struct {
	*aws.Request
	Input *ListThingRegistrationTaskReportsInput
	Copy  func(*ListThingRegistrationTaskReportsInput) ListThingRegistrationTaskReportsRequest
}

// Send marshals and sends the ListThingRegistrationTaskReports API request.
func (r ListThingRegistrationTaskReportsRequest) Send() (*ListThingRegistrationTaskReportsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListThingRegistrationTaskReportsOutput), nil
}

// ListThingRegistrationTaskReportsRequest returns a request value for making API operation for
// AWS IoT.
//
// Information about the thing registration tasks.
//
//    // Example sending a request using the ListThingRegistrationTaskReportsRequest method.
//    req := client.ListThingRegistrationTaskReportsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListThingRegistrationTaskReportsRequest(input *ListThingRegistrationTaskReportsInput) ListThingRegistrationTaskReportsRequest {
	op := &aws.Operation{
		Name:       opListThingRegistrationTaskReports,
		HTTPMethod: "GET",
		HTTPPath:   "/thing-registration-tasks/{taskId}/reports",
	}

	if input == nil {
		input = &ListThingRegistrationTaskReportsInput{}
	}

	output := &ListThingRegistrationTaskReportsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListThingRegistrationTaskReportsRequest{Request: req, Input: input, Copy: c.ListThingRegistrationTaskReportsRequest}
}

const opListThingRegistrationTasks = "ListThingRegistrationTasks"

// ListThingRegistrationTasksRequest is a API request type for the ListThingRegistrationTasks API operation.
type ListThingRegistrationTasksRequest struct {
	*aws.Request
	Input *ListThingRegistrationTasksInput
	Copy  func(*ListThingRegistrationTasksInput) ListThingRegistrationTasksRequest
}

// Send marshals and sends the ListThingRegistrationTasks API request.
func (r ListThingRegistrationTasksRequest) Send() (*ListThingRegistrationTasksOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListThingRegistrationTasksOutput), nil
}

// ListThingRegistrationTasksRequest returns a request value for making API operation for
// AWS IoT.
//
// List bulk thing provisioning tasks.
//
//    // Example sending a request using the ListThingRegistrationTasksRequest method.
//    req := client.ListThingRegistrationTasksRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListThingRegistrationTasksRequest(input *ListThingRegistrationTasksInput) ListThingRegistrationTasksRequest {
	op := &aws.Operation{
		Name:       opListThingRegistrationTasks,
		HTTPMethod: "GET",
		HTTPPath:   "/thing-registration-tasks",
	}

	if input == nil {
		input = &ListThingRegistrationTasksInput{}
	}

	output := &ListThingRegistrationTasksOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListThingRegistrationTasksRequest{Request: req, Input: input, Copy: c.ListThingRegistrationTasksRequest}
}

const opListThingTypes = "ListThingTypes"

// ListThingTypesRequest is a API request type for the ListThingTypes API operation.
type ListThingTypesRequest struct {
	*aws.Request
	Input *ListThingTypesInput
	Copy  func(*ListThingTypesInput) ListThingTypesRequest
}

// Send marshals and sends the ListThingTypes API request.
func (r ListThingTypesRequest) Send() (*ListThingTypesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListThingTypesOutput), nil
}

// ListThingTypesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the existing thing types.
//
//    // Example sending a request using the ListThingTypesRequest method.
//    req := client.ListThingTypesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListThingTypesRequest(input *ListThingTypesInput) ListThingTypesRequest {
	op := &aws.Operation{
		Name:       opListThingTypes,
		HTTPMethod: "GET",
		HTTPPath:   "/thing-types",
	}

	if input == nil {
		input = &ListThingTypesInput{}
	}

	output := &ListThingTypesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListThingTypesRequest{Request: req, Input: input, Copy: c.ListThingTypesRequest}
}

const opListThings = "ListThings"

// ListThingsRequest is a API request type for the ListThings API operation.
type ListThingsRequest struct {
	*aws.Request
	Input *ListThingsInput
	Copy  func(*ListThingsInput) ListThingsRequest
}

// Send marshals and sends the ListThings API request.
func (r ListThingsRequest) Send() (*ListThingsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListThingsOutput), nil
}

// ListThingsRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists your things. Use the attributeName and attributeValue parameters to
// filter your things. For example, calling ListThings with attributeName=Color
// and attributeValue=Red retrieves all things in the registry that contain
// an attribute Color with the value Red.
//
//    // Example sending a request using the ListThingsRequest method.
//    req := client.ListThingsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListThingsRequest(input *ListThingsInput) ListThingsRequest {
	op := &aws.Operation{
		Name:       opListThings,
		HTTPMethod: "GET",
		HTTPPath:   "/things",
	}

	if input == nil {
		input = &ListThingsInput{}
	}

	output := &ListThingsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListThingsRequest{Request: req, Input: input, Copy: c.ListThingsRequest}
}

const opListThingsInThingGroup = "ListThingsInThingGroup"

// ListThingsInThingGroupRequest is a API request type for the ListThingsInThingGroup API operation.
type ListThingsInThingGroupRequest struct {
	*aws.Request
	Input *ListThingsInThingGroupInput
	Copy  func(*ListThingsInThingGroupInput) ListThingsInThingGroupRequest
}

// Send marshals and sends the ListThingsInThingGroup API request.
func (r ListThingsInThingGroupRequest) Send() (*ListThingsInThingGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListThingsInThingGroupOutput), nil
}

// ListThingsInThingGroupRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the things in the specified group.
//
//    // Example sending a request using the ListThingsInThingGroupRequest method.
//    req := client.ListThingsInThingGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListThingsInThingGroupRequest(input *ListThingsInThingGroupInput) ListThingsInThingGroupRequest {
	op := &aws.Operation{
		Name:       opListThingsInThingGroup,
		HTTPMethod: "GET",
		HTTPPath:   "/thing-groups/{thingGroupName}/things",
	}

	if input == nil {
		input = &ListThingsInThingGroupInput{}
	}

	output := &ListThingsInThingGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListThingsInThingGroupRequest{Request: req, Input: input, Copy: c.ListThingsInThingGroupRequest}
}

const opListTopicRules = "ListTopicRules"

// ListTopicRulesRequest is a API request type for the ListTopicRules API operation.
type ListTopicRulesRequest struct {
	*aws.Request
	Input *ListTopicRulesInput
	Copy  func(*ListTopicRulesInput) ListTopicRulesRequest
}

// Send marshals and sends the ListTopicRules API request.
func (r ListTopicRulesRequest) Send() (*ListTopicRulesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTopicRulesOutput), nil
}

// ListTopicRulesRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists the rules for the specific topic.
//
//    // Example sending a request using the ListTopicRulesRequest method.
//    req := client.ListTopicRulesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListTopicRulesRequest(input *ListTopicRulesInput) ListTopicRulesRequest {
	op := &aws.Operation{
		Name:       opListTopicRules,
		HTTPMethod: "GET",
		HTTPPath:   "/rules",
	}

	if input == nil {
		input = &ListTopicRulesInput{}
	}

	output := &ListTopicRulesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTopicRulesRequest{Request: req, Input: input, Copy: c.ListTopicRulesRequest}
}

const opListV2LoggingLevels = "ListV2LoggingLevels"

// ListV2LoggingLevelsRequest is a API request type for the ListV2LoggingLevels API operation.
type ListV2LoggingLevelsRequest struct {
	*aws.Request
	Input *ListV2LoggingLevelsInput
	Copy  func(*ListV2LoggingLevelsInput) ListV2LoggingLevelsRequest
}

// Send marshals and sends the ListV2LoggingLevels API request.
func (r ListV2LoggingLevelsRequest) Send() (*ListV2LoggingLevelsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListV2LoggingLevelsOutput), nil
}

// ListV2LoggingLevelsRequest returns a request value for making API operation for
// AWS IoT.
//
// Lists logging levels.
//
//    // Example sending a request using the ListV2LoggingLevelsRequest method.
//    req := client.ListV2LoggingLevelsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ListV2LoggingLevelsRequest(input *ListV2LoggingLevelsInput) ListV2LoggingLevelsRequest {
	op := &aws.Operation{
		Name:       opListV2LoggingLevels,
		HTTPMethod: "GET",
		HTTPPath:   "/v2LoggingLevel",
	}

	if input == nil {
		input = &ListV2LoggingLevelsInput{}
	}

	output := &ListV2LoggingLevelsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListV2LoggingLevelsRequest{Request: req, Input: input, Copy: c.ListV2LoggingLevelsRequest}
}

const opRegisterCACertificate = "RegisterCACertificate"

// RegisterCACertificateRequest is a API request type for the RegisterCACertificate API operation.
type RegisterCACertificateRequest struct {
	*aws.Request
	Input *RegisterCACertificateInput
	Copy  func(*RegisterCACertificateInput) RegisterCACertificateRequest
}

// Send marshals and sends the RegisterCACertificate API request.
func (r RegisterCACertificateRequest) Send() (*RegisterCACertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RegisterCACertificateOutput), nil
}

// RegisterCACertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Registers a CA certificate with AWS IoT. This CA certificate can then be
// used to sign device certificates, which can be then registered with AWS IoT.
// You can register up to 10 CA certificates per AWS account that have the same
// subject field. This enables you to have up to 10 certificate authorities
// sign your device certificates. If you have more than one CA certificate registered,
// make sure you pass the CA certificate when you register your device certificates
// with the RegisterCertificate API.
//
//    // Example sending a request using the RegisterCACertificateRequest method.
//    req := client.RegisterCACertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) RegisterCACertificateRequest(input *RegisterCACertificateInput) RegisterCACertificateRequest {
	op := &aws.Operation{
		Name:       opRegisterCACertificate,
		HTTPMethod: "POST",
		HTTPPath:   "/cacertificate",
	}

	if input == nil {
		input = &RegisterCACertificateInput{}
	}

	output := &RegisterCACertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RegisterCACertificateRequest{Request: req, Input: input, Copy: c.RegisterCACertificateRequest}
}

const opRegisterCertificate = "RegisterCertificate"

// RegisterCertificateRequest is a API request type for the RegisterCertificate API operation.
type RegisterCertificateRequest struct {
	*aws.Request
	Input *RegisterCertificateInput
	Copy  func(*RegisterCertificateInput) RegisterCertificateRequest
}

// Send marshals and sends the RegisterCertificate API request.
func (r RegisterCertificateRequest) Send() (*RegisterCertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RegisterCertificateOutput), nil
}

// RegisterCertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Registers a device certificate with AWS IoT. If you have more than one CA
// certificate that has the same subject field, you must specify the CA certificate
// that was used to sign the device certificate being registered.
//
//    // Example sending a request using the RegisterCertificateRequest method.
//    req := client.RegisterCertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) RegisterCertificateRequest(input *RegisterCertificateInput) RegisterCertificateRequest {
	op := &aws.Operation{
		Name:       opRegisterCertificate,
		HTTPMethod: "POST",
		HTTPPath:   "/certificate/register",
	}

	if input == nil {
		input = &RegisterCertificateInput{}
	}

	output := &RegisterCertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RegisterCertificateRequest{Request: req, Input: input, Copy: c.RegisterCertificateRequest}
}

const opRegisterThing = "RegisterThing"

// RegisterThingRequest is a API request type for the RegisterThing API operation.
type RegisterThingRequest struct {
	*aws.Request
	Input *RegisterThingInput
	Copy  func(*RegisterThingInput) RegisterThingRequest
}

// Send marshals and sends the RegisterThing API request.
func (r RegisterThingRequest) Send() (*RegisterThingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RegisterThingOutput), nil
}

// RegisterThingRequest returns a request value for making API operation for
// AWS IoT.
//
// Provisions a thing.
//
//    // Example sending a request using the RegisterThingRequest method.
//    req := client.RegisterThingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) RegisterThingRequest(input *RegisterThingInput) RegisterThingRequest {
	op := &aws.Operation{
		Name:       opRegisterThing,
		HTTPMethod: "POST",
		HTTPPath:   "/things",
	}

	if input == nil {
		input = &RegisterThingInput{}
	}

	output := &RegisterThingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RegisterThingRequest{Request: req, Input: input, Copy: c.RegisterThingRequest}
}

const opRejectCertificateTransfer = "RejectCertificateTransfer"

// RejectCertificateTransferRequest is a API request type for the RejectCertificateTransfer API operation.
type RejectCertificateTransferRequest struct {
	*aws.Request
	Input *RejectCertificateTransferInput
	Copy  func(*RejectCertificateTransferInput) RejectCertificateTransferRequest
}

// Send marshals and sends the RejectCertificateTransfer API request.
func (r RejectCertificateTransferRequest) Send() (*RejectCertificateTransferOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RejectCertificateTransferOutput), nil
}

// RejectCertificateTransferRequest returns a request value for making API operation for
// AWS IoT.
//
// Rejects a pending certificate transfer. After AWS IoT rejects a certificate
// transfer, the certificate status changes from PENDING_TRANSFER to INACTIVE.
//
// To check for pending certificate transfers, call ListCertificates to enumerate
// your certificates.
//
// This operation can only be called by the transfer destination. After it is
// called, the certificate will be returned to the source's account in the INACTIVE
// state.
//
//    // Example sending a request using the RejectCertificateTransferRequest method.
//    req := client.RejectCertificateTransferRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) RejectCertificateTransferRequest(input *RejectCertificateTransferInput) RejectCertificateTransferRequest {
	op := &aws.Operation{
		Name:       opRejectCertificateTransfer,
		HTTPMethod: "PATCH",
		HTTPPath:   "/reject-certificate-transfer/{certificateId}",
	}

	if input == nil {
		input = &RejectCertificateTransferInput{}
	}

	output := &RejectCertificateTransferOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return RejectCertificateTransferRequest{Request: req, Input: input, Copy: c.RejectCertificateTransferRequest}
}

const opRemoveThingFromThingGroup = "RemoveThingFromThingGroup"

// RemoveThingFromThingGroupRequest is a API request type for the RemoveThingFromThingGroup API operation.
type RemoveThingFromThingGroupRequest struct {
	*aws.Request
	Input *RemoveThingFromThingGroupInput
	Copy  func(*RemoveThingFromThingGroupInput) RemoveThingFromThingGroupRequest
}

// Send marshals and sends the RemoveThingFromThingGroup API request.
func (r RemoveThingFromThingGroupRequest) Send() (*RemoveThingFromThingGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RemoveThingFromThingGroupOutput), nil
}

// RemoveThingFromThingGroupRequest returns a request value for making API operation for
// AWS IoT.
//
// Remove the specified thing from the specified group.
//
//    // Example sending a request using the RemoveThingFromThingGroupRequest method.
//    req := client.RemoveThingFromThingGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) RemoveThingFromThingGroupRequest(input *RemoveThingFromThingGroupInput) RemoveThingFromThingGroupRequest {
	op := &aws.Operation{
		Name:       opRemoveThingFromThingGroup,
		HTTPMethod: "PUT",
		HTTPPath:   "/thing-groups/removeThingFromThingGroup",
	}

	if input == nil {
		input = &RemoveThingFromThingGroupInput{}
	}

	output := &RemoveThingFromThingGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RemoveThingFromThingGroupRequest{Request: req, Input: input, Copy: c.RemoveThingFromThingGroupRequest}
}

const opReplaceTopicRule = "ReplaceTopicRule"

// ReplaceTopicRuleRequest is a API request type for the ReplaceTopicRule API operation.
type ReplaceTopicRuleRequest struct {
	*aws.Request
	Input *ReplaceTopicRuleInput
	Copy  func(*ReplaceTopicRuleInput) ReplaceTopicRuleRequest
}

// Send marshals and sends the ReplaceTopicRule API request.
func (r ReplaceTopicRuleRequest) Send() (*ReplaceTopicRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ReplaceTopicRuleOutput), nil
}

// ReplaceTopicRuleRequest returns a request value for making API operation for
// AWS IoT.
//
// Replaces the rule. You must specify all parameters for the new rule. Creating
// rules is an administrator-level action. Any user who has permission to create
// rules will be able to access data processed by the rule.
//
//    // Example sending a request using the ReplaceTopicRuleRequest method.
//    req := client.ReplaceTopicRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) ReplaceTopicRuleRequest(input *ReplaceTopicRuleInput) ReplaceTopicRuleRequest {
	op := &aws.Operation{
		Name:       opReplaceTopicRule,
		HTTPMethod: "PATCH",
		HTTPPath:   "/rules/{ruleName}",
	}

	if input == nil {
		input = &ReplaceTopicRuleInput{}
	}

	output := &ReplaceTopicRuleOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return ReplaceTopicRuleRequest{Request: req, Input: input, Copy: c.ReplaceTopicRuleRequest}
}

const opSearchIndex = "SearchIndex"

// SearchIndexRequest is a API request type for the SearchIndex API operation.
type SearchIndexRequest struct {
	*aws.Request
	Input *SearchIndexInput
	Copy  func(*SearchIndexInput) SearchIndexRequest
}

// Send marshals and sends the SearchIndex API request.
func (r SearchIndexRequest) Send() (*SearchIndexOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SearchIndexOutput), nil
}

// SearchIndexRequest returns a request value for making API operation for
// AWS IoT.
//
// The query search index.
//
//    // Example sending a request using the SearchIndexRequest method.
//    req := client.SearchIndexRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) SearchIndexRequest(input *SearchIndexInput) SearchIndexRequest {
	op := &aws.Operation{
		Name:       opSearchIndex,
		HTTPMethod: "POST",
		HTTPPath:   "/indices/search",
	}

	if input == nil {
		input = &SearchIndexInput{}
	}

	output := &SearchIndexOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return SearchIndexRequest{Request: req, Input: input, Copy: c.SearchIndexRequest}
}

const opSetDefaultAuthorizer = "SetDefaultAuthorizer"

// SetDefaultAuthorizerRequest is a API request type for the SetDefaultAuthorizer API operation.
type SetDefaultAuthorizerRequest struct {
	*aws.Request
	Input *SetDefaultAuthorizerInput
	Copy  func(*SetDefaultAuthorizerInput) SetDefaultAuthorizerRequest
}

// Send marshals and sends the SetDefaultAuthorizer API request.
func (r SetDefaultAuthorizerRequest) Send() (*SetDefaultAuthorizerOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SetDefaultAuthorizerOutput), nil
}

// SetDefaultAuthorizerRequest returns a request value for making API operation for
// AWS IoT.
//
// Sets the default authorizer. This will be used if a websocket connection
// is made without specifying an authorizer.
//
//    // Example sending a request using the SetDefaultAuthorizerRequest method.
//    req := client.SetDefaultAuthorizerRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) SetDefaultAuthorizerRequest(input *SetDefaultAuthorizerInput) SetDefaultAuthorizerRequest {
	op := &aws.Operation{
		Name:       opSetDefaultAuthorizer,
		HTTPMethod: "POST",
		HTTPPath:   "/default-authorizer",
	}

	if input == nil {
		input = &SetDefaultAuthorizerInput{}
	}

	output := &SetDefaultAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return SetDefaultAuthorizerRequest{Request: req, Input: input, Copy: c.SetDefaultAuthorizerRequest}
}

const opSetDefaultPolicyVersion = "SetDefaultPolicyVersion"

// SetDefaultPolicyVersionRequest is a API request type for the SetDefaultPolicyVersion API operation.
type SetDefaultPolicyVersionRequest struct {
	*aws.Request
	Input *SetDefaultPolicyVersionInput
	Copy  func(*SetDefaultPolicyVersionInput) SetDefaultPolicyVersionRequest
}

// Send marshals and sends the SetDefaultPolicyVersion API request.
func (r SetDefaultPolicyVersionRequest) Send() (*SetDefaultPolicyVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SetDefaultPolicyVersionOutput), nil
}

// SetDefaultPolicyVersionRequest returns a request value for making API operation for
// AWS IoT.
//
// Sets the specified version of the specified policy as the policy's default
// (operative) version. This action affects all certificates to which the policy
// is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy
// API.
//
//    // Example sending a request using the SetDefaultPolicyVersionRequest method.
//    req := client.SetDefaultPolicyVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) SetDefaultPolicyVersionRequest(input *SetDefaultPolicyVersionInput) SetDefaultPolicyVersionRequest {
	op := &aws.Operation{
		Name:       opSetDefaultPolicyVersion,
		HTTPMethod: "PATCH",
		HTTPPath:   "/policies/{policyName}/version/{policyVersionId}",
	}

	if input == nil {
		input = &SetDefaultPolicyVersionInput{}
	}

	output := &SetDefaultPolicyVersionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return SetDefaultPolicyVersionRequest{Request: req, Input: input, Copy: c.SetDefaultPolicyVersionRequest}
}

const opSetLoggingOptions = "SetLoggingOptions"

// SetLoggingOptionsRequest is a API request type for the SetLoggingOptions API operation.
type SetLoggingOptionsRequest struct {
	*aws.Request
	Input *SetLoggingOptionsInput
	Copy  func(*SetLoggingOptionsInput) SetLoggingOptionsRequest
}

// Send marshals and sends the SetLoggingOptions API request.
func (r SetLoggingOptionsRequest) Send() (*SetLoggingOptionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SetLoggingOptionsOutput), nil
}

// SetLoggingOptionsRequest returns a request value for making API operation for
// AWS IoT.
//
// Sets the logging options.
//
//    // Example sending a request using the SetLoggingOptionsRequest method.
//    req := client.SetLoggingOptionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) SetLoggingOptionsRequest(input *SetLoggingOptionsInput) SetLoggingOptionsRequest {
	op := &aws.Operation{
		Name:       opSetLoggingOptions,
		HTTPMethod: "POST",
		HTTPPath:   "/loggingOptions",
	}

	if input == nil {
		input = &SetLoggingOptionsInput{}
	}

	output := &SetLoggingOptionsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return SetLoggingOptionsRequest{Request: req, Input: input, Copy: c.SetLoggingOptionsRequest}
}

const opSetV2LoggingLevel = "SetV2LoggingLevel"

// SetV2LoggingLevelRequest is a API request type for the SetV2LoggingLevel API operation.
type SetV2LoggingLevelRequest struct {
	*aws.Request
	Input *SetV2LoggingLevelInput
	Copy  func(*SetV2LoggingLevelInput) SetV2LoggingLevelRequest
}

// Send marshals and sends the SetV2LoggingLevel API request.
func (r SetV2LoggingLevelRequest) Send() (*SetV2LoggingLevelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SetV2LoggingLevelOutput), nil
}

// SetV2LoggingLevelRequest returns a request value for making API operation for
// AWS IoT.
//
// Sets the logging level.
//
//    // Example sending a request using the SetV2LoggingLevelRequest method.
//    req := client.SetV2LoggingLevelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) SetV2LoggingLevelRequest(input *SetV2LoggingLevelInput) SetV2LoggingLevelRequest {
	op := &aws.Operation{
		Name:       opSetV2LoggingLevel,
		HTTPMethod: "POST",
		HTTPPath:   "/v2LoggingLevel",
	}

	if input == nil {
		input = &SetV2LoggingLevelInput{}
	}

	output := &SetV2LoggingLevelOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return SetV2LoggingLevelRequest{Request: req, Input: input, Copy: c.SetV2LoggingLevelRequest}
}

const opSetV2LoggingOptions = "SetV2LoggingOptions"

// SetV2LoggingOptionsRequest is a API request type for the SetV2LoggingOptions API operation.
type SetV2LoggingOptionsRequest struct {
	*aws.Request
	Input *SetV2LoggingOptionsInput
	Copy  func(*SetV2LoggingOptionsInput) SetV2LoggingOptionsRequest
}

// Send marshals and sends the SetV2LoggingOptions API request.
func (r SetV2LoggingOptionsRequest) Send() (*SetV2LoggingOptionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SetV2LoggingOptionsOutput), nil
}

// SetV2LoggingOptionsRequest returns a request value for making API operation for
// AWS IoT.
//
// Sets the logging options for the V2 logging service.
//
//    // Example sending a request using the SetV2LoggingOptionsRequest method.
//    req := client.SetV2LoggingOptionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) SetV2LoggingOptionsRequest(input *SetV2LoggingOptionsInput) SetV2LoggingOptionsRequest {
	op := &aws.Operation{
		Name:       opSetV2LoggingOptions,
		HTTPMethod: "POST",
		HTTPPath:   "/v2LoggingOptions",
	}

	if input == nil {
		input = &SetV2LoggingOptionsInput{}
	}

	output := &SetV2LoggingOptionsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return SetV2LoggingOptionsRequest{Request: req, Input: input, Copy: c.SetV2LoggingOptionsRequest}
}

const opStartThingRegistrationTask = "StartThingRegistrationTask"

// StartThingRegistrationTaskRequest is a API request type for the StartThingRegistrationTask API operation.
type StartThingRegistrationTaskRequest struct {
	*aws.Request
	Input *StartThingRegistrationTaskInput
	Copy  func(*StartThingRegistrationTaskInput) StartThingRegistrationTaskRequest
}

// Send marshals and sends the StartThingRegistrationTask API request.
func (r StartThingRegistrationTaskRequest) Send() (*StartThingRegistrationTaskOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartThingRegistrationTaskOutput), nil
}

// StartThingRegistrationTaskRequest returns a request value for making API operation for
// AWS IoT.
//
// Creates a bulk thing provisioning task.
//
//    // Example sending a request using the StartThingRegistrationTaskRequest method.
//    req := client.StartThingRegistrationTaskRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) StartThingRegistrationTaskRequest(input *StartThingRegistrationTaskInput) StartThingRegistrationTaskRequest {
	op := &aws.Operation{
		Name:       opStartThingRegistrationTask,
		HTTPMethod: "POST",
		HTTPPath:   "/thing-registration-tasks",
	}

	if input == nil {
		input = &StartThingRegistrationTaskInput{}
	}

	output := &StartThingRegistrationTaskOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartThingRegistrationTaskRequest{Request: req, Input: input, Copy: c.StartThingRegistrationTaskRequest}
}

const opStopThingRegistrationTask = "StopThingRegistrationTask"

// StopThingRegistrationTaskRequest is a API request type for the StopThingRegistrationTask API operation.
type StopThingRegistrationTaskRequest struct {
	*aws.Request
	Input *StopThingRegistrationTaskInput
	Copy  func(*StopThingRegistrationTaskInput) StopThingRegistrationTaskRequest
}

// Send marshals and sends the StopThingRegistrationTask API request.
func (r StopThingRegistrationTaskRequest) Send() (*StopThingRegistrationTaskOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StopThingRegistrationTaskOutput), nil
}

// StopThingRegistrationTaskRequest returns a request value for making API operation for
// AWS IoT.
//
// Cancels a bulk thing provisioning task.
//
//    // Example sending a request using the StopThingRegistrationTaskRequest method.
//    req := client.StopThingRegistrationTaskRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) StopThingRegistrationTaskRequest(input *StopThingRegistrationTaskInput) StopThingRegistrationTaskRequest {
	op := &aws.Operation{
		Name:       opStopThingRegistrationTask,
		HTTPMethod: "PUT",
		HTTPPath:   "/thing-registration-tasks/{taskId}/cancel",
	}

	if input == nil {
		input = &StopThingRegistrationTaskInput{}
	}

	output := &StopThingRegistrationTaskOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StopThingRegistrationTaskRequest{Request: req, Input: input, Copy: c.StopThingRegistrationTaskRequest}
}

const opTestAuthorization = "TestAuthorization"

// TestAuthorizationRequest is a API request type for the TestAuthorization API operation.
type TestAuthorizationRequest struct {
	*aws.Request
	Input *TestAuthorizationInput
	Copy  func(*TestAuthorizationInput) TestAuthorizationRequest
}

// Send marshals and sends the TestAuthorization API request.
func (r TestAuthorizationRequest) Send() (*TestAuthorizationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TestAuthorizationOutput), nil
}

// TestAuthorizationRequest returns a request value for making API operation for
// AWS IoT.
//
// Tests if a specified principal is authorized to perform an AWS IoT action
// on a specified resource. Use this to test and debug the authorization behavior
// of devices that connect to the AWS IoT device gateway.
//
//    // Example sending a request using the TestAuthorizationRequest method.
//    req := client.TestAuthorizationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) TestAuthorizationRequest(input *TestAuthorizationInput) TestAuthorizationRequest {
	op := &aws.Operation{
		Name:       opTestAuthorization,
		HTTPMethod: "POST",
		HTTPPath:   "/test-authorization",
	}

	if input == nil {
		input = &TestAuthorizationInput{}
	}

	output := &TestAuthorizationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TestAuthorizationRequest{Request: req, Input: input, Copy: c.TestAuthorizationRequest}
}

const opTestInvokeAuthorizer = "TestInvokeAuthorizer"

// TestInvokeAuthorizerRequest is a API request type for the TestInvokeAuthorizer API operation.
type TestInvokeAuthorizerRequest struct {
	*aws.Request
	Input *TestInvokeAuthorizerInput
	Copy  func(*TestInvokeAuthorizerInput) TestInvokeAuthorizerRequest
}

// Send marshals and sends the TestInvokeAuthorizer API request.
func (r TestInvokeAuthorizerRequest) Send() (*TestInvokeAuthorizerOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TestInvokeAuthorizerOutput), nil
}

// TestInvokeAuthorizerRequest returns a request value for making API operation for
// AWS IoT.
//
// Tests a custom authorization behavior by invoking a specified custom authorizer.
// Use this to test and debug the custom authorization behavior of devices that
// connect to the AWS IoT device gateway.
//
//    // Example sending a request using the TestInvokeAuthorizerRequest method.
//    req := client.TestInvokeAuthorizerRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) TestInvokeAuthorizerRequest(input *TestInvokeAuthorizerInput) TestInvokeAuthorizerRequest {
	op := &aws.Operation{
		Name:       opTestInvokeAuthorizer,
		HTTPMethod: "POST",
		HTTPPath:   "/authorizer/{authorizerName}/test",
	}

	if input == nil {
		input = &TestInvokeAuthorizerInput{}
	}

	output := &TestInvokeAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TestInvokeAuthorizerRequest{Request: req, Input: input, Copy: c.TestInvokeAuthorizerRequest}
}

const opTransferCertificate = "TransferCertificate"

// TransferCertificateRequest is a API request type for the TransferCertificate API operation.
type TransferCertificateRequest struct {
	*aws.Request
	Input *TransferCertificateInput
	Copy  func(*TransferCertificateInput) TransferCertificateRequest
}

// Send marshals and sends the TransferCertificate API request.
func (r TransferCertificateRequest) Send() (*TransferCertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TransferCertificateOutput), nil
}

// TransferCertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Transfers the specified certificate to the specified AWS account.
//
// You can cancel the transfer until it is acknowledged by the recipient.
//
// No notification is sent to the transfer destination's account. It is up to
// the caller to notify the transfer target.
//
// The certificate being transferred must not be in the ACTIVE state. You can
// use the UpdateCertificate API to deactivate it.
//
// The certificate must not have any policies attached to it. You can use the
// DetachPrincipalPolicy API to detach them.
//
//    // Example sending a request using the TransferCertificateRequest method.
//    req := client.TransferCertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) TransferCertificateRequest(input *TransferCertificateInput) TransferCertificateRequest {
	op := &aws.Operation{
		Name:       opTransferCertificate,
		HTTPMethod: "PATCH",
		HTTPPath:   "/transfer-certificate/{certificateId}",
	}

	if input == nil {
		input = &TransferCertificateInput{}
	}

	output := &TransferCertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TransferCertificateRequest{Request: req, Input: input, Copy: c.TransferCertificateRequest}
}

const opUpdateAuthorizer = "UpdateAuthorizer"

// UpdateAuthorizerRequest is a API request type for the UpdateAuthorizer API operation.
type UpdateAuthorizerRequest struct {
	*aws.Request
	Input *UpdateAuthorizerInput
	Copy  func(*UpdateAuthorizerInput) UpdateAuthorizerRequest
}

// Send marshals and sends the UpdateAuthorizer API request.
func (r UpdateAuthorizerRequest) Send() (*UpdateAuthorizerOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateAuthorizerOutput), nil
}

// UpdateAuthorizerRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates an authorizer.
//
//    // Example sending a request using the UpdateAuthorizerRequest method.
//    req := client.UpdateAuthorizerRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateAuthorizerRequest(input *UpdateAuthorizerInput) UpdateAuthorizerRequest {
	op := &aws.Operation{
		Name:       opUpdateAuthorizer,
		HTTPMethod: "PUT",
		HTTPPath:   "/authorizer/{authorizerName}",
	}

	if input == nil {
		input = &UpdateAuthorizerInput{}
	}

	output := &UpdateAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateAuthorizerRequest{Request: req, Input: input, Copy: c.UpdateAuthorizerRequest}
}

const opUpdateCACertificate = "UpdateCACertificate"

// UpdateCACertificateRequest is a API request type for the UpdateCACertificate API operation.
type UpdateCACertificateRequest struct {
	*aws.Request
	Input *UpdateCACertificateInput
	Copy  func(*UpdateCACertificateInput) UpdateCACertificateRequest
}

// Send marshals and sends the UpdateCACertificate API request.
func (r UpdateCACertificateRequest) Send() (*UpdateCACertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateCACertificateOutput), nil
}

// UpdateCACertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates a registered CA certificate.
//
//    // Example sending a request using the UpdateCACertificateRequest method.
//    req := client.UpdateCACertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateCACertificateRequest(input *UpdateCACertificateInput) UpdateCACertificateRequest {
	op := &aws.Operation{
		Name:       opUpdateCACertificate,
		HTTPMethod: "PUT",
		HTTPPath:   "/cacertificate/{caCertificateId}",
	}

	if input == nil {
		input = &UpdateCACertificateInput{}
	}

	output := &UpdateCACertificateOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateCACertificateRequest{Request: req, Input: input, Copy: c.UpdateCACertificateRequest}
}

const opUpdateCertificate = "UpdateCertificate"

// UpdateCertificateRequest is a API request type for the UpdateCertificate API operation.
type UpdateCertificateRequest struct {
	*aws.Request
	Input *UpdateCertificateInput
	Copy  func(*UpdateCertificateInput) UpdateCertificateRequest
}

// Send marshals and sends the UpdateCertificate API request.
func (r UpdateCertificateRequest) Send() (*UpdateCertificateOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateCertificateOutput), nil
}

// UpdateCertificateRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates the status of the specified certificate. This operation is idempotent.
//
// Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect
// currently connected devices, but these devices will be unable to reconnect.
//
// The ACTIVE state is required to authenticate devices connecting to AWS IoT
// using a certificate.
//
//    // Example sending a request using the UpdateCertificateRequest method.
//    req := client.UpdateCertificateRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateCertificateRequest(input *UpdateCertificateInput) UpdateCertificateRequest {
	op := &aws.Operation{
		Name:       opUpdateCertificate,
		HTTPMethod: "PUT",
		HTTPPath:   "/certificates/{certificateId}",
	}

	if input == nil {
		input = &UpdateCertificateInput{}
	}

	output := &UpdateCertificateOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateCertificateRequest{Request: req, Input: input, Copy: c.UpdateCertificateRequest}
}

const opUpdateEventConfigurations = "UpdateEventConfigurations"

// UpdateEventConfigurationsRequest is a API request type for the UpdateEventConfigurations API operation.
type UpdateEventConfigurationsRequest struct {
	*aws.Request
	Input *UpdateEventConfigurationsInput
	Copy  func(*UpdateEventConfigurationsInput) UpdateEventConfigurationsRequest
}

// Send marshals and sends the UpdateEventConfigurations API request.
func (r UpdateEventConfigurationsRequest) Send() (*UpdateEventConfigurationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateEventConfigurationsOutput), nil
}

// UpdateEventConfigurationsRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates the event configurations.
//
//    // Example sending a request using the UpdateEventConfigurationsRequest method.
//    req := client.UpdateEventConfigurationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateEventConfigurationsRequest(input *UpdateEventConfigurationsInput) UpdateEventConfigurationsRequest {
	op := &aws.Operation{
		Name:       opUpdateEventConfigurations,
		HTTPMethod: "PATCH",
		HTTPPath:   "/event-configurations",
	}

	if input == nil {
		input = &UpdateEventConfigurationsInput{}
	}

	output := &UpdateEventConfigurationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateEventConfigurationsRequest{Request: req, Input: input, Copy: c.UpdateEventConfigurationsRequest}
}

const opUpdateIndexingConfiguration = "UpdateIndexingConfiguration"

// UpdateIndexingConfigurationRequest is a API request type for the UpdateIndexingConfiguration API operation.
type UpdateIndexingConfigurationRequest struct {
	*aws.Request
	Input *UpdateIndexingConfigurationInput
	Copy  func(*UpdateIndexingConfigurationInput) UpdateIndexingConfigurationRequest
}

// Send marshals and sends the UpdateIndexingConfiguration API request.
func (r UpdateIndexingConfigurationRequest) Send() (*UpdateIndexingConfigurationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateIndexingConfigurationOutput), nil
}

// UpdateIndexingConfigurationRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates the search configuration.
//
//    // Example sending a request using the UpdateIndexingConfigurationRequest method.
//    req := client.UpdateIndexingConfigurationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateIndexingConfigurationRequest(input *UpdateIndexingConfigurationInput) UpdateIndexingConfigurationRequest {
	op := &aws.Operation{
		Name:       opUpdateIndexingConfiguration,
		HTTPMethod: "POST",
		HTTPPath:   "/indexing/config",
	}

	if input == nil {
		input = &UpdateIndexingConfigurationInput{}
	}

	output := &UpdateIndexingConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateIndexingConfigurationRequest{Request: req, Input: input, Copy: c.UpdateIndexingConfigurationRequest}
}

const opUpdateRoleAlias = "UpdateRoleAlias"

// UpdateRoleAliasRequest is a API request type for the UpdateRoleAlias API operation.
type UpdateRoleAliasRequest struct {
	*aws.Request
	Input *UpdateRoleAliasInput
	Copy  func(*UpdateRoleAliasInput) UpdateRoleAliasRequest
}

// Send marshals and sends the UpdateRoleAlias API request.
func (r UpdateRoleAliasRequest) Send() (*UpdateRoleAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRoleAliasOutput), nil
}

// UpdateRoleAliasRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates a role alias.
//
//    // Example sending a request using the UpdateRoleAliasRequest method.
//    req := client.UpdateRoleAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateRoleAliasRequest(input *UpdateRoleAliasInput) UpdateRoleAliasRequest {
	op := &aws.Operation{
		Name:       opUpdateRoleAlias,
		HTTPMethod: "PUT",
		HTTPPath:   "/role-aliases/{roleAlias}",
	}

	if input == nil {
		input = &UpdateRoleAliasInput{}
	}

	output := &UpdateRoleAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateRoleAliasRequest{Request: req, Input: input, Copy: c.UpdateRoleAliasRequest}
}

const opUpdateStream = "UpdateStream"

// UpdateStreamRequest is a API request type for the UpdateStream API operation.
type UpdateStreamRequest struct {
	*aws.Request
	Input *UpdateStreamInput
	Copy  func(*UpdateStreamInput) UpdateStreamRequest
}

// Send marshals and sends the UpdateStream API request.
func (r UpdateStreamRequest) Send() (*UpdateStreamOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateStreamOutput), nil
}

// UpdateStreamRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates an existing stream. The stream version will be incremented by one.
//
//    // Example sending a request using the UpdateStreamRequest method.
//    req := client.UpdateStreamRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateStreamRequest(input *UpdateStreamInput) UpdateStreamRequest {
	op := &aws.Operation{
		Name:       opUpdateStream,
		HTTPMethod: "PUT",
		HTTPPath:   "/streams/{streamId}",
	}

	if input == nil {
		input = &UpdateStreamInput{}
	}

	output := &UpdateStreamOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateStreamRequest{Request: req, Input: input, Copy: c.UpdateStreamRequest}
}

const opUpdateThing = "UpdateThing"

// UpdateThingRequest is a API request type for the UpdateThing API operation.
type UpdateThingRequest struct {
	*aws.Request
	Input *UpdateThingInput
	Copy  func(*UpdateThingInput) UpdateThingRequest
}

// Send marshals and sends the UpdateThing API request.
func (r UpdateThingRequest) Send() (*UpdateThingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateThingOutput), nil
}

// UpdateThingRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates the data for a thing.
//
//    // Example sending a request using the UpdateThingRequest method.
//    req := client.UpdateThingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateThingRequest(input *UpdateThingInput) UpdateThingRequest {
	op := &aws.Operation{
		Name:       opUpdateThing,
		HTTPMethod: "PATCH",
		HTTPPath:   "/things/{thingName}",
	}

	if input == nil {
		input = &UpdateThingInput{}
	}

	output := &UpdateThingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateThingRequest{Request: req, Input: input, Copy: c.UpdateThingRequest}
}

const opUpdateThingGroup = "UpdateThingGroup"

// UpdateThingGroupRequest is a API request type for the UpdateThingGroup API operation.
type UpdateThingGroupRequest struct {
	*aws.Request
	Input *UpdateThingGroupInput
	Copy  func(*UpdateThingGroupInput) UpdateThingGroupRequest
}

// Send marshals and sends the UpdateThingGroup API request.
func (r UpdateThingGroupRequest) Send() (*UpdateThingGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateThingGroupOutput), nil
}

// UpdateThingGroupRequest returns a request value for making API operation for
// AWS IoT.
//
// Update a thing group.
//
//    // Example sending a request using the UpdateThingGroupRequest method.
//    req := client.UpdateThingGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateThingGroupRequest(input *UpdateThingGroupInput) UpdateThingGroupRequest {
	op := &aws.Operation{
		Name:       opUpdateThingGroup,
		HTTPMethod: "PATCH",
		HTTPPath:   "/thing-groups/{thingGroupName}",
	}

	if input == nil {
		input = &UpdateThingGroupInput{}
	}

	output := &UpdateThingGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateThingGroupRequest{Request: req, Input: input, Copy: c.UpdateThingGroupRequest}
}

const opUpdateThingGroupsForThing = "UpdateThingGroupsForThing"

// UpdateThingGroupsForThingRequest is a API request type for the UpdateThingGroupsForThing API operation.
type UpdateThingGroupsForThingRequest struct {
	*aws.Request
	Input *UpdateThingGroupsForThingInput
	Copy  func(*UpdateThingGroupsForThingInput) UpdateThingGroupsForThingRequest
}

// Send marshals and sends the UpdateThingGroupsForThing API request.
func (r UpdateThingGroupsForThingRequest) Send() (*UpdateThingGroupsForThingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateThingGroupsForThingOutput), nil
}

// UpdateThingGroupsForThingRequest returns a request value for making API operation for
// AWS IoT.
//
// Updates the groups to which the thing belongs.
//
//    // Example sending a request using the UpdateThingGroupsForThingRequest method.
//    req := client.UpdateThingGroupsForThingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *IoT) UpdateThingGroupsForThingRequest(input *UpdateThingGroupsForThingInput) UpdateThingGroupsForThingRequest {
	op := &aws.Operation{
		Name:       opUpdateThingGroupsForThing,
		HTTPMethod: "PUT",
		HTTPPath:   "/thing-groups/updateThingGroupsForThing",
	}

	if input == nil {
		input = &UpdateThingGroupsForThingInput{}
	}

	output := &UpdateThingGroupsForThingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateThingGroupsForThingRequest{Request: req, Input: input, Copy: c.UpdateThingGroupsForThingRequest}
}

// The input for the AcceptCertificateTransfer operation.
type AcceptCertificateTransferInput struct {
	_ struct{} `type:"structure"`

	// The ID of the certificate. (The last part of the certificate ARN contains
	// the certificate ID.)
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"certificateId" min:"64" type:"string" required:"true"`

	// Specifies whether the certificate is active.
	SetAsActive *bool `location:"querystring" locationName:"setAsActive" type:"boolean"`
}

// String returns the string representation
func (s AcceptCertificateTransferInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AcceptCertificateTransferInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AcceptCertificateTransferInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AcceptCertificateTransferInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AcceptCertificateTransferInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SetAsActive != nil {
		v := *s.SetAsActive

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "setAsActive", protocol.BoolValue(v), metadata)
	}
	return nil
}

type AcceptCertificateTransferOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AcceptCertificateTransferOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AcceptCertificateTransferOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AcceptCertificateTransferOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AcceptCertificateTransferOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes the actions associated with a rule.
type Action struct {
	_ struct{} `type:"structure"`

	// Change the state of a CloudWatch alarm.
	CloudwatchAlarm *CloudwatchAlarmAction `locationName:"cloudwatchAlarm" type:"structure"`

	// Capture a CloudWatch metric.
	CloudwatchMetric *CloudwatchMetricAction `locationName:"cloudwatchMetric" type:"structure"`

	// Write to a DynamoDB table.
	DynamoDB *DynamoDBAction `locationName:"dynamoDB" type:"structure"`

	// Write to a DynamoDB table. This is a new version of the DynamoDB action.
	// It allows you to write each attribute in an MQTT message payload into a separate
	// DynamoDB column.
	DynamoDBv2 *DynamoDBv2Action `locationName:"dynamoDBv2" type:"structure"`

	// Write data to an Amazon Elasticsearch Service domain.
	Elasticsearch *ElasticsearchAction `locationName:"elasticsearch" type:"structure"`

	// Write to an Amazon Kinesis Firehose stream.
	Firehose *FirehoseAction `locationName:"firehose" type:"structure"`

	// Sends message data to an AWS IoT Analytics channel.
	IotAnalytics *IotAnalyticsAction `locationName:"iotAnalytics" type:"structure"`

	// Write data to an Amazon Kinesis stream.
	Kinesis *KinesisAction `locationName:"kinesis" type:"structure"`

	// Invoke a Lambda function.
	Lambda *LambdaAction `locationName:"lambda" type:"structure"`

	// Publish to another MQTT topic.
	Republish *RepublishAction `locationName:"republish" type:"structure"`

	// Write to an Amazon S3 bucket.
	S3 *S3Action `locationName:"s3" type:"structure"`

	// Send a message to a Salesforce IoT Cloud Input Stream.
	Salesforce *SalesforceAction `locationName:"salesforce" type:"structure"`

	// Publish to an Amazon SNS topic.
	Sns *SnsAction `locationName:"sns" type:"structure"`

	// Publish to an Amazon SQS queue.
	Sqs *SqsAction `locationName:"sqs" type:"structure"`
}

// String returns the string representation
func (s Action) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Action) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Action) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Action"}
	if s.CloudwatchAlarm != nil {
		if err := s.CloudwatchAlarm.Validate(); err != nil {
			invalidParams.AddNested("CloudwatchAlarm", err.(aws.ErrInvalidParams))
		}
	}
	if s.CloudwatchMetric != nil {
		if err := s.CloudwatchMetric.Validate(); err != nil {
			invalidParams.AddNested("CloudwatchMetric", err.(aws.ErrInvalidParams))
		}
	}
	if s.DynamoDB != nil {
		if err := s.DynamoDB.Validate(); err != nil {
			invalidParams.AddNested("DynamoDB", err.(aws.ErrInvalidParams))
		}
	}
	if s.DynamoDBv2 != nil {
		if err := s.DynamoDBv2.Validate(); err != nil {
			invalidParams.AddNested("DynamoDBv2", err.(aws.ErrInvalidParams))
		}
	}
	if s.Elasticsearch != nil {
		if err := s.Elasticsearch.Validate(); err != nil {
			invalidParams.AddNested("Elasticsearch", err.(aws.ErrInvalidParams))
		}
	}
	if s.Firehose != nil {
		if err := s.Firehose.Validate(); err != nil {
			invalidParams.AddNested("Firehose", err.(aws.ErrInvalidParams))
		}
	}
	if s.Kinesis != nil {
		if err := s.Kinesis.Validate(); err != nil {
			invalidParams.AddNested("Kinesis", err.(aws.ErrInvalidParams))
		}
	}
	if s.Lambda != nil {
		if err := s.Lambda.Validate(); err != nil {
			invalidParams.AddNested("Lambda", err.(aws.ErrInvalidParams))
		}
	}
	if s.Republish != nil {
		if err := s.Republish.Validate(); err != nil {
			invalidParams.AddNested("Republish", err.(aws.ErrInvalidParams))
		}
	}
	if s.S3 != nil {
		if err := s.S3.Validate(); err != nil {
			invalidParams.AddNested("S3", err.(aws.ErrInvalidParams))
		}
	}
	if s.Salesforce != nil {
		if err := s.Salesforce.Validate(); err != nil {
			invalidParams.AddNested("Salesforce", err.(aws.ErrInvalidParams))
		}
	}
	if s.Sns != nil {
		if err := s.Sns.Validate(); err != nil {
			invalidParams.AddNested("Sns", err.(aws.ErrInvalidParams))
		}
	}
	if s.Sqs != nil {
		if err := s.Sqs.Validate(); err != nil {
			invalidParams.AddNested("Sqs", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Action) MarshalFields(e protocol.FieldEncoder) error {
	if s.CloudwatchAlarm != nil {
		v := s.CloudwatchAlarm

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "cloudwatchAlarm", v, metadata)
	}
	if s.CloudwatchMetric != nil {
		v := s.CloudwatchMetric

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "cloudwatchMetric", v, metadata)
	}
	if s.DynamoDB != nil {
		v := s.DynamoDB

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dynamoDB", v, metadata)
	}
	if s.DynamoDBv2 != nil {
		v := s.DynamoDBv2

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dynamoDBv2", v, metadata)
	}
	if s.Elasticsearch != nil {
		v := s.Elasticsearch

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "elasticsearch", v, metadata)
	}
	if s.Firehose != nil {
		v := s.Firehose

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "firehose", v, metadata)
	}
	if s.IotAnalytics != nil {
		v := s.IotAnalytics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "iotAnalytics", v, metadata)
	}
	if s.Kinesis != nil {
		v := s.Kinesis

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "kinesis", v, metadata)
	}
	if s.Lambda != nil {
		v := s.Lambda

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "lambda", v, metadata)
	}
	if s.Republish != nil {
		v := s.Republish

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "republish", v, metadata)
	}
	if s.S3 != nil {
		v := s.S3

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "s3", v, metadata)
	}
	if s.Salesforce != nil {
		v := s.Salesforce

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "salesforce", v, metadata)
	}
	if s.Sns != nil {
		v := s.Sns

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "sns", v, metadata)
	}
	if s.Sqs != nil {
		v := s.Sqs

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "sqs", v, metadata)
	}
	return nil
}

type AddThingToThingGroupInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the thing to add to a group.
	ThingArn *string `locationName:"thingArn" type:"string"`

	// The ARN of the group to which you are adding a thing.
	ThingGroupArn *string `locationName:"thingGroupArn" type:"string"`

	// The name of the group to which you are adding a thing.
	ThingGroupName *string `locationName:"thingGroupName" min:"1" type:"string"`

	// The name of the thing to add to a group.
	ThingName *string `locationName:"thingName" min:"1" type:"string"`
}

// String returns the string representation
func (s AddThingToThingGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddThingToThingGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AddThingToThingGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AddThingToThingGroupInput"}
	if s.ThingGroupName != nil && len(*s.ThingGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupName", 1))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddThingToThingGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingArn != nil {
		v := *s.ThingArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupArn != nil {
		v := *s.ThingGroupArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AddThingToThingGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AddThingToThingGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddThingToThingGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AddThingToThingGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddThingToThingGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Contains information that allowed the authorization.
type Allowed struct {
	_ struct{} `type:"structure"`

	// A list of policies that allowed the authentication.
	Policies []Policy `locationName:"policies" type:"list"`
}

// String returns the string representation
func (s Allowed) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Allowed) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Allowed) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Policies) > 0 {
		v := s.Policies

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type AssociateTargetsWithJobInput struct {
	_ struct{} `type:"structure"`

	// An optional comment string describing why the job was associated with the
	// targets.
	Comment *string `locationName:"comment" type:"string"`

	// The unique identifier you assigned to this job when it was created.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`

	// A list of thing group ARNs that define the targets of the job.
	//
	// Targets is a required field
	Targets []string `locationName:"targets" min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s AssociateTargetsWithJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AssociateTargetsWithJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AssociateTargetsWithJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AssociateTargetsWithJobInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if s.Targets == nil {
		invalidParams.Add(aws.NewErrParamRequired("Targets"))
	}
	if s.Targets != nil && len(s.Targets) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Targets", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AssociateTargetsWithJobInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Comment != nil {
		v := *s.Comment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "comment", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Targets) > 0 {
		v := s.Targets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "targets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AssociateTargetsWithJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A short text description of the job.
	Description *string `locationName:"description" type:"string"`

	// An ARN identifying the job.
	JobArn *string `locationName:"jobArn" type:"string"`

	// The unique identifier you assigned to this job when it was created.
	JobId *string `locationName:"jobId" min:"1" type:"string"`
}

// String returns the string representation
func (s AssociateTargetsWithJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AssociateTargetsWithJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AssociateTargetsWithJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AssociateTargetsWithJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobArn != nil {
		v := *s.JobArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AttachPolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of the policy to attach.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`

	// The identity to which the policy is attached.
	//
	// Target is a required field
	Target *string `locationName:"target" type:"string" required:"true"`
}

// String returns the string representation
func (s AttachPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttachPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttachPolicyInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if s.Target == nil {
		invalidParams.Add(aws.NewErrParamRequired("Target"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Target != nil {
		v := *s.Target

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "target", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AttachPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AttachPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AttachPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the AttachPrincipalPolicy operation.
type AttachPrincipalPolicyInput struct {
	_ struct{} `type:"structure"`

	// The policy name.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`

	// The principal, which can be a certificate ARN (as returned from the CreateCertificate
	// operation) or an Amazon Cognito ID.
	//
	// Principal is a required field
	Principal *string `location:"header" locationName:"x-amzn-iot-principal" type:"string" required:"true"`
}

// String returns the string representation
func (s AttachPrincipalPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachPrincipalPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttachPrincipalPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttachPrincipalPolicyInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if s.Principal == nil {
		invalidParams.Add(aws.NewErrParamRequired("Principal"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachPrincipalPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Principal != nil {
		v := *s.Principal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amzn-iot-principal", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AttachPrincipalPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AttachPrincipalPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachPrincipalPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AttachPrincipalPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachPrincipalPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the AttachThingPrincipal operation.
type AttachThingPrincipalInput struct {
	_ struct{} `type:"structure"`

	// The principal, such as a certificate or other credential.
	//
	// Principal is a required field
	Principal *string `location:"header" locationName:"x-amzn-principal" type:"string" required:"true"`

	// The name of the thing.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s AttachThingPrincipalInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachThingPrincipalInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttachThingPrincipalInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttachThingPrincipalInput"}

	if s.Principal == nil {
		invalidParams.Add(aws.NewErrParamRequired("Principal"))
	}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachThingPrincipalInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Principal != nil {
		v := *s.Principal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amzn-principal", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the AttachThingPrincipal operation.
type AttachThingPrincipalOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AttachThingPrincipalOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachThingPrincipalOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AttachThingPrincipalOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachThingPrincipalOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The attribute payload.
type AttributePayload struct {
	_ struct{} `type:"structure"`

	// A JSON string containing up to three key-value pair in JSON format. For example:
	//
	// {\"attributes\":{\"string1\":\"string2\"}}
	Attributes map[string]string `locationName:"attributes" type:"map"`

	// Specifies whether the list of attributes provided in the AttributePayload
	// is merged with the attributes stored in the registry, instead of overwriting
	// them.
	//
	// To remove an attribute, call UpdateThing with an empty attribute value.
	//
	// The merge attribute is only valid when calling UpdateThing.
	Merge *bool `locationName:"merge" type:"boolean"`
}

// String returns the string representation
func (s AttributePayload) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributePayload) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttributePayload) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "attributes", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Merge != nil {
		v := *s.Merge

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "merge", protocol.BoolValue(v), metadata)
	}
	return nil
}

// A collection of authorization information.
type AuthInfo struct {
	_ struct{} `type:"structure"`

	// The type of action for which the principal is being authorized.
	ActionType ActionType `locationName:"actionType" type:"string" enum:"true"`

	// The resources for which the principal is being authorized to perform the
	// specified action.
	Resources []string `locationName:"resources" type:"list"`
}

// String returns the string representation
func (s AuthInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AuthInfo) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AuthInfo) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ActionType) > 0 {
		v := s.ActionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "actionType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Resources) > 0 {
		v := s.Resources

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "resources", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// The authorizer result.
type AuthResult struct {
	_ struct{} `type:"structure"`

	// The policies and statements that allowed the specified action.
	Allowed *Allowed `locationName:"allowed" type:"structure"`

	// The final authorization decision of this scenario. Multiple statements are
	// taken into account when determining the authorization decision. An explicit
	// deny statement can override multiple allow statements.
	AuthDecision AuthDecision `locationName:"authDecision" type:"string" enum:"true"`

	// Authorization information.
	AuthInfo *AuthInfo `locationName:"authInfo" type:"structure"`

	// The policies and statements that denied the specified action.
	Denied *Denied `locationName:"denied" type:"structure"`

	// Contains any missing context values found while evaluating policy.
	MissingContextValues []string `locationName:"missingContextValues" type:"list"`
}

// String returns the string representation
func (s AuthResult) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AuthResult) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AuthResult) MarshalFields(e protocol.FieldEncoder) error {
	if s.Allowed != nil {
		v := s.Allowed

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "allowed", v, metadata)
	}
	if len(s.AuthDecision) > 0 {
		v := s.AuthDecision

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authDecision", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.AuthInfo != nil {
		v := s.AuthInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "authInfo", v, metadata)
	}
	if s.Denied != nil {
		v := s.Denied

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "denied", v, metadata)
	}
	if len(s.MissingContextValues) > 0 {
		v := s.MissingContextValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "missingContextValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// The authorizer description.
type AuthorizerDescription struct {
	_ struct{} `type:"structure"`

	// The authorizer ARN.
	AuthorizerArn *string `locationName:"authorizerArn" type:"string"`

	// The authorizer's Lambda function ARN.
	AuthorizerFunctionArn *string `locationName:"authorizerFunctionArn" type:"string"`

	// The authorizer name.
	AuthorizerName *string `locationName:"authorizerName" min:"1" type:"string"`

	// The UNIX timestamp of when the authorizer was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The UNIX timestamp of when the authorizer was last updated.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`

	// The status of the authorizer.
	Status AuthorizerStatus `locationName:"status" type:"string" enum:"true"`

	// The key used to extract the token from the HTTP headers.
	TokenKeyName *string `locationName:"tokenKeyName" min:"1" type:"string"`

	// The public keys used to validate the token signature returned by your custom
	// authentication service.
	TokenSigningPublicKeys map[string]string `locationName:"tokenSigningPublicKeys" type:"map"`
}

// String returns the string representation
func (s AuthorizerDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AuthorizerDescription) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AuthorizerDescription) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthorizerArn != nil {
		v := *s.AuthorizerArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerFunctionArn != nil {
		v := *s.AuthorizerFunctionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerFunctionArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.TokenKeyName != nil {
		v := *s.TokenKeyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tokenKeyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TokenSigningPublicKeys) > 0 {
		v := s.TokenSigningPublicKeys

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tokenSigningPublicKeys", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// The authorizer summary.
type AuthorizerSummary struct {
	_ struct{} `type:"structure"`

	// The authorizer ARN.
	AuthorizerArn *string `locationName:"authorizerArn" type:"string"`

	// The authorizer name.
	AuthorizerName *string `locationName:"authorizerName" min:"1" type:"string"`
}

// String returns the string representation
func (s AuthorizerSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AuthorizerSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AuthorizerSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthorizerArn != nil {
		v := *s.AuthorizerArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A CA certificate.
type CACertificate struct {
	_ struct{} `type:"structure"`

	// The ARN of the CA certificate.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The ID of the CA certificate.
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`

	// The date the CA certificate was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The status of the CA certificate.
	//
	// The status value REGISTER_INACTIVE is deprecated and should not be used.
	Status CACertificateStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s CACertificate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CACertificate) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CACertificate) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes a CA certificate.
type CACertificateDescription struct {
	_ struct{} `type:"structure"`

	// Whether the CA certificate configured for auto registration of device certificates.
	// Valid values are "ENABLE" and "DISABLE"
	AutoRegistrationStatus AutoRegistrationStatus `locationName:"autoRegistrationStatus" type:"string" enum:"true"`

	// The CA certificate ARN.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The CA certificate ID.
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`

	// The CA certificate data, in PEM format.
	CertificatePem *string `locationName:"certificatePem" min:"1" type:"string"`

	// The date the CA certificate was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The customer version of the CA certificate.
	CustomerVersion *int64 `locationName:"customerVersion" min:"1" type:"integer"`

	// The generation ID of the CA certificate.
	GenerationId *string `locationName:"generationId" type:"string"`

	// The date the CA certificate was last modified.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`

	// The owner of the CA certificate.
	OwnedBy *string `locationName:"ownedBy" type:"string"`

	// The status of a CA certificate.
	Status CACertificateStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s CACertificateDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CACertificateDescription) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CACertificateDescription) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AutoRegistrationStatus) > 0 {
		v := s.AutoRegistrationStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "autoRegistrationStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificatePem != nil {
		v := *s.CertificatePem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificatePem", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CustomerVersion != nil {
		v := *s.CustomerVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "customerVersion", protocol.Int64Value(v), metadata)
	}
	if s.GenerationId != nil {
		v := *s.GenerationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "generationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.OwnedBy != nil {
		v := *s.OwnedBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ownedBy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The input for the CancelCertificateTransfer operation.
type CancelCertificateTransferInput struct {
	_ struct{} `type:"structure"`

	// The ID of the certificate. (The last part of the certificate ARN contains
	// the certificate ID.)
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"certificateId" min:"64" type:"string" required:"true"`
}

// String returns the string representation
func (s CancelCertificateTransferInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelCertificateTransferInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CancelCertificateTransferInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CancelCertificateTransferInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelCertificateTransferInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CancelCertificateTransferOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CancelCertificateTransferOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelCertificateTransferOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CancelCertificateTransferOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelCertificateTransferOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type CancelJobExecutionInput struct {
	_ struct{} `type:"structure"`

	// (Optional) The expected current version of the job execution. Each time you
	// update the job execution, its version is incremented. If the version of the
	// job execution stored in Jobs does not match, the update is rejected with
	// a VersionMismatch error, and an ErrorResponse that contains the current job
	// execution status data is returned. (This makes it unnecessary to perform
	// a separate DescribeJobExecution request in order to obtain the job execution
	// status data.)
	ExpectedVersion *int64 `locationName:"expectedVersion" type:"long"`

	// (Optional) If true the job execution will be canceled if it has status IN_PROGRESS
	// or QUEUED, otherwise the job execution will be canceled only if it has status
	// QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and
	// you do not set force to true, then an InvalidStateTransitionException will
	// be thrown. The default is false.
	//
	// Canceling a job execution which is "IN_PROGRESS", will cause the device to
	// be unable to update the job execution status. Use caution and ensure that
	// the device is able to recover to a valid state.
	Force *bool `location:"querystring" locationName:"force" type:"boolean"`

	// The ID of the job to be canceled.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`

	// A collection of name/value pairs that describe the status of the job execution.
	// If not specified, the statusDetails are unchanged. You can specify at most
	// 10 name/value pairs.
	StatusDetails map[string]string `locationName:"statusDetails" type:"map"`

	// The name of the thing whose execution of the job will be canceled.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CancelJobExecutionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelJobExecutionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CancelJobExecutionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CancelJobExecutionInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelJobExecutionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ExpectedVersion != nil {
		v := *s.ExpectedVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "expectedVersion", protocol.Int64Value(v), metadata)
	}
	if len(s.StatusDetails) > 0 {
		v := s.StatusDetails

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "statusDetails", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Force != nil {
		v := *s.Force

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "force", protocol.BoolValue(v), metadata)
	}
	return nil
}

type CancelJobExecutionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CancelJobExecutionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelJobExecutionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CancelJobExecutionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelJobExecutionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type CancelJobInput struct {
	_ struct{} `type:"structure"`

	// An optional comment string describing why the job was canceled.
	Comment *string `locationName:"comment" type:"string"`

	// (Optional) If true job executions with status "IN_PROGRESS" and "QUEUED"
	// are canceled, otherwise only job executions with status "QUEUED" are canceled.
	// The default is false.
	//
	// Canceling a job which is "IN_PROGRESS", will cause a device which is executing
	// the job to be unable to update the job execution status. Use caution and
	// ensure that each device executing a job which is canceled is able to recover
	// to a valid state.
	Force *bool `location:"querystring" locationName:"force" type:"boolean"`

	// The unique identifier you assigned to this job when it was created.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CancelJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CancelJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CancelJobInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelJobInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Comment != nil {
		v := *s.Comment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "comment", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Force != nil {
		v := *s.Force

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "force", protocol.BoolValue(v), metadata)
	}
	return nil
}

type CancelJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A short text description of the job.
	Description *string `locationName:"description" type:"string"`

	// The job ARN.
	JobArn *string `locationName:"jobArn" type:"string"`

	// The unique identifier you assigned to this job when it was created.
	JobId *string `locationName:"jobId" min:"1" type:"string"`
}

// String returns the string representation
func (s CancelJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CancelJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobArn != nil {
		v := *s.JobArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about a certificate.
type Certificate struct {
	_ struct{} `type:"structure"`

	// The ARN of the certificate.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The ID of the certificate. (The last part of the certificate ARN contains
	// the certificate ID.)
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`

	// The date and time the certificate was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The status of the certificate.
	//
	// The status value REGISTER_INACTIVE is deprecated and should not be used.
	Status CertificateStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s Certificate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Certificate) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Certificate) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes a certificate.
type CertificateDescription struct {
	_ struct{} `type:"structure"`

	// The certificate ID of the CA certificate used to sign this certificate.
	CaCertificateId *string `locationName:"caCertificateId" min:"64" type:"string"`

	// The ARN of the certificate.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The ID of the certificate.
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`

	// The certificate data, in PEM format.
	CertificatePem *string `locationName:"certificatePem" min:"1" type:"string"`

	// The date and time the certificate was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The customer version of the certificate.
	CustomerVersion *int64 `locationName:"customerVersion" min:"1" type:"integer"`

	// The generation ID of the certificate.
	GenerationId *string `locationName:"generationId" type:"string"`

	// The date and time the certificate was last modified.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`

	// The ID of the AWS account that owns the certificate.
	OwnedBy *string `locationName:"ownedBy" type:"string"`

	// The ID of the AWS account of the previous owner of the certificate.
	PreviousOwnedBy *string `locationName:"previousOwnedBy" type:"string"`

	// The status of the certificate.
	Status CertificateStatus `locationName:"status" type:"string" enum:"true"`

	// The transfer data.
	TransferData *TransferData `locationName:"transferData" type:"structure"`
}

// String returns the string representation
func (s CertificateDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CertificateDescription) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CertificateDescription) MarshalFields(e protocol.FieldEncoder) error {
	if s.CaCertificateId != nil {
		v := *s.CaCertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "caCertificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificatePem != nil {
		v := *s.CertificatePem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificatePem", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CustomerVersion != nil {
		v := *s.CustomerVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "customerVersion", protocol.Int64Value(v), metadata)
	}
	if s.GenerationId != nil {
		v := *s.GenerationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "generationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.OwnedBy != nil {
		v := *s.OwnedBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ownedBy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PreviousOwnedBy != nil {
		v := *s.PreviousOwnedBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "previousOwnedBy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.TransferData != nil {
		v := s.TransferData

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "transferData", v, metadata)
	}
	return nil
}

type ClearDefaultAuthorizerInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s ClearDefaultAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ClearDefaultAuthorizerInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ClearDefaultAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

type ClearDefaultAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s ClearDefaultAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ClearDefaultAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ClearDefaultAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ClearDefaultAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes an action that updates a CloudWatch alarm.
type CloudwatchAlarmAction struct {
	_ struct{} `type:"structure"`

	// The CloudWatch alarm name.
	//
	// AlarmName is a required field
	AlarmName *string `locationName:"alarmName" type:"string" required:"true"`

	// The IAM role that allows access to the CloudWatch alarm.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// The reason for the alarm change.
	//
	// StateReason is a required field
	StateReason *string `locationName:"stateReason" type:"string" required:"true"`

	// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
	//
	// StateValue is a required field
	StateValue *string `locationName:"stateValue" type:"string" required:"true"`
}

// String returns the string representation
func (s CloudwatchAlarmAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CloudwatchAlarmAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CloudwatchAlarmAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CloudwatchAlarmAction"}

	if s.AlarmName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AlarmName"))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if s.StateReason == nil {
		invalidParams.Add(aws.NewErrParamRequired("StateReason"))
	}

	if s.StateValue == nil {
		invalidParams.Add(aws.NewErrParamRequired("StateValue"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CloudwatchAlarmAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.AlarmName != nil {
		v := *s.AlarmName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "alarmName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StateReason != nil {
		v := *s.StateReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stateReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StateValue != nil {
		v := *s.StateValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stateValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an action that captures a CloudWatch metric.
type CloudwatchMetricAction struct {
	_ struct{} `type:"structure"`

	// The CloudWatch metric name.
	//
	// MetricName is a required field
	MetricName *string `locationName:"metricName" type:"string" required:"true"`

	// The CloudWatch metric namespace name.
	//
	// MetricNamespace is a required field
	MetricNamespace *string `locationName:"metricNamespace" type:"string" required:"true"`

	// An optional Unix timestamp (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
	MetricTimestamp *string `locationName:"metricTimestamp" type:"string"`

	// The metric unit (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit)
	// supported by CloudWatch.
	//
	// MetricUnit is a required field
	MetricUnit *string `locationName:"metricUnit" type:"string" required:"true"`

	// The CloudWatch metric value.
	//
	// MetricValue is a required field
	MetricValue *string `locationName:"metricValue" type:"string" required:"true"`

	// The IAM role that allows access to the CloudWatch metric.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`
}

// String returns the string representation
func (s CloudwatchMetricAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CloudwatchMetricAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CloudwatchMetricAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CloudwatchMetricAction"}

	if s.MetricName == nil {
		invalidParams.Add(aws.NewErrParamRequired("MetricName"))
	}

	if s.MetricNamespace == nil {
		invalidParams.Add(aws.NewErrParamRequired("MetricNamespace"))
	}

	if s.MetricUnit == nil {
		invalidParams.Add(aws.NewErrParamRequired("MetricUnit"))
	}

	if s.MetricValue == nil {
		invalidParams.Add(aws.NewErrParamRequired("MetricValue"))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CloudwatchMetricAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.MetricName != nil {
		v := *s.MetricName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "metricName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MetricNamespace != nil {
		v := *s.MetricNamespace

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "metricNamespace", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MetricTimestamp != nil {
		v := *s.MetricTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "metricTimestamp", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MetricUnit != nil {
		v := *s.MetricUnit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "metricUnit", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MetricValue != nil {
		v := *s.MetricValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "metricValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes the method to use when code signing a file.
type CodeSigning struct {
	_ struct{} `type:"structure"`

	// The ID of the AWSSignerJob which was created to sign the file.
	AwsSignerJobId *string `locationName:"awsSignerJobId" type:"string"`

	// A custom method for code signing a file.
	CustomCodeSigning *CustomCodeSigning `locationName:"customCodeSigning" type:"structure"`
}

// String returns the string representation
func (s CodeSigning) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CodeSigning) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CodeSigning) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CodeSigning"}
	if s.CustomCodeSigning != nil {
		if err := s.CustomCodeSigning.Validate(); err != nil {
			invalidParams.AddNested("CustomCodeSigning", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CodeSigning) MarshalFields(e protocol.FieldEncoder) error {
	if s.AwsSignerJobId != nil {
		v := *s.AwsSignerJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsSignerJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CustomCodeSigning != nil {
		v := s.CustomCodeSigning

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "customCodeSigning", v, metadata)
	}
	return nil
}

// Describes the certificate chain being used when code signing a file.
type CodeSigningCertificateChain struct {
	_ struct{} `type:"structure"`

	// The name of the certificate.
	CertificateName *string `locationName:"certificateName" type:"string"`

	// A base64 encoded binary representation of the code signing certificate chain.
	InlineDocument *string `locationName:"inlineDocument" type:"string"`

	// A stream of the certificate chain files.
	Stream *Stream `locationName:"stream" type:"structure"`
}

// String returns the string representation
func (s CodeSigningCertificateChain) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CodeSigningCertificateChain) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CodeSigningCertificateChain) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CodeSigningCertificateChain"}
	if s.Stream != nil {
		if err := s.Stream.Validate(); err != nil {
			invalidParams.AddNested("Stream", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CodeSigningCertificateChain) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateName != nil {
		v := *s.CertificateName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InlineDocument != nil {
		v := *s.InlineDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "inlineDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Stream != nil {
		v := s.Stream

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "stream", v, metadata)
	}
	return nil
}

// Describes the signature for a file.
type CodeSigningSignature struct {
	_ struct{} `type:"structure"`

	// A base64 encoded binary representation of the code signing signature.
	//
	// InlineDocument is automatically base64 encoded/decoded by the SDK.
	InlineDocument []byte `locationName:"inlineDocument" type:"blob"`

	// A stream of the code signing signature.
	Stream *Stream `locationName:"stream" type:"structure"`
}

// String returns the string representation
func (s CodeSigningSignature) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CodeSigningSignature) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CodeSigningSignature) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CodeSigningSignature"}
	if s.Stream != nil {
		if err := s.Stream.Validate(); err != nil {
			invalidParams.AddNested("Stream", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CodeSigningSignature) MarshalFields(e protocol.FieldEncoder) error {
	if s.InlineDocument != nil {
		v := s.InlineDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "inlineDocument", protocol.QuotedValue{ValueMarshaler: protocol.BytesValue(v)}, metadata)
	}
	if s.Stream != nil {
		v := s.Stream

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "stream", v, metadata)
	}
	return nil
}

// Configuration.
type Configuration struct {
	_ struct{} `type:"structure"`

	// True to enable the configuration.
	Enabled *bool `type:"boolean"`
}

// String returns the string representation
func (s Configuration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Configuration) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Configuration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Enabled", protocol.BoolValue(v), metadata)
	}
	return nil
}

type CreateAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the authorizer's Lambda function.
	//
	// AuthorizerFunctionArn is a required field
	AuthorizerFunctionArn *string `locationName:"authorizerFunctionArn" type:"string" required:"true"`

	// The authorizer name.
	//
	// AuthorizerName is a required field
	AuthorizerName *string `location:"uri" locationName:"authorizerName" min:"1" type:"string" required:"true"`

	// The status of the create authorizer request.
	Status AuthorizerStatus `locationName:"status" type:"string" enum:"true"`

	// The name of the token key used to extract the token from the HTTP headers.
	//
	// TokenKeyName is a required field
	TokenKeyName *string `locationName:"tokenKeyName" min:"1" type:"string" required:"true"`

	// The public keys used to verify the digital signature returned by your custom
	// authentication service.
	//
	// TokenSigningPublicKeys is a required field
	TokenSigningPublicKeys map[string]string `locationName:"tokenSigningPublicKeys" type:"map" required:"true"`
}

// String returns the string representation
func (s CreateAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateAuthorizerInput"}

	if s.AuthorizerFunctionArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerFunctionArn"))
	}

	if s.AuthorizerName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerName"))
	}
	if s.AuthorizerName != nil && len(*s.AuthorizerName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthorizerName", 1))
	}

	if s.TokenKeyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TokenKeyName"))
	}
	if s.TokenKeyName != nil && len(*s.TokenKeyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TokenKeyName", 1))
	}

	if s.TokenSigningPublicKeys == nil {
		invalidParams.Add(aws.NewErrParamRequired("TokenSigningPublicKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AuthorizerFunctionArn != nil {
		v := *s.AuthorizerFunctionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerFunctionArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.TokenKeyName != nil {
		v := *s.TokenKeyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tokenKeyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TokenSigningPublicKeys) > 0 {
		v := s.TokenSigningPublicKeys

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tokenSigningPublicKeys", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The authorizer ARN.
	AuthorizerArn *string `locationName:"authorizerArn" type:"string"`

	// The authorizer's name.
	AuthorizerName *string `locationName:"authorizerName" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthorizerArn != nil {
		v := *s.AuthorizerArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the CreateCertificateFromCsr operation.
type CreateCertificateFromCsrInput struct {
	_ struct{} `type:"structure"`

	// The certificate signing request (CSR).
	//
	// CertificateSigningRequest is a required field
	CertificateSigningRequest *string `locationName:"certificateSigningRequest" min:"1" type:"string" required:"true"`

	// Specifies whether the certificate is active.
	SetAsActive *bool `location:"querystring" locationName:"setAsActive" type:"boolean"`
}

// String returns the string representation
func (s CreateCertificateFromCsrInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCertificateFromCsrInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateCertificateFromCsrInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateCertificateFromCsrInput"}

	if s.CertificateSigningRequest == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateSigningRequest"))
	}
	if s.CertificateSigningRequest != nil && len(*s.CertificateSigningRequest) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateSigningRequest", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateCertificateFromCsrInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateSigningRequest != nil {
		v := *s.CertificateSigningRequest

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateSigningRequest", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SetAsActive != nil {
		v := *s.SetAsActive

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "setAsActive", protocol.BoolValue(v), metadata)
	}
	return nil
}

// The output from the CreateCertificateFromCsr operation.
type CreateCertificateFromCsrOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) of the certificate. You can use the ARN as
	// a principal for policy operations.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The ID of the certificate. Certificate management operations only take a
	// certificateId.
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`

	// The certificate data, in PEM format.
	CertificatePem *string `locationName:"certificatePem" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateCertificateFromCsrOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCertificateFromCsrOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateCertificateFromCsrOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateCertificateFromCsrOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificatePem != nil {
		v := *s.CertificatePem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificatePem", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateJobInput struct {
	_ struct{} `type:"structure"`

	// A short text description of the job.
	Description *string `locationName:"description" type:"string"`

	// The job document.
	Document *string `locationName:"document" type:"string"`

	// Parameters for the job document.
	DocumentParameters map[string]string `locationName:"documentParameters" type:"map"`

	// An S3 link to the job document.
	DocumentSource *string `locationName:"documentSource" min:"1" type:"string"`

	// Allows you to create a staged rollout of the job.
	JobExecutionsRolloutConfig *JobExecutionsRolloutConfig `locationName:"jobExecutionsRolloutConfig" type:"structure"`

	// A job identifier which must be unique for your AWS account. We recommend
	// using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`

	// Configuration information for pre-signed S3 URLs.
	PresignedUrlConfig *PresignedUrlConfig `locationName:"presignedUrlConfig" type:"structure"`

	// Specifies whether the job will continue to run (CONTINUOUS), or will be complete
	// after all those things specified as targets have completed the job (SNAPSHOT).
	// If continuous, the job may also be run on a thing when a change is detected
	// in a target. For example, a job will run on a thing when the thing is added
	// to a target group, even after the job was completed by all things originally
	// in the group.
	TargetSelection TargetSelection `locationName:"targetSelection" type:"string" enum:"true"`

	// A list of things and thing groups to which the job should be sent.
	//
	// Targets is a required field
	Targets []string `locationName:"targets" min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s CreateJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateJobInput"}
	if s.DocumentSource != nil && len(*s.DocumentSource) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DocumentSource", 1))
	}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if s.Targets == nil {
		invalidParams.Add(aws.NewErrParamRequired("Targets"))
	}
	if s.Targets != nil && len(s.Targets) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Targets", 1))
	}
	if s.JobExecutionsRolloutConfig != nil {
		if err := s.JobExecutionsRolloutConfig.Validate(); err != nil {
			invalidParams.AddNested("JobExecutionsRolloutConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.PresignedUrlConfig != nil {
		if err := s.PresignedUrlConfig.Validate(); err != nil {
			invalidParams.AddNested("PresignedUrlConfig", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateJobInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Document != nil {
		v := *s.Document

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "document", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.DocumentParameters) > 0 {
		v := s.DocumentParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "documentParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.DocumentSource != nil {
		v := *s.DocumentSource

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "documentSource", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobExecutionsRolloutConfig != nil {
		v := s.JobExecutionsRolloutConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "jobExecutionsRolloutConfig", v, metadata)
	}
	if s.PresignedUrlConfig != nil {
		v := s.PresignedUrlConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "presignedUrlConfig", v, metadata)
	}
	if len(s.TargetSelection) > 0 {
		v := s.TargetSelection

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "targetSelection", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Targets) > 0 {
		v := s.Targets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "targets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The job description.
	Description *string `locationName:"description" type:"string"`

	// The job ARN.
	JobArn *string `locationName:"jobArn" type:"string"`

	// The unique identifier you assigned to this job.
	JobId *string `locationName:"jobId" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobArn != nil {
		v := *s.JobArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the CreateKeysAndCertificate operation.
type CreateKeysAndCertificateInput struct {
	_ struct{} `type:"structure"`

	// Specifies whether the certificate is active.
	SetAsActive *bool `location:"querystring" locationName:"setAsActive" type:"boolean"`
}

// String returns the string representation
func (s CreateKeysAndCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateKeysAndCertificateInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateKeysAndCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.SetAsActive != nil {
		v := *s.SetAsActive

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "setAsActive", protocol.BoolValue(v), metadata)
	}
	return nil
}

// The output of the CreateKeysAndCertificate operation.
type CreateKeysAndCertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the certificate.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The ID of the certificate. AWS IoT issues a default subject name for the
	// certificate (for example, AWS IoT Certificate).
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`

	// The certificate data, in PEM format.
	CertificatePem *string `locationName:"certificatePem" min:"1" type:"string"`

	// The generated key pair.
	KeyPair *KeyPair `locationName:"keyPair" type:"structure"`
}

// String returns the string representation
func (s CreateKeysAndCertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateKeysAndCertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateKeysAndCertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateKeysAndCertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificatePem != nil {
		v := *s.CertificatePem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificatePem", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KeyPair != nil {
		v := s.KeyPair

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "keyPair", v, metadata)
	}
	return nil
}

type CreateOTAUpdateInput struct {
	_ struct{} `type:"structure"`

	// A list of additional OTA update parameters which are name-value pairs.
	AdditionalParameters map[string]string `locationName:"additionalParameters" type:"map"`

	// The description of the OTA update.
	Description *string `locationName:"description" type:"string"`

	// The files to be streamed by the OTA update.
	//
	// Files is a required field
	Files []OTAUpdateFile `locationName:"files" min:"1" type:"list" required:"true"`

	// The ID of the OTA update to be created.
	//
	// OtaUpdateId is a required field
	OtaUpdateId *string `location:"uri" locationName:"otaUpdateId" min:"1" type:"string" required:"true"`

	// The IAM role that allows access to the AWS IoT Jobs service.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" min:"20" type:"string" required:"true"`

	// Specifies whether the update will continue to run (CONTINUOUS), or will be
	// complete after all the things specified as targets have completed the update
	// (SNAPSHOT). If continuous, the update may also be run on a thing when a change
	// is detected in a target. For example, an update will run on a thing when
	// the thing is added to a target group, even after the update was completed
	// by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.
	TargetSelection TargetSelection `locationName:"targetSelection" type:"string" enum:"true"`

	// The targeted devices to receive OTA updates.
	//
	// Targets is a required field
	Targets []string `locationName:"targets" min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s CreateOTAUpdateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateOTAUpdateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateOTAUpdateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateOTAUpdateInput"}

	if s.Files == nil {
		invalidParams.Add(aws.NewErrParamRequired("Files"))
	}
	if s.Files != nil && len(s.Files) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Files", 1))
	}

	if s.OtaUpdateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("OtaUpdateId"))
	}
	if s.OtaUpdateId != nil && len(*s.OtaUpdateId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OtaUpdateId", 1))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}

	if s.Targets == nil {
		invalidParams.Add(aws.NewErrParamRequired("Targets"))
	}
	if s.Targets != nil && len(s.Targets) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Targets", 1))
	}
	if s.Files != nil {
		for i, v := range s.Files {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Files", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateOTAUpdateInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.AdditionalParameters) > 0 {
		v := s.AdditionalParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "additionalParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Files) > 0 {
		v := s.Files

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "files", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TargetSelection) > 0 {
		v := s.TargetSelection

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "targetSelection", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Targets) > 0 {
		v := s.Targets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "targets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.OtaUpdateId != nil {
		v := *s.OtaUpdateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "otaUpdateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateOTAUpdateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The AWS IoT job ARN associated with the OTA update.
	AwsIotJobArn *string `locationName:"awsIotJobArn" type:"string"`

	// The AWS IoT job ID associated with the OTA update.
	AwsIotJobId *string `locationName:"awsIotJobId" type:"string"`

	// The OTA update ARN.
	OtaUpdateArn *string `locationName:"otaUpdateArn" type:"string"`

	// The OTA update ID.
	OtaUpdateId *string `locationName:"otaUpdateId" min:"1" type:"string"`

	// The OTA update status.
	OtaUpdateStatus OTAUpdateStatus `locationName:"otaUpdateStatus" type:"string" enum:"true"`
}

// String returns the string representation
func (s CreateOTAUpdateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateOTAUpdateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateOTAUpdateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateOTAUpdateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AwsIotJobArn != nil {
		v := *s.AwsIotJobArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsIotJobArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AwsIotJobId != nil {
		v := *s.AwsIotJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsIotJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OtaUpdateArn != nil {
		v := *s.OtaUpdateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "otaUpdateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OtaUpdateId != nil {
		v := *s.OtaUpdateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "otaUpdateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OtaUpdateStatus) > 0 {
		v := s.OtaUpdateStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "otaUpdateStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The input for the CreatePolicy operation.
type CreatePolicyInput struct {
	_ struct{} `type:"structure"`

	// The JSON document that describes the policy. policyDocument must have a minimum
	// length of 1, with a maximum length of 2048, excluding whitespace.
	//
	// PolicyDocument is a required field
	PolicyDocument *string `locationName:"policyDocument" type:"string" required:"true"`

	// The policy name.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreatePolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreatePolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreatePolicyInput"}

	if s.PolicyDocument == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyDocument"))
	}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreatePolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyDocument != nil {
		v := *s.PolicyDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the CreatePolicy operation.
type CreatePolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The policy ARN.
	PolicyArn *string `locationName:"policyArn" type:"string"`

	// The JSON document that describes the policy.
	PolicyDocument *string `locationName:"policyDocument" type:"string"`

	// The policy name.
	PolicyName *string `locationName:"policyName" min:"1" type:"string"`

	// The policy version ID.
	PolicyVersionId *string `locationName:"policyVersionId" type:"string"`
}

// String returns the string representation
func (s CreatePolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreatePolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreatePolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.PolicyArn != nil {
		v := *s.PolicyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyDocument != nil {
		v := *s.PolicyDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyVersionId != nil {
		v := *s.PolicyVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyVersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the CreatePolicyVersion operation.
type CreatePolicyVersionInput struct {
	_ struct{} `type:"structure"`

	// The JSON document that describes the policy. Minimum length of 1. Maximum
	// length of 2048, excluding whitespace.
	//
	// PolicyDocument is a required field
	PolicyDocument *string `locationName:"policyDocument" type:"string" required:"true"`

	// The policy name.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`

	// Specifies whether the policy version is set as the default. When this parameter
	// is true, the new policy version becomes the operative version (that is, the
	// version that is in effect for the certificates to which the policy is attached).
	SetAsDefault *bool `location:"querystring" locationName:"setAsDefault" type:"boolean"`
}

// String returns the string representation
func (s CreatePolicyVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePolicyVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreatePolicyVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreatePolicyVersionInput"}

	if s.PolicyDocument == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyDocument"))
	}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreatePolicyVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyDocument != nil {
		v := *s.PolicyDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SetAsDefault != nil {
		v := *s.SetAsDefault

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "setAsDefault", protocol.BoolValue(v), metadata)
	}
	return nil
}

// The output of the CreatePolicyVersion operation.
type CreatePolicyVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Specifies whether the policy version is the default.
	IsDefaultVersion *bool `locationName:"isDefaultVersion" type:"boolean"`

	// The policy ARN.
	PolicyArn *string `locationName:"policyArn" type:"string"`

	// The JSON document that describes the policy.
	PolicyDocument *string `locationName:"policyDocument" type:"string"`

	// The policy version ID.
	PolicyVersionId *string `locationName:"policyVersionId" type:"string"`
}

// String returns the string representation
func (s CreatePolicyVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePolicyVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreatePolicyVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreatePolicyVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.IsDefaultVersion != nil {
		v := *s.IsDefaultVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "isDefaultVersion", protocol.BoolValue(v), metadata)
	}
	if s.PolicyArn != nil {
		v := *s.PolicyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyDocument != nil {
		v := *s.PolicyDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyVersionId != nil {
		v := *s.PolicyVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyVersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateRoleAliasInput struct {
	_ struct{} `type:"structure"`

	// How long (in seconds) the credentials will be valid.
	CredentialDurationSeconds *int64 `locationName:"credentialDurationSeconds" min:"900" type:"integer"`

	// The role alias that points to a role ARN. This allows you to change the role
	// without having to update the device.
	//
	// RoleAlias is a required field
	RoleAlias *string `location:"uri" locationName:"roleAlias" min:"1" type:"string" required:"true"`

	// The role ARN.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" min:"20" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateRoleAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateRoleAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateRoleAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateRoleAliasInput"}
	if s.CredentialDurationSeconds != nil && *s.CredentialDurationSeconds < 900 {
		invalidParams.Add(aws.NewErrParamMinValue("CredentialDurationSeconds", 900))
	}

	if s.RoleAlias == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleAlias"))
	}
	if s.RoleAlias != nil && len(*s.RoleAlias) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleAlias", 1))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateRoleAliasInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CredentialDurationSeconds != nil {
		v := *s.CredentialDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "credentialDurationSeconds", protocol.Int64Value(v), metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleAlias != nil {
		v := *s.RoleAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "roleAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateRoleAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The role alias.
	RoleAlias *string `locationName:"roleAlias" min:"1" type:"string"`

	// The role alias ARN.
	RoleAliasArn *string `locationName:"roleAliasArn" type:"string"`
}

// String returns the string representation
func (s CreateRoleAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateRoleAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateRoleAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateRoleAliasOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.RoleAlias != nil {
		v := *s.RoleAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleAliasArn != nil {
		v := *s.RoleAliasArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleAliasArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateStreamInput struct {
	_ struct{} `type:"structure"`

	// A description of the stream.
	Description *string `locationName:"description" type:"string"`

	// The files to stream.
	//
	// Files is a required field
	Files []StreamFile `locationName:"files" min:"1" type:"list" required:"true"`

	// An IAM role that allows the IoT service principal assumes to access your
	// S3 files.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" min:"20" type:"string" required:"true"`

	// The stream ID.
	//
	// StreamId is a required field
	StreamId *string `location:"uri" locationName:"streamId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateStreamInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateStreamInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateStreamInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateStreamInput"}

	if s.Files == nil {
		invalidParams.Add(aws.NewErrParamRequired("Files"))
	}
	if s.Files != nil && len(s.Files) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Files", 1))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}

	if s.StreamId == nil {
		invalidParams.Add(aws.NewErrParamRequired("StreamId"))
	}
	if s.StreamId != nil && len(*s.StreamId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StreamId", 1))
	}
	if s.Files != nil {
		for i, v := range s.Files {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Files", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateStreamInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Files) > 0 {
		v := s.Files

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "files", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateStreamOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A description of the stream.
	Description *string `locationName:"description" type:"string"`

	// The stream ARN.
	StreamArn *string `locationName:"streamArn" type:"string"`

	// The stream ID.
	StreamId *string `locationName:"streamId" min:"1" type:"string"`

	// The version of the stream.
	StreamVersion *int64 `locationName:"streamVersion" type:"integer"`
}

// String returns the string representation
func (s CreateStreamOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateStreamOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateStreamOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateStreamOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamArn != nil {
		v := *s.StreamArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamVersion != nil {
		v := *s.StreamVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamVersion", protocol.Int64Value(v), metadata)
	}
	return nil
}

type CreateThingGroupInput struct {
	_ struct{} `type:"structure"`

	// The name of the parent thing group.
	ParentGroupName *string `locationName:"parentGroupName" min:"1" type:"string"`

	// The thing group name to create.
	//
	// ThingGroupName is a required field
	ThingGroupName *string `location:"uri" locationName:"thingGroupName" min:"1" type:"string" required:"true"`

	// The thing group properties.
	ThingGroupProperties *ThingGroupProperties `locationName:"thingGroupProperties" type:"structure"`
}

// String returns the string representation
func (s CreateThingGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateThingGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateThingGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateThingGroupInput"}
	if s.ParentGroupName != nil && len(*s.ParentGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ParentGroupName", 1))
	}

	if s.ThingGroupName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingGroupName"))
	}
	if s.ThingGroupName != nil && len(*s.ThingGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateThingGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ParentGroupName != nil {
		v := *s.ParentGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "parentGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupProperties != nil {
		v := s.ThingGroupProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingGroupProperties", v, metadata)
	}
	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type CreateThingGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The thing group ARN.
	ThingGroupArn *string `locationName:"thingGroupArn" type:"string"`

	// The thing group ID.
	ThingGroupId *string `locationName:"thingGroupId" min:"1" type:"string"`

	// The thing group name.
	ThingGroupName *string `locationName:"thingGroupName" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateThingGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateThingGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateThingGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateThingGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ThingGroupArn != nil {
		v := *s.ThingGroupArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupId != nil {
		v := *s.ThingGroupId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the CreateThing operation.
type CreateThingInput struct {
	_ struct{} `type:"structure"`

	// The attribute payload, which consists of up to three name/value pairs in
	// a JSON document. For example:
	//
	// {\"attributes\":{\"string1\":\"string2\"}}
	AttributePayload *AttributePayload `locationName:"attributePayload" type:"structure"`

	// The name of the thing to create.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`

	// The name of the thing type associated with the new thing.
	ThingTypeName *string `locationName:"thingTypeName" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateThingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateThingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateThingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateThingInput"}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}
	if s.ThingTypeName != nil && len(*s.ThingTypeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingTypeName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateThingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AttributePayload != nil {
		v := s.AttributePayload

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "attributePayload", v, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output of the CreateThing operation.
type CreateThingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the new thing.
	ThingArn *string `locationName:"thingArn" type:"string"`

	// The thing ID.
	ThingId *string `locationName:"thingId" type:"string"`

	// The name of the new thing.
	ThingName *string `locationName:"thingName" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateThingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateThingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateThingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateThingOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ThingArn != nil {
		v := *s.ThingArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingId != nil {
		v := *s.ThingId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the CreateThingType operation.
type CreateThingTypeInput struct {
	_ struct{} `type:"structure"`

	// The name of the thing type.
	//
	// ThingTypeName is a required field
	ThingTypeName *string `location:"uri" locationName:"thingTypeName" min:"1" type:"string" required:"true"`

	// The ThingTypeProperties for the thing type to create. It contains information
	// about the new thing type including a description, and a list of searchable
	// thing attribute names.
	ThingTypeProperties *ThingTypeProperties `locationName:"thingTypeProperties" type:"structure"`
}

// String returns the string representation
func (s CreateThingTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateThingTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateThingTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateThingTypeInput"}

	if s.ThingTypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingTypeName"))
	}
	if s.ThingTypeName != nil && len(*s.ThingTypeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingTypeName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateThingTypeInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingTypeProperties != nil {
		v := s.ThingTypeProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingTypeProperties", v, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output of the CreateThingType operation.
type CreateThingTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) of the thing type.
	ThingTypeArn *string `locationName:"thingTypeArn" type:"string"`

	// The thing type ID.
	ThingTypeId *string `locationName:"thingTypeId" type:"string"`

	// The name of the thing type.
	ThingTypeName *string `locationName:"thingTypeName" min:"1" type:"string"`
}

// String returns the string representation
func (s CreateThingTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateThingTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateThingTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateThingTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ThingTypeArn != nil {
		v := *s.ThingTypeArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeId != nil {
		v := *s.ThingTypeId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the CreateTopicRule operation.
type CreateTopicRuleInput struct {
	_ struct{} `type:"structure" payload:"TopicRulePayload"`

	// The name of the rule.
	//
	// RuleName is a required field
	RuleName *string `location:"uri" locationName:"ruleName" min:"1" type:"string" required:"true"`

	// The rule payload.
	//
	// TopicRulePayload is a required field
	TopicRulePayload *TopicRulePayload `locationName:"topicRulePayload" type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateTopicRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTopicRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTopicRuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTopicRuleInput"}

	if s.RuleName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleName"))
	}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if s.TopicRulePayload == nil {
		invalidParams.Add(aws.NewErrParamRequired("TopicRulePayload"))
	}
	if s.TopicRulePayload != nil {
		if err := s.TopicRulePayload.Validate(); err != nil {
			invalidParams.AddNested("TopicRulePayload", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTopicRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ruleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TopicRulePayload != nil {
		v := s.TopicRulePayload

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "topicRulePayload", v, metadata)
	}
	return nil
}

type CreateTopicRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateTopicRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTopicRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTopicRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTopicRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes a custom method used to code sign a file.
type CustomCodeSigning struct {
	_ struct{} `type:"structure"`

	// The certificate chain.
	CertificateChain *CodeSigningCertificateChain `locationName:"certificateChain" type:"structure"`

	// The hash algorithm used to code sign the file.
	HashAlgorithm *string `locationName:"hashAlgorithm" type:"string"`

	// The signature for the file.
	Signature *CodeSigningSignature `locationName:"signature" type:"structure"`

	// The signature algorithm used to code sign the file.
	SignatureAlgorithm *string `locationName:"signatureAlgorithm" type:"string"`
}

// String returns the string representation
func (s CustomCodeSigning) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CustomCodeSigning) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CustomCodeSigning) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CustomCodeSigning"}
	if s.CertificateChain != nil {
		if err := s.CertificateChain.Validate(); err != nil {
			invalidParams.AddNested("CertificateChain", err.(aws.ErrInvalidParams))
		}
	}
	if s.Signature != nil {
		if err := s.Signature.Validate(); err != nil {
			invalidParams.AddNested("Signature", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CustomCodeSigning) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateChain != nil {
		v := s.CertificateChain

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "certificateChain", v, metadata)
	}
	if s.HashAlgorithm != nil {
		v := *s.HashAlgorithm

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hashAlgorithm", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Signature != nil {
		v := s.Signature

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signature", v, metadata)
	}
	if s.SignatureAlgorithm != nil {
		v := *s.SignatureAlgorithm

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "signatureAlgorithm", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// The name of the authorizer to delete.
	//
	// AuthorizerName is a required field
	AuthorizerName *string `location:"uri" locationName:"authorizerName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteAuthorizerInput"}

	if s.AuthorizerName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerName"))
	}
	if s.AuthorizerName != nil && len(*s.AuthorizerName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthorizerName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Input for the DeleteCACertificate operation.
type DeleteCACertificateInput struct {
	_ struct{} `type:"structure"`

	// The ID of the certificate to delete. (The last part of the certificate ARN
	// contains the certificate ID.)
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"caCertificateId" min:"64" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteCACertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCACertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteCACertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteCACertificateInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteCACertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "caCertificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output for the DeleteCACertificate operation.
type DeleteCACertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteCACertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCACertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteCACertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteCACertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DeleteCertificate operation.
type DeleteCertificateInput struct {
	_ struct{} `type:"structure"`

	// The ID of the certificate. (The last part of the certificate ARN contains
	// the certificate ID.)
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"certificateId" min:"64" type:"string" required:"true"`

	// Forces a certificate request to be deleted.
	ForceDelete *bool `location:"querystring" locationName:"forceDelete" type:"boolean"`
}

// String returns the string representation
func (s DeleteCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteCertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteCertificateInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ForceDelete != nil {
		v := *s.ForceDelete

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "forceDelete", protocol.BoolValue(v), metadata)
	}
	return nil
}

type DeleteCertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteCertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteCertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteCertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteJobExecutionInput struct {
	_ struct{} `type:"structure"`

	// The ID of the job execution to be deleted. The executionNumber refers to
	// the execution of a particular job on a particular device.
	//
	// Note that once a job execution is deleted, the executionNumber may be reused
	// by IoT, so be sure you get and use the correct value here.
	//
	// ExecutionNumber is a required field
	ExecutionNumber *int64 `location:"uri" locationName:"executionNumber" type:"long" required:"true"`

	// (Optional) When true, you can delete a job execution which is "IN_PROGRESS".
	// Otherwise, you can only delete a job execution which is in a terminal state
	// ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception
	// will occur. The default is false.
	//
	// Deleting a job execution which is "IN_PROGRESS", will cause the device to
	// be unable to access job information or update the job execution status. Use
	// caution and ensure that the device is able to recover to a valid state.
	Force *bool `location:"querystring" locationName:"force" type:"boolean"`

	// The ID of the job whose execution on a particular device will be deleted.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`

	// The name of the thing whose job execution will be deleted.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteJobExecutionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteJobExecutionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteJobExecutionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteJobExecutionInput"}

	if s.ExecutionNumber == nil {
		invalidParams.Add(aws.NewErrParamRequired("ExecutionNumber"))
	}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteJobExecutionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ExecutionNumber != nil {
		v := *s.ExecutionNumber

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "executionNumber", protocol.Int64Value(v), metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Force != nil {
		v := *s.Force

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "force", protocol.BoolValue(v), metadata)
	}
	return nil
}

type DeleteJobExecutionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteJobExecutionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteJobExecutionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteJobExecutionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteJobExecutionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteJobInput struct {
	_ struct{} `type:"structure"`

	// (Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise,
	// you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED")
	// or an exception will occur. The default is false.
	//
	// Deleting a job which is "IN_PROGRESS", will cause a device which is executing
	// the job to be unable to access job information or update the job execution
	// status. Use caution and ensure that each device executing a job which is
	// deleted is able to recover to a valid state.
	Force *bool `location:"querystring" locationName:"force" type:"boolean"`

	// The ID of the job to be deleted.
	//
	// After a job deletion is completed, you may reuse this jobId when you create
	// a new job. However, this is not recommended, and you must ensure that your
	// devices are not using the jobId to refer to the deleted job.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteJobInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteJobInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Force != nil {
		v := *s.Force

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "force", protocol.BoolValue(v), metadata)
	}
	return nil
}

type DeleteJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteOTAUpdateInput struct {
	_ struct{} `type:"structure"`

	// The OTA update ID to delete.
	//
	// OtaUpdateId is a required field
	OtaUpdateId *string `location:"uri" locationName:"otaUpdateId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteOTAUpdateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteOTAUpdateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteOTAUpdateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteOTAUpdateInput"}

	if s.OtaUpdateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("OtaUpdateId"))
	}
	if s.OtaUpdateId != nil && len(*s.OtaUpdateId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OtaUpdateId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteOTAUpdateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.OtaUpdateId != nil {
		v := *s.OtaUpdateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "otaUpdateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteOTAUpdateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteOTAUpdateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteOTAUpdateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteOTAUpdateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteOTAUpdateOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DeletePolicy operation.
type DeletePolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of the policy to delete.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeletePolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeletePolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeletePolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeletePolicyInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeletePolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeletePolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeletePolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeletePolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeletePolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeletePolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DeletePolicyVersion operation.
type DeletePolicyVersionInput struct {
	_ struct{} `type:"structure"`

	// The name of the policy.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`

	// The policy version ID.
	//
	// PolicyVersionId is a required field
	PolicyVersionId *string `location:"uri" locationName:"policyVersionId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeletePolicyVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeletePolicyVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeletePolicyVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeletePolicyVersionInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if s.PolicyVersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyVersionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeletePolicyVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyVersionId != nil {
		v := *s.PolicyVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyVersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeletePolicyVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeletePolicyVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeletePolicyVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeletePolicyVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeletePolicyVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DeleteRegistrationCode operation.
type DeleteRegistrationCodeInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DeleteRegistrationCodeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRegistrationCodeInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRegistrationCodeInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// The output for the DeleteRegistrationCode operation.
type DeleteRegistrationCodeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteRegistrationCodeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRegistrationCodeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteRegistrationCodeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRegistrationCodeOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteRoleAliasInput struct {
	_ struct{} `type:"structure"`

	// The role alias to delete.
	//
	// RoleAlias is a required field
	RoleAlias *string `location:"uri" locationName:"roleAlias" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteRoleAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRoleAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteRoleAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteRoleAliasInput"}

	if s.RoleAlias == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleAlias"))
	}
	if s.RoleAlias != nil && len(*s.RoleAlias) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleAlias", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRoleAliasInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RoleAlias != nil {
		v := *s.RoleAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "roleAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteRoleAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteRoleAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRoleAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteRoleAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRoleAliasOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteStreamInput struct {
	_ struct{} `type:"structure"`

	// The stream ID.
	//
	// StreamId is a required field
	StreamId *string `location:"uri" locationName:"streamId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteStreamInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteStreamInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteStreamInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteStreamInput"}

	if s.StreamId == nil {
		invalidParams.Add(aws.NewErrParamRequired("StreamId"))
	}
	if s.StreamId != nil && len(*s.StreamId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StreamId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteStreamInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteStreamOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteStreamOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteStreamOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteStreamOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteStreamOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteThingGroupInput struct {
	_ struct{} `type:"structure"`

	// The expected version of the thing group to delete.
	ExpectedVersion *int64 `location:"querystring" locationName:"expectedVersion" type:"long"`

	// The name of the thing group to delete.
	//
	// ThingGroupName is a required field
	ThingGroupName *string `location:"uri" locationName:"thingGroupName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteThingGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteThingGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteThingGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteThingGroupInput"}

	if s.ThingGroupName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingGroupName"))
	}
	if s.ThingGroupName != nil && len(*s.ThingGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteThingGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ExpectedVersion != nil {
		v := *s.ExpectedVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "expectedVersion", protocol.Int64Value(v), metadata)
	}
	return nil
}

type DeleteThingGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteThingGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteThingGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteThingGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteThingGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DeleteThing operation.
type DeleteThingInput struct {
	_ struct{} `type:"structure"`

	// The expected version of the thing record in the registry. If the version
	// of the record in the registry does not match the expected version specified
	// in the request, the DeleteThing request is rejected with a VersionConflictException.
	ExpectedVersion *int64 `location:"querystring" locationName:"expectedVersion" type:"long"`

	// The name of the thing to delete.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteThingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteThingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteThingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteThingInput"}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteThingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ExpectedVersion != nil {
		v := *s.ExpectedVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "expectedVersion", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The output of the DeleteThing operation.
type DeleteThingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteThingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteThingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteThingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteThingOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DeleteThingType operation.
type DeleteThingTypeInput struct {
	_ struct{} `type:"structure"`

	// The name of the thing type.
	//
	// ThingTypeName is a required field
	ThingTypeName *string `location:"uri" locationName:"thingTypeName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteThingTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteThingTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteThingTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteThingTypeInput"}

	if s.ThingTypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingTypeName"))
	}
	if s.ThingTypeName != nil && len(*s.ThingTypeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingTypeName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteThingTypeInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output for the DeleteThingType operation.
type DeleteThingTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteThingTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteThingTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteThingTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteThingTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DeleteTopicRule operation.
type DeleteTopicRuleInput struct {
	_ struct{} `type:"structure"`

	// The name of the rule.
	//
	// RuleName is a required field
	RuleName *string `location:"uri" locationName:"ruleName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteTopicRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTopicRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTopicRuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTopicRuleInput"}

	if s.RuleName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleName"))
	}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTopicRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ruleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteTopicRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteTopicRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTopicRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTopicRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTopicRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteV2LoggingLevelInput struct {
	_ struct{} `type:"structure"`

	// The name of the resource for which you are configuring logging.
	//
	// TargetName is a required field
	TargetName *string `location:"querystring" locationName:"targetName" type:"string" required:"true"`

	// The type of resource for which you are configuring logging. Must be THING_Group.
	//
	// TargetType is a required field
	TargetType LogTargetType `location:"querystring" locationName:"targetType" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s DeleteV2LoggingLevelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteV2LoggingLevelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteV2LoggingLevelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteV2LoggingLevelInput"}

	if s.TargetName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetName"))
	}
	if len(s.TargetType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("TargetType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteV2LoggingLevelInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.TargetName != nil {
		v := *s.TargetName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "targetName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TargetType) > 0 {
		v := s.TargetType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "targetType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type DeleteV2LoggingLevelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteV2LoggingLevelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteV2LoggingLevelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteV2LoggingLevelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteV2LoggingLevelOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Contains information that denied the authorization.
type Denied struct {
	_ struct{} `type:"structure"`

	// Information that explicitly denies the authorization.
	ExplicitDeny *ExplicitDeny `locationName:"explicitDeny" type:"structure"`

	// Information that implicitly denies the authorization. When a policy doesn't
	// explicitly deny or allow an action on a resource it is considered an implicit
	// deny.
	ImplicitDeny *ImplicitDeny `locationName:"implicitDeny" type:"structure"`
}

// String returns the string representation
func (s Denied) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Denied) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Denied) MarshalFields(e protocol.FieldEncoder) error {
	if s.ExplicitDeny != nil {
		v := s.ExplicitDeny

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "explicitDeny", v, metadata)
	}
	if s.ImplicitDeny != nil {
		v := s.ImplicitDeny

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "implicitDeny", v, metadata)
	}
	return nil
}

// The input for the DeprecateThingType operation.
type DeprecateThingTypeInput struct {
	_ struct{} `type:"structure"`

	// The name of the thing type to deprecate.
	//
	// ThingTypeName is a required field
	ThingTypeName *string `location:"uri" locationName:"thingTypeName" min:"1" type:"string" required:"true"`

	// Whether to undeprecate a deprecated thing type. If true, the thing type will
	// not be deprecated anymore and you can associate it with things.
	UndoDeprecate *bool `locationName:"undoDeprecate" type:"boolean"`
}

// String returns the string representation
func (s DeprecateThingTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeprecateThingTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeprecateThingTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeprecateThingTypeInput"}

	if s.ThingTypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingTypeName"))
	}
	if s.ThingTypeName != nil && len(*s.ThingTypeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingTypeName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeprecateThingTypeInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.UndoDeprecate != nil {
		v := *s.UndoDeprecate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "undoDeprecate", protocol.BoolValue(v), metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output for the DeprecateThingType operation.
type DeprecateThingTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeprecateThingTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeprecateThingTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeprecateThingTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeprecateThingTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DescribeAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// The name of the authorizer to describe.
	//
	// AuthorizerName is a required field
	AuthorizerName *string `location:"uri" locationName:"authorizerName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeAuthorizerInput"}

	if s.AuthorizerName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerName"))
	}
	if s.AuthorizerName != nil && len(*s.AuthorizerName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthorizerName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The authorizer description.
	AuthorizerDescription *AuthorizerDescription `locationName:"authorizerDescription" type:"structure"`
}

// String returns the string representation
func (s DescribeAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthorizerDescription != nil {
		v := s.AuthorizerDescription

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "authorizerDescription", v, metadata)
	}
	return nil
}

// The input for the DescribeCACertificate operation.
type DescribeCACertificateInput struct {
	_ struct{} `type:"structure"`

	// The CA certificate identifier.
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"caCertificateId" min:"64" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeCACertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeCACertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeCACertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeCACertificateInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeCACertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "caCertificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the DescribeCACertificate operation.
type DescribeCACertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The CA certificate description.
	CertificateDescription *CACertificateDescription `locationName:"certificateDescription" type:"structure"`

	// Information about the registration configuration.
	RegistrationConfig *RegistrationConfig `locationName:"registrationConfig" type:"structure"`
}

// String returns the string representation
func (s DescribeCACertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeCACertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeCACertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeCACertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateDescription != nil {
		v := s.CertificateDescription

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "certificateDescription", v, metadata)
	}
	if s.RegistrationConfig != nil {
		v := s.RegistrationConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "registrationConfig", v, metadata)
	}
	return nil
}

// The input for the DescribeCertificate operation.
type DescribeCertificateInput struct {
	_ struct{} `type:"structure"`

	// The ID of the certificate. (The last part of the certificate ARN contains
	// the certificate ID.)
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"certificateId" min:"64" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeCertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeCertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeCertificateInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output of the DescribeCertificate operation.
type DescribeCertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The description of the certificate.
	CertificateDescription *CertificateDescription `locationName:"certificateDescription" type:"structure"`
}

// String returns the string representation
func (s DescribeCertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeCertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeCertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeCertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateDescription != nil {
		v := s.CertificateDescription

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "certificateDescription", v, metadata)
	}
	return nil
}

type DescribeDefaultAuthorizerInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DescribeDefaultAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeDefaultAuthorizerInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeDefaultAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

type DescribeDefaultAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The default authorizer's description.
	AuthorizerDescription *AuthorizerDescription `locationName:"authorizerDescription" type:"structure"`
}

// String returns the string representation
func (s DescribeDefaultAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeDefaultAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeDefaultAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeDefaultAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthorizerDescription != nil {
		v := s.AuthorizerDescription

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "authorizerDescription", v, metadata)
	}
	return nil
}

// The input for the DescribeEndpoint operation.
type DescribeEndpointInput struct {
	_ struct{} `type:"structure"`

	// The endpoint type.
	EndpointType *string `location:"querystring" locationName:"endpointType" type:"string"`
}

// String returns the string representation
func (s DescribeEndpointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEndpointInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeEndpointInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.EndpointType != nil {
		v := *s.EndpointType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "endpointType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the DescribeEndpoint operation.
type DescribeEndpointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The endpoint. The format of the endpoint is as follows: identifier.iot.region.amazonaws.com.
	EndpointAddress *string `locationName:"endpointAddress" type:"string"`
}

// String returns the string representation
func (s DescribeEndpointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEndpointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeEndpointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeEndpointOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.EndpointAddress != nil {
		v := *s.EndpointAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "endpointAddress", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeEventConfigurationsInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DescribeEventConfigurationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEventConfigurationsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeEventConfigurationsInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

type DescribeEventConfigurationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The creation date of the event configuration.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The event configurations.
	EventConfigurations map[string]Configuration `locationName:"eventConfigurations" type:"map"`

	// The date the event configurations were last modified.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s DescribeEventConfigurationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEventConfigurationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeEventConfigurationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeEventConfigurationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.EventConfigurations) > 0 {
		v := s.EventConfigurations

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "eventConfigurations", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

type DescribeIndexInput struct {
	_ struct{} `type:"structure"`

	// The index name.
	//
	// IndexName is a required field
	IndexName *string `location:"uri" locationName:"indexName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeIndexInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeIndexInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeIndexInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeIndexInput"}

	if s.IndexName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexName"))
	}
	if s.IndexName != nil && len(*s.IndexName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeIndexInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.IndexName != nil {
		v := *s.IndexName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "indexName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeIndexOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The index name.
	IndexName *string `locationName:"indexName" min:"1" type:"string"`

	// The index status.
	IndexStatus IndexStatus `locationName:"indexStatus" type:"string" enum:"true"`

	// Contains a value that specifies the type of indexing performed. Valid values
	// are:
	//
	// REGISTRY – Your thing index will contain only registry data.
	//
	// REGISTRY_AND_SHADOW - Your thing index will contain registry and shadow data.
	Schema *string `locationName:"schema" type:"string"`
}

// String returns the string representation
func (s DescribeIndexOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeIndexOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeIndexOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeIndexOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.IndexName != nil {
		v := *s.IndexName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "indexName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.IndexStatus) > 0 {
		v := s.IndexStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "indexStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Schema != nil {
		v := *s.Schema

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "schema", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeJobExecutionInput struct {
	_ struct{} `type:"structure"`

	// A string (consisting of the digits "0" through "9" which is used to specify
	// a particular job execution on a particular device.
	ExecutionNumber *int64 `location:"querystring" locationName:"executionNumber" type:"long"`

	// The unique identifier you assigned to this job when it was created.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`

	// The name of the thing on which the job execution is running.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeJobExecutionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobExecutionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeJobExecutionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeJobExecutionInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobExecutionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ExecutionNumber != nil {
		v := *s.ExecutionNumber

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "executionNumber", protocol.Int64Value(v), metadata)
	}
	return nil
}

type DescribeJobExecutionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Information about the job execution.
	Execution *JobExecution `locationName:"execution" type:"structure"`
}

// String returns the string representation
func (s DescribeJobExecutionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobExecutionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeJobExecutionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobExecutionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Execution != nil {
		v := s.Execution

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "execution", v, metadata)
	}
	return nil
}

type DescribeJobInput struct {
	_ struct{} `type:"structure"`

	// The unique identifier you assigned to this job when it was created.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeJobInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An S3 link to the job document.
	DocumentSource *string `locationName:"documentSource" min:"1" type:"string"`

	// Information about the job.
	Job *Job `locationName:"job" type:"structure"`
}

// String returns the string representation
func (s DescribeJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DocumentSource != nil {
		v := *s.DocumentSource

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "documentSource", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Job != nil {
		v := s.Job

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "job", v, metadata)
	}
	return nil
}

type DescribeRoleAliasInput struct {
	_ struct{} `type:"structure"`

	// The role alias to describe.
	//
	// RoleAlias is a required field
	RoleAlias *string `location:"uri" locationName:"roleAlias" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeRoleAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRoleAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeRoleAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeRoleAliasInput"}

	if s.RoleAlias == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleAlias"))
	}
	if s.RoleAlias != nil && len(*s.RoleAlias) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleAlias", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeRoleAliasInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RoleAlias != nil {
		v := *s.RoleAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "roleAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeRoleAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The role alias description.
	RoleAliasDescription *RoleAliasDescription `locationName:"roleAliasDescription" type:"structure"`
}

// String returns the string representation
func (s DescribeRoleAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRoleAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeRoleAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeRoleAliasOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.RoleAliasDescription != nil {
		v := s.RoleAliasDescription

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "roleAliasDescription", v, metadata)
	}
	return nil
}

type DescribeStreamInput struct {
	_ struct{} `type:"structure"`

	// The stream ID.
	//
	// StreamId is a required field
	StreamId *string `location:"uri" locationName:"streamId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeStreamInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeStreamInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeStreamInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeStreamInput"}

	if s.StreamId == nil {
		invalidParams.Add(aws.NewErrParamRequired("StreamId"))
	}
	if s.StreamId != nil && len(*s.StreamId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StreamId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeStreamInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeStreamOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Information about the stream.
	StreamInfo *StreamInfo `locationName:"streamInfo" type:"structure"`
}

// String returns the string representation
func (s DescribeStreamOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeStreamOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeStreamOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeStreamOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.StreamInfo != nil {
		v := s.StreamInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "streamInfo", v, metadata)
	}
	return nil
}

type DescribeThingGroupInput struct {
	_ struct{} `type:"structure"`

	// The name of the thing group.
	//
	// ThingGroupName is a required field
	ThingGroupName *string `location:"uri" locationName:"thingGroupName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeThingGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeThingGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeThingGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeThingGroupInput"}

	if s.ThingGroupName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingGroupName"))
	}
	if s.ThingGroupName != nil && len(*s.ThingGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeThingGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeThingGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The thing group ARN.
	ThingGroupArn *string `locationName:"thingGroupArn" type:"string"`

	// The thing group ID.
	ThingGroupId *string `locationName:"thingGroupId" min:"1" type:"string"`

	// Thing group metadata.
	ThingGroupMetadata *ThingGroupMetadata `locationName:"thingGroupMetadata" type:"structure"`

	// The name of the thing group.
	ThingGroupName *string `locationName:"thingGroupName" min:"1" type:"string"`

	// The thing group properties.
	ThingGroupProperties *ThingGroupProperties `locationName:"thingGroupProperties" type:"structure"`

	// The version of the thing group.
	Version *int64 `locationName:"version" type:"long"`
}

// String returns the string representation
func (s DescribeThingGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeThingGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeThingGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeThingGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ThingGroupArn != nil {
		v := *s.ThingGroupArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupId != nil {
		v := *s.ThingGroupId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupMetadata != nil {
		v := s.ThingGroupMetadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingGroupMetadata", v, metadata)
	}
	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupProperties != nil {
		v := s.ThingGroupProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingGroupProperties", v, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The input for the DescribeThing operation.
type DescribeThingInput struct {
	_ struct{} `type:"structure"`

	// The name of the thing.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeThingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeThingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeThingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeThingInput"}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeThingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the DescribeThing operation.
type DescribeThingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The thing attributes.
	Attributes map[string]string `locationName:"attributes" type:"map"`

	// The default client ID.
	DefaultClientId *string `locationName:"defaultClientId" type:"string"`

	// The ARN of the thing to describe.
	ThingArn *string `locationName:"thingArn" type:"string"`

	// The ID of the thing to describe.
	ThingId *string `locationName:"thingId" type:"string"`

	// The name of the thing.
	ThingName *string `locationName:"thingName" min:"1" type:"string"`

	// The thing type name.
	ThingTypeName *string `locationName:"thingTypeName" min:"1" type:"string"`

	// The current version of the thing record in the registry.
	//
	// To avoid unintentional changes to the information in the registry, you can
	// pass the version information in the expectedVersion parameter of the UpdateThing
	// and DeleteThing calls.
	Version *int64 `locationName:"version" type:"long"`
}

// String returns the string representation
func (s DescribeThingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeThingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeThingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeThingOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "attributes", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.DefaultClientId != nil {
		v := *s.DefaultClientId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultClientId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingArn != nil {
		v := *s.ThingArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingId != nil {
		v := *s.ThingId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.Int64Value(v), metadata)
	}
	return nil
}

type DescribeThingRegistrationTaskInput struct {
	_ struct{} `type:"structure"`

	// The task ID.
	//
	// TaskId is a required field
	TaskId *string `location:"uri" locationName:"taskId" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeThingRegistrationTaskInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeThingRegistrationTaskInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeThingRegistrationTaskInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeThingRegistrationTaskInput"}

	if s.TaskId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TaskId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeThingRegistrationTaskInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.TaskId != nil {
		v := *s.TaskId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "taskId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DescribeThingRegistrationTaskOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The task creation date.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The number of things that failed to be provisioned.
	FailureCount *int64 `locationName:"failureCount" type:"integer"`

	// The S3 bucket that contains the input file.
	InputFileBucket *string `locationName:"inputFileBucket" min:"3" type:"string"`

	// The input file key.
	InputFileKey *string `locationName:"inputFileKey" min:"1" type:"string"`

	// The date when the task was last modified.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`

	// The message.
	Message *string `locationName:"message" type:"string"`

	// The progress of the bulk provisioning task expressed as a percentage.
	PercentageProgress *int64 `locationName:"percentageProgress" type:"integer"`

	// The role ARN that grants access to the input file bucket.
	RoleArn *string `locationName:"roleArn" min:"20" type:"string"`

	// The status of the bulk thing provisioning task.
	Status Status `locationName:"status" type:"string" enum:"true"`

	// The number of things successfully provisioned.
	SuccessCount *int64 `locationName:"successCount" type:"integer"`

	// The task ID.
	TaskId *string `locationName:"taskId" type:"string"`

	// The task's template.
	TemplateBody *string `locationName:"templateBody" type:"string"`
}

// String returns the string representation
func (s DescribeThingRegistrationTaskOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeThingRegistrationTaskOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeThingRegistrationTaskOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeThingRegistrationTaskOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.FailureCount != nil {
		v := *s.FailureCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "failureCount", protocol.Int64Value(v), metadata)
	}
	if s.InputFileBucket != nil {
		v := *s.InputFileBucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "inputFileBucket", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InputFileKey != nil {
		v := *s.InputFileKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "inputFileKey", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "message", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PercentageProgress != nil {
		v := *s.PercentageProgress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "percentageProgress", protocol.Int64Value(v), metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SuccessCount != nil {
		v := *s.SuccessCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "successCount", protocol.Int64Value(v), metadata)
	}
	if s.TaskId != nil {
		v := *s.TaskId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "taskId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TemplateBody != nil {
		v := *s.TemplateBody

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "templateBody", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the DescribeThingType operation.
type DescribeThingTypeInput struct {
	_ struct{} `type:"structure"`

	// The name of the thing type.
	//
	// ThingTypeName is a required field
	ThingTypeName *string `location:"uri" locationName:"thingTypeName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeThingTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeThingTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeThingTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeThingTypeInput"}

	if s.ThingTypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingTypeName"))
	}
	if s.ThingTypeName != nil && len(*s.ThingTypeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingTypeName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeThingTypeInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output for the DescribeThingType operation.
type DescribeThingTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The thing type ARN.
	ThingTypeArn *string `locationName:"thingTypeArn" type:"string"`

	// The thing type ID.
	ThingTypeId *string `locationName:"thingTypeId" type:"string"`

	// The ThingTypeMetadata contains additional information about the thing type
	// including: creation date and time, a value indicating whether the thing type
	// is deprecated, and a date and time when it was deprecated.
	ThingTypeMetadata *ThingTypeMetadata `locationName:"thingTypeMetadata" type:"structure"`

	// The name of the thing type.
	ThingTypeName *string `locationName:"thingTypeName" min:"1" type:"string"`

	// The ThingTypeProperties contains information about the thing type including
	// description, and a list of searchable thing attribute names.
	ThingTypeProperties *ThingTypeProperties `locationName:"thingTypeProperties" type:"structure"`
}

// String returns the string representation
func (s DescribeThingTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeThingTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeThingTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeThingTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ThingTypeArn != nil {
		v := *s.ThingTypeArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeId != nil {
		v := *s.ThingTypeId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeMetadata != nil {
		v := s.ThingTypeMetadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingTypeMetadata", v, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeProperties != nil {
		v := s.ThingTypeProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingTypeProperties", v, metadata)
	}
	return nil
}

type DetachPolicyInput struct {
	_ struct{} `type:"structure"`

	// The policy to detach.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`

	// The target from which the policy will be detached.
	//
	// Target is a required field
	Target *string `locationName:"target" type:"string" required:"true"`
}

// String returns the string representation
func (s DetachPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DetachPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DetachPolicyInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if s.Target == nil {
		invalidParams.Add(aws.NewErrParamRequired("Target"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Target != nil {
		v := *s.Target

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "target", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DetachPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DetachPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DetachPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DetachPrincipalPolicy operation.
type DetachPrincipalPolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of the policy to detach.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`

	// The principal.
	//
	// If the principal is a certificate, specify the certificate ARN. If the principal
	// is an Amazon Cognito identity, specify the identity ID.
	//
	// Principal is a required field
	Principal *string `location:"header" locationName:"x-amzn-iot-principal" type:"string" required:"true"`
}

// String returns the string representation
func (s DetachPrincipalPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachPrincipalPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DetachPrincipalPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DetachPrincipalPolicyInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if s.Principal == nil {
		invalidParams.Add(aws.NewErrParamRequired("Principal"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachPrincipalPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Principal != nil {
		v := *s.Principal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amzn-iot-principal", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DetachPrincipalPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DetachPrincipalPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachPrincipalPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DetachPrincipalPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachPrincipalPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DetachThingPrincipal operation.
type DetachThingPrincipalInput struct {
	_ struct{} `type:"structure"`

	// If the principal is a certificate, this value must be ARN of the certificate.
	// If the principal is an Amazon Cognito identity, this value must be the ID
	// of the Amazon Cognito identity.
	//
	// Principal is a required field
	Principal *string `location:"header" locationName:"x-amzn-principal" type:"string" required:"true"`

	// The name of the thing.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DetachThingPrincipalInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachThingPrincipalInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DetachThingPrincipalInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DetachThingPrincipalInput"}

	if s.Principal == nil {
		invalidParams.Add(aws.NewErrParamRequired("Principal"))
	}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachThingPrincipalInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Principal != nil {
		v := *s.Principal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amzn-principal", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the DetachThingPrincipal operation.
type DetachThingPrincipalOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DetachThingPrincipalOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachThingPrincipalOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DetachThingPrincipalOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachThingPrincipalOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the DisableTopicRuleRequest operation.
type DisableTopicRuleInput struct {
	_ struct{} `type:"structure"`

	// The name of the rule to disable.
	//
	// RuleName is a required field
	RuleName *string `location:"uri" locationName:"ruleName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DisableTopicRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DisableTopicRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DisableTopicRuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DisableTopicRuleInput"}

	if s.RuleName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleName"))
	}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DisableTopicRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ruleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DisableTopicRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DisableTopicRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DisableTopicRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DisableTopicRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DisableTopicRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes an action to write to a DynamoDB table.
//
// The tableName, hashKeyField, and rangeKeyField values must match the values
// used when you created the table.
//
// The hashKeyValue and rangeKeyvalue fields use a substitution template syntax.
// These templates provide data at runtime. The syntax is as follows: ${sql-expression}.
//
// You can specify any valid expression in a WHERE or SELECT clause, including
// JSON properties, comparisons, calculations, and functions. For example, the
// following field uses the third level of the topic:
//
// "hashKeyValue": "${topic(3)}"
//
// The following field uses the timestamp:
//
// "rangeKeyValue": "${timestamp()}"
type DynamoDBAction struct {
	_ struct{} `type:"structure"`

	// The hash key name.
	//
	// HashKeyField is a required field
	HashKeyField *string `locationName:"hashKeyField" type:"string" required:"true"`

	// The hash key type. Valid values are "STRING" or "NUMBER"
	HashKeyType DynamoKeyType `locationName:"hashKeyType" type:"string" enum:"true"`

	// The hash key value.
	//
	// HashKeyValue is a required field
	HashKeyValue *string `locationName:"hashKeyValue" type:"string" required:"true"`

	// The type of operation to be performed. This follows the substitution template,
	// so it can be ${operation}, but the substitution must result in one of the
	// following: INSERT, UPDATE, or DELETE.
	Operation *string `locationName:"operation" type:"string"`

	// The action payload. This name can be customized.
	PayloadField *string `locationName:"payloadField" type:"string"`

	// The range key name.
	RangeKeyField *string `locationName:"rangeKeyField" type:"string"`

	// The range key type. Valid values are "STRING" or "NUMBER"
	RangeKeyType DynamoKeyType `locationName:"rangeKeyType" type:"string" enum:"true"`

	// The range key value.
	RangeKeyValue *string `locationName:"rangeKeyValue" type:"string"`

	// The ARN of the IAM role that grants access to the DynamoDB table.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// The name of the DynamoDB table.
	//
	// TableName is a required field
	TableName *string `locationName:"tableName" type:"string" required:"true"`
}

// String returns the string representation
func (s DynamoDBAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DynamoDBAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DynamoDBAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DynamoDBAction"}

	if s.HashKeyField == nil {
		invalidParams.Add(aws.NewErrParamRequired("HashKeyField"))
	}

	if s.HashKeyValue == nil {
		invalidParams.Add(aws.NewErrParamRequired("HashKeyValue"))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DynamoDBAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.HashKeyField != nil {
		v := *s.HashKeyField

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hashKeyField", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.HashKeyType) > 0 {
		v := s.HashKeyType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hashKeyType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.HashKeyValue != nil {
		v := *s.HashKeyValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hashKeyValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Operation != nil {
		v := *s.Operation

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "operation", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PayloadField != nil {
		v := *s.PayloadField

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "payloadField", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RangeKeyField != nil {
		v := *s.RangeKeyField

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "rangeKeyField", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RangeKeyType) > 0 {
		v := s.RangeKeyType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "rangeKeyType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RangeKeyValue != nil {
		v := *s.RangeKeyValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "rangeKeyValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TableName != nil {
		v := *s.TableName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tableName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an action to write to a DynamoDB table.
//
// This DynamoDB action writes each attribute in the message payload into it's
// own column in the DynamoDB table.
type DynamoDBv2Action struct {
	_ struct{} `type:"structure"`

	// Specifies the DynamoDB table to which the message data will be written. For
	// example:
	//
	// { "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName":
	// "my-table" } } }
	//
	// Each attribute in the message payload will be written to a separate column
	// in the DynamoDB database.
	PutItem *PutItemInput `locationName:"putItem" type:"structure"`

	// The ARN of the IAM role that grants access to the DynamoDB table.
	RoleArn *string `locationName:"roleArn" type:"string"`
}

// String returns the string representation
func (s DynamoDBv2Action) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DynamoDBv2Action) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DynamoDBv2Action) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DynamoDBv2Action"}
	if s.PutItem != nil {
		if err := s.PutItem.Validate(); err != nil {
			invalidParams.AddNested("PutItem", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DynamoDBv2Action) MarshalFields(e protocol.FieldEncoder) error {
	if s.PutItem != nil {
		v := s.PutItem

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "putItem", v, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The policy that has the effect on the authorization results.
type EffectivePolicy struct {
	_ struct{} `type:"structure"`

	// The policy ARN.
	PolicyArn *string `locationName:"policyArn" type:"string"`

	// The IAM policy document.
	PolicyDocument *string `locationName:"policyDocument" type:"string"`

	// The policy name.
	PolicyName *string `locationName:"policyName" min:"1" type:"string"`
}

// String returns the string representation
func (s EffectivePolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EffectivePolicy) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EffectivePolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.PolicyArn != nil {
		v := *s.PolicyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyDocument != nil {
		v := *s.PolicyDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an action that writes data to an Amazon Elasticsearch Service domain.
type ElasticsearchAction struct {
	_ struct{} `type:"structure"`

	// The endpoint of your Elasticsearch domain.
	//
	// Endpoint is a required field
	Endpoint *string `locationName:"endpoint" type:"string" required:"true"`

	// The unique identifier for the document you are storing.
	//
	// Id is a required field
	Id *string `locationName:"id" type:"string" required:"true"`

	// The Elasticsearch index where you want to store your data.
	//
	// Index is a required field
	Index *string `locationName:"index" type:"string" required:"true"`

	// The IAM role ARN that has access to Elasticsearch.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// The type of document you are storing.
	//
	// Type is a required field
	Type *string `locationName:"type" type:"string" required:"true"`
}

// String returns the string representation
func (s ElasticsearchAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ElasticsearchAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ElasticsearchAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ElasticsearchAction"}

	if s.Endpoint == nil {
		invalidParams.Add(aws.NewErrParamRequired("Endpoint"))
	}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if s.Index == nil {
		invalidParams.Add(aws.NewErrParamRequired("Index"))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if s.Type == nil {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ElasticsearchAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.Endpoint != nil {
		v := *s.Endpoint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "endpoint", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Index != nil {
		v := *s.Index

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "index", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the EnableTopicRuleRequest operation.
type EnableTopicRuleInput struct {
	_ struct{} `type:"structure"`

	// The name of the topic rule to enable.
	//
	// RuleName is a required field
	RuleName *string `location:"uri" locationName:"ruleName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s EnableTopicRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EnableTopicRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *EnableTopicRuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "EnableTopicRuleInput"}

	if s.RuleName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleName"))
	}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EnableTopicRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ruleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type EnableTopicRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s EnableTopicRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EnableTopicRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s EnableTopicRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EnableTopicRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Error information.
type ErrorInfo struct {
	_ struct{} `type:"structure"`

	// The error code.
	Code *string `locationName:"code" type:"string"`

	// The error message.
	Message *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ErrorInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ErrorInfo) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ErrorInfo) MarshalFields(e protocol.FieldEncoder) error {
	if s.Code != nil {
		v := *s.Code

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "message", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information that explicitly denies authorization.
type ExplicitDeny struct {
	_ struct{} `type:"structure"`

	// The policies that denied the authorization.
	Policies []Policy `locationName:"policies" type:"list"`
}

// String returns the string representation
func (s ExplicitDeny) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ExplicitDeny) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ExplicitDeny) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Policies) > 0 {
		v := s.Policies

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Describes an action that writes data to an Amazon Kinesis Firehose stream.
type FirehoseAction struct {
	_ struct{} `type:"structure"`

	// The delivery stream name.
	//
	// DeliveryStreamName is a required field
	DeliveryStreamName *string `locationName:"deliveryStreamName" type:"string" required:"true"`

	// The IAM role that grants access to the Amazon Kinesis Firehose stream.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// A character separator that will be used to separate records written to the
	// Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows
	// newline), ',' (comma).
	Separator *string `locationName:"separator" type:"string"`
}

// String returns the string representation
func (s FirehoseAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FirehoseAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FirehoseAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FirehoseAction"}

	if s.DeliveryStreamName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DeliveryStreamName"))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FirehoseAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.DeliveryStreamName != nil {
		v := *s.DeliveryStreamName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deliveryStreamName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Separator != nil {
		v := *s.Separator

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "separator", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type GetEffectivePoliciesInput struct {
	_ struct{} `type:"structure"`

	// The Cognito identity pool ID.
	CognitoIdentityPoolId *string `locationName:"cognitoIdentityPoolId" type:"string"`

	// The principal.
	Principal *string `locationName:"principal" type:"string"`

	// The thing name.
	ThingName *string `location:"querystring" locationName:"thingName" min:"1" type:"string"`
}

// String returns the string representation
func (s GetEffectivePoliciesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetEffectivePoliciesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetEffectivePoliciesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetEffectivePoliciesInput"}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetEffectivePoliciesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CognitoIdentityPoolId != nil {
		v := *s.CognitoIdentityPoolId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cognitoIdentityPoolId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Principal != nil {
		v := *s.Principal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "principal", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type GetEffectivePoliciesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The effective policies.
	EffectivePolicies []EffectivePolicy `locationName:"effectivePolicies" type:"list"`
}

// String returns the string representation
func (s GetEffectivePoliciesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetEffectivePoliciesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetEffectivePoliciesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetEffectivePoliciesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.EffectivePolicies) > 0 {
		v := s.EffectivePolicies

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "effectivePolicies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type GetIndexingConfigurationInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetIndexingConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIndexingConfigurationInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIndexingConfigurationInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

type GetIndexingConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Thing indexing configuration.
	ThingIndexingConfiguration *ThingIndexingConfiguration `locationName:"thingIndexingConfiguration" type:"structure"`
}

// String returns the string representation
func (s GetIndexingConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIndexingConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetIndexingConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIndexingConfigurationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ThingIndexingConfiguration != nil {
		v := s.ThingIndexingConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingIndexingConfiguration", v, metadata)
	}
	return nil
}

type GetJobDocumentInput struct {
	_ struct{} `type:"structure"`

	// The unique identifier you assigned to this job when it was created.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetJobDocumentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetJobDocumentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetJobDocumentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetJobDocumentInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetJobDocumentInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type GetJobDocumentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The job document content.
	Document *string `locationName:"document" type:"string"`
}

// String returns the string representation
func (s GetJobDocumentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetJobDocumentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetJobDocumentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetJobDocumentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Document != nil {
		v := *s.Document

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "document", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the GetLoggingOptions operation.
type GetLoggingOptionsInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetLoggingOptionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetLoggingOptionsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetLoggingOptionsInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// The output from the GetLoggingOptions operation.
type GetLoggingOptionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The logging level.
	LogLevel LogLevel `locationName:"logLevel" type:"string" enum:"true"`

	// The ARN of the IAM role that grants access.
	RoleArn *string `locationName:"roleArn" type:"string"`
}

// String returns the string representation
func (s GetLoggingOptionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetLoggingOptionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetLoggingOptionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetLoggingOptionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.LogLevel) > 0 {
		v := s.LogLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "logLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type GetOTAUpdateInput struct {
	_ struct{} `type:"structure"`

	// The OTA update ID.
	//
	// OtaUpdateId is a required field
	OtaUpdateId *string `location:"uri" locationName:"otaUpdateId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetOTAUpdateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetOTAUpdateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetOTAUpdateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetOTAUpdateInput"}

	if s.OtaUpdateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("OtaUpdateId"))
	}
	if s.OtaUpdateId != nil && len(*s.OtaUpdateId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("OtaUpdateId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetOTAUpdateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.OtaUpdateId != nil {
		v := *s.OtaUpdateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "otaUpdateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type GetOTAUpdateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The OTA update info.
	OtaUpdateInfo *OTAUpdateInfo `locationName:"otaUpdateInfo" type:"structure"`
}

// String returns the string representation
func (s GetOTAUpdateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetOTAUpdateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetOTAUpdateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetOTAUpdateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.OtaUpdateInfo != nil {
		v := s.OtaUpdateInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "otaUpdateInfo", v, metadata)
	}
	return nil
}

// The input for the GetPolicy operation.
type GetPolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of the policy.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetPolicyInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the GetPolicy operation.
type GetPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The date the policy was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The default policy version ID.
	DefaultVersionId *string `locationName:"defaultVersionId" type:"string"`

	// The generation ID of the policy.
	GenerationId *string `locationName:"generationId" type:"string"`

	// The date the policy was last modified.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`

	// The policy ARN.
	PolicyArn *string `locationName:"policyArn" type:"string"`

	// The JSON document that describes the policy.
	PolicyDocument *string `locationName:"policyDocument" type:"string"`

	// The policy name.
	PolicyName *string `locationName:"policyName" min:"1" type:"string"`
}

// String returns the string representation
func (s GetPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.DefaultVersionId != nil {
		v := *s.DefaultVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultVersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GenerationId != nil {
		v := *s.GenerationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "generationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.PolicyArn != nil {
		v := *s.PolicyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyDocument != nil {
		v := *s.PolicyDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the GetPolicyVersion operation.
type GetPolicyVersionInput struct {
	_ struct{} `type:"structure"`

	// The name of the policy.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`

	// The policy version ID.
	//
	// PolicyVersionId is a required field
	PolicyVersionId *string `location:"uri" locationName:"policyVersionId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetPolicyVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPolicyVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetPolicyVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetPolicyVersionInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if s.PolicyVersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyVersionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetPolicyVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyVersionId != nil {
		v := *s.PolicyVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyVersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the GetPolicyVersion operation.
type GetPolicyVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The date the policy version was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The generation ID of the policy version.
	GenerationId *string `locationName:"generationId" type:"string"`

	// Specifies whether the policy version is the default.
	IsDefaultVersion *bool `locationName:"isDefaultVersion" type:"boolean"`

	// The date the policy version was last modified.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`

	// The policy ARN.
	PolicyArn *string `locationName:"policyArn" type:"string"`

	// The JSON document that describes the policy.
	PolicyDocument *string `locationName:"policyDocument" type:"string"`

	// The policy name.
	PolicyName *string `locationName:"policyName" min:"1" type:"string"`

	// The policy version ID.
	PolicyVersionId *string `locationName:"policyVersionId" type:"string"`
}

// String returns the string representation
func (s GetPolicyVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPolicyVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetPolicyVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetPolicyVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.GenerationId != nil {
		v := *s.GenerationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "generationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IsDefaultVersion != nil {
		v := *s.IsDefaultVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "isDefaultVersion", protocol.BoolValue(v), metadata)
	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.PolicyArn != nil {
		v := *s.PolicyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyDocument != nil {
		v := *s.PolicyDocument

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyDocument", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyVersionId != nil {
		v := *s.PolicyVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyVersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input to the GetRegistrationCode operation.
type GetRegistrationCodeInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetRegistrationCodeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRegistrationCodeInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRegistrationCodeInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// The output from the GetRegistrationCode operation.
type GetRegistrationCodeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The CA certificate registration code.
	RegistrationCode *string `locationName:"registrationCode" min:"64" type:"string"`
}

// String returns the string representation
func (s GetRegistrationCodeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRegistrationCodeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetRegistrationCodeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRegistrationCodeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.RegistrationCode != nil {
		v := *s.RegistrationCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "registrationCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the GetTopicRule operation.
type GetTopicRuleInput struct {
	_ struct{} `type:"structure"`

	// The name of the rule.
	//
	// RuleName is a required field
	RuleName *string `location:"uri" locationName:"ruleName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetTopicRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTopicRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTopicRuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTopicRuleInput"}

	if s.RuleName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleName"))
	}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTopicRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ruleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the GetTopicRule operation.
type GetTopicRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The rule.
	Rule *TopicRule `locationName:"rule" type:"structure"`

	// The rule ARN.
	RuleArn *string `locationName:"ruleArn" type:"string"`
}

// String returns the string representation
func (s GetTopicRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTopicRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTopicRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTopicRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Rule != nil {
		v := s.Rule

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "rule", v, metadata)
	}
	if s.RuleArn != nil {
		v := *s.RuleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ruleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type GetV2LoggingOptionsInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetV2LoggingOptionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetV2LoggingOptionsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetV2LoggingOptionsInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

type GetV2LoggingOptionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The default log level.
	DefaultLogLevel LogLevel `locationName:"defaultLogLevel" type:"string" enum:"true"`

	// Disables all logs.
	DisableAllLogs *bool `locationName:"disableAllLogs" type:"boolean"`

	// The IAM role ARN AWS IoT uses to write to your CloudWatch logs.
	RoleArn *string `locationName:"roleArn" type:"string"`
}

// String returns the string representation
func (s GetV2LoggingOptionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetV2LoggingOptionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetV2LoggingOptionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetV2LoggingOptionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DefaultLogLevel) > 0 {
		v := s.DefaultLogLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultLogLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DisableAllLogs != nil {
		v := *s.DisableAllLogs

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "disableAllLogs", protocol.BoolValue(v), metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The name and ARN of a group.
type GroupNameAndArn struct {
	_ struct{} `type:"structure"`

	// The group ARN.
	GroupArn *string `locationName:"groupArn" type:"string"`

	// The group name.
	GroupName *string `locationName:"groupName" min:"1" type:"string"`
}

// String returns the string representation
func (s GroupNameAndArn) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GroupNameAndArn) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GroupNameAndArn) MarshalFields(e protocol.FieldEncoder) error {
	if s.GroupArn != nil {
		v := *s.GroupArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "groupArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupName != nil {
		v := *s.GroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "groupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information that implicitly denies authorization. When policy doesn't explicitly
// deny or allow an action on a resource it is considered an implicit deny.
type ImplicitDeny struct {
	_ struct{} `type:"structure"`

	// Policies that don't contain a matching allow or deny statement for the specified
	// action on the specified resource.
	Policies []Policy `locationName:"policies" type:"list"`
}

// String returns the string representation
func (s ImplicitDeny) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ImplicitDeny) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ImplicitDeny) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Policies) > 0 {
		v := s.Policies

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Sends messge data to an AWS IoT Analytics channel.
type IotAnalyticsAction struct {
	_ struct{} `type:"structure"`

	// (deprecated) The ARN of the IoT Analytics channel to which message data will
	// be sent.
	ChannelArn *string `locationName:"channelArn" type:"string"`

	// The name of the IoT Analytics channel to which message data will be sent.
	ChannelName *string `locationName:"channelName" type:"string"`

	// The ARN of the role which has a policy that grants IoT Analytics permission
	// to send message data via IoT Analytics (iotanalytics:BatchPutMessage).
	RoleArn *string `locationName:"roleArn" type:"string"`
}

// String returns the string representation
func (s IotAnalyticsAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s IotAnalyticsAction) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s IotAnalyticsAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.ChannelArn != nil {
		v := *s.ChannelArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "channelArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ChannelName != nil {
		v := *s.ChannelName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "channelName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The Job object contains details about a job.
type Job struct {
	_ struct{} `type:"structure"`

	// If the job was updated, describes the reason for the update.
	Comment *string `locationName:"comment" type:"string"`

	// The time, in milliseconds since the epoch, when the job was completed.
	CompletedAt *time.Time `locationName:"completedAt" type:"timestamp" timestampFormat:"unix"`

	// The time, in milliseconds since the epoch, when the job was created.
	CreatedAt *time.Time `locationName:"createdAt" type:"timestamp" timestampFormat:"unix"`

	// A short text description of the job.
	Description *string `locationName:"description" type:"string"`

	// The parameters specified for the job document.
	DocumentParameters map[string]string `locationName:"documentParameters" type:"map"`

	// Will be true if the job was canceled with the optional force parameter set
	// to true.
	ForceCanceled *bool `locationName:"forceCanceled" type:"boolean"`

	// An ARN identifying the job with format "arn:aws:iot:region:account:job/jobId".
	JobArn *string `locationName:"jobArn" type:"string"`

	// Allows you to create a staged rollout of a job.
	JobExecutionsRolloutConfig *JobExecutionsRolloutConfig `locationName:"jobExecutionsRolloutConfig" type:"structure"`

	// The unique identifier you assigned to this job when it was created.
	JobId *string `locationName:"jobId" min:"1" type:"string"`

	// Details about the job process.
	JobProcessDetails *JobProcessDetails `locationName:"jobProcessDetails" type:"structure"`

	// The time, in milliseconds since the epoch, when the job was last updated.
	LastUpdatedAt *time.Time `locationName:"lastUpdatedAt" type:"timestamp" timestampFormat:"unix"`

	// Configuration for pre-signed S3 URLs.
	PresignedUrlConfig *PresignedUrlConfig `locationName:"presignedUrlConfig" type:"structure"`

	// The status of the job, one of IN_PROGRESS, CANCELED, or COMPLETED.
	Status JobStatus `locationName:"status" type:"string" enum:"true"`

	// Specifies whether the job will continue to run (CONTINUOUS), or will be complete
	// after all those things specified as targets have completed the job (SNAPSHOT).
	// If continuous, the job may also be run on a thing when a change is detected
	// in a target. For example, a job will run on a device when the thing representing
	// the device is added to a target group, even after the job was completed by
	// all things originally in the group.
	TargetSelection TargetSelection `locationName:"targetSelection" type:"string" enum:"true"`

	// A list of IoT things and thing groups to which the job should be sent.
	Targets []string `locationName:"targets" min:"1" type:"list"`
}

// String returns the string representation
func (s Job) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Job) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Job) MarshalFields(e protocol.FieldEncoder) error {
	if s.Comment != nil {
		v := *s.Comment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "comment", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CompletedAt != nil {
		v := *s.CompletedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "completedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.DocumentParameters) > 0 {
		v := s.DocumentParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "documentParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.ForceCanceled != nil {
		v := *s.ForceCanceled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "forceCanceled", protocol.BoolValue(v), metadata)
	}
	if s.JobArn != nil {
		v := *s.JobArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobExecutionsRolloutConfig != nil {
		v := s.JobExecutionsRolloutConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "jobExecutionsRolloutConfig", v, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobProcessDetails != nil {
		v := s.JobProcessDetails

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "jobProcessDetails", v, metadata)
	}
	if s.LastUpdatedAt != nil {
		v := *s.LastUpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.PresignedUrlConfig != nil {
		v := s.PresignedUrlConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "presignedUrlConfig", v, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.TargetSelection) > 0 {
		v := s.TargetSelection

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "targetSelection", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Targets) > 0 {
		v := s.Targets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "targets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// The job execution object represents the execution of a job on a particular
// device.
type JobExecution struct {
	_ struct{} `type:"structure"`

	// A string (consisting of the digits "0" through "9") which identifies this
	// particular job execution on this particular device. It can be used in commands
	// which return or update job execution information.
	ExecutionNumber *int64 `locationName:"executionNumber" type:"long"`

	// Will be true if the job execution was canceled with the optional force parameter
	// set to true.
	ForceCanceled *bool `locationName:"forceCanceled" type:"boolean"`

	// The unique identifier you assigned to the job when it was created.
	JobId *string `locationName:"jobId" min:"1" type:"string"`

	// The time, in milliseconds since the epoch, when the job execution was last
	// updated.
	LastUpdatedAt *time.Time `locationName:"lastUpdatedAt" type:"timestamp" timestampFormat:"unix"`

	// The time, in milliseconds since the epoch, when the job execution was queued.
	QueuedAt *time.Time `locationName:"queuedAt" type:"timestamp" timestampFormat:"unix"`

	// The time, in milliseconds since the epoch, when the job execution started.
	StartedAt *time.Time `locationName:"startedAt" type:"timestamp" timestampFormat:"unix"`

	// The status of the job execution (IN_PROGRESS, QUEUED, FAILED, SUCCESS, CANCELED,
	// or REJECTED).
	Status JobExecutionStatus `locationName:"status" type:"string" enum:"true"`

	// A collection of name/value pairs that describe the status of the job execution.
	StatusDetails *JobExecutionStatusDetails `locationName:"statusDetails" type:"structure"`

	// The ARN of the thing on which the job execution is running.
	ThingArn *string `locationName:"thingArn" type:"string"`

	// The version of the job execution. Job execution versions are incremented
	// each time they are updated by a device.
	VersionNumber *int64 `locationName:"versionNumber" type:"long"`
}

// String returns the string representation
func (s JobExecution) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobExecution) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobExecution) MarshalFields(e protocol.FieldEncoder) error {
	if s.ExecutionNumber != nil {
		v := *s.ExecutionNumber

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "executionNumber", protocol.Int64Value(v), metadata)
	}
	if s.ForceCanceled != nil {
		v := *s.ForceCanceled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "forceCanceled", protocol.BoolValue(v), metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedAt != nil {
		v := *s.LastUpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.QueuedAt != nil {
		v := *s.QueuedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "queuedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.StartedAt != nil {
		v := *s.StartedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusDetails != nil {
		v := s.StatusDetails

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "statusDetails", v, metadata)
	}
	if s.ThingArn != nil {
		v := *s.ThingArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.VersionNumber != nil {
		v := *s.VersionNumber

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "versionNumber", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Details of the job execution status.
type JobExecutionStatusDetails struct {
	_ struct{} `type:"structure"`

	// The job execution status.
	DetailsMap map[string]string `locationName:"detailsMap" type:"map"`
}

// String returns the string representation
func (s JobExecutionStatusDetails) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobExecutionStatusDetails) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobExecutionStatusDetails) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DetailsMap) > 0 {
		v := s.DetailsMap

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "detailsMap", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// The job execution summary.
type JobExecutionSummary struct {
	_ struct{} `type:"structure"`

	// A string (consisting of the digits "0" through "9") which identifies this
	// particular job execution on this particular device. It can be used later
	// in commands which return or update job execution information.
	ExecutionNumber *int64 `locationName:"executionNumber" type:"long"`

	// The time, in milliseconds since the epoch, when the job execution was last
	// updated.
	LastUpdatedAt *time.Time `locationName:"lastUpdatedAt" type:"timestamp" timestampFormat:"unix"`

	// The time, in milliseconds since the epoch, when the job execution was queued.
	QueuedAt *time.Time `locationName:"queuedAt" type:"timestamp" timestampFormat:"unix"`

	// The time, in milliseconds since the epoch, when the job execution started.
	StartedAt *time.Time `locationName:"startedAt" type:"timestamp" timestampFormat:"unix"`

	// The status of the job execution.
	Status JobExecutionStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s JobExecutionSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobExecutionSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobExecutionSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.ExecutionNumber != nil {
		v := *s.ExecutionNumber

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "executionNumber", protocol.Int64Value(v), metadata)
	}
	if s.LastUpdatedAt != nil {
		v := *s.LastUpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.QueuedAt != nil {
		v := *s.QueuedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "queuedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.StartedAt != nil {
		v := *s.StartedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Contains a summary of information about job executions for a specific job.
type JobExecutionSummaryForJob struct {
	_ struct{} `type:"structure"`

	// Contains a subset of information about a job execution.
	JobExecutionSummary *JobExecutionSummary `locationName:"jobExecutionSummary" type:"structure"`

	// The ARN of the thing on which the job execution is running.
	ThingArn *string `locationName:"thingArn" type:"string"`
}

// String returns the string representation
func (s JobExecutionSummaryForJob) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobExecutionSummaryForJob) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobExecutionSummaryForJob) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobExecutionSummary != nil {
		v := s.JobExecutionSummary

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "jobExecutionSummary", v, metadata)
	}
	if s.ThingArn != nil {
		v := *s.ThingArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The job execution summary for a thing.
type JobExecutionSummaryForThing struct {
	_ struct{} `type:"structure"`

	// Contains a subset of information about a job execution.
	JobExecutionSummary *JobExecutionSummary `locationName:"jobExecutionSummary" type:"structure"`

	// The unique identifier you assigned to this job when it was created.
	JobId *string `locationName:"jobId" min:"1" type:"string"`
}

// String returns the string representation
func (s JobExecutionSummaryForThing) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobExecutionSummaryForThing) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobExecutionSummaryForThing) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobExecutionSummary != nil {
		v := s.JobExecutionSummary

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "jobExecutionSummary", v, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Allows you to create a staged rollout of a job.
type JobExecutionsRolloutConfig struct {
	_ struct{} `type:"structure"`

	// The maximum number of things that will be notified of a pending job, per
	// minute. This parameter allows you to create a staged rollout.
	MaximumPerMinute *int64 `locationName:"maximumPerMinute" min:"1" type:"integer"`
}

// String returns the string representation
func (s JobExecutionsRolloutConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobExecutionsRolloutConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *JobExecutionsRolloutConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "JobExecutionsRolloutConfig"}
	if s.MaximumPerMinute != nil && *s.MaximumPerMinute < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaximumPerMinute", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobExecutionsRolloutConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaximumPerMinute != nil {
		v := *s.MaximumPerMinute

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maximumPerMinute", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The job process details.
type JobProcessDetails struct {
	_ struct{} `type:"structure"`

	// The number of things that cancelled the job.
	NumberOfCanceledThings *int64 `locationName:"numberOfCanceledThings" type:"integer"`

	// The number of things that failed executing the job.
	NumberOfFailedThings *int64 `locationName:"numberOfFailedThings" type:"integer"`

	// The number of things currently executing the job.
	NumberOfInProgressThings *int64 `locationName:"numberOfInProgressThings" type:"integer"`

	// The number of things that are awaiting execution of the job.
	NumberOfQueuedThings *int64 `locationName:"numberOfQueuedThings" type:"integer"`

	// The number of things that rejected the job.
	NumberOfRejectedThings *int64 `locationName:"numberOfRejectedThings" type:"integer"`

	// The number of things that are no longer scheduled to execute the job because
	// they have been deleted or have been removed from the group that was a target
	// of the job.
	NumberOfRemovedThings *int64 `locationName:"numberOfRemovedThings" type:"integer"`

	// The number of things which successfully completed the job.
	NumberOfSucceededThings *int64 `locationName:"numberOfSucceededThings" type:"integer"`

	// The target devices to which the job execution is being rolled out. This value
	// will be null after the job execution has finished rolling out to all the
	// target devices.
	ProcessingTargets []string `locationName:"processingTargets" type:"list"`
}

// String returns the string representation
func (s JobProcessDetails) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobProcessDetails) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobProcessDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.NumberOfCanceledThings != nil {
		v := *s.NumberOfCanceledThings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "numberOfCanceledThings", protocol.Int64Value(v), metadata)
	}
	if s.NumberOfFailedThings != nil {
		v := *s.NumberOfFailedThings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "numberOfFailedThings", protocol.Int64Value(v), metadata)
	}
	if s.NumberOfInProgressThings != nil {
		v := *s.NumberOfInProgressThings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "numberOfInProgressThings", protocol.Int64Value(v), metadata)
	}
	if s.NumberOfQueuedThings != nil {
		v := *s.NumberOfQueuedThings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "numberOfQueuedThings", protocol.Int64Value(v), metadata)
	}
	if s.NumberOfRejectedThings != nil {
		v := *s.NumberOfRejectedThings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "numberOfRejectedThings", protocol.Int64Value(v), metadata)
	}
	if s.NumberOfRemovedThings != nil {
		v := *s.NumberOfRemovedThings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "numberOfRemovedThings", protocol.Int64Value(v), metadata)
	}
	if s.NumberOfSucceededThings != nil {
		v := *s.NumberOfSucceededThings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "numberOfSucceededThings", protocol.Int64Value(v), metadata)
	}
	if len(s.ProcessingTargets) > 0 {
		v := s.ProcessingTargets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "processingTargets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// The job summary.
type JobSummary struct {
	_ struct{} `type:"structure"`

	// The time, in milliseconds since the epoch, when the job completed.
	CompletedAt *time.Time `locationName:"completedAt" type:"timestamp" timestampFormat:"unix"`

	// The time, in milliseconds since the epoch, when the job was created.
	CreatedAt *time.Time `locationName:"createdAt" type:"timestamp" timestampFormat:"unix"`

	// The job ARN.
	JobArn *string `locationName:"jobArn" type:"string"`

	// The unique identifier you assigned to this job when it was created.
	JobId *string `locationName:"jobId" min:"1" type:"string"`

	// The time, in milliseconds since the epoch, when the job was last updated.
	LastUpdatedAt *time.Time `locationName:"lastUpdatedAt" type:"timestamp" timestampFormat:"unix"`

	// The job summary status.
	Status JobStatus `locationName:"status" type:"string" enum:"true"`

	// Specifies whether the job will continue to run (CONTINUOUS), or will be complete
	// after all those things specified as targets have completed the job (SNAPSHOT).
	// If continuous, the job may also be run on a thing when a change is detected
	// in a target. For example, a job will run on a thing when the thing is added
	// to a target group, even after the job was completed by all things originally
	// in the group.
	TargetSelection TargetSelection `locationName:"targetSelection" type:"string" enum:"true"`

	// The ID of the thing group.
	ThingGroupId *string `locationName:"thingGroupId" min:"1" type:"string"`
}

// String returns the string representation
func (s JobSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.CompletedAt != nil {
		v := *s.CompletedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "completedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.JobArn != nil {
		v := *s.JobArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedAt != nil {
		v := *s.LastUpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.TargetSelection) > 0 {
		v := s.TargetSelection

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "targetSelection", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ThingGroupId != nil {
		v := *s.ThingGroupId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a key pair.
type KeyPair struct {
	_ struct{} `type:"structure"`

	// The private key.
	PrivateKey *string `min:"1" type:"string"`

	// The public key.
	PublicKey *string `min:"1" type:"string"`
}

// String returns the string representation
func (s KeyPair) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s KeyPair) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s KeyPair) MarshalFields(e protocol.FieldEncoder) error {
	if s.PrivateKey != nil {
		v := *s.PrivateKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PrivateKey", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PublicKey != nil {
		v := *s.PublicKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PublicKey", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an action to write data to an Amazon Kinesis stream.
type KinesisAction struct {
	_ struct{} `type:"structure"`

	// The partition key.
	PartitionKey *string `locationName:"partitionKey" type:"string"`

	// The ARN of the IAM role that grants access to the Amazon Kinesis stream.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// The name of the Amazon Kinesis stream.
	//
	// StreamName is a required field
	StreamName *string `locationName:"streamName" type:"string" required:"true"`
}

// String returns the string representation
func (s KinesisAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s KinesisAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *KinesisAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "KinesisAction"}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if s.StreamName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StreamName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s KinesisAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.PartitionKey != nil {
		v := *s.PartitionKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "partitionKey", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamName != nil {
		v := *s.StreamName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an action to invoke a Lambda function.
type LambdaAction struct {
	_ struct{} `type:"structure"`

	// The ARN of the Lambda function.
	//
	// FunctionArn is a required field
	FunctionArn *string `locationName:"functionArn" type:"string" required:"true"`
}

// String returns the string representation
func (s LambdaAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LambdaAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LambdaAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LambdaAction"}

	if s.FunctionArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("FunctionArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LambdaAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.FunctionArn != nil {
		v := *s.FunctionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "functionArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListAttachedPoliciesInput struct {
	_ struct{} `type:"structure"`

	// The token to retrieve the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The maximum number of results to be returned per request.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`

	// When true, recursively list attached policies.
	Recursive *bool `location:"querystring" locationName:"recursive" type:"boolean"`

	// The group for which the policies will be listed.
	//
	// Target is a required field
	Target *string `location:"uri" locationName:"target" type:"string" required:"true"`
}

// String returns the string representation
func (s ListAttachedPoliciesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAttachedPoliciesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListAttachedPoliciesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListAttachedPoliciesInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if s.Target == nil {
		invalidParams.Add(aws.NewErrParamRequired("Target"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListAttachedPoliciesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Target != nil {
		v := *s.Target

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "target", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	if s.Recursive != nil {
		v := *s.Recursive

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "recursive", protocol.BoolValue(v), metadata)
	}
	return nil
}

type ListAttachedPoliciesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token to retrieve the next set of results, or ``null`` if there are no
	// more results.
	NextMarker *string `locationName:"nextMarker" type:"string"`

	// The policies.
	Policies []Policy `locationName:"policies" type:"list"`
}

// String returns the string representation
func (s ListAttachedPoliciesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAttachedPoliciesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListAttachedPoliciesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListAttachedPoliciesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Policies) > 0 {
		v := s.Policies

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type ListAuthorizersInput struct {
	_ struct{} `type:"structure"`

	// Return the list of authorizers in ascending alphabetical order.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// A marker used to get the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The maximum number of results to return at one time.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`

	// The status of the list authorizers request.
	Status AuthorizerStatus `location:"querystring" locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListAuthorizersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAuthorizersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListAuthorizersInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListAuthorizersInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListAuthorizersInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type ListAuthorizersOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The authorizers.
	Authorizers []AuthorizerSummary `locationName:"authorizers" type:"list"`

	// A marker used to get the next set of results.
	NextMarker *string `locationName:"nextMarker" type:"string"`
}

// String returns the string representation
func (s ListAuthorizersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAuthorizersOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListAuthorizersOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListAuthorizersOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Authorizers) > 0 {
		v := s.Authorizers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "authorizers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Input for the ListCACertificates operation.
type ListCACertificatesInput struct {
	_ struct{} `type:"structure"`

	// Determines the order of the results.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// The marker for the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The result page size.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`
}

// String returns the string representation
func (s ListCACertificatesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListCACertificatesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListCACertificatesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListCACertificatesInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListCACertificatesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The output from the ListCACertificates operation.
type ListCACertificatesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The CA certificates registered in your AWS account.
	Certificates []CACertificate `locationName:"certificates" type:"list"`

	// The current position within the list of CA certificates.
	NextMarker *string `locationName:"nextMarker" type:"string"`
}

// String returns the string representation
func (s ListCACertificatesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListCACertificatesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListCACertificatesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListCACertificatesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Certificates) > 0 {
		v := s.Certificates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "certificates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input to the ListCertificatesByCA operation.
type ListCertificatesByCAInput struct {
	_ struct{} `type:"structure"`

	// Specifies the order for results. If True, the results are returned in ascending
	// order, based on the creation date.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// The ID of the CA certificate. This operation will list all registered device
	// certificate that were signed by this CA certificate.
	//
	// CaCertificateId is a required field
	CaCertificateId *string `location:"uri" locationName:"caCertificateId" min:"64" type:"string" required:"true"`

	// The marker for the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The result page size.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`
}

// String returns the string representation
func (s ListCertificatesByCAInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListCertificatesByCAInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListCertificatesByCAInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListCertificatesByCAInput"}

	if s.CaCertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CaCertificateId"))
	}
	if s.CaCertificateId != nil && len(*s.CaCertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CaCertificateId", 64))
	}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListCertificatesByCAInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CaCertificateId != nil {
		v := *s.CaCertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "caCertificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The output of the ListCertificatesByCA operation.
type ListCertificatesByCAOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The device certificates signed by the specified CA certificate.
	Certificates []Certificate `locationName:"certificates" type:"list"`

	// The marker for the next set of results, or null if there are no additional
	// results.
	NextMarker *string `locationName:"nextMarker" type:"string"`
}

// String returns the string representation
func (s ListCertificatesByCAOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListCertificatesByCAOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListCertificatesByCAOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListCertificatesByCAOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Certificates) > 0 {
		v := s.Certificates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "certificates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the ListCertificates operation.
type ListCertificatesInput struct {
	_ struct{} `type:"structure"`

	// Specifies the order for results. If True, the results are returned in ascending
	// order, based on the creation date.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// The marker for the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The result page size.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`
}

// String returns the string representation
func (s ListCertificatesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListCertificatesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListCertificatesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListCertificatesInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListCertificatesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The output of the ListCertificates operation.
type ListCertificatesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The descriptions of the certificates.
	Certificates []Certificate `locationName:"certificates" type:"list"`

	// The marker for the next set of results, or null if there are no additional
	// results.
	NextMarker *string `locationName:"nextMarker" type:"string"`
}

// String returns the string representation
func (s ListCertificatesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListCertificatesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListCertificatesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListCertificatesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Certificates) > 0 {
		v := s.Certificates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "certificates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListIndicesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return at one time.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListIndicesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListIndicesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListIndicesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListIndicesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListIndicesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListIndicesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The index names.
	IndexNames []string `locationName:"indexNames" type:"list"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListIndicesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListIndicesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListIndicesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListIndicesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IndexNames) > 0 {
		v := s.IndexNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "indexNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListJobExecutionsForJobInput struct {
	_ struct{} `type:"structure"`

	// The unique identifier you assigned to this job when it was created.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" min:"1" type:"string" required:"true"`

	// The maximum number of results to be returned per request.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token to retrieve the next set of results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The status of the job.
	Status JobExecutionStatus `location:"querystring" locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListJobExecutionsForJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobExecutionsForJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListJobExecutionsForJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListJobExecutionsForJobInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}
	if s.JobId != nil && len(*s.JobId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("JobId", 1))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobExecutionsForJobInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type ListJobExecutionsForJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of job execution summaries.
	ExecutionSummaries []JobExecutionSummaryForJob `locationName:"executionSummaries" type:"list"`

	// The token for the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListJobExecutionsForJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobExecutionsForJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListJobExecutionsForJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobExecutionsForJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ExecutionSummaries) > 0 {
		v := s.ExecutionSummaries

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "executionSummaries", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListJobExecutionsForThingInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to be returned per request.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token to retrieve the next set of results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// An optional filter that lets you search for jobs that have the specified
	// status.
	Status JobExecutionStatus `location:"querystring" locationName:"status" type:"string" enum:"true"`

	// The thing name.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListJobExecutionsForThingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobExecutionsForThingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListJobExecutionsForThingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListJobExecutionsForThingInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobExecutionsForThingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type ListJobExecutionsForThingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of job execution summaries.
	ExecutionSummaries []JobExecutionSummaryForThing `locationName:"executionSummaries" type:"list"`

	// The token for the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListJobExecutionsForThingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobExecutionsForThingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListJobExecutionsForThingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobExecutionsForThingOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ExecutionSummaries) > 0 {
		v := s.ExecutionSummaries

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "executionSummaries", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListJobsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return per request.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token to retrieve the next set of results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// An optional filter that lets you search for jobs that have the specified
	// status.
	Status JobStatus `location:"querystring" locationName:"status" type:"string" enum:"true"`

	// Specifies whether the job will continue to run (CONTINUOUS), or will be complete
	// after all those things specified as targets have completed the job (SNAPSHOT).
	// If continuous, the job may also be run on a thing when a change is detected
	// in a target. For example, a job will run on a thing when the thing is added
	// to a target group, even after the job was completed by all things originally
	// in the group.
	TargetSelection TargetSelection `location:"querystring" locationName:"targetSelection" type:"string" enum:"true"`

	// A filter that limits the returned jobs to those for the specified group.
	ThingGroupId *string `location:"querystring" locationName:"thingGroupId" min:"1" type:"string"`

	// A filter that limits the returned jobs to those for the specified group.
	ThingGroupName *string `location:"querystring" locationName:"thingGroupName" min:"1" type:"string"`
}

// String returns the string representation
func (s ListJobsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListJobsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListJobsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.ThingGroupId != nil && len(*s.ThingGroupId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupId", 1))
	}
	if s.ThingGroupName != nil && len(*s.ThingGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.TargetSelection) > 0 {
		v := s.TargetSelection

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "targetSelection", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ThingGroupId != nil {
		v := *s.ThingGroupId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "thingGroupId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListJobsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of jobs.
	Jobs []JobSummary `locationName:"jobs" type:"list"`

	// The token for the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListJobsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListJobsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Jobs) > 0 {
		v := s.Jobs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListOTAUpdatesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return at one time.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// A token used to retrieve the next set of results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The OTA update job status.
	OtaUpdateStatus OTAUpdateStatus `location:"querystring" locationName:"otaUpdateStatus" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListOTAUpdatesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListOTAUpdatesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListOTAUpdatesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListOTAUpdatesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListOTAUpdatesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OtaUpdateStatus) > 0 {
		v := s.OtaUpdateStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "otaUpdateStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type ListOTAUpdatesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A token to use to get the next set of results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A list of OTA update jobs.
	OtaUpdates []OTAUpdateSummary `locationName:"otaUpdates" type:"list"`
}

// String returns the string representation
func (s ListOTAUpdatesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListOTAUpdatesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListOTAUpdatesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListOTAUpdatesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OtaUpdates) > 0 {
		v := s.OtaUpdates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "otaUpdates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The input to the ListOutgoingCertificates operation.
type ListOutgoingCertificatesInput struct {
	_ struct{} `type:"structure"`

	// Specifies the order for results. If True, the results are returned in ascending
	// order, based on the creation date.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// The marker for the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The result page size.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`
}

// String returns the string representation
func (s ListOutgoingCertificatesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListOutgoingCertificatesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListOutgoingCertificatesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListOutgoingCertificatesInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListOutgoingCertificatesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The output from the ListOutgoingCertificates operation.
type ListOutgoingCertificatesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The marker for the next set of results.
	NextMarker *string `locationName:"nextMarker" type:"string"`

	// The certificates that are being transferred but not yet accepted.
	OutgoingCertificates []OutgoingCertificate `locationName:"outgoingCertificates" type:"list"`
}

// String returns the string representation
func (s ListOutgoingCertificatesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListOutgoingCertificatesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListOutgoingCertificatesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListOutgoingCertificatesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OutgoingCertificates) > 0 {
		v := s.OutgoingCertificates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "outgoingCertificates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The input for the ListPolicies operation.
type ListPoliciesInput struct {
	_ struct{} `type:"structure"`

	// Specifies the order for results. If true, the results are returned in ascending
	// creation order.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// The marker for the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The result page size.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`
}

// String returns the string representation
func (s ListPoliciesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPoliciesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPoliciesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListPoliciesInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPoliciesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The output from the ListPolicies operation.
type ListPoliciesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The marker for the next set of results, or null if there are no additional
	// results.
	NextMarker *string `locationName:"nextMarker" type:"string"`

	// The descriptions of the policies.
	Policies []Policy `locationName:"policies" type:"list"`
}

// String returns the string representation
func (s ListPoliciesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPoliciesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListPoliciesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPoliciesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Policies) > 0 {
		v := s.Policies

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The input for the ListPolicyPrincipals operation.
type ListPolicyPrincipalsInput struct {
	_ struct{} `type:"structure"`

	// Specifies the order for results. If true, the results are returned in ascending
	// creation order.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// The marker for the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The result page size.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`

	// The policy name.
	//
	// PolicyName is a required field
	PolicyName *string `location:"header" locationName:"x-amzn-iot-policy" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListPolicyPrincipalsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPolicyPrincipalsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPolicyPrincipalsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListPolicyPrincipalsInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPolicyPrincipalsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amzn-iot-policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The output from the ListPolicyPrincipals operation.
type ListPolicyPrincipalsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The marker for the next set of results, or null if there are no additional
	// results.
	NextMarker *string `locationName:"nextMarker" type:"string"`

	// The descriptions of the principals.
	Principals []string `locationName:"principals" type:"list"`
}

// String returns the string representation
func (s ListPolicyPrincipalsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPolicyPrincipalsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListPolicyPrincipalsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPolicyPrincipalsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Principals) > 0 {
		v := s.Principals

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "principals", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// The input for the ListPolicyVersions operation.
type ListPolicyVersionsInput struct {
	_ struct{} `type:"structure"`

	// The policy name.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListPolicyVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPolicyVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPolicyVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListPolicyVersionsInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPolicyVersionsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the ListPolicyVersions operation.
type ListPolicyVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The policy versions.
	PolicyVersions []PolicyVersion `locationName:"policyVersions" type:"list"`
}

// String returns the string representation
func (s ListPolicyVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPolicyVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListPolicyVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPolicyVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.PolicyVersions) > 0 {
		v := s.PolicyVersions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policyVersions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The input for the ListPrincipalPolicies operation.
type ListPrincipalPoliciesInput struct {
	_ struct{} `type:"structure"`

	// Specifies the order for results. If true, results are returned in ascending
	// creation order.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// The marker for the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The result page size.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`

	// The principal.
	//
	// Principal is a required field
	Principal *string `location:"header" locationName:"x-amzn-iot-principal" type:"string" required:"true"`
}

// String returns the string representation
func (s ListPrincipalPoliciesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPrincipalPoliciesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPrincipalPoliciesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListPrincipalPoliciesInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if s.Principal == nil {
		invalidParams.Add(aws.NewErrParamRequired("Principal"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPrincipalPoliciesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Principal != nil {
		v := *s.Principal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amzn-iot-principal", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The output from the ListPrincipalPolicies operation.
type ListPrincipalPoliciesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The marker for the next set of results, or null if there are no additional
	// results.
	NextMarker *string `locationName:"nextMarker" type:"string"`

	// The policies.
	Policies []Policy `locationName:"policies" type:"list"`
}

// String returns the string representation
func (s ListPrincipalPoliciesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPrincipalPoliciesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListPrincipalPoliciesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPrincipalPoliciesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Policies) > 0 {
		v := s.Policies

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The input for the ListPrincipalThings operation.
type ListPrincipalThingsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return in this operation.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The principal.
	//
	// Principal is a required field
	Principal *string `location:"header" locationName:"x-amzn-principal" type:"string" required:"true"`
}

// String returns the string representation
func (s ListPrincipalThingsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPrincipalThingsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPrincipalThingsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListPrincipalThingsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.Principal == nil {
		invalidParams.Add(aws.NewErrParamRequired("Principal"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPrincipalThingsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Principal != nil {
		v := *s.Principal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amzn-principal", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the ListPrincipalThings operation.
type ListPrincipalThingsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The things.
	Things []string `locationName:"things" type:"list"`
}

// String returns the string representation
func (s ListPrincipalThingsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPrincipalThingsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListPrincipalThingsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPrincipalThingsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Things) > 0 {
		v := s.Things

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "things", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type ListRoleAliasesInput struct {
	_ struct{} `type:"structure"`

	// Return the list of role aliases in ascending alphabetical order.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// A marker used to get the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The maximum number of results to return at one time.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`
}

// String returns the string representation
func (s ListRoleAliasesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRoleAliasesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListRoleAliasesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListRoleAliasesInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListRoleAliasesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

type ListRoleAliasesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A marker used to get the next set of results.
	NextMarker *string `locationName:"nextMarker" type:"string"`

	// The role aliases.
	RoleAliases []string `locationName:"roleAliases" type:"list"`
}

// String returns the string representation
func (s ListRoleAliasesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRoleAliasesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListRoleAliasesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListRoleAliasesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RoleAliases) > 0 {
		v := s.RoleAliases

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "roleAliases", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type ListStreamsInput struct {
	_ struct{} `type:"structure"`

	// Set to true to return the list of streams in ascending order.
	AscendingOrder *bool `location:"querystring" locationName:"isAscendingOrder" type:"boolean"`

	// The maximum number of results to return at a time.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// A token used to get the next set of results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListStreamsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListStreamsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListStreamsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListStreamsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListStreamsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AscendingOrder != nil {
		v := *s.AscendingOrder

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "isAscendingOrder", protocol.BoolValue(v), metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListStreamsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A token used to get the next set of results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A list of streams.
	Streams []StreamSummary `locationName:"streams" type:"list"`
}

// String returns the string representation
func (s ListStreamsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListStreamsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListStreamsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListStreamsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Streams) > 0 {
		v := s.Streams

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "streams", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type ListTargetsForPolicyInput struct {
	_ struct{} `type:"structure"`

	// A marker used to get the next set of results.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The maximum number of results to return at one time.
	PageSize *int64 `location:"querystring" locationName:"pageSize" min:"1" type:"integer"`

	// The policy name.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTargetsForPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTargetsForPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTargetsForPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTargetsForPolicyInput"}
	if s.PageSize != nil && *s.PageSize < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("PageSize", 1))
	}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTargetsForPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PageSize != nil {
		v := *s.PageSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "pageSize", protocol.Int64Value(v), metadata)
	}
	return nil
}

type ListTargetsForPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A marker used to get the next set of results.
	NextMarker *string `locationName:"nextMarker" type:"string"`

	// The policy targets.
	Targets []string `locationName:"targets" type:"list"`
}

// String returns the string representation
func (s ListTargetsForPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTargetsForPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTargetsForPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTargetsForPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Targets) > 0 {
		v := s.Targets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "targets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type ListThingGroupsForThingInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return at one time.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The thing name.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListThingGroupsForThingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingGroupsForThingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListThingGroupsForThingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListThingGroupsForThingInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingGroupsForThingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ListThingGroupsForThingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The thing groups.
	ThingGroups []GroupNameAndArn `locationName:"thingGroups" type:"list"`
}

// String returns the string representation
func (s ListThingGroupsForThingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingGroupsForThingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListThingGroupsForThingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingGroupsForThingOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ThingGroups) > 0 {
		v := s.ThingGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "thingGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type ListThingGroupsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return at one time.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// A filter that limits the results to those with the specified name prefix.
	NamePrefixFilter *string `location:"querystring" locationName:"namePrefixFilter" min:"1" type:"string"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// A filter that limits the results to those with the specified parent group.
	ParentGroup *string `location:"querystring" locationName:"parentGroup" min:"1" type:"string"`

	// If true, return child groups as well.
	Recursive *bool `location:"querystring" locationName:"recursive" type:"boolean"`
}

// String returns the string representation
func (s ListThingGroupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingGroupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListThingGroupsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListThingGroupsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.NamePrefixFilter != nil && len(*s.NamePrefixFilter) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NamePrefixFilter", 1))
	}
	if s.ParentGroup != nil && len(*s.ParentGroup) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ParentGroup", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingGroupsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NamePrefixFilter != nil {
		v := *s.NamePrefixFilter

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "namePrefixFilter", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentGroup != nil {
		v := *s.ParentGroup

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "parentGroup", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Recursive != nil {
		v := *s.Recursive

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "recursive", protocol.BoolValue(v), metadata)
	}
	return nil
}

type ListThingGroupsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The thing groups.
	ThingGroups []GroupNameAndArn `locationName:"thingGroups" type:"list"`
}

// String returns the string representation
func (s ListThingGroupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingGroupsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListThingGroupsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingGroupsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ThingGroups) > 0 {
		v := s.ThingGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "thingGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The input for the ListThingPrincipal operation.
type ListThingPrincipalsInput struct {
	_ struct{} `type:"structure"`

	// The name of the thing.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListThingPrincipalsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingPrincipalsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListThingPrincipalsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListThingPrincipalsInput"}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingPrincipalsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the ListThingPrincipals operation.
type ListThingPrincipalsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The principals associated with the thing.
	Principals []string `locationName:"principals" type:"list"`
}

// String returns the string representation
func (s ListThingPrincipalsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingPrincipalsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListThingPrincipalsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingPrincipalsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Principals) > 0 {
		v := s.Principals

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "principals", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type ListThingRegistrationTaskReportsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return per request.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token to retrieve the next set of results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The type of task report.
	//
	// ReportType is a required field
	ReportType ReportType `location:"querystring" locationName:"reportType" type:"string" required:"true" enum:"true"`

	// The id of the task.
	//
	// TaskId is a required field
	TaskId *string `location:"uri" locationName:"taskId" type:"string" required:"true"`
}

// String returns the string representation
func (s ListThingRegistrationTaskReportsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingRegistrationTaskReportsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListThingRegistrationTaskReportsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListThingRegistrationTaskReportsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if len(s.ReportType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ReportType"))
	}

	if s.TaskId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TaskId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingRegistrationTaskReportsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.TaskId != nil {
		v := *s.TaskId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "taskId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ReportType) > 0 {
		v := s.ReportType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "reportType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type ListThingRegistrationTaskReportsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token to retrieve the next set of results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The type of task report.
	ReportType ReportType `locationName:"reportType" type:"string" enum:"true"`

	// Links to the task resources.
	ResourceLinks []string `locationName:"resourceLinks" type:"list"`
}

// String returns the string representation
func (s ListThingRegistrationTaskReportsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingRegistrationTaskReportsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListThingRegistrationTaskReportsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingRegistrationTaskReportsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ReportType) > 0 {
		v := s.ReportType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "reportType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.ResourceLinks) > 0 {
		v := s.ResourceLinks

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "resourceLinks", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type ListThingRegistrationTasksInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return at one time.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The status of the bulk thing provisioning task.
	Status Status `location:"querystring" locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListThingRegistrationTasksInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingRegistrationTasksInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListThingRegistrationTasksInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListThingRegistrationTasksInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingRegistrationTasksInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type ListThingRegistrationTasksOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A list of bulk thing provisioning task IDs.
	TaskIds []string `locationName:"taskIds" type:"list"`
}

// String returns the string representation
func (s ListThingRegistrationTasksOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingRegistrationTasksOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListThingRegistrationTasksOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingRegistrationTasksOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TaskIds) > 0 {
		v := s.TaskIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "taskIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// The input for the ListThingTypes operation.
type ListThingTypesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return in this operation.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token for the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The name of the thing type.
	ThingTypeName *string `location:"querystring" locationName:"thingTypeName" min:"1" type:"string"`
}

// String returns the string representation
func (s ListThingTypesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingTypesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListThingTypesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListThingTypesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.ThingTypeName != nil && len(*s.ThingTypeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingTypeName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingTypesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output for the ListThingTypes operation.
type ListThingTypesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token for the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The thing types.
	ThingTypes []ThingTypeDefinition `locationName:"thingTypes" type:"list"`
}

// String returns the string representation
func (s ListThingTypesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingTypesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListThingTypesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingTypesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ThingTypes) > 0 {
		v := s.ThingTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "thingTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type ListThingsInThingGroupInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return at one time.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// When true, list things in this thing group and in all child groups as well.
	Recursive *bool `location:"querystring" locationName:"recursive" type:"boolean"`

	// The thing group name.
	//
	// ThingGroupName is a required field
	ThingGroupName *string `location:"uri" locationName:"thingGroupName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListThingsInThingGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingsInThingGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListThingsInThingGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListThingsInThingGroupInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ThingGroupName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingGroupName"))
	}
	if s.ThingGroupName != nil && len(*s.ThingGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingsInThingGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Recursive != nil {
		v := *s.Recursive

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "recursive", protocol.BoolValue(v), metadata)
	}
	return nil
}

type ListThingsInThingGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The things in the specified thing group.
	Things []string `locationName:"things" type:"list"`
}

// String returns the string representation
func (s ListThingsInThingGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingsInThingGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListThingsInThingGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingsInThingGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Things) > 0 {
		v := s.Things

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "things", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// The input for the ListThings operation.
type ListThingsInput struct {
	_ struct{} `type:"structure"`

	// The attribute name used to search for things.
	AttributeName *string `location:"querystring" locationName:"attributeName" type:"string"`

	// The attribute value used to search for things.
	AttributeValue *string `location:"querystring" locationName:"attributeValue" type:"string"`

	// The maximum number of results to return in this operation.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The name of the thing type used to search for things.
	ThingTypeName *string `location:"querystring" locationName:"thingTypeName" min:"1" type:"string"`
}

// String returns the string representation
func (s ListThingsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListThingsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListThingsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.ThingTypeName != nil && len(*s.ThingTypeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingTypeName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AttributeName != nil {
		v := *s.AttributeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "attributeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AttributeValue != nil {
		v := *s.AttributeValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "attributeValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the ListThings operation.
type ListThingsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The things.
	Things []ThingAttribute `locationName:"things" type:"list"`
}

// String returns the string representation
func (s ListThingsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListThingsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListThingsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListThingsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Things) > 0 {
		v := s.Things

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "things", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The input for the ListTopicRules operation.
type ListTopicRulesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// A token used to retrieve the next value.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// Specifies whether the rule is disabled.
	RuleDisabled *bool `location:"querystring" locationName:"ruleDisabled" type:"boolean"`

	// The topic.
	Topic *string `location:"querystring" locationName:"topic" type:"string"`
}

// String returns the string representation
func (s ListTopicRulesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTopicRulesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTopicRulesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTopicRulesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTopicRulesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleDisabled != nil {
		v := *s.RuleDisabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "ruleDisabled", protocol.BoolValue(v), metadata)
	}
	if s.Topic != nil {
		v := *s.Topic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "topic", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the ListTopicRules operation.
type ListTopicRulesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A token used to retrieve the next value.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The rules.
	Rules []TopicRuleListItem `locationName:"rules" type:"list"`
}

// String returns the string representation
func (s ListTopicRulesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTopicRulesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTopicRulesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTopicRulesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Rules) > 0 {
		v := s.Rules

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "rules", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type ListV2LoggingLevelsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to return at one time.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The type of resource for which you are configuring logging. Must be THING_Group.
	TargetType LogTargetType `location:"querystring" locationName:"targetType" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListV2LoggingLevelsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListV2LoggingLevelsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListV2LoggingLevelsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListV2LoggingLevelsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListV2LoggingLevelsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TargetType) > 0 {
		v := s.TargetType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "targetType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type ListV2LoggingLevelsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The logging configuration for a target.
	LogTargetConfigurations []LogTargetConfiguration `locationName:"logTargetConfigurations" type:"list"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListV2LoggingLevelsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListV2LoggingLevelsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListV2LoggingLevelsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListV2LoggingLevelsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.LogTargetConfigurations) > 0 {
		v := s.LogTargetConfigurations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "logTargetConfigurations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A log target.
type LogTarget struct {
	_ struct{} `type:"structure"`

	// The target name.
	TargetName *string `locationName:"targetName" type:"string"`

	// The target type.
	//
	// TargetType is a required field
	TargetType LogTargetType `locationName:"targetType" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s LogTarget) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LogTarget) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LogTarget) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LogTarget"}
	if len(s.TargetType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("TargetType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LogTarget) MarshalFields(e protocol.FieldEncoder) error {
	if s.TargetName != nil {
		v := *s.TargetName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "targetName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TargetType) > 0 {
		v := s.TargetType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "targetType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The target configuration.
type LogTargetConfiguration struct {
	_ struct{} `type:"structure"`

	// The logging level.
	LogLevel LogLevel `locationName:"logLevel" type:"string" enum:"true"`

	// A log target
	LogTarget *LogTarget `locationName:"logTarget" type:"structure"`
}

// String returns the string representation
func (s LogTargetConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LogTargetConfiguration) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LogTargetConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.LogLevel) > 0 {
		v := s.LogLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "logLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.LogTarget != nil {
		v := s.LogTarget

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logTarget", v, metadata)
	}
	return nil
}

// Describes the logging options payload.
type LoggingOptionsPayload struct {
	_ struct{} `type:"structure"`

	// The log level.
	LogLevel LogLevel `locationName:"logLevel" type:"string" enum:"true"`

	// The ARN of the IAM role that grants access.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`
}

// String returns the string representation
func (s LoggingOptionsPayload) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LoggingOptionsPayload) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LoggingOptionsPayload) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LoggingOptionsPayload"}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LoggingOptionsPayload) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.LogLevel) > 0 {
		v := s.LogLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "logLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a file to be associated with an OTA update.
type OTAUpdateFile struct {
	_ struct{} `type:"structure"`

	// A list of name/attribute pairs.
	Attributes map[string]string `locationName:"attributes" type:"map"`

	// The code signing method of the file.
	CodeSigning *CodeSigning `locationName:"codeSigning" type:"structure"`

	// The name of the file.
	FileName *string `locationName:"fileName" type:"string"`

	// The source of the file.
	FileSource *Stream `locationName:"fileSource" type:"structure"`

	// The file version.
	FileVersion *string `locationName:"fileVersion" type:"string"`
}

// String returns the string representation
func (s OTAUpdateFile) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OTAUpdateFile) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *OTAUpdateFile) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "OTAUpdateFile"}
	if s.CodeSigning != nil {
		if err := s.CodeSigning.Validate(); err != nil {
			invalidParams.AddNested("CodeSigning", err.(aws.ErrInvalidParams))
		}
	}
	if s.FileSource != nil {
		if err := s.FileSource.Validate(); err != nil {
			invalidParams.AddNested("FileSource", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OTAUpdateFile) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "attributes", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.CodeSigning != nil {
		v := s.CodeSigning

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "codeSigning", v, metadata)
	}
	if s.FileName != nil {
		v := *s.FileName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "fileName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FileSource != nil {
		v := s.FileSource

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "fileSource", v, metadata)
	}
	if s.FileVersion != nil {
		v := *s.FileVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "fileVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about an OTA update.
type OTAUpdateInfo struct {
	_ struct{} `type:"structure"`

	// A collection of name/value pairs
	AdditionalParameters map[string]string `locationName:"additionalParameters" type:"map"`

	// The AWS IoT job ARN associated with the OTA update.
	AwsIotJobArn *string `locationName:"awsIotJobArn" type:"string"`

	// The AWS IoT job ID associated with the OTA update.
	AwsIotJobId *string `locationName:"awsIotJobId" type:"string"`

	// The date when the OTA update was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// A description of the OTA update.
	Description *string `locationName:"description" type:"string"`

	// Error information associated with the OTA update.
	ErrorInfo *ErrorInfo `locationName:"errorInfo" type:"structure"`

	// The date when the OTA update was last updated.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`

	// The OTA update ARN.
	OtaUpdateArn *string `locationName:"otaUpdateArn" type:"string"`

	// A list of files associated with the OTA update.
	OtaUpdateFiles []OTAUpdateFile `locationName:"otaUpdateFiles" min:"1" type:"list"`

	// The OTA update ID.
	OtaUpdateId *string `locationName:"otaUpdateId" min:"1" type:"string"`

	// The status of the OTA update.
	OtaUpdateStatus OTAUpdateStatus `locationName:"otaUpdateStatus" type:"string" enum:"true"`

	// Specifies whether the OTA update will continue to run (CONTINUOUS), or will
	// be complete after all those things specified as targets have completed the
	// OTA update (SNAPSHOT). If continuous, the OTA update may also be run on a
	// thing when a change is detected in a target. For example, an OTA update will
	// run on a thing when the thing is added to a target group, even after the
	// OTA update was completed by all things originally in the group.
	TargetSelection TargetSelection `locationName:"targetSelection" type:"string" enum:"true"`

	// The targets of the OTA update.
	Targets []string `locationName:"targets" min:"1" type:"list"`
}

// String returns the string representation
func (s OTAUpdateInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OTAUpdateInfo) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OTAUpdateInfo) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AdditionalParameters) > 0 {
		v := s.AdditionalParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "additionalParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.AwsIotJobArn != nil {
		v := *s.AwsIotJobArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsIotJobArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AwsIotJobId != nil {
		v := *s.AwsIotJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsIotJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ErrorInfo != nil {
		v := s.ErrorInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "errorInfo", v, metadata)
	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.OtaUpdateArn != nil {
		v := *s.OtaUpdateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "otaUpdateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OtaUpdateFiles) > 0 {
		v := s.OtaUpdateFiles

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "otaUpdateFiles", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.OtaUpdateId != nil {
		v := *s.OtaUpdateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "otaUpdateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OtaUpdateStatus) > 0 {
		v := s.OtaUpdateStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "otaUpdateStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.TargetSelection) > 0 {
		v := s.TargetSelection

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "targetSelection", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Targets) > 0 {
		v := s.Targets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "targets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// An OTA update summary.
type OTAUpdateSummary struct {
	_ struct{} `type:"structure"`

	// The date when the OTA update was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The OTA update ARN.
	OtaUpdateArn *string `locationName:"otaUpdateArn" type:"string"`

	// The OTA update ID.
	OtaUpdateId *string `locationName:"otaUpdateId" min:"1" type:"string"`
}

// String returns the string representation
func (s OTAUpdateSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OTAUpdateSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OTAUpdateSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.OtaUpdateArn != nil {
		v := *s.OtaUpdateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "otaUpdateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OtaUpdateId != nil {
		v := *s.OtaUpdateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "otaUpdateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A certificate that has been transferred but not yet accepted.
type OutgoingCertificate struct {
	_ struct{} `type:"structure"`

	// The certificate ARN.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The certificate ID.
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`

	// The certificate creation date.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The date the transfer was initiated.
	TransferDate *time.Time `locationName:"transferDate" type:"timestamp" timestampFormat:"unix"`

	// The transfer message.
	TransferMessage *string `locationName:"transferMessage" type:"string"`

	// The AWS account to which the transfer was made.
	TransferredTo *string `locationName:"transferredTo" type:"string"`
}

// String returns the string representation
func (s OutgoingCertificate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OutgoingCertificate) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OutgoingCertificate) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.TransferDate != nil {
		v := *s.TransferDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "transferDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.TransferMessage != nil {
		v := *s.TransferMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "transferMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TransferredTo != nil {
		v := *s.TransferredTo

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "transferredTo", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an AWS IoT policy.
type Policy struct {
	_ struct{} `type:"structure"`

	// The policy ARN.
	PolicyArn *string `locationName:"policyArn" type:"string"`

	// The policy name.
	PolicyName *string `locationName:"policyName" min:"1" type:"string"`
}

// String returns the string representation
func (s Policy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Policy) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Policy) MarshalFields(e protocol.FieldEncoder) error {
	if s.PolicyArn != nil {
		v := *s.PolicyArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a policy version.
type PolicyVersion struct {
	_ struct{} `type:"structure"`

	// The date and time the policy was created.
	CreateDate *time.Time `locationName:"createDate" type:"timestamp" timestampFormat:"unix"`

	// Specifies whether the policy version is the default.
	IsDefaultVersion *bool `locationName:"isDefaultVersion" type:"boolean"`

	// The policy version ID.
	VersionId *string `locationName:"versionId" type:"string"`
}

// String returns the string representation
func (s PolicyVersion) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PolicyVersion) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PolicyVersion) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreateDate != nil {
		v := *s.CreateDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.IsDefaultVersion != nil {
		v := *s.IsDefaultVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "isDefaultVersion", protocol.BoolValue(v), metadata)
	}
	if s.VersionId != nil {
		v := *s.VersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "versionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Configuration for pre-signed S3 URLs.
type PresignedUrlConfig struct {
	_ struct{} `type:"structure"`

	// How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600,
	// the default value is 3600 seconds. Pre-signed URLs are generated when Jobs
	// receives an MQTT request for the job document.
	ExpiresInSec *int64 `locationName:"expiresInSec" min:"60" type:"long"`

	// The ARN of an IAM role that grants grants permission to download files from
	// the S3 bucket where the job data/updates are stored. The role must also grant
	// permission for IoT to download the files.
	RoleArn *string `locationName:"roleArn" min:"20" type:"string"`
}

// String returns the string representation
func (s PresignedUrlConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PresignedUrlConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PresignedUrlConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PresignedUrlConfig"}
	if s.ExpiresInSec != nil && *s.ExpiresInSec < 60 {
		invalidParams.Add(aws.NewErrParamMinValue("ExpiresInSec", 60))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PresignedUrlConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.ExpiresInSec != nil {
		v := *s.ExpiresInSec

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "expiresInSec", protocol.Int64Value(v), metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the DynamoActionVS action that specifies the DynamoDB table
// to which the message data will be written.
type PutItemInput struct {
	_ struct{} `type:"structure"`

	// The table where the message data will be written
	//
	// TableName is a required field
	TableName *string `locationName:"tableName" type:"string" required:"true"`
}

// String returns the string representation
func (s PutItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutItemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutItemInput"}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutItemInput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TableName != nil {
		v := *s.TableName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tableName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input to the RegisterCACertificate operation.
type RegisterCACertificateInput struct {
	_ struct{} `type:"structure"`

	// Allows this CA certificate to be used for auto registration of device certificates.
	AllowAutoRegistration *bool `location:"querystring" locationName:"allowAutoRegistration" type:"boolean"`

	// The CA certificate.
	//
	// CaCertificate is a required field
	CaCertificate *string `locationName:"caCertificate" min:"1" type:"string" required:"true"`

	// Information about the registration configuration.
	RegistrationConfig *RegistrationConfig `locationName:"registrationConfig" type:"structure"`

	// A boolean value that specifies if the CA certificate is set to active.
	SetAsActive *bool `location:"querystring" locationName:"setAsActive" type:"boolean"`

	// The private key verification certificate.
	//
	// VerificationCertificate is a required field
	VerificationCertificate *string `locationName:"verificationCertificate" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RegisterCACertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterCACertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RegisterCACertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RegisterCACertificateInput"}

	if s.CaCertificate == nil {
		invalidParams.Add(aws.NewErrParamRequired("CaCertificate"))
	}
	if s.CaCertificate != nil && len(*s.CaCertificate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CaCertificate", 1))
	}

	if s.VerificationCertificate == nil {
		invalidParams.Add(aws.NewErrParamRequired("VerificationCertificate"))
	}
	if s.VerificationCertificate != nil && len(*s.VerificationCertificate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VerificationCertificate", 1))
	}
	if s.RegistrationConfig != nil {
		if err := s.RegistrationConfig.Validate(); err != nil {
			invalidParams.AddNested("RegistrationConfig", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegisterCACertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CaCertificate != nil {
		v := *s.CaCertificate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "caCertificate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RegistrationConfig != nil {
		v := s.RegistrationConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "registrationConfig", v, metadata)
	}
	if s.VerificationCertificate != nil {
		v := *s.VerificationCertificate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "verificationCertificate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AllowAutoRegistration != nil {
		v := *s.AllowAutoRegistration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "allowAutoRegistration", protocol.BoolValue(v), metadata)
	}
	if s.SetAsActive != nil {
		v := *s.SetAsActive

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "setAsActive", protocol.BoolValue(v), metadata)
	}
	return nil
}

// The output from the RegisterCACertificateResponse operation.
type RegisterCACertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The CA certificate ARN.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The CA certificate identifier.
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`
}

// String returns the string representation
func (s RegisterCACertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterCACertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RegisterCACertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegisterCACertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input to the RegisterCertificate operation.
type RegisterCertificateInput struct {
	_ struct{} `type:"structure"`

	// The CA certificate used to sign the device certificate being registered.
	CaCertificatePem *string `locationName:"caCertificatePem" min:"1" type:"string"`

	// The certificate data, in PEM format.
	//
	// CertificatePem is a required field
	CertificatePem *string `locationName:"certificatePem" min:"1" type:"string" required:"true"`

	// A boolean value that specifies if the CA certificate is set to active.
	SetAsActive *bool `location:"querystring" locationName:"setAsActive" deprecated:"true" type:"boolean"`

	// The status of the register certificate request.
	Status CertificateStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s RegisterCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterCertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RegisterCertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RegisterCertificateInput"}
	if s.CaCertificatePem != nil && len(*s.CaCertificatePem) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CaCertificatePem", 1))
	}

	if s.CertificatePem == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificatePem"))
	}
	if s.CertificatePem != nil && len(*s.CertificatePem) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificatePem", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegisterCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CaCertificatePem != nil {
		v := *s.CaCertificatePem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "caCertificatePem", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificatePem != nil {
		v := *s.CertificatePem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificatePem", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SetAsActive != nil {
		v := *s.SetAsActive

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "setAsActive", protocol.BoolValue(v), metadata)
	}
	return nil
}

// The output from the RegisterCertificate operation.
type RegisterCertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The certificate ARN.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The certificate identifier.
	CertificateId *string `locationName:"certificateId" min:"64" type:"string"`
}

// String returns the string representation
func (s RegisterCertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterCertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RegisterCertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegisterCertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type RegisterThingInput struct {
	_ struct{} `type:"structure"`

	// The parameters for provisioning a thing. See Programmatic Provisioning (http://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html)
	// for more information.
	Parameters map[string]string `locationName:"parameters" type:"map"`

	// The provisioning template. See Programmatic Provisioning (http://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html)
	// for more information.
	//
	// TemplateBody is a required field
	TemplateBody *string `locationName:"templateBody" type:"string" required:"true"`
}

// String returns the string representation
func (s RegisterThingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterThingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RegisterThingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RegisterThingInput"}

	if s.TemplateBody == nil {
		invalidParams.Add(aws.NewErrParamRequired("TemplateBody"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegisterThingInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.TemplateBody != nil {
		v := *s.TemplateBody

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "templateBody", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type RegisterThingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The PEM of a certificate.
	CertificatePem *string `locationName:"certificatePem" min:"1" type:"string"`

	// ARNs for the generated resources.
	ResourceArns map[string]string `locationName:"resourceArns" type:"map"`
}

// String returns the string representation
func (s RegisterThingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterThingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RegisterThingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegisterThingOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificatePem != nil {
		v := *s.CertificatePem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificatePem", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceArns) > 0 {
		v := s.ResourceArns

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "resourceArns", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// The registration configuration.
type RegistrationConfig struct {
	_ struct{} `type:"structure"`

	// The ARN of the role.
	RoleArn *string `locationName:"roleArn" min:"20" type:"string"`

	// The template body.
	TemplateBody *string `locationName:"templateBody" type:"string"`
}

// String returns the string representation
func (s RegistrationConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegistrationConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RegistrationConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RegistrationConfig"}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegistrationConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TemplateBody != nil {
		v := *s.TemplateBody

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "templateBody", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the RejectCertificateTransfer operation.
type RejectCertificateTransferInput struct {
	_ struct{} `type:"structure"`

	// The ID of the certificate. (The last part of the certificate ARN contains
	// the certificate ID.)
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"certificateId" min:"64" type:"string" required:"true"`

	// The reason the certificate transfer was rejected.
	RejectReason *string `locationName:"rejectReason" type:"string"`
}

// String returns the string representation
func (s RejectCertificateTransferInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RejectCertificateTransferInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RejectCertificateTransferInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RejectCertificateTransferInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RejectCertificateTransferInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RejectReason != nil {
		v := *s.RejectReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "rejectReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type RejectCertificateTransferOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s RejectCertificateTransferOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RejectCertificateTransferOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RejectCertificateTransferOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RejectCertificateTransferOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type RemoveThingFromThingGroupInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the thing to remove from the group.
	ThingArn *string `locationName:"thingArn" type:"string"`

	// The group ARN.
	ThingGroupArn *string `locationName:"thingGroupArn" type:"string"`

	// The group name.
	ThingGroupName *string `locationName:"thingGroupName" min:"1" type:"string"`

	// The name of the thing to remove from the group.
	ThingName *string `locationName:"thingName" min:"1" type:"string"`
}

// String returns the string representation
func (s RemoveThingFromThingGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveThingFromThingGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RemoveThingFromThingGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RemoveThingFromThingGroupInput"}
	if s.ThingGroupName != nil && len(*s.ThingGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupName", 1))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveThingFromThingGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingArn != nil {
		v := *s.ThingArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupArn != nil {
		v := *s.ThingGroupArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type RemoveThingFromThingGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s RemoveThingFromThingGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveThingFromThingGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RemoveThingFromThingGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveThingFromThingGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the ReplaceTopicRule operation.
type ReplaceTopicRuleInput struct {
	_ struct{} `type:"structure" payload:"TopicRulePayload"`

	// The name of the rule.
	//
	// RuleName is a required field
	RuleName *string `location:"uri" locationName:"ruleName" min:"1" type:"string" required:"true"`

	// The rule payload.
	//
	// TopicRulePayload is a required field
	TopicRulePayload *TopicRulePayload `locationName:"topicRulePayload" type:"structure" required:"true"`
}

// String returns the string representation
func (s ReplaceTopicRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplaceTopicRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplaceTopicRuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ReplaceTopicRuleInput"}

	if s.RuleName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleName"))
	}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if s.TopicRulePayload == nil {
		invalidParams.Add(aws.NewErrParamRequired("TopicRulePayload"))
	}
	if s.TopicRulePayload != nil {
		if err := s.TopicRulePayload.Validate(); err != nil {
			invalidParams.AddNested("TopicRulePayload", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReplaceTopicRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ruleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TopicRulePayload != nil {
		v := s.TopicRulePayload

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "topicRulePayload", v, metadata)
	}
	return nil
}

type ReplaceTopicRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s ReplaceTopicRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplaceTopicRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ReplaceTopicRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReplaceTopicRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes an action to republish to another topic.
type RepublishAction struct {
	_ struct{} `type:"structure"`

	// The ARN of the IAM role that grants access.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// The name of the MQTT topic.
	//
	// Topic is a required field
	Topic *string `locationName:"topic" type:"string" required:"true"`
}

// String returns the string representation
func (s RepublishAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepublishAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RepublishAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RepublishAction"}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if s.Topic == nil {
		invalidParams.Add(aws.NewErrParamRequired("Topic"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RepublishAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Topic != nil {
		v := *s.Topic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "topic", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Role alias description.
type RoleAliasDescription struct {
	_ struct{} `type:"structure"`

	// The UNIX timestamp of when the role alias was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The number of seconds for which the credential is valid.
	CredentialDurationSeconds *int64 `locationName:"credentialDurationSeconds" min:"900" type:"integer"`

	// The UNIX timestamp of when the role alias was last modified.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp" timestampFormat:"unix"`

	// The role alias owner.
	Owner *string `locationName:"owner" type:"string"`

	// The role alias.
	RoleAlias *string `locationName:"roleAlias" min:"1" type:"string"`

	// The ARN of the role alias.
	RoleAliasArn *string `locationName:"roleAliasArn" type:"string"`

	// The role ARN.
	RoleArn *string `locationName:"roleArn" min:"20" type:"string"`
}

// String returns the string representation
func (s RoleAliasDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RoleAliasDescription) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RoleAliasDescription) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CredentialDurationSeconds != nil {
		v := *s.CredentialDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "credentialDurationSeconds", protocol.Int64Value(v), metadata)
	}
	if s.LastModifiedDate != nil {
		v := *s.LastModifiedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastModifiedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Owner != nil {
		v := *s.Owner

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "owner", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleAlias != nil {
		v := *s.RoleAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleAliasArn != nil {
		v := *s.RoleAliasArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleAliasArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an action to write data to an Amazon S3 bucket.
type S3Action struct {
	_ struct{} `type:"structure"`

	// The Amazon S3 bucket.
	//
	// BucketName is a required field
	BucketName *string `locationName:"bucketName" type:"string" required:"true"`

	// The Amazon S3 canned ACL that controls access to the object identified by
	// the object key. For more information, see S3 canned ACLs (http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl).
	CannedAcl CannedAccessControlList `locationName:"cannedAcl" type:"string" enum:"true"`

	// The object key.
	//
	// Key is a required field
	Key *string `locationName:"key" type:"string" required:"true"`

	// The ARN of the IAM role that grants access.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`
}

// String returns the string representation
func (s S3Action) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s S3Action) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Action) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Action"}

	if s.BucketName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BucketName"))
	}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Action) MarshalFields(e protocol.FieldEncoder) error {
	if s.BucketName != nil {
		v := *s.BucketName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "bucketName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.CannedAcl) > 0 {
		v := s.CannedAcl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cannedAcl", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The location in S3 the contains the files to stream.
type S3Location struct {
	_ struct{} `type:"structure"`

	// The S3 bucket that contains the file to stream.
	//
	// Bucket is a required field
	Bucket *string `locationName:"bucket" min:"1" type:"string" required:"true"`

	// The name of the file within the S3 bucket to stream.
	//
	// Key is a required field
	Key *string `locationName:"key" min:"1" type:"string" required:"true"`

	// The file version.
	Version *string `locationName:"version" type:"string"`
}

// String returns the string representation
func (s S3Location) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s S3Location) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Location) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Location"}

	if s.Bucket == nil {
		invalidParams.Add(aws.NewErrParamRequired("Bucket"))
	}
	if s.Bucket != nil && len(*s.Bucket) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Bucket", 1))
	}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Location) MarshalFields(e protocol.FieldEncoder) error {
	if s.Bucket != nil {
		v := *s.Bucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "bucket", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an action to write a message to a Salesforce IoT Cloud Input Stream.
type SalesforceAction struct {
	_ struct{} `type:"structure"`

	// The token used to authenticate access to the Salesforce IoT Cloud Input Stream.
	// The token is available from the Salesforce IoT Cloud platform after creation
	// of the Input Stream.
	//
	// Token is a required field
	Token *string `locationName:"token" min:"40" type:"string" required:"true"`

	// The URL exposed by the Salesforce IoT Cloud Input Stream. The URL is available
	// from the Salesforce IoT Cloud platform after creation of the Input Stream.
	//
	// Url is a required field
	Url *string `locationName:"url" type:"string" required:"true"`
}

// String returns the string representation
func (s SalesforceAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SalesforceAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SalesforceAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SalesforceAction"}

	if s.Token == nil {
		invalidParams.Add(aws.NewErrParamRequired("Token"))
	}
	if s.Token != nil && len(*s.Token) < 40 {
		invalidParams.Add(aws.NewErrParamMinLen("Token", 40))
	}

	if s.Url == nil {
		invalidParams.Add(aws.NewErrParamRequired("Url"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SalesforceAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.Token != nil {
		v := *s.Token

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "token", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Url != nil {
		v := *s.Url

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "url", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type SearchIndexInput struct {
	_ struct{} `type:"structure"`

	// The search index name.
	IndexName *string `locationName:"indexName" min:"1" type:"string"`

	// The maximum number of results to return at one time.
	MaxResults *int64 `locationName:"maxResults" min:"1" type:"integer"`

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The search query string.
	//
	// QueryString is a required field
	QueryString *string `locationName:"queryString" min:"1" type:"string" required:"true"`

	// The query version.
	QueryVersion *string `locationName:"queryVersion" type:"string"`
}

// String returns the string representation
func (s SearchIndexInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SearchIndexInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SearchIndexInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SearchIndexInput"}
	if s.IndexName != nil && len(*s.IndexName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 1))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.QueryString == nil {
		invalidParams.Add(aws.NewErrParamRequired("QueryString"))
	}
	if s.QueryString != nil && len(*s.QueryString) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("QueryString", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SearchIndexInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.IndexName != nil {
		v := *s.IndexName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "indexName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.QueryString != nil {
		v := *s.QueryString

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "queryString", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.QueryVersion != nil {
		v := *s.QueryVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "queryVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type SearchIndexOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token used to get the next set of results, or null if there are no additional
	// results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The things that match the search query.
	Things []ThingDocument `locationName:"things" type:"list"`
}

// String returns the string representation
func (s SearchIndexOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SearchIndexOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SearchIndexOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SearchIndexOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Things) > 0 {
		v := s.Things

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "things", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type SetDefaultAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// The authorizer name.
	//
	// AuthorizerName is a required field
	AuthorizerName *string `locationName:"authorizerName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s SetDefaultAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetDefaultAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SetDefaultAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SetDefaultAuthorizerInput"}

	if s.AuthorizerName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerName"))
	}
	if s.AuthorizerName != nil && len(*s.AuthorizerName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthorizerName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetDefaultAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type SetDefaultAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The authorizer ARN.
	AuthorizerArn *string `locationName:"authorizerArn" type:"string"`

	// The authorizer name.
	AuthorizerName *string `locationName:"authorizerName" min:"1" type:"string"`
}

// String returns the string representation
func (s SetDefaultAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetDefaultAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SetDefaultAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetDefaultAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthorizerArn != nil {
		v := *s.AuthorizerArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the SetDefaultPolicyVersion operation.
type SetDefaultPolicyVersionInput struct {
	_ struct{} `type:"structure"`

	// The policy name.
	//
	// PolicyName is a required field
	PolicyName *string `location:"uri" locationName:"policyName" min:"1" type:"string" required:"true"`

	// The policy version ID.
	//
	// PolicyVersionId is a required field
	PolicyVersionId *string `location:"uri" locationName:"policyVersionId" type:"string" required:"true"`
}

// String returns the string representation
func (s SetDefaultPolicyVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetDefaultPolicyVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SetDefaultPolicyVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SetDefaultPolicyVersionInput"}

	if s.PolicyName == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if s.PolicyVersionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyVersionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetDefaultPolicyVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PolicyName != nil {
		v := *s.PolicyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyVersionId != nil {
		v := *s.PolicyVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "policyVersionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type SetDefaultPolicyVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s SetDefaultPolicyVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetDefaultPolicyVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SetDefaultPolicyVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetDefaultPolicyVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the SetLoggingOptions operation.
type SetLoggingOptionsInput struct {
	_ struct{} `type:"structure" payload:"LoggingOptionsPayload"`

	// The logging options payload.
	//
	// LoggingOptionsPayload is a required field
	LoggingOptionsPayload *LoggingOptionsPayload `locationName:"loggingOptionsPayload" type:"structure" required:"true"`
}

// String returns the string representation
func (s SetLoggingOptionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetLoggingOptionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SetLoggingOptionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SetLoggingOptionsInput"}

	if s.LoggingOptionsPayload == nil {
		invalidParams.Add(aws.NewErrParamRequired("LoggingOptionsPayload"))
	}
	if s.LoggingOptionsPayload != nil {
		if err := s.LoggingOptionsPayload.Validate(); err != nil {
			invalidParams.AddNested("LoggingOptionsPayload", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetLoggingOptionsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.LoggingOptionsPayload != nil {
		v := s.LoggingOptionsPayload

		metadata := protocol.Metadata{}
		e.SetFields(protocol.PayloadTarget, "loggingOptionsPayload", v, metadata)
	}
	return nil
}

type SetLoggingOptionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s SetLoggingOptionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetLoggingOptionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SetLoggingOptionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetLoggingOptionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type SetV2LoggingLevelInput struct {
	_ struct{} `type:"structure"`

	// The log level.
	//
	// LogLevel is a required field
	LogLevel LogLevel `locationName:"logLevel" type:"string" required:"true" enum:"true"`

	// The log target.
	//
	// LogTarget is a required field
	LogTarget *LogTarget `locationName:"logTarget" type:"structure" required:"true"`
}

// String returns the string representation
func (s SetV2LoggingLevelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetV2LoggingLevelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SetV2LoggingLevelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SetV2LoggingLevelInput"}
	if len(s.LogLevel) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("LogLevel"))
	}

	if s.LogTarget == nil {
		invalidParams.Add(aws.NewErrParamRequired("LogTarget"))
	}
	if s.LogTarget != nil {
		if err := s.LogTarget.Validate(); err != nil {
			invalidParams.AddNested("LogTarget", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetV2LoggingLevelInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.LogLevel) > 0 {
		v := s.LogLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "logLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.LogTarget != nil {
		v := s.LogTarget

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logTarget", v, metadata)
	}
	return nil
}

type SetV2LoggingLevelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s SetV2LoggingLevelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetV2LoggingLevelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SetV2LoggingLevelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetV2LoggingLevelOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type SetV2LoggingOptionsInput struct {
	_ struct{} `type:"structure"`

	// The default logging level.
	DefaultLogLevel LogLevel `locationName:"defaultLogLevel" type:"string" enum:"true"`

	// Set to true to disable all logs, otherwise set to false.
	DisableAllLogs *bool `locationName:"disableAllLogs" type:"boolean"`

	// The role ARN that allows IoT to write to Cloudwatch logs.
	RoleArn *string `locationName:"roleArn" type:"string"`
}

// String returns the string representation
func (s SetV2LoggingOptionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetV2LoggingOptionsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetV2LoggingOptionsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.DefaultLogLevel) > 0 {
		v := s.DefaultLogLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultLogLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DisableAllLogs != nil {
		v := *s.DisableAllLogs

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "disableAllLogs", protocol.BoolValue(v), metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type SetV2LoggingOptionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s SetV2LoggingOptionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetV2LoggingOptionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SetV2LoggingOptionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SetV2LoggingOptionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes an action to publish to an Amazon SNS topic.
type SnsAction struct {
	_ struct{} `type:"structure"`

	// (Optional) The message format of the message to publish. Accepted values
	// are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses
	// this setting to determine if the payload should be parsed and relevant platform-specific
	// bits of the payload should be extracted. To read more about SNS message formats,
	// see http://docs.aws.amazon.com/sns/latest/dg/json-formats.html (http://docs.aws.amazon.com/sns/latest/dg/json-formats.html)
	// refer to their official documentation.
	MessageFormat MessageFormat `locationName:"messageFormat" type:"string" enum:"true"`

	// The ARN of the IAM role that grants access.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// The ARN of the SNS topic.
	//
	// TargetArn is a required field
	TargetArn *string `locationName:"targetArn" type:"string" required:"true"`
}

// String returns the string representation
func (s SnsAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SnsAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SnsAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SnsAction"}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if s.TargetArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SnsAction) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.MessageFormat) > 0 {
		v := s.MessageFormat

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "messageFormat", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TargetArn != nil {
		v := *s.TargetArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "targetArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes an action to publish data to an Amazon SQS queue.
type SqsAction struct {
	_ struct{} `type:"structure"`

	// The URL of the Amazon SQS queue.
	//
	// QueueUrl is a required field
	QueueUrl *string `locationName:"queueUrl" type:"string" required:"true"`

	// The ARN of the IAM role that grants access.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" type:"string" required:"true"`

	// Specifies whether to use Base64 encoding.
	UseBase64 *bool `locationName:"useBase64" type:"boolean"`
}

// String returns the string representation
func (s SqsAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SqsAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SqsAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SqsAction"}

	if s.QueueUrl == nil {
		invalidParams.Add(aws.NewErrParamRequired("QueueUrl"))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SqsAction) MarshalFields(e protocol.FieldEncoder) error {
	if s.QueueUrl != nil {
		v := *s.QueueUrl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "queueUrl", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UseBase64 != nil {
		v := *s.UseBase64

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "useBase64", protocol.BoolValue(v), metadata)
	}
	return nil
}

type StartThingRegistrationTaskInput struct {
	_ struct{} `type:"structure"`

	// The S3 bucket that contains the input file.
	//
	// InputFileBucket is a required field
	InputFileBucket *string `locationName:"inputFileBucket" min:"3" type:"string" required:"true"`

	// The name of input file within the S3 bucket. This file contains a newline
	// delimited JSON file. Each line contains the parameter values to provision
	// one device (thing).
	//
	// InputFileKey is a required field
	InputFileKey *string `locationName:"inputFileKey" min:"1" type:"string" required:"true"`

	// The IAM role ARN that grants permission the input file.
	//
	// RoleArn is a required field
	RoleArn *string `locationName:"roleArn" min:"20" type:"string" required:"true"`

	// The provisioning template.
	//
	// TemplateBody is a required field
	TemplateBody *string `locationName:"templateBody" type:"string" required:"true"`
}

// String returns the string representation
func (s StartThingRegistrationTaskInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartThingRegistrationTaskInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartThingRegistrationTaskInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartThingRegistrationTaskInput"}

	if s.InputFileBucket == nil {
		invalidParams.Add(aws.NewErrParamRequired("InputFileBucket"))
	}
	if s.InputFileBucket != nil && len(*s.InputFileBucket) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("InputFileBucket", 3))
	}

	if s.InputFileKey == nil {
		invalidParams.Add(aws.NewErrParamRequired("InputFileKey"))
	}
	if s.InputFileKey != nil && len(*s.InputFileKey) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("InputFileKey", 1))
	}

	if s.RoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleArn"))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}

	if s.TemplateBody == nil {
		invalidParams.Add(aws.NewErrParamRequired("TemplateBody"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartThingRegistrationTaskInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.InputFileBucket != nil {
		v := *s.InputFileBucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "inputFileBucket", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InputFileKey != nil {
		v := *s.InputFileKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "inputFileKey", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TemplateBody != nil {
		v := *s.TemplateBody

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "templateBody", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type StartThingRegistrationTaskOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The bulk thing provisioning task ID.
	TaskId *string `locationName:"taskId" type:"string"`
}

// String returns the string representation
func (s StartThingRegistrationTaskOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartThingRegistrationTaskOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartThingRegistrationTaskOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartThingRegistrationTaskOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TaskId != nil {
		v := *s.TaskId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "taskId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type StopThingRegistrationTaskInput struct {
	_ struct{} `type:"structure"`

	// The bulk thing provisioning task ID.
	//
	// TaskId is a required field
	TaskId *string `location:"uri" locationName:"taskId" type:"string" required:"true"`
}

// String returns the string representation
func (s StopThingRegistrationTaskInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopThingRegistrationTaskInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StopThingRegistrationTaskInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StopThingRegistrationTaskInput"}

	if s.TaskId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TaskId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StopThingRegistrationTaskInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.TaskId != nil {
		v := *s.TaskId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "taskId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type StopThingRegistrationTaskOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s StopThingRegistrationTaskOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopThingRegistrationTaskOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StopThingRegistrationTaskOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StopThingRegistrationTaskOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes a group of files that can be streamed.
type Stream struct {
	_ struct{} `type:"structure"`

	// The ID of a file associated with a stream.
	FileId *int64 `locationName:"fileId" type:"integer"`

	// The stream ID.
	StreamId *string `locationName:"streamId" min:"1" type:"string"`
}

// String returns the string representation
func (s Stream) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Stream) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Stream) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Stream"}
	if s.StreamId != nil && len(*s.StreamId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StreamId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Stream) MarshalFields(e protocol.FieldEncoder) error {
	if s.FileId != nil {
		v := *s.FileId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "fileId", protocol.Int64Value(v), metadata)
	}
	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a file to stream.
type StreamFile struct {
	_ struct{} `type:"structure"`

	// The file ID.
	FileId *int64 `locationName:"fileId" type:"integer"`

	// The location of the file in S3.
	S3Location *S3Location `locationName:"s3Location" type:"structure"`
}

// String returns the string representation
func (s StreamFile) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StreamFile) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StreamFile) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StreamFile"}
	if s.S3Location != nil {
		if err := s.S3Location.Validate(); err != nil {
			invalidParams.AddNested("S3Location", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StreamFile) MarshalFields(e protocol.FieldEncoder) error {
	if s.FileId != nil {
		v := *s.FileId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "fileId", protocol.Int64Value(v), metadata)
	}
	if s.S3Location != nil {
		v := s.S3Location

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "s3Location", v, metadata)
	}
	return nil
}

// Information about a stream.
type StreamInfo struct {
	_ struct{} `type:"structure"`

	// The date when the stream was created.
	CreatedAt *time.Time `locationName:"createdAt" type:"timestamp" timestampFormat:"unix"`

	// The description of the stream.
	Description *string `locationName:"description" type:"string"`

	// The files to stream.
	Files []StreamFile `locationName:"files" min:"1" type:"list"`

	// The date when the stream was last updated.
	LastUpdatedAt *time.Time `locationName:"lastUpdatedAt" type:"timestamp" timestampFormat:"unix"`

	// An IAM role AWS IoT assumes to access your S3 files.
	RoleArn *string `locationName:"roleArn" min:"20" type:"string"`

	// The stream ARN.
	StreamArn *string `locationName:"streamArn" type:"string"`

	// The stream ID.
	StreamId *string `locationName:"streamId" min:"1" type:"string"`

	// The stream version.
	StreamVersion *int64 `locationName:"streamVersion" type:"integer"`
}

// String returns the string representation
func (s StreamInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StreamInfo) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StreamInfo) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Files) > 0 {
		v := s.Files

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "files", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.LastUpdatedAt != nil {
		v := *s.LastUpdatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamArn != nil {
		v := *s.StreamArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamVersion != nil {
		v := *s.StreamVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamVersion", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A summary of a stream.
type StreamSummary struct {
	_ struct{} `type:"structure"`

	// A description of the stream.
	Description *string `locationName:"description" type:"string"`

	// The stream ARN.
	StreamArn *string `locationName:"streamArn" type:"string"`

	// The stream ID.
	StreamId *string `locationName:"streamId" min:"1" type:"string"`

	// The stream version.
	StreamVersion *int64 `locationName:"streamVersion" type:"integer"`
}

// String returns the string representation
func (s StreamSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StreamSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StreamSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamArn != nil {
		v := *s.StreamArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamVersion != nil {
		v := *s.StreamVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamVersion", protocol.Int64Value(v), metadata)
	}
	return nil
}

type TestAuthorizationInput struct {
	_ struct{} `type:"structure"`

	// A list of authorization info objects. Simulating authorization will create
	// a response for each authInfo object in the list.
	//
	// AuthInfos is a required field
	AuthInfos []AuthInfo `locationName:"authInfos" min:"1" type:"list" required:"true"`

	// The MQTT client ID.
	ClientId *string `location:"querystring" locationName:"clientId" type:"string"`

	// The Cognito identity pool ID.
	CognitoIdentityPoolId *string `locationName:"cognitoIdentityPoolId" type:"string"`

	// When testing custom authorization, the policies specified here are treated
	// as if they are attached to the principal being authorized.
	PolicyNamesToAdd []string `locationName:"policyNamesToAdd" type:"list"`

	// When testing custom authorization, the policies specified here are treated
	// as if they are not attached to the principal being authorized.
	PolicyNamesToSkip []string `locationName:"policyNamesToSkip" type:"list"`

	// The principal.
	Principal *string `locationName:"principal" type:"string"`
}

// String returns the string representation
func (s TestAuthorizationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestAuthorizationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TestAuthorizationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TestAuthorizationInput"}

	if s.AuthInfos == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthInfos"))
	}
	if s.AuthInfos != nil && len(s.AuthInfos) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthInfos", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestAuthorizationInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.AuthInfos) > 0 {
		v := s.AuthInfos

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "authInfos", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.CognitoIdentityPoolId != nil {
		v := *s.CognitoIdentityPoolId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cognitoIdentityPoolId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PolicyNamesToAdd) > 0 {
		v := s.PolicyNamesToAdd

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policyNamesToAdd", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.PolicyNamesToSkip) > 0 {
		v := s.PolicyNamesToSkip

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policyNamesToSkip", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Principal != nil {
		v := *s.Principal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "principal", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ClientId != nil {
		v := *s.ClientId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "clientId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type TestAuthorizationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The authentication results.
	AuthResults []AuthResult `locationName:"authResults" type:"list"`
}

// String returns the string representation
func (s TestAuthorizationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestAuthorizationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TestAuthorizationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestAuthorizationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AuthResults) > 0 {
		v := s.AuthResults

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "authResults", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type TestInvokeAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// The custom authorizer name.
	//
	// AuthorizerName is a required field
	AuthorizerName *string `location:"uri" locationName:"authorizerName" min:"1" type:"string" required:"true"`

	// The token returned by your custom authentication service.
	//
	// Token is a required field
	Token *string `locationName:"token" min:"1" type:"string" required:"true"`

	// The signature made with the token and your custom authentication service's
	// private key.
	//
	// TokenSignature is a required field
	TokenSignature *string `locationName:"tokenSignature" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s TestInvokeAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestInvokeAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TestInvokeAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TestInvokeAuthorizerInput"}

	if s.AuthorizerName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerName"))
	}
	if s.AuthorizerName != nil && len(*s.AuthorizerName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthorizerName", 1))
	}

	if s.Token == nil {
		invalidParams.Add(aws.NewErrParamRequired("Token"))
	}
	if s.Token != nil && len(*s.Token) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Token", 1))
	}

	if s.TokenSignature == nil {
		invalidParams.Add(aws.NewErrParamRequired("TokenSignature"))
	}
	if s.TokenSignature != nil && len(*s.TokenSignature) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TokenSignature", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestInvokeAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Token != nil {
		v := *s.Token

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "token", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TokenSignature != nil {
		v := *s.TokenSignature

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tokenSignature", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type TestInvokeAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The number of seconds after which the connection is terminated.
	DisconnectAfterInSeconds *int64 `locationName:"disconnectAfterInSeconds" type:"integer"`

	// True if the token is authenticated, otherwise false.
	IsAuthenticated *bool `locationName:"isAuthenticated" type:"boolean"`

	// IAM policy documents.
	PolicyDocuments []string `locationName:"policyDocuments" type:"list"`

	// The principal ID.
	PrincipalId *string `locationName:"principalId" min:"1" type:"string"`

	// The number of seconds after which the temporary credentials are refreshed.
	RefreshAfterInSeconds *int64 `locationName:"refreshAfterInSeconds" type:"integer"`
}

// String returns the string representation
func (s TestInvokeAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestInvokeAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TestInvokeAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestInvokeAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DisconnectAfterInSeconds != nil {
		v := *s.DisconnectAfterInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "disconnectAfterInSeconds", protocol.Int64Value(v), metadata)
	}
	if s.IsAuthenticated != nil {
		v := *s.IsAuthenticated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "isAuthenticated", protocol.BoolValue(v), metadata)
	}
	if len(s.PolicyDocuments) > 0 {
		v := s.PolicyDocuments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "policyDocuments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.PrincipalId != nil {
		v := *s.PrincipalId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "principalId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RefreshAfterInSeconds != nil {
		v := *s.RefreshAfterInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "refreshAfterInSeconds", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The properties of the thing, including thing name, thing type name, and a
// list of thing attributes.
type ThingAttribute struct {
	_ struct{} `type:"structure"`

	// A list of thing attributes which are name-value pairs.
	Attributes map[string]string `locationName:"attributes" type:"map"`

	// The thing ARN.
	ThingArn *string `locationName:"thingArn" type:"string"`

	// The name of the thing.
	ThingName *string `locationName:"thingName" min:"1" type:"string"`

	// The name of the thing type, if the thing has been associated with a type.
	ThingTypeName *string `locationName:"thingTypeName" min:"1" type:"string"`

	// The version of the thing record in the registry.
	Version *int64 `locationName:"version" type:"long"`
}

// String returns the string representation
func (s ThingAttribute) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThingAttribute) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThingAttribute) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "attributes", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.ThingArn != nil {
		v := *s.ThingArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The thing search index document.
type ThingDocument struct {
	_ struct{} `type:"structure"`

	// The attributes.
	Attributes map[string]string `locationName:"attributes" type:"map"`

	// The shadow.
	Shadow *string `locationName:"shadow" type:"string"`

	// Thing group names.
	ThingGroupNames []string `locationName:"thingGroupNames" type:"list"`

	// The thing ID.
	ThingId *string `locationName:"thingId" type:"string"`

	// The thing name.
	ThingName *string `locationName:"thingName" min:"1" type:"string"`

	// The thing type name.
	ThingTypeName *string `locationName:"thingTypeName" min:"1" type:"string"`
}

// String returns the string representation
func (s ThingDocument) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThingDocument) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThingDocument) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "attributes", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Shadow != nil {
		v := *s.Shadow

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "shadow", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ThingGroupNames) > 0 {
		v := s.ThingGroupNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "thingGroupNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ThingId != nil {
		v := *s.ThingId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Thing group metadata.
type ThingGroupMetadata struct {
	_ struct{} `type:"structure"`

	// The UNIX timestamp of when the thing group was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// The parent thing group name.
	ParentGroupName *string `locationName:"parentGroupName" min:"1" type:"string"`

	// The root parent thing group.
	RootToParentThingGroups []GroupNameAndArn `locationName:"rootToParentThingGroups" type:"list"`
}

// String returns the string representation
func (s ThingGroupMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThingGroupMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThingGroupMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ParentGroupName != nil {
		v := *s.ParentGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "parentGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RootToParentThingGroups) > 0 {
		v := s.RootToParentThingGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "rootToParentThingGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Thing group properties.
type ThingGroupProperties struct {
	_ struct{} `type:"structure"`

	// The thing group attributes in JSON format.
	AttributePayload *AttributePayload `locationName:"attributePayload" type:"structure"`

	// The thing group description.
	ThingGroupDescription *string `locationName:"thingGroupDescription" type:"string"`
}

// String returns the string representation
func (s ThingGroupProperties) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThingGroupProperties) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThingGroupProperties) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttributePayload != nil {
		v := s.AttributePayload

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "attributePayload", v, metadata)
	}
	if s.ThingGroupDescription != nil {
		v := *s.ThingGroupDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingGroupDescription", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Thing indexing configuration.
type ThingIndexingConfiguration struct {
	_ struct{} `type:"structure"`

	// Thing indexing mode. Valid values are:
	//
	//    * REGISTRY – Your thing index will contain only registry data.
	//
	//    * REGISTRY_AND_SHADOW - Your thing index will contain registry and shadow
	//    data.
	//
	//    * OFF - Thing indexing is disabled.
	ThingIndexingMode ThingIndexingMode `locationName:"thingIndexingMode" type:"string" enum:"true"`
}

// String returns the string representation
func (s ThingIndexingConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThingIndexingConfiguration) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThingIndexingConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ThingIndexingMode) > 0 {
		v := s.ThingIndexingMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingIndexingMode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The definition of the thing type, including thing type name and description.
type ThingTypeDefinition struct {
	_ struct{} `type:"structure"`

	// The thing type ARN.
	ThingTypeArn *string `locationName:"thingTypeArn" type:"string"`

	// The ThingTypeMetadata contains additional information about the thing type
	// including: creation date and time, a value indicating whether the thing type
	// is deprecated, and a date and time when it was deprecated.
	ThingTypeMetadata *ThingTypeMetadata `locationName:"thingTypeMetadata" type:"structure"`

	// The name of the thing type.
	ThingTypeName *string `locationName:"thingTypeName" min:"1" type:"string"`

	// The ThingTypeProperties for the thing type.
	ThingTypeProperties *ThingTypeProperties `locationName:"thingTypeProperties" type:"structure"`
}

// String returns the string representation
func (s ThingTypeDefinition) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThingTypeDefinition) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThingTypeDefinition) MarshalFields(e protocol.FieldEncoder) error {
	if s.ThingTypeArn != nil {
		v := *s.ThingTypeArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeMetadata != nil {
		v := s.ThingTypeMetadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingTypeMetadata", v, metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingTypeProperties != nil {
		v := s.ThingTypeProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingTypeProperties", v, metadata)
	}
	return nil
}

// The ThingTypeMetadata contains additional information about the thing type
// including: creation date and time, a value indicating whether the thing type
// is deprecated, and a date and time when time was deprecated.
type ThingTypeMetadata struct {
	_ struct{} `type:"structure"`

	// The date and time when the thing type was created.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp" timestampFormat:"unix"`

	// Whether the thing type is deprecated. If true, no new things could be associated
	// with this type.
	Deprecated *bool `locationName:"deprecated" type:"boolean"`

	// The date and time when the thing type was deprecated.
	DeprecationDate *time.Time `locationName:"deprecationDate" type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s ThingTypeMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThingTypeMetadata) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThingTypeMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Deprecated != nil {
		v := *s.Deprecated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deprecated", protocol.BoolValue(v), metadata)
	}
	if s.DeprecationDate != nil {
		v := *s.DeprecationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deprecationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// The ThingTypeProperties contains information about the thing type including:
// a thing type description, and a list of searchable thing attribute names.
type ThingTypeProperties struct {
	_ struct{} `type:"structure"`

	// A list of searchable thing attribute names.
	SearchableAttributes []string `locationName:"searchableAttributes" type:"list"`

	// The description of the thing type.
	ThingTypeDescription *string `locationName:"thingTypeDescription" type:"string"`
}

// String returns the string representation
func (s ThingTypeProperties) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThingTypeProperties) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThingTypeProperties) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.SearchableAttributes) > 0 {
		v := s.SearchableAttributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "searchableAttributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ThingTypeDescription != nil {
		v := *s.ThingTypeDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeDescription", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a rule.
type TopicRule struct {
	_ struct{} `type:"structure"`

	// The actions associated with the rule.
	Actions []Action `locationName:"actions" type:"list"`

	// The version of the SQL rules engine to use when evaluating the rule.
	AwsIotSqlVersion *string `locationName:"awsIotSqlVersion" type:"string"`

	// The date and time the rule was created.
	CreatedAt *time.Time `locationName:"createdAt" type:"timestamp" timestampFormat:"unix"`

	// The description of the rule.
	Description *string `locationName:"description" type:"string"`

	// The action to perform when an error occurs.
	ErrorAction *Action `locationName:"errorAction" type:"structure"`

	// Specifies whether the rule is disabled.
	RuleDisabled *bool `locationName:"ruleDisabled" type:"boolean"`

	// The name of the rule.
	RuleName *string `locationName:"ruleName" min:"1" type:"string"`

	// The SQL statement used to query the topic. When using a SQL query with multiple
	// lines, be sure to escape the newline characters.
	Sql *string `locationName:"sql" type:"string"`
}

// String returns the string representation
func (s TopicRule) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TopicRule) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TopicRule) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Actions) > 0 {
		v := s.Actions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "actions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.AwsIotSqlVersion != nil {
		v := *s.AwsIotSqlVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsIotSqlVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ErrorAction != nil {
		v := s.ErrorAction

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "errorAction", v, metadata)
	}
	if s.RuleDisabled != nil {
		v := *s.RuleDisabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ruleDisabled", protocol.BoolValue(v), metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ruleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Sql != nil {
		v := *s.Sql

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "sql", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a rule.
type TopicRuleListItem struct {
	_ struct{} `type:"structure"`

	// The date and time the rule was created.
	CreatedAt *time.Time `locationName:"createdAt" type:"timestamp" timestampFormat:"unix"`

	// The rule ARN.
	RuleArn *string `locationName:"ruleArn" type:"string"`

	// Specifies whether the rule is disabled.
	RuleDisabled *bool `locationName:"ruleDisabled" type:"boolean"`

	// The name of the rule.
	RuleName *string `locationName:"ruleName" min:"1" type:"string"`

	// The pattern for the topic names that apply.
	TopicPattern *string `locationName:"topicPattern" type:"string"`
}

// String returns the string representation
func (s TopicRuleListItem) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TopicRuleListItem) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TopicRuleListItem) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.RuleArn != nil {
		v := *s.RuleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ruleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleDisabled != nil {
		v := *s.RuleDisabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ruleDisabled", protocol.BoolValue(v), metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ruleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TopicPattern != nil {
		v := *s.TopicPattern

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "topicPattern", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a rule.
type TopicRulePayload struct {
	_ struct{} `type:"structure"`

	// The actions associated with the rule.
	//
	// Actions is a required field
	Actions []Action `locationName:"actions" type:"list" required:"true"`

	// The version of the SQL rules engine to use when evaluating the rule.
	AwsIotSqlVersion *string `locationName:"awsIotSqlVersion" type:"string"`

	// The description of the rule.
	Description *string `locationName:"description" type:"string"`

	// The action to take when an error occurs.
	ErrorAction *Action `locationName:"errorAction" type:"structure"`

	// Specifies whether the rule is disabled.
	RuleDisabled *bool `locationName:"ruleDisabled" type:"boolean"`

	// The SQL statement used to query the topic. For more information, see AWS
	// IoT SQL Reference (http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference)
	// in the AWS IoT Developer Guide.
	//
	// Sql is a required field
	Sql *string `locationName:"sql" type:"string" required:"true"`
}

// String returns the string representation
func (s TopicRulePayload) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TopicRulePayload) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TopicRulePayload) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TopicRulePayload"}

	if s.Actions == nil {
		invalidParams.Add(aws.NewErrParamRequired("Actions"))
	}

	if s.Sql == nil {
		invalidParams.Add(aws.NewErrParamRequired("Sql"))
	}
	if s.Actions != nil {
		for i, v := range s.Actions {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Actions", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.ErrorAction != nil {
		if err := s.ErrorAction.Validate(); err != nil {
			invalidParams.AddNested("ErrorAction", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TopicRulePayload) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Actions) > 0 {
		v := s.Actions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "actions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.AwsIotSqlVersion != nil {
		v := *s.AwsIotSqlVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsIotSqlVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ErrorAction != nil {
		v := s.ErrorAction

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "errorAction", v, metadata)
	}
	if s.RuleDisabled != nil {
		v := *s.RuleDisabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ruleDisabled", protocol.BoolValue(v), metadata)
	}
	if s.Sql != nil {
		v := *s.Sql

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "sql", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input for the TransferCertificate operation.
type TransferCertificateInput struct {
	_ struct{} `type:"structure"`

	// The ID of the certificate. (The last part of the certificate ARN contains
	// the certificate ID.)
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"certificateId" min:"64" type:"string" required:"true"`

	// The AWS account.
	//
	// TargetAwsAccount is a required field
	TargetAwsAccount *string `location:"querystring" locationName:"targetAwsAccount" type:"string" required:"true"`

	// The transfer message.
	TransferMessage *string `locationName:"transferMessage" type:"string"`
}

// String returns the string representation
func (s TransferCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransferCertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TransferCertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TransferCertificateInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}

	if s.TargetAwsAccount == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetAwsAccount"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TransferCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.TransferMessage != nil {
		v := *s.TransferMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "transferMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TargetAwsAccount != nil {
		v := *s.TargetAwsAccount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "targetAwsAccount", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the TransferCertificate operation.
type TransferCertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the certificate.
	TransferredCertificateArn *string `locationName:"transferredCertificateArn" type:"string"`
}

// String returns the string representation
func (s TransferCertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransferCertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TransferCertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TransferCertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TransferredCertificateArn != nil {
		v := *s.TransferredCertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "transferredCertificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Data used to transfer a certificate to an AWS account.
type TransferData struct {
	_ struct{} `type:"structure"`

	// The date the transfer was accepted.
	AcceptDate *time.Time `locationName:"acceptDate" type:"timestamp" timestampFormat:"unix"`

	// The date the transfer was rejected.
	RejectDate *time.Time `locationName:"rejectDate" type:"timestamp" timestampFormat:"unix"`

	// The reason why the transfer was rejected.
	RejectReason *string `locationName:"rejectReason" type:"string"`

	// The date the transfer took place.
	TransferDate *time.Time `locationName:"transferDate" type:"timestamp" timestampFormat:"unix"`

	// The transfer message.
	TransferMessage *string `locationName:"transferMessage" type:"string"`
}

// String returns the string representation
func (s TransferData) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransferData) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TransferData) MarshalFields(e protocol.FieldEncoder) error {
	if s.AcceptDate != nil {
		v := *s.AcceptDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "acceptDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.RejectDate != nil {
		v := *s.RejectDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "rejectDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.RejectReason != nil {
		v := *s.RejectReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "rejectReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TransferDate != nil {
		v := *s.TransferDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "transferDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.TransferMessage != nil {
		v := *s.TransferMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "transferMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type UpdateAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the authorizer's Lambda function.
	AuthorizerFunctionArn *string `locationName:"authorizerFunctionArn" type:"string"`

	// The authorizer name.
	//
	// AuthorizerName is a required field
	AuthorizerName *string `location:"uri" locationName:"authorizerName" min:"1" type:"string" required:"true"`

	// The status of the update authorizer request.
	Status AuthorizerStatus `locationName:"status" type:"string" enum:"true"`

	// The key used to extract the token from the HTTP headers.
	TokenKeyName *string `locationName:"tokenKeyName" min:"1" type:"string"`

	// The public keys used to verify the token signature.
	TokenSigningPublicKeys map[string]string `locationName:"tokenSigningPublicKeys" type:"map"`
}

// String returns the string representation
func (s UpdateAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateAuthorizerInput"}

	if s.AuthorizerName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerName"))
	}
	if s.AuthorizerName != nil && len(*s.AuthorizerName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AuthorizerName", 1))
	}
	if s.TokenKeyName != nil && len(*s.TokenKeyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TokenKeyName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AuthorizerFunctionArn != nil {
		v := *s.AuthorizerFunctionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerFunctionArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.TokenKeyName != nil {
		v := *s.TokenKeyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tokenKeyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TokenSigningPublicKeys) > 0 {
		v := s.TokenSigningPublicKeys

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tokenSigningPublicKeys", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type UpdateAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The authorizer ARN.
	AuthorizerArn *string `locationName:"authorizerArn" type:"string"`

	// The authorizer name.
	AuthorizerName *string `locationName:"authorizerName" min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthorizerArn != nil {
		v := *s.AuthorizerArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerName != nil {
		v := *s.AuthorizerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The input to the UpdateCACertificate operation.
type UpdateCACertificateInput struct {
	_ struct{} `type:"structure"`

	// The CA certificate identifier.
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"caCertificateId" min:"64" type:"string" required:"true"`

	// The new value for the auto registration status. Valid values are: "ENABLE"
	// or "DISABLE".
	NewAutoRegistrationStatus AutoRegistrationStatus `location:"querystring" locationName:"newAutoRegistrationStatus" type:"string" enum:"true"`

	// The updated status of the CA certificate.
	//
	// Note: The status value REGISTER_INACTIVE is deprecated and should not be
	// used.
	NewStatus CACertificateStatus `location:"querystring" locationName:"newStatus" type:"string" enum:"true"`

	// Information about the registration configuration.
	RegistrationConfig *RegistrationConfig `locationName:"registrationConfig" type:"structure"`

	// If true, remove auto registration.
	RemoveAutoRegistration *bool `locationName:"removeAutoRegistration" type:"boolean"`
}

// String returns the string representation
func (s UpdateCACertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateCACertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateCACertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateCACertificateInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}
	if s.RegistrationConfig != nil {
		if err := s.RegistrationConfig.Validate(); err != nil {
			invalidParams.AddNested("RegistrationConfig", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateCACertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RegistrationConfig != nil {
		v := s.RegistrationConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "registrationConfig", v, metadata)
	}
	if s.RemoveAutoRegistration != nil {
		v := *s.RemoveAutoRegistration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "removeAutoRegistration", protocol.BoolValue(v), metadata)
	}
	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "caCertificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.NewAutoRegistrationStatus) > 0 {
		v := s.NewAutoRegistrationStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "newAutoRegistrationStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.NewStatus) > 0 {
		v := s.NewStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "newStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type UpdateCACertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateCACertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateCACertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateCACertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateCACertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the UpdateCertificate operation.
type UpdateCertificateInput struct {
	_ struct{} `type:"structure"`

	// The ID of the certificate. (The last part of the certificate ARN contains
	// the certificate ID.)
	//
	// CertificateId is a required field
	CertificateId *string `location:"uri" locationName:"certificateId" min:"64" type:"string" required:"true"`

	// The new status.
	//
	// Note: Setting the status to PENDING_TRANSFER will result in an exception
	// being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It
	// is not intended for developer use.
	//
	// Note: The status value REGISTER_INACTIVE is deprecated and should not be
	// used.
	//
	// NewStatus is a required field
	NewStatus CertificateStatus `location:"querystring" locationName:"newStatus" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s UpdateCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateCertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateCertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateCertificateInput"}

	if s.CertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateId"))
	}
	if s.CertificateId != nil && len(*s.CertificateId) < 64 {
		invalidParams.Add(aws.NewErrParamMinLen("CertificateId", 64))
	}
	if len(s.NewStatus) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("NewStatus"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateId != nil {
		v := *s.CertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "certificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.NewStatus) > 0 {
		v := s.NewStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "newStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

type UpdateCertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateCertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateCertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateCertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateCertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type UpdateEventConfigurationsInput struct {
	_ struct{} `type:"structure"`

	// The new event configuration values.
	EventConfigurations map[string]Configuration `locationName:"eventConfigurations" type:"map"`
}

// String returns the string representation
func (s UpdateEventConfigurationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateEventConfigurationsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateEventConfigurationsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.EventConfigurations) > 0 {
		v := s.EventConfigurations

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "eventConfigurations", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	return nil
}

type UpdateEventConfigurationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateEventConfigurationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateEventConfigurationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateEventConfigurationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateEventConfigurationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type UpdateIndexingConfigurationInput struct {
	_ struct{} `type:"structure"`

	// Thing indexing configuration.
	ThingIndexingConfiguration *ThingIndexingConfiguration `locationName:"thingIndexingConfiguration" type:"structure"`
}

// String returns the string representation
func (s UpdateIndexingConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateIndexingConfigurationInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateIndexingConfigurationInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ThingIndexingConfiguration != nil {
		v := s.ThingIndexingConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingIndexingConfiguration", v, metadata)
	}
	return nil
}

type UpdateIndexingConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateIndexingConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateIndexingConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateIndexingConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateIndexingConfigurationOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type UpdateRoleAliasInput struct {
	_ struct{} `type:"structure"`

	// The number of seconds the credential will be valid.
	CredentialDurationSeconds *int64 `locationName:"credentialDurationSeconds" min:"900" type:"integer"`

	// The role alias to update.
	//
	// RoleAlias is a required field
	RoleAlias *string `location:"uri" locationName:"roleAlias" min:"1" type:"string" required:"true"`

	// The role ARN.
	RoleArn *string `locationName:"roleArn" min:"20" type:"string"`
}

// String returns the string representation
func (s UpdateRoleAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRoleAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateRoleAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateRoleAliasInput"}
	if s.CredentialDurationSeconds != nil && *s.CredentialDurationSeconds < 900 {
		invalidParams.Add(aws.NewErrParamMinValue("CredentialDurationSeconds", 900))
	}

	if s.RoleAlias == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleAlias"))
	}
	if s.RoleAlias != nil && len(*s.RoleAlias) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleAlias", 1))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateRoleAliasInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CredentialDurationSeconds != nil {
		v := *s.CredentialDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "credentialDurationSeconds", protocol.Int64Value(v), metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleAlias != nil {
		v := *s.RoleAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "roleAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type UpdateRoleAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The role alias.
	RoleAlias *string `locationName:"roleAlias" min:"1" type:"string"`

	// The role alias ARN.
	RoleAliasArn *string `locationName:"roleAliasArn" type:"string"`
}

// String returns the string representation
func (s UpdateRoleAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRoleAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateRoleAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateRoleAliasOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.RoleAlias != nil {
		v := *s.RoleAlias

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleAlias", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleAliasArn != nil {
		v := *s.RoleAliasArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleAliasArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type UpdateStreamInput struct {
	_ struct{} `type:"structure"`

	// The description of the stream.
	Description *string `locationName:"description" type:"string"`

	// The files associated with the stream.
	Files []StreamFile `locationName:"files" min:"1" type:"list"`

	// An IAM role that allows the IoT service principal assumes to access your
	// S3 files.
	RoleArn *string `locationName:"roleArn" min:"20" type:"string"`

	// The stream ID.
	//
	// StreamId is a required field
	StreamId *string `location:"uri" locationName:"streamId" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateStreamInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateStreamInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateStreamInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateStreamInput"}
	if s.Files != nil && len(s.Files) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Files", 1))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}

	if s.StreamId == nil {
		invalidParams.Add(aws.NewErrParamRequired("StreamId"))
	}
	if s.StreamId != nil && len(*s.StreamId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StreamId", 1))
	}
	if s.Files != nil {
		for i, v := range s.Files {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Files", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateStreamInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Files) > 0 {
		v := s.Files

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "files", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "roleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type UpdateStreamOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A description of the stream.
	Description *string `locationName:"description" type:"string"`

	// The stream ARN.
	StreamArn *string `locationName:"streamArn" type:"string"`

	// The stream ID.
	StreamId *string `locationName:"streamId" min:"1" type:"string"`

	// The stream version.
	StreamVersion *int64 `locationName:"streamVersion" type:"integer"`
}

// String returns the string representation
func (s UpdateStreamOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateStreamOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateStreamOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateStreamOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamArn != nil {
		v := *s.StreamArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamId != nil {
		v := *s.StreamId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StreamVersion != nil {
		v := *s.StreamVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "streamVersion", protocol.Int64Value(v), metadata)
	}
	return nil
}

type UpdateThingGroupInput struct {
	_ struct{} `type:"structure"`

	// The expected version of the thing group. If this does not match the version
	// of the thing group being updated, the update will fail.
	ExpectedVersion *int64 `locationName:"expectedVersion" type:"long"`

	// The thing group to update.
	//
	// ThingGroupName is a required field
	ThingGroupName *string `location:"uri" locationName:"thingGroupName" min:"1" type:"string" required:"true"`

	// The thing group properties.
	//
	// ThingGroupProperties is a required field
	ThingGroupProperties *ThingGroupProperties `locationName:"thingGroupProperties" type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateThingGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateThingGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateThingGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateThingGroupInput"}

	if s.ThingGroupName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingGroupName"))
	}
	if s.ThingGroupName != nil && len(*s.ThingGroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingGroupName", 1))
	}

	if s.ThingGroupProperties == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingGroupProperties"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateThingGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ExpectedVersion != nil {
		v := *s.ExpectedVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "expectedVersion", protocol.Int64Value(v), metadata)
	}
	if s.ThingGroupProperties != nil {
		v := s.ThingGroupProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "thingGroupProperties", v, metadata)
	}
	if s.ThingGroupName != nil {
		v := *s.ThingGroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingGroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type UpdateThingGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The version of the updated thing group.
	Version *int64 `locationName:"version" type:"long"`
}

// String returns the string representation
func (s UpdateThingGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateThingGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateThingGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateThingGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.Int64Value(v), metadata)
	}
	return nil
}

type UpdateThingGroupsForThingInput struct {
	_ struct{} `type:"structure"`

	// The groups to which the thing will be added.
	ThingGroupsToAdd []string `locationName:"thingGroupsToAdd" type:"list"`

	// The groups from which the thing will be removed.
	ThingGroupsToRemove []string `locationName:"thingGroupsToRemove" type:"list"`

	// The thing whose group memberships will be updated.
	ThingName *string `locationName:"thingName" min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateThingGroupsForThingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateThingGroupsForThingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateThingGroupsForThingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateThingGroupsForThingInput"}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateThingGroupsForThingInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ThingGroupsToAdd) > 0 {
		v := s.ThingGroupsToAdd

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "thingGroupsToAdd", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.ThingGroupsToRemove) > 0 {
		v := s.ThingGroupsToRemove

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "thingGroupsToRemove", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type UpdateThingGroupsForThingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateThingGroupsForThingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateThingGroupsForThingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateThingGroupsForThingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateThingGroupsForThingOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input for the UpdateThing operation.
type UpdateThingInput struct {
	_ struct{} `type:"structure"`

	// A list of thing attributes, a JSON string containing name-value pairs. For
	// example:
	//
	// {\"attributes\":{\"name1\":\"value2\"}}
	//
	// This data is used to add new attributes or update existing attributes.
	AttributePayload *AttributePayload `locationName:"attributePayload" type:"structure"`

	// The expected version of the thing record in the registry. If the version
	// of the record in the registry does not match the expected version specified
	// in the request, the UpdateThing request is rejected with a VersionConflictException.
	ExpectedVersion *int64 `locationName:"expectedVersion" type:"long"`

	// Remove a thing type association. If true, the association is removed.
	RemoveThingType *bool `locationName:"removeThingType" type:"boolean"`

	// The name of the thing to update.
	//
	// ThingName is a required field
	ThingName *string `location:"uri" locationName:"thingName" min:"1" type:"string" required:"true"`

	// The name of the thing type.
	ThingTypeName *string `locationName:"thingTypeName" min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateThingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateThingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateThingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateThingInput"}

	if s.ThingName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ThingName"))
	}
	if s.ThingName != nil && len(*s.ThingName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingName", 1))
	}
	if s.ThingTypeName != nil && len(*s.ThingTypeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ThingTypeName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateThingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AttributePayload != nil {
		v := s.AttributePayload

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "attributePayload", v, metadata)
	}
	if s.ExpectedVersion != nil {
		v := *s.ExpectedVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "expectedVersion", protocol.Int64Value(v), metadata)
	}
	if s.RemoveThingType != nil {
		v := *s.RemoveThingType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "removeThingType", protocol.BoolValue(v), metadata)
	}
	if s.ThingTypeName != nil {
		v := *s.ThingTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "thingTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ThingName != nil {
		v := *s.ThingName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "thingName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The output from the UpdateThing operation.
type UpdateThingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateThingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateThingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateThingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateThingOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type ActionType string

// Enum values for ActionType
const (
	ActionTypePublish   ActionType = "PUBLISH"
	ActionTypeSubscribe ActionType = "SUBSCRIBE"
	ActionTypeReceive   ActionType = "RECEIVE"
	ActionTypeConnect   ActionType = "CONNECT"
)

func (enum ActionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ActionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type AuthDecision string

// Enum values for AuthDecision
const (
	AuthDecisionAllowed      AuthDecision = "ALLOWED"
	AuthDecisionExplicitDeny AuthDecision = "EXPLICIT_DENY"
	AuthDecisionImplicitDeny AuthDecision = "IMPLICIT_DENY"
)

func (enum AuthDecision) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AuthDecision) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type AuthorizerStatus string

// Enum values for AuthorizerStatus
const (
	AuthorizerStatusActive   AuthorizerStatus = "ACTIVE"
	AuthorizerStatusInactive AuthorizerStatus = "INACTIVE"
)

func (enum AuthorizerStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AuthorizerStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type AutoRegistrationStatus string

// Enum values for AutoRegistrationStatus
const (
	AutoRegistrationStatusEnable  AutoRegistrationStatus = "ENABLE"
	AutoRegistrationStatusDisable AutoRegistrationStatus = "DISABLE"
)

func (enum AutoRegistrationStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AutoRegistrationStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CACertificateStatus string

// Enum values for CACertificateStatus
const (
	CACertificateStatusActive   CACertificateStatus = "ACTIVE"
	CACertificateStatusInactive CACertificateStatus = "INACTIVE"
)

func (enum CACertificateStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CACertificateStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CannedAccessControlList string

// Enum values for CannedAccessControlList
const (
	CannedAccessControlListPrivate                CannedAccessControlList = "private"
	CannedAccessControlListPublicRead             CannedAccessControlList = "public-read"
	CannedAccessControlListPublicReadWrite        CannedAccessControlList = "public-read-write"
	CannedAccessControlListAwsExecRead            CannedAccessControlList = "aws-exec-read"
	CannedAccessControlListAuthenticatedRead      CannedAccessControlList = "authenticated-read"
	CannedAccessControlListBucketOwnerRead        CannedAccessControlList = "bucket-owner-read"
	CannedAccessControlListBucketOwnerFullControl CannedAccessControlList = "bucket-owner-full-control"
	CannedAccessControlListLogDeliveryWrite       CannedAccessControlList = "log-delivery-write"
)

func (enum CannedAccessControlList) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CannedAccessControlList) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CertificateStatus string

// Enum values for CertificateStatus
const (
	CertificateStatusActive            CertificateStatus = "ACTIVE"
	CertificateStatusInactive          CertificateStatus = "INACTIVE"
	CertificateStatusRevoked           CertificateStatus = "REVOKED"
	CertificateStatusPendingTransfer   CertificateStatus = "PENDING_TRANSFER"
	CertificateStatusRegisterInactive  CertificateStatus = "REGISTER_INACTIVE"
	CertificateStatusPendingActivation CertificateStatus = "PENDING_ACTIVATION"
)

func (enum CertificateStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CertificateStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DynamoKeyType string

// Enum values for DynamoKeyType
const (
	DynamoKeyTypeString DynamoKeyType = "STRING"
	DynamoKeyTypeNumber DynamoKeyType = "NUMBER"
)

func (enum DynamoKeyType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DynamoKeyType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type EventType string

// Enum values for EventType
const (
	EventTypeThing                EventType = "THING"
	EventTypeThingGroup           EventType = "THING_GROUP"
	EventTypeThingType            EventType = "THING_TYPE"
	EventTypeThingGroupMembership EventType = "THING_GROUP_MEMBERSHIP"
	EventTypeThingGroupHierarchy  EventType = "THING_GROUP_HIERARCHY"
	EventTypeThingTypeAssociation EventType = "THING_TYPE_ASSOCIATION"
	EventTypeJob                  EventType = "JOB"
	EventTypeJobExecution         EventType = "JOB_EXECUTION"
)

func (enum EventType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EventType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type IndexStatus string

// Enum values for IndexStatus
const (
	IndexStatusActive     IndexStatus = "ACTIVE"
	IndexStatusBuilding   IndexStatus = "BUILDING"
	IndexStatusRebuilding IndexStatus = "REBUILDING"
)

func (enum IndexStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum IndexStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type JobExecutionStatus string

// Enum values for JobExecutionStatus
const (
	JobExecutionStatusQueued     JobExecutionStatus = "QUEUED"
	JobExecutionStatusInProgress JobExecutionStatus = "IN_PROGRESS"
	JobExecutionStatusSucceeded  JobExecutionStatus = "SUCCEEDED"
	JobExecutionStatusFailed     JobExecutionStatus = "FAILED"
	JobExecutionStatusRejected   JobExecutionStatus = "REJECTED"
	JobExecutionStatusRemoved    JobExecutionStatus = "REMOVED"
	JobExecutionStatusCanceled   JobExecutionStatus = "CANCELED"
)

func (enum JobExecutionStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum JobExecutionStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type JobStatus string

// Enum values for JobStatus
const (
	JobStatusInProgress         JobStatus = "IN_PROGRESS"
	JobStatusCanceled           JobStatus = "CANCELED"
	JobStatusCompleted          JobStatus = "COMPLETED"
	JobStatusDeletionInProgress JobStatus = "DELETION_IN_PROGRESS"
)

func (enum JobStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum JobStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type LogLevel string

// Enum values for LogLevel
const (
	LogLevelDebug    LogLevel = "DEBUG"
	LogLevelInfo     LogLevel = "INFO"
	LogLevelError    LogLevel = "ERROR"
	LogLevelWarn     LogLevel = "WARN"
	LogLevelDisabled LogLevel = "DISABLED"
)

func (enum LogLevel) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum LogLevel) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type LogTargetType string

// Enum values for LogTargetType
const (
	LogTargetTypeDefault    LogTargetType = "DEFAULT"
	LogTargetTypeThingGroup LogTargetType = "THING_GROUP"
)

func (enum LogTargetType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum LogTargetType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type MessageFormat string

// Enum values for MessageFormat
const (
	MessageFormatRaw  MessageFormat = "RAW"
	MessageFormatJson MessageFormat = "JSON"
)

func (enum MessageFormat) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum MessageFormat) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type OTAUpdateStatus string

// Enum values for OTAUpdateStatus
const (
	OTAUpdateStatusCreatePending    OTAUpdateStatus = "CREATE_PENDING"
	OTAUpdateStatusCreateInProgress OTAUpdateStatus = "CREATE_IN_PROGRESS"
	OTAUpdateStatusCreateComplete   OTAUpdateStatus = "CREATE_COMPLETE"
	OTAUpdateStatusCreateFailed     OTAUpdateStatus = "CREATE_FAILED"
)

func (enum OTAUpdateStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum OTAUpdateStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ReportType string

// Enum values for ReportType
const (
	ReportTypeErrors  ReportType = "ERRORS"
	ReportTypeResults ReportType = "RESULTS"
)

func (enum ReportType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReportType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Status string

// Enum values for Status
const (
	StatusInProgress Status = "InProgress"
	StatusCompleted  Status = "Completed"
	StatusFailed     Status = "Failed"
	StatusCancelled  Status = "Cancelled"
	StatusCancelling Status = "Cancelling"
)

func (enum Status) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Status) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type TargetSelection string

// Enum values for TargetSelection
const (
	TargetSelectionContinuous TargetSelection = "CONTINUOUS"
	TargetSelectionSnapshot   TargetSelection = "SNAPSHOT"
)

func (enum TargetSelection) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum TargetSelection) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ThingIndexingMode string

// Enum values for ThingIndexingMode
const (
	ThingIndexingModeOff               ThingIndexingMode = "OFF"
	ThingIndexingModeRegistry          ThingIndexingMode = "REGISTRY"
	ThingIndexingModeRegistryAndShadow ThingIndexingMode = "REGISTRY_AND_SHADOW"
)

func (enum ThingIndexingMode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ThingIndexingMode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
