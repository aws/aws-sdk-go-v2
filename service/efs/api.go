// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package efs

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opCreateFileSystem = "CreateFileSystem"

// CreateFileSystemRequest is a API request type for the CreateFileSystem API operation.
type CreateFileSystemRequest struct {
	*aws.Request
	Input *CreateFileSystemInput
	Copy  func(*CreateFileSystemInput) CreateFileSystemRequest
}

// Send marshals and sends the CreateFileSystem API request.
func (r CreateFileSystemRequest) Send() (*CreateFileSystemOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateFileSystemOutput), nil
}

// CreateFileSystemRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Creates a new, empty file system. The operation requires a creation token
// in the request that Amazon EFS uses to ensure idempotent creation (calling
// the operation with same creation token has no effect). If a file system does
// not currently exist that is owned by the caller's AWS account with the specified
// creation token, this operation does the following:
//
//    * Creates a new, empty file system. The file system will have an Amazon
//    EFS assigned ID, and an initial lifecycle state creating.
//
//    * Returns with the description of the created file system.
//
// Otherwise, this operation returns a FileSystemAlreadyExists error with the
// ID of the existing file system.
//
// For basic use cases, you can use a randomly generated UUID for the creation
// token.
//
// The idempotent operation allows you to retry a CreateFileSystem call without
// risk of creating an extra file system. This can happen when an initial call
// fails in a way that leaves it uncertain whether or not a file system was
// actually created. An example might be that a transport level timeout occurred
// or your connection was reset. As long as you use the same creation token,
// if the initial call had succeeded in creating a file system, the client can
// learn of its existence from the FileSystemAlreadyExists error.
//
// The CreateFileSystem call returns while the file system's lifecycle state
// is still creating. You can check the file system creation status by calling
// the DescribeFileSystems operation, which among other things returns the file
// system state.
//
// This operation also takes an optional PerformanceMode parameter that you
// choose for your file system. We recommend generalPurpose performance mode
// for most file systems. File systems using the maxIO performance mode can
// scale to higher levels of aggregate throughput and operations per second
// with a tradeoff of slightly higher latencies for most file operations. The
// performance mode can't be changed after the file system has been created.
// For more information, see Amazon EFS: Performance Modes (http://docs.aws.amazon.com/efs/latest/ug/performance.html#performancemodes.html).
//
// After the file system is fully created, Amazon EFS sets its lifecycle state
// to available, at which point you can create one or more mount targets for
// the file system in your VPC. For more information, see CreateMountTarget.
// You mount your Amazon EFS file system on an EC2 instances in your VPC via
// the mount target. For more information, see Amazon EFS: How it Works (http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html).
//
// This operation requires permissions for the elasticfilesystem:CreateFileSystem
// action.
//
//    // Example sending a request using the CreateFileSystemRequest method.
//    req := client.CreateFileSystemRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/CreateFileSystem
func (c *EFS) CreateFileSystemRequest(input *CreateFileSystemInput) CreateFileSystemRequest {
	op := &aws.Operation{
		Name:       opCreateFileSystem,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-02-01/file-systems",
	}

	if input == nil {
		input = &CreateFileSystemInput{}
	}

	output := &CreateFileSystemOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateFileSystemRequest{Request: req, Input: input, Copy: c.CreateFileSystemRequest}
}

const opCreateMountTarget = "CreateMountTarget"

// CreateMountTargetRequest is a API request type for the CreateMountTarget API operation.
type CreateMountTargetRequest struct {
	*aws.Request
	Input *CreateMountTargetInput
	Copy  func(*CreateMountTargetInput) CreateMountTargetRequest
}

// Send marshals and sends the CreateMountTarget API request.
func (r CreateMountTargetRequest) Send() (*CreateMountTargetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateMountTargetOutput), nil
}

// CreateMountTargetRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Creates a mount target for a file system. You can then mount the file system
// on EC2 instances via the mount target.
//
// You can create one mount target in each Availability Zone in your VPC. All
// EC2 instances in a VPC within a given Availability Zone share a single mount
// target for a given file system. If you have multiple subnets in an Availability
// Zone, you create a mount target in one of the subnets. EC2 instances do not
// need to be in the same subnet as the mount target in order to access their
// file system. For more information, see Amazon EFS: How it Works (http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html).
//
// In the request, you also specify a file system ID for which you are creating
// the mount target and the file system's lifecycle state must be available.
// For more information, see DescribeFileSystems.
//
// In the request, you also provide a subnet ID, which determines the following:
//
//    * VPC in which Amazon EFS creates the mount target
//
//    * Availability Zone in which Amazon EFS creates the mount target
//
//    * IP address range from which Amazon EFS selects the IP address of the
//    mount target (if you don't specify an IP address in the request)
//
// After creating the mount target, Amazon EFS returns a response that includes,
// a MountTargetId and an IpAddress. You use this IP address when mounting the
// file system in an EC2 instance. You can also use the mount target's DNS name
// when mounting the file system. The EC2 instance on which you mount the file
// system via the mount target can resolve the mount target's DNS name to its
// IP address. For more information, see How it Works: Implementation Overview
// (http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation).
//
// Note that you can create mount targets for a file system in only one VPC,
// and there can be only one mount target per Availability Zone. That is, if
// the file system already has one or more mount targets created for it, the
// subnet specified in the request to add another mount target must meet the
// following requirements:
//
//    * Must belong to the same VPC as the subnets of the existing mount targets
//
//    * Must not be in the same Availability Zone as any of the subnets of the
//    existing mount targets
//
// If the request satisfies the requirements, Amazon EFS does the following:
//
//    * Creates a new mount target in the specified subnet.
//
//    * Also creates a new network interface in the subnet as follows:
//
// If the request provides an IpAddress, Amazon EFS assigns that IP address
//    to the network interface. Otherwise, Amazon EFS assigns a free address
//    in the subnet (in the same way that the Amazon EC2 CreateNetworkInterface
//    call does when a request does not specify a primary private IP address).
//
// If the request provides SecurityGroups, this network interface is associated
//    with those security groups. Otherwise, it belongs to the default security
//    group for the subnet's VPC.
//
// Assigns the description Mount target fsmt-id for file system fs-id where
//    fsmt-id is the mount target ID, and fs-id is the FileSystemId.
//
// Sets the requesterManaged property of the network interface to true, and
//    the requesterId value to EFS.
//
// Each Amazon EFS mount target has one corresponding requester-managed EC2
//    network interface. After the network interface is created, Amazon EFS
//    sets the NetworkInterfaceId field in the mount target's description to
//    the network interface ID, and the IpAddress field to its address. If network
//    interface creation fails, the entire CreateMountTarget operation fails.
//
// The CreateMountTarget call returns only after creating the network interface,
// but while the mount target state is still creating, you can check the mount
// target creation status by calling the DescribeMountTargets operation, which
// among other things returns the mount target state.
//
// We recommend you create a mount target in each of the Availability Zones.
// There are cost considerations for using a file system in an Availability
// Zone through a mount target created in another Availability Zone. For more
// information, see Amazon EFS (http://aws.amazon.com/efs/). In addition, by
// always using a mount target local to the instance's Availability Zone, you
// eliminate a partial failure scenario. If the Availability Zone in which your
// mount target is created goes down, then you won't be able to access your
// file system through that mount target.
//
// This operation requires permissions for the following action on the file
// system:
//
//    * elasticfilesystem:CreateMountTarget
//
// This operation also requires permissions for the following Amazon EC2 actions:
//
//    * ec2:DescribeSubnets
//
//    * ec2:DescribeNetworkInterfaces
//
//    * ec2:CreateNetworkInterface
//
//    // Example sending a request using the CreateMountTargetRequest method.
//    req := client.CreateMountTargetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/CreateMountTarget
func (c *EFS) CreateMountTargetRequest(input *CreateMountTargetInput) CreateMountTargetRequest {
	op := &aws.Operation{
		Name:       opCreateMountTarget,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-02-01/mount-targets",
	}

	if input == nil {
		input = &CreateMountTargetInput{}
	}

	output := &CreateMountTargetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateMountTargetRequest{Request: req, Input: input, Copy: c.CreateMountTargetRequest}
}

const opCreateTags = "CreateTags"

// CreateTagsRequest is a API request type for the CreateTags API operation.
type CreateTagsRequest struct {
	*aws.Request
	Input *CreateTagsInput
	Copy  func(*CreateTagsInput) CreateTagsRequest
}

// Send marshals and sends the CreateTags API request.
func (r CreateTagsRequest) Send() (*CreateTagsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTagsOutput), nil
}

// CreateTagsRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Creates or overwrites tags associated with a file system. Each tag is a key-value
// pair. If a tag key specified in the request already exists on the file system,
// this operation overwrites its value with the value provided in the request.
// If you add the Name tag to your file system, Amazon EFS returns it in the
// response to the DescribeFileSystems operation.
//
// This operation requires permission for the elasticfilesystem:CreateTags action.
//
//    // Example sending a request using the CreateTagsRequest method.
//    req := client.CreateTagsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/CreateTags
func (c *EFS) CreateTagsRequest(input *CreateTagsInput) CreateTagsRequest {
	op := &aws.Operation{
		Name:       opCreateTags,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-02-01/create-tags/{FileSystemId}",
	}

	if input == nil {
		input = &CreateTagsInput{}
	}

	output := &CreateTagsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTagsRequest{Request: req, Input: input, Copy: c.CreateTagsRequest}
}

const opDeleteFileSystem = "DeleteFileSystem"

// DeleteFileSystemRequest is a API request type for the DeleteFileSystem API operation.
type DeleteFileSystemRequest struct {
	*aws.Request
	Input *DeleteFileSystemInput
	Copy  func(*DeleteFileSystemInput) DeleteFileSystemRequest
}

// Send marshals and sends the DeleteFileSystem API request.
func (r DeleteFileSystemRequest) Send() (*DeleteFileSystemOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteFileSystemOutput), nil
}

// DeleteFileSystemRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Deletes a file system, permanently severing access to its contents. Upon
// return, the file system no longer exists and you can't access any contents
// of the deleted file system.
//
// You can't delete a file system that is in use. That is, if the file system
// has any mount targets, you must first delete them. For more information,
// see DescribeMountTargets and DeleteMountTarget.
//
// The DeleteFileSystem call returns while the file system state is still deleting.
// You can check the file system deletion status by calling the DescribeFileSystems
// operation, which returns a list of file systems in your account. If you pass
// file system ID or creation token for the deleted file system, the DescribeFileSystems
// returns a 404 FileSystemNotFound error.
//
// This operation requires permissions for the elasticfilesystem:DeleteFileSystem
// action.
//
//    // Example sending a request using the DeleteFileSystemRequest method.
//    req := client.DeleteFileSystemRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteFileSystem
func (c *EFS) DeleteFileSystemRequest(input *DeleteFileSystemInput) DeleteFileSystemRequest {
	op := &aws.Operation{
		Name:       opDeleteFileSystem,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2015-02-01/file-systems/{FileSystemId}",
	}

	if input == nil {
		input = &DeleteFileSystemInput{}
	}

	output := &DeleteFileSystemOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteFileSystemRequest{Request: req, Input: input, Copy: c.DeleteFileSystemRequest}
}

const opDeleteMountTarget = "DeleteMountTarget"

// DeleteMountTargetRequest is a API request type for the DeleteMountTarget API operation.
type DeleteMountTargetRequest struct {
	*aws.Request
	Input *DeleteMountTargetInput
	Copy  func(*DeleteMountTargetInput) DeleteMountTargetRequest
}

// Send marshals and sends the DeleteMountTarget API request.
func (r DeleteMountTargetRequest) Send() (*DeleteMountTargetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteMountTargetOutput), nil
}

// DeleteMountTargetRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Deletes the specified mount target.
//
// This operation forcibly breaks any mounts of the file system via the mount
// target that is being deleted, which might disrupt instances or applications
// using those mounts. To avoid applications getting cut off abruptly, you might
// consider unmounting any mounts of the mount target, if feasible. The operation
// also deletes the associated network interface. Uncommitted writes may be
// lost, but breaking a mount target using this operation does not corrupt the
// file system itself. The file system you created remains. You can mount an
// EC2 instance in your VPC via another mount target.
//
// This operation requires permissions for the following action on the file
// system:
//
//    * elasticfilesystem:DeleteMountTarget
//
// The DeleteMountTarget call returns while the mount target state is still
// deleting. You can check the mount target deletion by calling the DescribeMountTargets
// operation, which returns a list of mount target descriptions for the given
// file system.
//
// The operation also requires permissions for the following Amazon EC2 action
// on the mount target's network interface:
//
//    * ec2:DeleteNetworkInterface
//
//    // Example sending a request using the DeleteMountTargetRequest method.
//    req := client.DeleteMountTargetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteMountTarget
func (c *EFS) DeleteMountTargetRequest(input *DeleteMountTargetInput) DeleteMountTargetRequest {
	op := &aws.Operation{
		Name:       opDeleteMountTarget,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2015-02-01/mount-targets/{MountTargetId}",
	}

	if input == nil {
		input = &DeleteMountTargetInput{}
	}

	output := &DeleteMountTargetOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteMountTargetRequest{Request: req, Input: input, Copy: c.DeleteMountTargetRequest}
}

const opDeleteTags = "DeleteTags"

// DeleteTagsRequest is a API request type for the DeleteTags API operation.
type DeleteTagsRequest struct {
	*aws.Request
	Input *DeleteTagsInput
	Copy  func(*DeleteTagsInput) DeleteTagsRequest
}

// Send marshals and sends the DeleteTags API request.
func (r DeleteTagsRequest) Send() (*DeleteTagsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTagsOutput), nil
}

// DeleteTagsRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Deletes the specified tags from a file system. If the DeleteTags request
// includes a tag key that does not exist, Amazon EFS ignores it and doesn't
// cause an error. For more information about tags and related restrictions,
// see Tag Restrictions (http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html)
// in the AWS Billing and Cost Management User Guide.
//
// This operation requires permissions for the elasticfilesystem:DeleteTags
// action.
//
//    // Example sending a request using the DeleteTagsRequest method.
//    req := client.DeleteTagsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteTags
func (c *EFS) DeleteTagsRequest(input *DeleteTagsInput) DeleteTagsRequest {
	op := &aws.Operation{
		Name:       opDeleteTags,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-02-01/delete-tags/{FileSystemId}",
	}

	if input == nil {
		input = &DeleteTagsInput{}
	}

	output := &DeleteTagsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTagsRequest{Request: req, Input: input, Copy: c.DeleteTagsRequest}
}

const opDescribeFileSystems = "DescribeFileSystems"

// DescribeFileSystemsRequest is a API request type for the DescribeFileSystems API operation.
type DescribeFileSystemsRequest struct {
	*aws.Request
	Input *DescribeFileSystemsInput
	Copy  func(*DescribeFileSystemsInput) DescribeFileSystemsRequest
}

// Send marshals and sends the DescribeFileSystems API request.
func (r DescribeFileSystemsRequest) Send() (*DescribeFileSystemsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeFileSystemsOutput), nil
}

// DescribeFileSystemsRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Returns the description of a specific Amazon EFS file system if either the
// file system CreationToken or the FileSystemId is provided. Otherwise, it
// returns descriptions of all file systems owned by the caller's AWS account
// in the AWS Region of the endpoint that you're calling.
//
// When retrieving all file system descriptions, you can optionally specify
// the MaxItems parameter to limit the number of descriptions in a response.
// If more file system descriptions remain, Amazon EFS returns a NextMarker,
// an opaque token, in the response. In this case, you should send a subsequent
// request with the Marker request parameter set to the value of NextMarker.
//
// To retrieve a list of your file system descriptions, this operation is used
// in an iterative process, where DescribeFileSystems is called first without
// the Marker and then the operation continues to call it with the Marker parameter
// set to the value of the NextMarker from the previous response until the response
// has no NextMarker.
//
// The implementation may return fewer than MaxItems file system descriptions
// while still including a NextMarker value.
//
// The order of file systems returned in the response of one DescribeFileSystems
// call and the order of file systems returned across the responses of a multi-call
// iteration is unspecified.
//
// This operation requires permissions for the elasticfilesystem:DescribeFileSystems
// action.
//
//    // Example sending a request using the DescribeFileSystemsRequest method.
//    req := client.DescribeFileSystemsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeFileSystems
func (c *EFS) DescribeFileSystemsRequest(input *DescribeFileSystemsInput) DescribeFileSystemsRequest {
	op := &aws.Operation{
		Name:       opDescribeFileSystems,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-02-01/file-systems",
	}

	if input == nil {
		input = &DescribeFileSystemsInput{}
	}

	output := &DescribeFileSystemsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeFileSystemsRequest{Request: req, Input: input, Copy: c.DescribeFileSystemsRequest}
}

const opDescribeMountTargetSecurityGroups = "DescribeMountTargetSecurityGroups"

// DescribeMountTargetSecurityGroupsRequest is a API request type for the DescribeMountTargetSecurityGroups API operation.
type DescribeMountTargetSecurityGroupsRequest struct {
	*aws.Request
	Input *DescribeMountTargetSecurityGroupsInput
	Copy  func(*DescribeMountTargetSecurityGroupsInput) DescribeMountTargetSecurityGroupsRequest
}

// Send marshals and sends the DescribeMountTargetSecurityGroups API request.
func (r DescribeMountTargetSecurityGroupsRequest) Send() (*DescribeMountTargetSecurityGroupsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeMountTargetSecurityGroupsOutput), nil
}

// DescribeMountTargetSecurityGroupsRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Returns the security groups currently in effect for a mount target. This
// operation requires that the network interface of the mount target has been
// created and the lifecycle state of the mount target is not deleted.
//
// This operation requires permissions for the following actions:
//
//    * elasticfilesystem:DescribeMountTargetSecurityGroups action on the mount
//    target's file system.
//
//    * ec2:DescribeNetworkInterfaceAttribute action on the mount target's network
//    interface.
//
//    // Example sending a request using the DescribeMountTargetSecurityGroupsRequest method.
//    req := client.DescribeMountTargetSecurityGroupsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeMountTargetSecurityGroups
func (c *EFS) DescribeMountTargetSecurityGroupsRequest(input *DescribeMountTargetSecurityGroupsInput) DescribeMountTargetSecurityGroupsRequest {
	op := &aws.Operation{
		Name:       opDescribeMountTargetSecurityGroups,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-02-01/mount-targets/{MountTargetId}/security-groups",
	}

	if input == nil {
		input = &DescribeMountTargetSecurityGroupsInput{}
	}

	output := &DescribeMountTargetSecurityGroupsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeMountTargetSecurityGroupsRequest{Request: req, Input: input, Copy: c.DescribeMountTargetSecurityGroupsRequest}
}

const opDescribeMountTargets = "DescribeMountTargets"

// DescribeMountTargetsRequest is a API request type for the DescribeMountTargets API operation.
type DescribeMountTargetsRequest struct {
	*aws.Request
	Input *DescribeMountTargetsInput
	Copy  func(*DescribeMountTargetsInput) DescribeMountTargetsRequest
}

// Send marshals and sends the DescribeMountTargets API request.
func (r DescribeMountTargetsRequest) Send() (*DescribeMountTargetsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeMountTargetsOutput), nil
}

// DescribeMountTargetsRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Returns the descriptions of all the current mount targets, or a specific
// mount target, for a file system. When requesting all of the current mount
// targets, the order of mount targets returned in the response is unspecified.
//
// This operation requires permissions for the elasticfilesystem:DescribeMountTargets
// action, on either the file system ID that you specify in FileSystemId, or
// on the file system of the mount target that you specify in MountTargetId.
//
//    // Example sending a request using the DescribeMountTargetsRequest method.
//    req := client.DescribeMountTargetsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeMountTargets
func (c *EFS) DescribeMountTargetsRequest(input *DescribeMountTargetsInput) DescribeMountTargetsRequest {
	op := &aws.Operation{
		Name:       opDescribeMountTargets,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-02-01/mount-targets",
	}

	if input == nil {
		input = &DescribeMountTargetsInput{}
	}

	output := &DescribeMountTargetsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeMountTargetsRequest{Request: req, Input: input, Copy: c.DescribeMountTargetsRequest}
}

const opDescribeTags = "DescribeTags"

// DescribeTagsRequest is a API request type for the DescribeTags API operation.
type DescribeTagsRequest struct {
	*aws.Request
	Input *DescribeTagsInput
	Copy  func(*DescribeTagsInput) DescribeTagsRequest
}

// Send marshals and sends the DescribeTags API request.
func (r DescribeTagsRequest) Send() (*DescribeTagsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeTagsOutput), nil
}

// DescribeTagsRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Returns the tags associated with a file system. The order of tags returned
// in the response of one DescribeTags call and the order of tags returned across
// the responses of a multi-call iteration (when using pagination) is unspecified.
//
// This operation requires permissions for the elasticfilesystem:DescribeTags
// action.
//
//    // Example sending a request using the DescribeTagsRequest method.
//    req := client.DescribeTagsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeTags
func (c *EFS) DescribeTagsRequest(input *DescribeTagsInput) DescribeTagsRequest {
	op := &aws.Operation{
		Name:       opDescribeTags,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-02-01/tags/{FileSystemId}/",
	}

	if input == nil {
		input = &DescribeTagsInput{}
	}

	output := &DescribeTagsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeTagsRequest{Request: req, Input: input, Copy: c.DescribeTagsRequest}
}

const opModifyMountTargetSecurityGroups = "ModifyMountTargetSecurityGroups"

// ModifyMountTargetSecurityGroupsRequest is a API request type for the ModifyMountTargetSecurityGroups API operation.
type ModifyMountTargetSecurityGroupsRequest struct {
	*aws.Request
	Input *ModifyMountTargetSecurityGroupsInput
	Copy  func(*ModifyMountTargetSecurityGroupsInput) ModifyMountTargetSecurityGroupsRequest
}

// Send marshals and sends the ModifyMountTargetSecurityGroups API request.
func (r ModifyMountTargetSecurityGroupsRequest) Send() (*ModifyMountTargetSecurityGroupsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ModifyMountTargetSecurityGroupsOutput), nil
}

// ModifyMountTargetSecurityGroupsRequest returns a request value for making API operation for
// Amazon Elastic File System.
//
// Modifies the set of security groups in effect for a mount target.
//
// When you create a mount target, Amazon EFS also creates a new network interface.
// For more information, see CreateMountTarget. This operation replaces the
// security groups in effect for the network interface associated with a mount
// target, with the SecurityGroups provided in the request. This operation requires
// that the network interface of the mount target has been created and the lifecycle
// state of the mount target is not deleted.
//
// The operation requires permissions for the following actions:
//
//    * elasticfilesystem:ModifyMountTargetSecurityGroups action on the mount
//    target's file system.
//
//    * ec2:ModifyNetworkInterfaceAttribute action on the mount target's network
//    interface.
//
//    // Example sending a request using the ModifyMountTargetSecurityGroupsRequest method.
//    req := client.ModifyMountTargetSecurityGroupsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/ModifyMountTargetSecurityGroups
func (c *EFS) ModifyMountTargetSecurityGroupsRequest(input *ModifyMountTargetSecurityGroupsInput) ModifyMountTargetSecurityGroupsRequest {
	op := &aws.Operation{
		Name:       opModifyMountTargetSecurityGroups,
		HTTPMethod: "PUT",
		HTTPPath:   "/2015-02-01/mount-targets/{MountTargetId}/security-groups",
	}

	if input == nil {
		input = &ModifyMountTargetSecurityGroupsInput{}
	}

	output := &ModifyMountTargetSecurityGroupsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return ModifyMountTargetSecurityGroupsRequest{Request: req, Input: input, Copy: c.ModifyMountTargetSecurityGroupsRequest}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/CreateFileSystemRequest
type CreateFileSystemInput struct {
	_ struct{} `type:"structure"`

	// String of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent
	// creation.
	//
	// CreationToken is a required field
	CreationToken *string `min:"1" type:"string" required:"true"`

	// A boolean value that, if true, creates an encrypted file system. When creating
	// an encrypted file system, you have the option of specifying a CreateFileSystemRequest$KmsKeyId
	// for an existing AWS Key Management Service (AWS KMS) customer master key
	// (CMK). If you don't specify a CMK, then the default CMK for Amazon EFS, /aws/elasticfilesystem,
	// is used to protect the encrypted file system.
	Encrypted *bool `type:"boolean"`

	// The id of the AWS KMS CMK that will be used to protect the encrypted file
	// system. This parameter is only required if you want to use a non-default
	// CMK. If this parameter is not specified, the default CMK for Amazon EFS is
	// used. This id can be in one of the following formats:
	//
	//    * Key ID - A unique identifier of the key. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
	//
	//    * ARN - An Amazon Resource Name for the key. For example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
	//
	//    * Key alias - A previously created display name for a key. For example,
	//    alias/projectKey1.
	//
	//    * Key alias ARN - An Amazon Resource Name for a key alias. For example,
	//    arn:aws:kms:us-west-2:444455556666:alias/projectKey1.
	//
	// Note that if the KmsKeyId is specified, the CreateFileSystemRequest$Encrypted
	// parameter must be set to true.
	KmsKeyId *string `min:"1" type:"string"`

	// The PerformanceMode of the file system. We recommend generalPurpose performance
	// mode for most file systems. File systems using the maxIO performance mode
	// can scale to higher levels of aggregate throughput and operations per second
	// with a tradeoff of slightly higher latencies for most file operations. This
	// can't be changed after the file system has been created.
	PerformanceMode PerformanceMode `type:"string" enum:"true"`
}

// String returns the string representation
func (s CreateFileSystemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFileSystemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateFileSystemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateFileSystemInput"}

	if s.CreationToken == nil {
		invalidParams.Add(aws.NewErrParamRequired("CreationToken"))
	}
	if s.CreationToken != nil && len(*s.CreationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CreationToken", 1))
	}
	if s.KmsKeyId != nil && len(*s.KmsKeyId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("KmsKeyId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateFileSystemInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CreationToken != nil {
		v := *s.CreationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Encrypted != nil {
		v := *s.Encrypted

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Encrypted", protocol.BoolValue(v), metadata)
	}
	if s.KmsKeyId != nil {
		v := *s.KmsKeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KmsKeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PerformanceMode) > 0 {
		v := s.PerformanceMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PerformanceMode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Description of the file system.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/FileSystemDescription
type CreateFileSystemOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Time that the file system was created, in seconds (since 1970-01-01T00:00:00Z).
	//
	// CreationTime is a required field
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Opaque string specified in the request.
	//
	// CreationToken is a required field
	CreationToken *string `min:"1" type:"string" required:"true"`

	// A boolean value that, if true, indicates that the file system is encrypted.
	Encrypted *bool `type:"boolean"`

	// ID of the file system, assigned by Amazon EFS.
	//
	// FileSystemId is a required field
	FileSystemId *string `type:"string" required:"true"`

	// The id of an AWS Key Management Service (AWS KMS) customer master key (CMK)
	// that was used to protect the encrypted file system.
	KmsKeyId *string `min:"1" type:"string"`

	// Lifecycle phase of the file system.
	//
	// LifeCycleState is a required field
	LifeCycleState LifeCycleState `type:"string" required:"true" enum:"true"`

	// You can add tags to a file system, including a Name tag. For more information,
	// see CreateTags. If the file system has a Name tag, Amazon EFS returns the
	// value in this field.
	Name *string `type:"string"`

	// Current number of mount targets that the file system has. For more information,
	// see CreateMountTarget.
	//
	// NumberOfMountTargets is a required field
	NumberOfMountTargets *int64 `type:"integer" required:"true"`

	// AWS account that created the file system. If the file system was created
	// by an IAM user, the parent account to which the user belongs is the owner.
	//
	// OwnerId is a required field
	OwnerId *string `type:"string" required:"true"`

	// The PerformanceMode of the file system.
	//
	// PerformanceMode is a required field
	PerformanceMode PerformanceMode `type:"string" required:"true" enum:"true"`

	// Latest known metered size (in bytes) of data stored in the file system, in
	// bytes, in its Value field, and the time at which that size was determined
	// in its Timestamp field. The Timestamp value is the integer number of seconds
	// since 1970-01-01T00:00:00Z. Note that the value does not represent the size
	// of a consistent snapshot of the file system, but it is eventually consistent
	// when there are no writes to the file system. That is, the value will represent
	// actual size only if the file system is not modified for a period longer than
	// a couple of hours. Otherwise, the value is not the exact size the file system
	// was at any instant in time.
	//
	// SizeInBytes is a required field
	SizeInBytes *FileSystemSize `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateFileSystemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFileSystemOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateFileSystemOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateFileSystemOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationTime != nil {
		v := *s.CreationTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreationToken != nil {
		v := *s.CreationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Encrypted != nil {
		v := *s.Encrypted

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Encrypted", protocol.BoolValue(v), metadata)
	}
	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KmsKeyId != nil {
		v := *s.KmsKeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KmsKeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.LifeCycleState) > 0 {
		v := s.LifeCycleState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LifeCycleState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NumberOfMountTargets != nil {
		v := *s.NumberOfMountTargets

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberOfMountTargets", protocol.Int64Value(v), metadata)
	}
	if s.OwnerId != nil {
		v := *s.OwnerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OwnerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PerformanceMode) > 0 {
		v := s.PerformanceMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PerformanceMode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SizeInBytes != nil {
		v := s.SizeInBytes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SizeInBytes", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/CreateMountTargetRequest
type CreateMountTargetInput struct {
	_ struct{} `type:"structure"`

	// ID of the file system for which to create the mount target.
	//
	// FileSystemId is a required field
	FileSystemId *string `type:"string" required:"true"`

	// Valid IPv4 address within the address range of the specified subnet.
	IpAddress *string `type:"string"`

	// Up to five VPC security group IDs, of the form sg-xxxxxxxx. These must be
	// for the same VPC as subnet specified.
	SecurityGroups []string `type:"list"`

	// ID of the subnet to add the mount target in.
	//
	// SubnetId is a required field
	SubnetId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s CreateMountTargetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateMountTargetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateMountTargetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateMountTargetInput"}

	if s.FileSystemId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FileSystemId"))
	}

	if s.SubnetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("SubnetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateMountTargetInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IpAddress != nil {
		v := *s.IpAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IpAddress", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SecurityGroups) > 0 {
		v := s.SecurityGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SecurityGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.SubnetId != nil {
		v := *s.SubnetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubnetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Provides a description of a mount target.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/MountTargetDescription
type CreateMountTargetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// ID of the file system for which the mount target is intended.
	//
	// FileSystemId is a required field
	FileSystemId *string `type:"string" required:"true"`

	// Address at which the file system may be mounted via the mount target.
	IpAddress *string `type:"string"`

	// Lifecycle state of the mount target.
	//
	// LifeCycleState is a required field
	LifeCycleState LifeCycleState `type:"string" required:"true" enum:"true"`

	// System-assigned mount target ID.
	//
	// MountTargetId is a required field
	MountTargetId *string `type:"string" required:"true"`

	// ID of the network interface that Amazon EFS created when it created the mount
	// target.
	NetworkInterfaceId *string `type:"string"`

	// AWS account ID that owns the resource.
	OwnerId *string `type:"string"`

	// ID of the mount target's subnet.
	//
	// SubnetId is a required field
	SubnetId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s CreateMountTargetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateMountTargetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateMountTargetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateMountTargetOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IpAddress != nil {
		v := *s.IpAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IpAddress", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.LifeCycleState) > 0 {
		v := s.LifeCycleState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LifeCycleState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.MountTargetId != nil {
		v := *s.MountTargetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MountTargetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NetworkInterfaceId != nil {
		v := *s.NetworkInterfaceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NetworkInterfaceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OwnerId != nil {
		v := *s.OwnerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OwnerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SubnetId != nil {
		v := *s.SubnetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubnetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/CreateTagsRequest
type CreateTagsInput struct {
	_ struct{} `type:"structure"`

	// ID of the file system whose tags you want to modify (String). This operation
	// modifies the tags only, not the file system.
	//
	// FileSystemId is a required field
	FileSystemId *string `location:"uri" locationName:"FileSystemId" type:"string" required:"true"`

	// Array of Tag objects to add. Each Tag object is a key-value pair.
	//
	// Tags is a required field
	Tags []Tag `type:"list" required:"true"`
}

// String returns the string representation
func (s CreateTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTagsInput"}

	if s.FileSystemId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FileSystemId"))
	}

	if s.Tags == nil {
		invalidParams.Add(aws.NewErrParamRequired("Tags"))
	}
	if s.Tags != nil {
		for i, v := range s.Tags {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Tags", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTagsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Tags", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/CreateTagsOutput
type CreateTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteFileSystemRequest
type DeleteFileSystemInput struct {
	_ struct{} `type:"structure"`

	// ID of the file system you want to delete.
	//
	// FileSystemId is a required field
	FileSystemId *string `location:"uri" locationName:"FileSystemId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteFileSystemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFileSystemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteFileSystemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteFileSystemInput"}

	if s.FileSystemId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FileSystemId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteFileSystemInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteFileSystemOutput
type DeleteFileSystemOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteFileSystemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFileSystemOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteFileSystemOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteFileSystemOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteMountTargetRequest
type DeleteMountTargetInput struct {
	_ struct{} `type:"structure"`

	// ID of the mount target to delete (String).
	//
	// MountTargetId is a required field
	MountTargetId *string `location:"uri" locationName:"MountTargetId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteMountTargetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMountTargetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteMountTargetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteMountTargetInput"}

	if s.MountTargetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MountTargetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteMountTargetInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MountTargetId != nil {
		v := *s.MountTargetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "MountTargetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteMountTargetOutput
type DeleteMountTargetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteMountTargetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMountTargetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteMountTargetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteMountTargetOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteTagsRequest
type DeleteTagsInput struct {
	_ struct{} `type:"structure"`

	// ID of the file system whose tags you want to delete (String).
	//
	// FileSystemId is a required field
	FileSystemId *string `location:"uri" locationName:"FileSystemId" type:"string" required:"true"`

	// List of tag keys to delete.
	//
	// TagKeys is a required field
	TagKeys []string `type:"list" required:"true"`
}

// String returns the string representation
func (s DeleteTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTagsInput"}

	if s.FileSystemId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FileSystemId"))
	}

	if s.TagKeys == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTagsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.TagKeys) > 0 {
		v := s.TagKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TagKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DeleteTagsOutput
type DeleteTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeFileSystemsRequest
type DescribeFileSystemsInput struct {
	_ struct{} `type:"structure"`

	// (Optional) Restricts the list to the file system with this creation token
	// (String). You specify a creation token when you create an Amazon EFS file
	// system.
	CreationToken *string `location:"querystring" locationName:"CreationToken" min:"1" type:"string"`

	// (Optional) ID of the file system whose description you want to retrieve (String).
	FileSystemId *string `location:"querystring" locationName:"FileSystemId" type:"string"`

	// (Optional) Opaque pagination token returned from a previous DescribeFileSystems
	// operation (String). If present, specifies to continue the list from where
	// the returning call had left off.
	Marker *string `location:"querystring" locationName:"Marker" type:"string"`

	// (Optional) Specifies the maximum number of file systems to return in the
	// response (integer). This parameter value must be greater than 0. The number
	// of items that Amazon EFS returns is the minimum of the MaxItems parameter
	// specified in the request and the service's internal maximum number of items
	// per page.
	MaxItems *int64 `location:"querystring" locationName:"MaxItems" min:"1" type:"integer"`
}

// String returns the string representation
func (s DescribeFileSystemsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFileSystemsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeFileSystemsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeFileSystemsInput"}
	if s.CreationToken != nil && len(*s.CreationToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CreationToken", 1))
	}
	if s.MaxItems != nil && *s.MaxItems < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxItems", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeFileSystemsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CreationToken != nil {
		v := *s.CreationToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "CreationToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "MaxItems", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeFileSystemsResponse
type DescribeFileSystemsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Array of file system descriptions.
	FileSystems []CreateFileSystemOutput `type:"list"`

	// Present if provided by caller in the request (String).
	Marker *string `type:"string"`

	// Present if there are more file systems than returned in the response (String).
	// You can use the NextMarker in the subsequent request to fetch the descriptions.
	NextMarker *string `type:"string"`
}

// String returns the string representation
func (s DescribeFileSystemsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFileSystemsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeFileSystemsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeFileSystemsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.FileSystems) > 0 {
		v := s.FileSystems

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FileSystems", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeMountTargetSecurityGroupsRequest
type DescribeMountTargetSecurityGroupsInput struct {
	_ struct{} `type:"structure"`

	// ID of the mount target whose security groups you want to retrieve.
	//
	// MountTargetId is a required field
	MountTargetId *string `location:"uri" locationName:"MountTargetId" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeMountTargetSecurityGroupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMountTargetSecurityGroupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeMountTargetSecurityGroupsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeMountTargetSecurityGroupsInput"}

	if s.MountTargetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MountTargetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeMountTargetSecurityGroupsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MountTargetId != nil {
		v := *s.MountTargetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "MountTargetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeMountTargetSecurityGroupsResponse
type DescribeMountTargetSecurityGroupsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Array of security groups.
	//
	// SecurityGroups is a required field
	SecurityGroups []string `type:"list" required:"true"`
}

// String returns the string representation
func (s DescribeMountTargetSecurityGroupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMountTargetSecurityGroupsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeMountTargetSecurityGroupsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeMountTargetSecurityGroupsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.SecurityGroups) > 0 {
		v := s.SecurityGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SecurityGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeMountTargetsRequest
type DescribeMountTargetsInput struct {
	_ struct{} `type:"structure"`

	// (Optional) ID of the file system whose mount targets you want to list (String).
	// It must be included in your request if MountTargetId is not included.
	FileSystemId *string `location:"querystring" locationName:"FileSystemId" type:"string"`

	// (Optional) Opaque pagination token returned from a previous DescribeMountTargets
	// operation (String). If present, it specifies to continue the list from where
	// the previous returning call left off.
	Marker *string `location:"querystring" locationName:"Marker" type:"string"`

	// (Optional) Maximum number of mount targets to return in the response. It
	// must be an integer with a value greater than zero.
	MaxItems *int64 `location:"querystring" locationName:"MaxItems" min:"1" type:"integer"`

	// (Optional) ID of the mount target that you want to have described (String).
	// It must be included in your request if FileSystemId is not included.
	MountTargetId *string `location:"querystring" locationName:"MountTargetId" type:"string"`
}

// String returns the string representation
func (s DescribeMountTargetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMountTargetsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeMountTargetsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeMountTargetsInput"}
	if s.MaxItems != nil && *s.MaxItems < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxItems", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeMountTargetsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "MaxItems", protocol.Int64Value(v), metadata)
	}
	if s.MountTargetId != nil {
		v := *s.MountTargetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "MountTargetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeMountTargetsResponse
type DescribeMountTargetsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If the request included the Marker, the response returns that value in this
	// field.
	Marker *string `type:"string"`

	// Returns the file system's mount targets as an array of MountTargetDescription
	// objects.
	MountTargets []CreateMountTargetOutput `type:"list"`

	// If a value is present, there are more mount targets to return. In a subsequent
	// request, you can provide Marker in your request with this value to retrieve
	// the next set of mount targets.
	NextMarker *string `type:"string"`
}

// String returns the string representation
func (s DescribeMountTargetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMountTargetsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeMountTargetsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeMountTargetsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.MountTargets) > 0 {
		v := s.MountTargets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "MountTargets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeTagsRequest
type DescribeTagsInput struct {
	_ struct{} `type:"structure"`

	// ID of the file system whose tag set you want to retrieve.
	//
	// FileSystemId is a required field
	FileSystemId *string `location:"uri" locationName:"FileSystemId" type:"string" required:"true"`

	// (Optional) Opaque pagination token returned from a previous DescribeTags
	// operation (String). If present, it specifies to continue the list from where
	// the previous call left off.
	Marker *string `location:"querystring" locationName:"Marker" type:"string"`

	// (Optional) Maximum number of file system tags to return in the response.
	// It must be an integer with a value greater than zero.
	MaxItems *int64 `location:"querystring" locationName:"MaxItems" min:"1" type:"integer"`
}

// String returns the string representation
func (s DescribeTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeTagsInput"}

	if s.FileSystemId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FileSystemId"))
	}
	if s.MaxItems != nil && *s.MaxItems < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxItems", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeTagsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.FileSystemId != nil {
		v := *s.FileSystemId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "FileSystemId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "MaxItems", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/DescribeTagsResponse
type DescribeTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If the request included a Marker, the response returns that value in this
	// field.
	Marker *string `type:"string"`

	// If a value is present, there are more tags to return. In a subsequent request,
	// you can provide the value of NextMarker as the value of the Marker parameter
	// in your next request to retrieve the next set of tags.
	NextMarker *string `type:"string"`

	// Returns tags associated with the file system as an array of Tag objects.
	//
	// Tags is a required field
	Tags []Tag `type:"list" required:"true"`
}

// String returns the string representation
func (s DescribeTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextMarker", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Tags", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Latest known metered size (in bytes) of data stored in the file system, in
// its Value field, and the time at which that size was determined in its Timestamp
// field. Note that the value does not represent the size of a consistent snapshot
// of the file system, but it is eventually consistent when there are no writes
// to the file system. That is, the value will represent the actual size only
// if the file system is not modified for a period longer than a couple of hours.
// Otherwise, the value is not necessarily the exact size the file system was
// at any instant in time.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/FileSystemSize
type FileSystemSize struct {
	_ struct{} `type:"structure"`

	// Time at which the size of data, returned in the Value field, was determined.
	// The value is the integer number of seconds since 1970-01-01T00:00:00Z.
	Timestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Latest known metered size (in bytes) of data stored in the file system.
	//
	// Value is a required field
	Value *int64 `type:"long" required:"true"`
}

// String returns the string representation
func (s FileSystemSize) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileSystemSize) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FileSystemSize) MarshalFields(e protocol.FieldEncoder) error {
	if s.Timestamp != nil {
		v := *s.Timestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Timestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/ModifyMountTargetSecurityGroupsRequest
type ModifyMountTargetSecurityGroupsInput struct {
	_ struct{} `type:"structure"`

	// ID of the mount target whose security groups you want to modify.
	//
	// MountTargetId is a required field
	MountTargetId *string `location:"uri" locationName:"MountTargetId" type:"string" required:"true"`

	// Array of up to five VPC security group IDs.
	SecurityGroups []string `type:"list"`
}

// String returns the string representation
func (s ModifyMountTargetSecurityGroupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ModifyMountTargetSecurityGroupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ModifyMountTargetSecurityGroupsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ModifyMountTargetSecurityGroupsInput"}

	if s.MountTargetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MountTargetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ModifyMountTargetSecurityGroupsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.SecurityGroups) > 0 {
		v := s.SecurityGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SecurityGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.MountTargetId != nil {
		v := *s.MountTargetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "MountTargetId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/ModifyMountTargetSecurityGroupsOutput
type ModifyMountTargetSecurityGroupsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s ModifyMountTargetSecurityGroupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ModifyMountTargetSecurityGroupsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ModifyMountTargetSecurityGroupsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ModifyMountTargetSecurityGroupsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A tag is a key-value pair. Allowed characters: letters, whitespace, and numbers,
// representable in UTF-8, and the following characters: + - = . _ : /
// Please also see https://docs.aws.amazon.com/goto/WebAPI/elasticfilesystem-2015-02-01/Tag
type Tag struct {
	_ struct{} `type:"structure"`

	// Tag key (String). The key can't start with aws:.
	//
	// Key is a required field
	Key *string `min:"1" type:"string" required:"true"`

	// Value of the tag key.
	//
	// Value is a required field
	Value *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Tag) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Tag) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Tag) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Tag"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Tag) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type LifeCycleState string

// Enum values for LifeCycleState
const (
	LifeCycleStateCreating  LifeCycleState = "creating"
	LifeCycleStateAvailable LifeCycleState = "available"
	LifeCycleStateDeleting  LifeCycleState = "deleting"
	LifeCycleStateDeleted   LifeCycleState = "deleted"
)

func (enum LifeCycleState) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum LifeCycleState) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type PerformanceMode string

// Enum values for PerformanceMode
const (
	PerformanceModeGeneralPurpose PerformanceMode = "generalPurpose"
	PerformanceModeMaxIo          PerformanceMode = "maxIO"
)

func (enum PerformanceMode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum PerformanceMode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
