// Code generated by smithy-go-codegen DO NOT EDIT.

package applicationautoscaling

import (
	"context"
	awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
	awsid "github.com/aws/aws-sdk-go-v2/aws/middleware/id"
	"github.com/aws/aws-sdk-go-v2/aws/signer/v4"
	"github.com/aws/aws-sdk-go-v2/service/applicationautoscaling/types"
	"github.com/awslabs/smithy-go/middleware"
	smithyid "github.com/awslabs/smithy-go/middleware/id"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

// Registers or updates a scalable target. A scalable target is a resource that
// Application Auto Scaling can scale out and scale in. Scalable targets are
// uniquely identified by the combination of resource ID, scalable dimension, and
// namespace. When you register a new scalable target, you must specify values for
// minimum and maximum capacity. Application Auto Scaling scaling policies will not
// scale capacity to values that are outside of this range. After you register a
// scalable target, you do not need to register it again to use other Application
// Auto Scaling operations. To see which resources have been registered, use
// DescribeScalableTargets
// (https://docs.aws.amazon.com/autoscaling/application/APIReference/API_DescribeScalableTargets.html).
// You can also view the scaling policies for a service namespace by using
// DescribeScalableTargets
// (https://docs.aws.amazon.com/autoscaling/application/APIReference/API_DescribeScalableTargets.html).
// If you no longer need a scalable target, you can deregister it by using
// DeregisterScalableTarget
// (https://docs.aws.amazon.com/autoscaling/application/APIReference/API_DeregisterScalableTarget.html).
// To update a scalable target, specify the parameters that you want to change.
// Include the parameters that identify the scalable target: resource ID, scalable
// dimension, and namespace. Any parameters that you don't specify are not changed
// by this update request.
func (c *Client) RegisterScalableTarget(ctx context.Context, params *RegisterScalableTargetInput, optFns ...func(*Options)) (*RegisterScalableTargetOutput, error) {
	if params == nil {
		params = &RegisterScalableTargetInput{}
	}

	result, metadata, err := c.invokeOperation(ctx, "RegisterScalableTarget", params, optFns, addOperationRegisterScalableTargetMiddlewares)
	if err != nil {
		return nil, err
	}

	out := result.(*RegisterScalableTargetOutput)
	out.ResultMetadata = metadata
	return out, nil
}

type RegisterScalableTargetInput struct {

	// The identifier of the resource that is associated with the scalable target. This
	// string consists of the resource type and unique identifier.
	//
	//     * ECS service -
	// The resource type is service and the unique identifier is the cluster name and
	// service name. Example: service/default/sample-webapp.
	//
	//     * Spot Fleet request
	// - The resource type is spot-fleet-request and the unique identifier is the Spot
	// Fleet request ID. Example:
	// spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE.
	//
	//     * EMR cluster
	// - The resource type is instancegroup and the unique identifier is the cluster ID
	// and instance group ID. Example:
	// instancegroup/j-2EEZNYKUA1NTV/ig-1791Y4E1L8YI0.
	//
	//     * AppStream 2.0 fleet - The
	// resource type is fleet and the unique identifier is the fleet name. Example:
	// fleet/sample-fleet.
	//
	//     * DynamoDB table - The resource type is table and the
	// unique identifier is the table name. Example: table/my-table.
	//
	//     * DynamoDB
	// global secondary index - The resource type is index and the unique identifier is
	// the index name. Example: table/my-table/index/my-table-index.
	//
	//     * Aurora DB
	// cluster - The resource type is cluster and the unique identifier is the cluster
	// name. Example: cluster:my-db-cluster.
	//
	//     * Amazon SageMaker endpoint variant -
	// The resource type is variant and the unique identifier is the resource ID.
	// Example: endpoint/my-end-point/variant/KMeansClustering.
	//
	//     * Custom resources
	// are not supported with a resource type. This parameter must specify the
	// OutputValue from the CloudFormation template stack used to access the resources.
	// The unique identifier is defined by the service provider. More information is
	// available in our GitHub repository
	// (https://github.com/aws/aws-auto-scaling-custom-resource).
	//
	//     * Amazon
	// Comprehend document classification endpoint - The resource type and unique
	// identifier are specified using the endpoint ARN. Example:
	// arn:aws:comprehend:us-west-2:123456789012:document-classifier-endpoint/EXAMPLE.
	//
	//
	// * Lambda provisioned concurrency - The resource type is function and the unique
	// identifier is the function name with a function version or alias name suffix
	// that is not $LATEST. Example: function:my-function:prod or
	// function:my-function:1.
	//
	//     * Amazon Keyspaces table - The resource type is
	// table and the unique identifier is the table name. Example:
	// keyspace/mykeyspace/table/mytable.
	//
	// This member is required.
	ResourceId *string

	// The scalable dimension associated with the scalable target. This string consists
	// of the service namespace, resource type, and scaling property.
	//
	//     *
	// ecs:service:DesiredCount - The desired task count of an ECS service.
	//
	//     *
	// ec2:spot-fleet-request:TargetCapacity - The target capacity of a Spot Fleet
	// request.
	//
	//     * elasticmapreduce:instancegroup:InstanceCount - The instance
	// count of an EMR Instance Group.
	//
	//     * appstream:fleet:DesiredCapacity - The
	// desired capacity of an AppStream 2.0 fleet.
	//
	//     *
	// dynamodb:table:ReadCapacityUnits - The provisioned read capacity for a DynamoDB
	// table.
	//
	//     * dynamodb:table:WriteCapacityUnits - The provisioned write capacity
	// for a DynamoDB table.
	//
	//     * dynamodb:index:ReadCapacityUnits - The provisioned
	// read capacity for a DynamoDB global secondary index.
	//
	//     *
	// dynamodb:index:WriteCapacityUnits - The provisioned write capacity for a
	// DynamoDB global secondary index.
	//
	//     * rds:cluster:ReadReplicaCount - The count
	// of Aurora Replicas in an Aurora DB cluster. Available for Aurora
	// MySQL-compatible edition and Aurora PostgreSQL-compatible edition.
	//
	//     *
	// sagemaker:variant:DesiredInstanceCount - The number of EC2 instances for an
	// Amazon SageMaker model endpoint variant.
	//
	//     *
	// custom-resource:ResourceType:Property - The scalable dimension for a custom
	// resource provided by your own application or service.
	//
	//     *
	// comprehend:document-classifier-endpoint:DesiredInferenceUnits - The number of
	// inference units for an Amazon Comprehend document classification endpoint.
	//
	//
	// * lambda:function:ProvisionedConcurrency - The provisioned concurrency for a
	// Lambda function.
	//
	//     * cassandra:table:ReadCapacityUnits - The provisioned read
	// capacity for an Amazon Keyspaces table.
	//
	//     *
	// cassandra:table:WriteCapacityUnits - The provisioned write capacity for an
	// Amazon Keyspaces table.
	//
	// This member is required.
	ScalableDimension types.ScalableDimension

	// The namespace of the AWS service that provides the resource. For a resource
	// provided by your own application or service, use custom-resource instead.
	//
	// This member is required.
	ServiceNamespace types.ServiceNamespace

	// The maximum value that you plan to scale out to. When a scaling policy is in
	// effect, Application Auto Scaling can scale out (expand) as needed to the maximum
	// capacity limit in response to changing demand. This parameter is required if you
	// are registering a scalable target.
	MaxCapacity *int32

	// The minimum value that you plan to scale in to. When a scaling policy is in
	// effect, Application Auto Scaling can scale in (contract) as needed to the
	// minimum capacity limit in response to changing demand. This parameter is
	// required if you are registering a scalable target. For certain resources, the
	// minimum value allowed is 0. This includes Lambda provisioned concurrency, Spot
	// Fleet, ECS services, Aurora DB clusters, EMR clusters, and custom resources. For
	// all other resources, the minimum value allowed is 1.
	MinCapacity *int32

	// This parameter is required for services that do not support service-linked roles
	// (such as Amazon EMR), and it must specify the ARN of an IAM role that allows
	// Application Auto Scaling to modify the scalable target on your behalf. If the
	// service supports service-linked roles, Application Auto Scaling uses a
	// service-linked role, which it creates if it does not yet exist. For more
	// information, see Application Auto Scaling IAM Roles
	// (https://docs.aws.amazon.com/autoscaling/application/userguide/security_iam_service-with-iam.html#security_iam_service-with-iam-roles).
	RoleARN *string

	// An embedded object that contains attributes and attribute values that are used
	// to suspend and resume automatic scaling. Setting the value of an attribute to
	// true suspends the specified scaling activities. Setting it to false (default)
	// resumes the specified scaling activities. Suspension Outcomes
	//
	//     * For
	// DynamicScalingInSuspended, while a suspension is in effect, all scale-in
	// activities that are triggered by a scaling policy are suspended.
	//
	//     * For
	// DynamicScalingOutSuspended, while a suspension is in effect, all scale-out
	// activities that are triggered by a scaling policy are suspended.
	//
	//     * For
	// ScheduledScalingSuspended, while a suspension is in effect, all scaling
	// activities that involve scheduled actions are suspended.
	//
	// For more information,
	// see Suspending and Resuming Scaling
	// (https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-suspend-resume-scaling.html)
	// in the Application Auto Scaling User Guide.
	SuspendedState *types.SuspendedState
}

type RegisterScalableTargetOutput struct {
	// Metadata pertaining to the operation's result.
	ResultMetadata middleware.Metadata
}

func addOperationRegisterScalableTargetStackSlots(stack *middleware.Stack) error {
	if err := stack.Initialize.AddSlot(middleware.After,
		smithyid.OperationIdempotencyTokenAutoFill,
		smithyid.OperationInputValidation,
	); err != nil {
		return err
	}
	if err := stack.Initialize.AddSlot(middleware.Before,
		awsid.RegisterServiceMetadata,
		awsid.Presigning,
	); err != nil {
		return err
	}
	if err := stack.Serialize.AddSlot(middleware.After,
		smithyid.OperationSerializer,
	); err != nil {
		return err
	}
	if err := stack.Serialize.InsertSlot(smithyid.OperationSerializer, middleware.Before,
		awsid.ResolveEndpoint,
	); err != nil {
		return err
	}
	if err := stack.Build.AddSlot(middleware.After,
		smithyid.ContentChecksum,
		smithyid.ComputeContentLength,
		smithyid.ValidateContentLength,
	); err != nil {
		return err
	}
	if err := stack.Build.AddSlot(middleware.After,
		awsid.ClientRequestID,
		awsid.ComputePayloadHash,
		awsid.UserAgent,
	); err != nil {
		return err
	}
	if err := stack.Finalize.AddSlot(middleware.After,
		awsid.Retry,
		awsid.Signing,
	); err != nil {
		return err
	}
	if err := stack.Deserialize.AddSlot(middleware.After,
		smithyid.ErrorCloseResponseBody,
		smithyid.CloseResponseBody,
		smithyid.OperationDeserializer,
	); err != nil {
		return err
	}
	if err := stack.Deserialize.AddSlot(middleware.Before,
		awsid.ResponseErrorWrapper,
		awsid.RequestIDRetriever,
	); err != nil {
		return err
	}
	if err := stack.Deserialize.InsertSlot(smithyid.OperationDeserializer, middleware.After,
		awsid.ResponseReadTimeout,
	); err != nil {
		return err
	}
	return nil
}
func addOperationRegisterScalableTargetMiddlewares(stack *middleware.Stack, options Options) (err error) {
	if err := addOperationRegisterScalableTargetStackSlots(stack); err != nil {
		return err
	}
	err = stack.Serialize.Add(&awsAwsjson11_serializeOpRegisterScalableTarget{}, middleware.After)
	if err != nil {
		return err
	}
	err = stack.Deserialize.Add(&awsAwsjson11_deserializeOpRegisterScalableTarget{}, middleware.After)
	if err != nil {
		return err
	}
	if err := awsmiddleware.AddClientRequestIDMiddleware(stack); err != nil {
		return err
	}
	if err := smithyhttp.AddComputeContentLengthMiddleware(stack); err != nil {
		return err
	}
	if err := addResolveEndpointMiddleware(stack, options); err != nil {
		return err
	}
	if err := v4.AddComputePayloadSHA256Middleware(stack); err != nil {
		return err
	}
	if err := addRetryMiddlewares(stack, options); err != nil {
		return err
	}
	if err := addHTTPSignerV4Middleware(stack, options); err != nil {
		return err
	}
	if err := awsmiddleware.AddAttemptClockSkewMiddleware(stack); err != nil {
		return err
	}
	if err := addClientUserAgent(stack); err != nil {
		return err
	}
	if err := smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {
		return err
	}
	if err := smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {
		return err
	}
	if err := addOpRegisterScalableTargetValidationMiddleware(stack); err != nil {
		return err
	}
	if err := stack.Initialize.Add(newServiceMetadataMiddleware_opRegisterScalableTarget(options.Region), middleware.Before); err != nil {
		return err
	}
	if err := addRequestIDRetrieverMiddleware(stack); err != nil {
		return err
	}
	if err := addResponseErrorMiddleware(stack); err != nil {
		return err
	}
	return nil
}

func newServiceMetadataMiddleware_opRegisterScalableTarget(region string) *awsmiddleware.RegisterServiceMetadata {
	return &awsmiddleware.RegisterServiceMetadata{
		Region:        region,
		ServiceID:     ServiceID,
		SigningName:   "application-autoscaling",
		OperationName: "RegisterScalableTarget",
	}
}
