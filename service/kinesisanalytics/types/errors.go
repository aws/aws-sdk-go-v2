// Code generated by smithy-go-codegen DO NOT EDIT.

package types

import (
	"fmt"
	smithy "github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/ptr"
)

// User-provided application code (query) is invalid. This can be a simple syntax
// error.
type CodeValidationException struct {
	Message *string
}

func (e *CodeValidationException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *CodeValidationException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *CodeValidationException) ErrorCode() string             { return "CodeValidationException" }
func (e *CodeValidationException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *CodeValidationException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *CodeValidationException) HasMessage() bool {
	return e.Message != nil
}

// Exception thrown as a result of concurrent modification to an application. For
// example, two individuals attempting to edit the same application at the same
// time.
type ConcurrentModificationException struct {
	Message *string
}

func (e *ConcurrentModificationException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *ConcurrentModificationException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *ConcurrentModificationException) ErrorCode() string {
	return "ConcurrentModificationException"
}
func (e *ConcurrentModificationException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *ConcurrentModificationException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *ConcurrentModificationException) HasMessage() bool {
	return e.Message != nil
}

// User-provided application configuration is not valid.
type InvalidApplicationConfigurationException struct {
	Message *string
}

func (e *InvalidApplicationConfigurationException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *InvalidApplicationConfigurationException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *InvalidApplicationConfigurationException) ErrorCode() string {
	return "InvalidApplicationConfigurationException"
}
func (e *InvalidApplicationConfigurationException) ErrorFault() smithy.ErrorFault {
	return smithy.FaultClient
}
func (e *InvalidApplicationConfigurationException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *InvalidApplicationConfigurationException) HasMessage() bool {
	return e.Message != nil
}

// Specified input parameter value is invalid.
type InvalidArgumentException struct {
	Message *string
}

func (e *InvalidArgumentException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *InvalidArgumentException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *InvalidArgumentException) ErrorCode() string             { return "InvalidArgumentException" }
func (e *InvalidArgumentException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *InvalidArgumentException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *InvalidArgumentException) HasMessage() bool {
	return e.Message != nil
}

// Exceeded the number of applications allowed.
type LimitExceededException struct {
	Message *string
}

func (e *LimitExceededException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *LimitExceededException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *LimitExceededException) ErrorCode() string             { return "LimitExceededException" }
func (e *LimitExceededException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *LimitExceededException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *LimitExceededException) HasMessage() bool {
	return e.Message != nil
}

// Application is not available for this operation.
type ResourceInUseException struct {
	Message *string
}

func (e *ResourceInUseException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *ResourceInUseException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *ResourceInUseException) ErrorCode() string             { return "ResourceInUseException" }
func (e *ResourceInUseException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *ResourceInUseException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *ResourceInUseException) HasMessage() bool {
	return e.Message != nil
}

// Specified application can't be found.
type ResourceNotFoundException struct {
	Message *string
}

func (e *ResourceNotFoundException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *ResourceNotFoundException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *ResourceNotFoundException) ErrorCode() string             { return "ResourceNotFoundException" }
func (e *ResourceNotFoundException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *ResourceNotFoundException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *ResourceNotFoundException) HasMessage() bool {
	return e.Message != nil
}

// Discovery failed to get a record from the streaming source because of the Amazon
// Kinesis Streams ProvisionedThroughputExceededException. For more information,
// see GetRecords
// (https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html) in
// the Amazon Kinesis Streams API Reference.
type ResourceProvisionedThroughputExceededException struct {
	Message *string
}

func (e *ResourceProvisionedThroughputExceededException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *ResourceProvisionedThroughputExceededException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *ResourceProvisionedThroughputExceededException) ErrorCode() string {
	return "ResourceProvisionedThroughputExceededException"
}
func (e *ResourceProvisionedThroughputExceededException) ErrorFault() smithy.ErrorFault {
	return smithy.FaultClient
}
func (e *ResourceProvisionedThroughputExceededException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *ResourceProvisionedThroughputExceededException) HasMessage() bool {
	return e.Message != nil
}

// The service is unavailable. Back off and retry the operation.
type ServiceUnavailableException struct {
	Message *string
}

func (e *ServiceUnavailableException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *ServiceUnavailableException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *ServiceUnavailableException) ErrorCode() string             { return "ServiceUnavailableException" }
func (e *ServiceUnavailableException) ErrorFault() smithy.ErrorFault { return smithy.FaultServer }
func (e *ServiceUnavailableException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *ServiceUnavailableException) HasMessage() bool {
	return e.Message != nil
}

// Application created with too many tags, or too many tags added to an
// application. Note that the maximum number of application tags includes system
// tags. The maximum number of user-defined application tags is 50.
type TooManyTagsException struct {
	Message *string
}

func (e *TooManyTagsException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *TooManyTagsException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *TooManyTagsException) ErrorCode() string             { return "TooManyTagsException" }
func (e *TooManyTagsException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *TooManyTagsException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *TooManyTagsException) HasMessage() bool {
	return e.Message != nil
}

// Data format is not valid. Amazon Kinesis Analytics is not able to detect schema
// for the given streaming source.
type UnableToDetectSchemaException struct {
	Message *string

	RawInputRecords       []*string
	ProcessedInputRecords []*string
}

func (e *UnableToDetectSchemaException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *UnableToDetectSchemaException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *UnableToDetectSchemaException) ErrorCode() string             { return "UnableToDetectSchemaException" }
func (e *UnableToDetectSchemaException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *UnableToDetectSchemaException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *UnableToDetectSchemaException) HasMessage() bool {
	return e.Message != nil
}
func (e *UnableToDetectSchemaException) GetRawInputRecords() []*string {
	return e.RawInputRecords
}
func (e *UnableToDetectSchemaException) HasRawInputRecords() bool {
	return e.RawInputRecords != nil
}
func (e *UnableToDetectSchemaException) GetProcessedInputRecords() []*string {
	return e.ProcessedInputRecords
}
func (e *UnableToDetectSchemaException) HasProcessedInputRecords() bool {
	return e.ProcessedInputRecords != nil
}

// The request was rejected because a specified parameter is not supported or a
// specified resource is not valid for this operation.
type UnsupportedOperationException struct {
	Message *string
}

func (e *UnsupportedOperationException) Error() string {
	return fmt.Sprintf("%s: %s", e.ErrorCode(), e.ErrorMessage())
}
func (e *UnsupportedOperationException) ErrorMessage() string {
	if e.Message == nil {
		return ""
	}
	return *e.Message
}
func (e *UnsupportedOperationException) ErrorCode() string             { return "UnsupportedOperationException" }
func (e *UnsupportedOperationException) ErrorFault() smithy.ErrorFault { return smithy.FaultClient }
func (e *UnsupportedOperationException) GetMessage() string {
	return ptr.ToString(e.Message)
}
func (e *UnsupportedOperationException) HasMessage() bool {
	return e.Message != nil
}
