// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package clouddirectory

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opAddFacetToObject = "AddFacetToObject"

// AddFacetToObjectRequest is a API request type for the AddFacetToObject API operation.
type AddFacetToObjectRequest struct {
	*aws.Request
	Input *AddFacetToObjectInput
	Copy  func(*AddFacetToObjectInput) AddFacetToObjectRequest
}

// Send marshals and sends the AddFacetToObject API request.
func (r AddFacetToObjectRequest) Send() (*AddFacetToObjectOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AddFacetToObjectOutput), nil
}

// AddFacetToObjectRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Adds a new Facet to an object. An object can have more than one facet applied
// on it.
//
//    // Example sending a request using the AddFacetToObjectRequest method.
//    req := client.AddFacetToObjectRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AddFacetToObject
func (c *CloudDirectory) AddFacetToObjectRequest(input *AddFacetToObjectInput) AddFacetToObjectRequest {
	op := &aws.Operation{
		Name:       opAddFacetToObject,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/facets",
	}

	if input == nil {
		input = &AddFacetToObjectInput{}
	}

	output := &AddFacetToObjectOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AddFacetToObjectRequest{Request: req, Input: input, Copy: c.AddFacetToObjectRequest}
}

const opApplySchema = "ApplySchema"

// ApplySchemaRequest is a API request type for the ApplySchema API operation.
type ApplySchemaRequest struct {
	*aws.Request
	Input *ApplySchemaInput
	Copy  func(*ApplySchemaInput) ApplySchemaRequest
}

// Send marshals and sends the ApplySchema API request.
func (r ApplySchemaRequest) Send() (*ApplySchemaOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ApplySchemaOutput), nil
}

// ApplySchemaRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Copies the input published schema, at the specified version, into the Directory
// with the same name and version as that of the published schema.
//
//    // Example sending a request using the ApplySchemaRequest method.
//    req := client.ApplySchemaRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ApplySchema
func (c *CloudDirectory) ApplySchemaRequest(input *ApplySchemaInput) ApplySchemaRequest {
	op := &aws.Operation{
		Name:       opApplySchema,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/apply",
	}

	if input == nil {
		input = &ApplySchemaInput{}
	}

	output := &ApplySchemaOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ApplySchemaRequest{Request: req, Input: input, Copy: c.ApplySchemaRequest}
}

const opAttachObject = "AttachObject"

// AttachObjectRequest is a API request type for the AttachObject API operation.
type AttachObjectRequest struct {
	*aws.Request
	Input *AttachObjectInput
	Copy  func(*AttachObjectInput) AttachObjectRequest
}

// Send marshals and sends the AttachObject API request.
func (r AttachObjectRequest) Send() (*AttachObjectOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AttachObjectOutput), nil
}

// AttachObjectRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Attaches an existing object to another object. An object can be accessed
// in two ways:
//
// Using the path
//
// Using ObjectIdentifier
//
//    // Example sending a request using the AttachObjectRequest method.
//    req := client.AttachObjectRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachObject
func (c *CloudDirectory) AttachObjectRequest(input *AttachObjectInput) AttachObjectRequest {
	op := &aws.Operation{
		Name:       opAttachObject,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/attach",
	}

	if input == nil {
		input = &AttachObjectInput{}
	}

	output := &AttachObjectOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AttachObjectRequest{Request: req, Input: input, Copy: c.AttachObjectRequest}
}

const opAttachPolicy = "AttachPolicy"

// AttachPolicyRequest is a API request type for the AttachPolicy API operation.
type AttachPolicyRequest struct {
	*aws.Request
	Input *AttachPolicyInput
	Copy  func(*AttachPolicyInput) AttachPolicyRequest
}

// Send marshals and sends the AttachPolicy API request.
func (r AttachPolicyRequest) Send() (*AttachPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AttachPolicyOutput), nil
}

// AttachPolicyRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Attaches a policy object to a regular object. An object can have a limited
// number of attached policies.
//
//    // Example sending a request using the AttachPolicyRequest method.
//    req := client.AttachPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachPolicy
func (c *CloudDirectory) AttachPolicyRequest(input *AttachPolicyInput) AttachPolicyRequest {
	op := &aws.Operation{
		Name:       opAttachPolicy,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/policy/attach",
	}

	if input == nil {
		input = &AttachPolicyInput{}
	}

	output := &AttachPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AttachPolicyRequest{Request: req, Input: input, Copy: c.AttachPolicyRequest}
}

const opAttachToIndex = "AttachToIndex"

// AttachToIndexRequest is a API request type for the AttachToIndex API operation.
type AttachToIndexRequest struct {
	*aws.Request
	Input *AttachToIndexInput
	Copy  func(*AttachToIndexInput) AttachToIndexRequest
}

// Send marshals and sends the AttachToIndex API request.
func (r AttachToIndexRequest) Send() (*AttachToIndexOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AttachToIndexOutput), nil
}

// AttachToIndexRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Attaches the specified object to the specified index.
//
//    // Example sending a request using the AttachToIndexRequest method.
//    req := client.AttachToIndexRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachToIndex
func (c *CloudDirectory) AttachToIndexRequest(input *AttachToIndexInput) AttachToIndexRequest {
	op := &aws.Operation{
		Name:       opAttachToIndex,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/index/attach",
	}

	if input == nil {
		input = &AttachToIndexInput{}
	}

	output := &AttachToIndexOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AttachToIndexRequest{Request: req, Input: input, Copy: c.AttachToIndexRequest}
}

const opAttachTypedLink = "AttachTypedLink"

// AttachTypedLinkRequest is a API request type for the AttachTypedLink API operation.
type AttachTypedLinkRequest struct {
	*aws.Request
	Input *AttachTypedLinkInput
	Copy  func(*AttachTypedLinkInput) AttachTypedLinkRequest
}

// Send marshals and sends the AttachTypedLink API request.
func (r AttachTypedLinkRequest) Send() (*AttachTypedLinkOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AttachTypedLinkOutput), nil
}

// AttachTypedLinkRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Attaches a typed link to a specified source and target object. For more information,
// see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the AttachTypedLinkRequest method.
//    req := client.AttachTypedLinkRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachTypedLink
func (c *CloudDirectory) AttachTypedLinkRequest(input *AttachTypedLinkInput) AttachTypedLinkRequest {
	op := &aws.Operation{
		Name:       opAttachTypedLink,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/attach",
	}

	if input == nil {
		input = &AttachTypedLinkInput{}
	}

	output := &AttachTypedLinkOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AttachTypedLinkRequest{Request: req, Input: input, Copy: c.AttachTypedLinkRequest}
}

const opBatchRead = "BatchRead"

// BatchReadRequest is a API request type for the BatchRead API operation.
type BatchReadRequest struct {
	*aws.Request
	Input *BatchReadInput
	Copy  func(*BatchReadInput) BatchReadRequest
}

// Send marshals and sends the BatchRead API request.
func (r BatchReadRequest) Send() (*BatchReadOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*BatchReadOutput), nil
}

// BatchReadRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Performs all the read operations in a batch.
//
//    // Example sending a request using the BatchReadRequest method.
//    req := client.BatchReadRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchRead
func (c *CloudDirectory) BatchReadRequest(input *BatchReadInput) BatchReadRequest {
	op := &aws.Operation{
		Name:       opBatchRead,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/batchread",
	}

	if input == nil {
		input = &BatchReadInput{}
	}

	output := &BatchReadOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return BatchReadRequest{Request: req, Input: input, Copy: c.BatchReadRequest}
}

const opBatchWrite = "BatchWrite"

// BatchWriteRequest is a API request type for the BatchWrite API operation.
type BatchWriteRequest struct {
	*aws.Request
	Input *BatchWriteInput
	Copy  func(*BatchWriteInput) BatchWriteRequest
}

// Send marshals and sends the BatchWrite API request.
func (r BatchWriteRequest) Send() (*BatchWriteOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*BatchWriteOutput), nil
}

// BatchWriteRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Performs all the write operations in a batch. Either all the operations succeed
// or none.
//
//    // Example sending a request using the BatchWriteRequest method.
//    req := client.BatchWriteRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchWrite
func (c *CloudDirectory) BatchWriteRequest(input *BatchWriteInput) BatchWriteRequest {
	op := &aws.Operation{
		Name:       opBatchWrite,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/batchwrite",
	}

	if input == nil {
		input = &BatchWriteInput{}
	}

	output := &BatchWriteOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return BatchWriteRequest{Request: req, Input: input, Copy: c.BatchWriteRequest}
}

const opCreateDirectory = "CreateDirectory"

// CreateDirectoryRequest is a API request type for the CreateDirectory API operation.
type CreateDirectoryRequest struct {
	*aws.Request
	Input *CreateDirectoryInput
	Copy  func(*CreateDirectoryInput) CreateDirectoryRequest
}

// Send marshals and sends the CreateDirectory API request.
func (r CreateDirectoryRequest) Send() (*CreateDirectoryOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateDirectoryOutput), nil
}

// CreateDirectoryRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Creates a Directory by copying the published schema into the directory. A
// directory cannot be created without a schema.
//
//    // Example sending a request using the CreateDirectoryRequest method.
//    req := client.CreateDirectoryRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateDirectory
func (c *CloudDirectory) CreateDirectoryRequest(input *CreateDirectoryInput) CreateDirectoryRequest {
	op := &aws.Operation{
		Name:       opCreateDirectory,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/directory/create",
	}

	if input == nil {
		input = &CreateDirectoryInput{}
	}

	output := &CreateDirectoryOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDirectoryRequest{Request: req, Input: input, Copy: c.CreateDirectoryRequest}
}

const opCreateFacet = "CreateFacet"

// CreateFacetRequest is a API request type for the CreateFacet API operation.
type CreateFacetRequest struct {
	*aws.Request
	Input *CreateFacetInput
	Copy  func(*CreateFacetInput) CreateFacetRequest
}

// Send marshals and sends the CreateFacet API request.
func (r CreateFacetRequest) Send() (*CreateFacetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateFacetOutput), nil
}

// CreateFacetRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Creates a new Facet in a schema. Facet creation is allowed only in development
// or applied schemas.
//
//    // Example sending a request using the CreateFacetRequest method.
//    req := client.CreateFacetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateFacet
func (c *CloudDirectory) CreateFacetRequest(input *CreateFacetInput) CreateFacetRequest {
	op := &aws.Operation{
		Name:       opCreateFacet,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/facet/create",
	}

	if input == nil {
		input = &CreateFacetInput{}
	}

	output := &CreateFacetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateFacetRequest{Request: req, Input: input, Copy: c.CreateFacetRequest}
}

const opCreateIndex = "CreateIndex"

// CreateIndexRequest is a API request type for the CreateIndex API operation.
type CreateIndexRequest struct {
	*aws.Request
	Input *CreateIndexInput
	Copy  func(*CreateIndexInput) CreateIndexRequest
}

// Send marshals and sends the CreateIndex API request.
func (r CreateIndexRequest) Send() (*CreateIndexOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateIndexOutput), nil
}

// CreateIndexRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Creates an index object. See Indexing (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_indexing.html)
// for more information.
//
//    // Example sending a request using the CreateIndexRequest method.
//    req := client.CreateIndexRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateIndex
func (c *CloudDirectory) CreateIndexRequest(input *CreateIndexInput) CreateIndexRequest {
	op := &aws.Operation{
		Name:       opCreateIndex,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/index",
	}

	if input == nil {
		input = &CreateIndexInput{}
	}

	output := &CreateIndexOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateIndexRequest{Request: req, Input: input, Copy: c.CreateIndexRequest}
}

const opCreateObject = "CreateObject"

// CreateObjectRequest is a API request type for the CreateObject API operation.
type CreateObjectRequest struct {
	*aws.Request
	Input *CreateObjectInput
	Copy  func(*CreateObjectInput) CreateObjectRequest
}

// Send marshals and sends the CreateObject API request.
func (r CreateObjectRequest) Send() (*CreateObjectOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateObjectOutput), nil
}

// CreateObjectRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Creates an object in a Directory. Additionally attaches the object to a parent,
// if a parent reference and LinkName is specified. An object is simply a collection
// of Facet attributes. You can also use this API call to create a policy object,
// if the facet from which you create the object is a policy facet.
//
//    // Example sending a request using the CreateObjectRequest method.
//    req := client.CreateObjectRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateObject
func (c *CloudDirectory) CreateObjectRequest(input *CreateObjectInput) CreateObjectRequest {
	op := &aws.Operation{
		Name:       opCreateObject,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object",
	}

	if input == nil {
		input = &CreateObjectInput{}
	}

	output := &CreateObjectOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateObjectRequest{Request: req, Input: input, Copy: c.CreateObjectRequest}
}

const opCreateSchema = "CreateSchema"

// CreateSchemaRequest is a API request type for the CreateSchema API operation.
type CreateSchemaRequest struct {
	*aws.Request
	Input *CreateSchemaInput
	Copy  func(*CreateSchemaInput) CreateSchemaRequest
}

// Send marshals and sends the CreateSchema API request.
func (r CreateSchemaRequest) Send() (*CreateSchemaOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateSchemaOutput), nil
}

// CreateSchemaRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Creates a new schema in a development state. A schema can exist in three
// phases:
//
//    * Development: This is a mutable phase of the schema. All new schemas
//    are in the development phase. Once the schema is finalized, it can be
//    published.
//
//    * Published: Published schemas are immutable and have a version associated
//    with them.
//
//    * Applied: Applied schemas are mutable in a way that allows you to add
//    new schema facets. You can also add new, nonrequired attributes to existing
//    schema facets. You can apply only published schemas to directories.
//
//    // Example sending a request using the CreateSchemaRequest method.
//    req := client.CreateSchemaRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateSchema
func (c *CloudDirectory) CreateSchemaRequest(input *CreateSchemaInput) CreateSchemaRequest {
	op := &aws.Operation{
		Name:       opCreateSchema,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/create",
	}

	if input == nil {
		input = &CreateSchemaInput{}
	}

	output := &CreateSchemaOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateSchemaRequest{Request: req, Input: input, Copy: c.CreateSchemaRequest}
}

const opCreateTypedLinkFacet = "CreateTypedLinkFacet"

// CreateTypedLinkFacetRequest is a API request type for the CreateTypedLinkFacet API operation.
type CreateTypedLinkFacetRequest struct {
	*aws.Request
	Input *CreateTypedLinkFacetInput
	Copy  func(*CreateTypedLinkFacetInput) CreateTypedLinkFacetRequest
}

// Send marshals and sends the CreateTypedLinkFacet API request.
func (r CreateTypedLinkFacetRequest) Send() (*CreateTypedLinkFacetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTypedLinkFacetOutput), nil
}

// CreateTypedLinkFacetRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Creates a TypedLinkFacet. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the CreateTypedLinkFacetRequest method.
//    req := client.CreateTypedLinkFacetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateTypedLinkFacet
func (c *CloudDirectory) CreateTypedLinkFacetRequest(input *CreateTypedLinkFacetInput) CreateTypedLinkFacetRequest {
	op := &aws.Operation{
		Name:       opCreateTypedLinkFacet,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/facet/create",
	}

	if input == nil {
		input = &CreateTypedLinkFacetInput{}
	}

	output := &CreateTypedLinkFacetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTypedLinkFacetRequest{Request: req, Input: input, Copy: c.CreateTypedLinkFacetRequest}
}

const opDeleteDirectory = "DeleteDirectory"

// DeleteDirectoryRequest is a API request type for the DeleteDirectory API operation.
type DeleteDirectoryRequest struct {
	*aws.Request
	Input *DeleteDirectoryInput
	Copy  func(*DeleteDirectoryInput) DeleteDirectoryRequest
}

// Send marshals and sends the DeleteDirectory API request.
func (r DeleteDirectoryRequest) Send() (*DeleteDirectoryOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteDirectoryOutput), nil
}

// DeleteDirectoryRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Deletes a directory. Only disabled directories can be deleted. A deleted
// directory cannot be undone. Exercise extreme caution when deleting directories.
//
//    // Example sending a request using the DeleteDirectoryRequest method.
//    req := client.DeleteDirectoryRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteDirectory
func (c *CloudDirectory) DeleteDirectoryRequest(input *DeleteDirectoryInput) DeleteDirectoryRequest {
	op := &aws.Operation{
		Name:       opDeleteDirectory,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/directory",
	}

	if input == nil {
		input = &DeleteDirectoryInput{}
	}

	output := &DeleteDirectoryOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteDirectoryRequest{Request: req, Input: input, Copy: c.DeleteDirectoryRequest}
}

const opDeleteFacet = "DeleteFacet"

// DeleteFacetRequest is a API request type for the DeleteFacet API operation.
type DeleteFacetRequest struct {
	*aws.Request
	Input *DeleteFacetInput
	Copy  func(*DeleteFacetInput) DeleteFacetRequest
}

// Send marshals and sends the DeleteFacet API request.
func (r DeleteFacetRequest) Send() (*DeleteFacetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteFacetOutput), nil
}

// DeleteFacetRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Deletes a given Facet. All attributes and Rules that are associated with
// the facet will be deleted. Only development schema facets are allowed deletion.
//
//    // Example sending a request using the DeleteFacetRequest method.
//    req := client.DeleteFacetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteFacet
func (c *CloudDirectory) DeleteFacetRequest(input *DeleteFacetInput) DeleteFacetRequest {
	op := &aws.Operation{
		Name:       opDeleteFacet,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/facet/delete",
	}

	if input == nil {
		input = &DeleteFacetInput{}
	}

	output := &DeleteFacetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteFacetRequest{Request: req, Input: input, Copy: c.DeleteFacetRequest}
}

const opDeleteObject = "DeleteObject"

// DeleteObjectRequest is a API request type for the DeleteObject API operation.
type DeleteObjectRequest struct {
	*aws.Request
	Input *DeleteObjectInput
	Copy  func(*DeleteObjectInput) DeleteObjectRequest
}

// Send marshals and sends the DeleteObject API request.
func (r DeleteObjectRequest) Send() (*DeleteObjectOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteObjectOutput), nil
}

// DeleteObjectRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Deletes an object and its associated attributes. Only objects with no children
// and no parents can be deleted.
//
//    // Example sending a request using the DeleteObjectRequest method.
//    req := client.DeleteObjectRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteObject
func (c *CloudDirectory) DeleteObjectRequest(input *DeleteObjectInput) DeleteObjectRequest {
	op := &aws.Operation{
		Name:       opDeleteObject,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/delete",
	}

	if input == nil {
		input = &DeleteObjectInput{}
	}

	output := &DeleteObjectOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteObjectRequest{Request: req, Input: input, Copy: c.DeleteObjectRequest}
}

const opDeleteSchema = "DeleteSchema"

// DeleteSchemaRequest is a API request type for the DeleteSchema API operation.
type DeleteSchemaRequest struct {
	*aws.Request
	Input *DeleteSchemaInput
	Copy  func(*DeleteSchemaInput) DeleteSchemaRequest
}

// Send marshals and sends the DeleteSchema API request.
func (r DeleteSchemaRequest) Send() (*DeleteSchemaOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteSchemaOutput), nil
}

// DeleteSchemaRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Deletes a given schema. Schemas in a development and published state can
// only be deleted.
//
//    // Example sending a request using the DeleteSchemaRequest method.
//    req := client.DeleteSchemaRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteSchema
func (c *CloudDirectory) DeleteSchemaRequest(input *DeleteSchemaInput) DeleteSchemaRequest {
	op := &aws.Operation{
		Name:       opDeleteSchema,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema",
	}

	if input == nil {
		input = &DeleteSchemaInput{}
	}

	output := &DeleteSchemaOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteSchemaRequest{Request: req, Input: input, Copy: c.DeleteSchemaRequest}
}

const opDeleteTypedLinkFacet = "DeleteTypedLinkFacet"

// DeleteTypedLinkFacetRequest is a API request type for the DeleteTypedLinkFacet API operation.
type DeleteTypedLinkFacetRequest struct {
	*aws.Request
	Input *DeleteTypedLinkFacetInput
	Copy  func(*DeleteTypedLinkFacetInput) DeleteTypedLinkFacetRequest
}

// Send marshals and sends the DeleteTypedLinkFacet API request.
func (r DeleteTypedLinkFacetRequest) Send() (*DeleteTypedLinkFacetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTypedLinkFacetOutput), nil
}

// DeleteTypedLinkFacetRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Deletes a TypedLinkFacet. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the DeleteTypedLinkFacetRequest method.
//    req := client.DeleteTypedLinkFacetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteTypedLinkFacet
func (c *CloudDirectory) DeleteTypedLinkFacetRequest(input *DeleteTypedLinkFacetInput) DeleteTypedLinkFacetRequest {
	op := &aws.Operation{
		Name:       opDeleteTypedLinkFacet,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/facet/delete",
	}

	if input == nil {
		input = &DeleteTypedLinkFacetInput{}
	}

	output := &DeleteTypedLinkFacetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTypedLinkFacetRequest{Request: req, Input: input, Copy: c.DeleteTypedLinkFacetRequest}
}

const opDetachFromIndex = "DetachFromIndex"

// DetachFromIndexRequest is a API request type for the DetachFromIndex API operation.
type DetachFromIndexRequest struct {
	*aws.Request
	Input *DetachFromIndexInput
	Copy  func(*DetachFromIndexInput) DetachFromIndexRequest
}

// Send marshals and sends the DetachFromIndex API request.
func (r DetachFromIndexRequest) Send() (*DetachFromIndexOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DetachFromIndexOutput), nil
}

// DetachFromIndexRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Detaches the specified object from the specified index.
//
//    // Example sending a request using the DetachFromIndexRequest method.
//    req := client.DetachFromIndexRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachFromIndex
func (c *CloudDirectory) DetachFromIndexRequest(input *DetachFromIndexInput) DetachFromIndexRequest {
	op := &aws.Operation{
		Name:       opDetachFromIndex,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/index/detach",
	}

	if input == nil {
		input = &DetachFromIndexInput{}
	}

	output := &DetachFromIndexOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DetachFromIndexRequest{Request: req, Input: input, Copy: c.DetachFromIndexRequest}
}

const opDetachObject = "DetachObject"

// DetachObjectRequest is a API request type for the DetachObject API operation.
type DetachObjectRequest struct {
	*aws.Request
	Input *DetachObjectInput
	Copy  func(*DetachObjectInput) DetachObjectRequest
}

// Send marshals and sends the DetachObject API request.
func (r DetachObjectRequest) Send() (*DetachObjectOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DetachObjectOutput), nil
}

// DetachObjectRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Detaches a given object from the parent object. The object that is to be
// detached from the parent is specified by the link name.
//
//    // Example sending a request using the DetachObjectRequest method.
//    req := client.DetachObjectRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachObject
func (c *CloudDirectory) DetachObjectRequest(input *DetachObjectInput) DetachObjectRequest {
	op := &aws.Operation{
		Name:       opDetachObject,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/detach",
	}

	if input == nil {
		input = &DetachObjectInput{}
	}

	output := &DetachObjectOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DetachObjectRequest{Request: req, Input: input, Copy: c.DetachObjectRequest}
}

const opDetachPolicy = "DetachPolicy"

// DetachPolicyRequest is a API request type for the DetachPolicy API operation.
type DetachPolicyRequest struct {
	*aws.Request
	Input *DetachPolicyInput
	Copy  func(*DetachPolicyInput) DetachPolicyRequest
}

// Send marshals and sends the DetachPolicy API request.
func (r DetachPolicyRequest) Send() (*DetachPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DetachPolicyOutput), nil
}

// DetachPolicyRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Detaches a policy from an object.
//
//    // Example sending a request using the DetachPolicyRequest method.
//    req := client.DetachPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachPolicy
func (c *CloudDirectory) DetachPolicyRequest(input *DetachPolicyInput) DetachPolicyRequest {
	op := &aws.Operation{
		Name:       opDetachPolicy,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/policy/detach",
	}

	if input == nil {
		input = &DetachPolicyInput{}
	}

	output := &DetachPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DetachPolicyRequest{Request: req, Input: input, Copy: c.DetachPolicyRequest}
}

const opDetachTypedLink = "DetachTypedLink"

// DetachTypedLinkRequest is a API request type for the DetachTypedLink API operation.
type DetachTypedLinkRequest struct {
	*aws.Request
	Input *DetachTypedLinkInput
	Copy  func(*DetachTypedLinkInput) DetachTypedLinkRequest
}

// Send marshals and sends the DetachTypedLink API request.
func (r DetachTypedLinkRequest) Send() (*DetachTypedLinkOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DetachTypedLinkOutput), nil
}

// DetachTypedLinkRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Detaches a typed link from a specified source and target object. For more
// information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the DetachTypedLinkRequest method.
//    req := client.DetachTypedLinkRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachTypedLink
func (c *CloudDirectory) DetachTypedLinkRequest(input *DetachTypedLinkInput) DetachTypedLinkRequest {
	op := &aws.Operation{
		Name:       opDetachTypedLink,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/detach",
	}

	if input == nil {
		input = &DetachTypedLinkInput{}
	}

	output := &DetachTypedLinkOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DetachTypedLinkRequest{Request: req, Input: input, Copy: c.DetachTypedLinkRequest}
}

const opDisableDirectory = "DisableDirectory"

// DisableDirectoryRequest is a API request type for the DisableDirectory API operation.
type DisableDirectoryRequest struct {
	*aws.Request
	Input *DisableDirectoryInput
	Copy  func(*DisableDirectoryInput) DisableDirectoryRequest
}

// Send marshals and sends the DisableDirectory API request.
func (r DisableDirectoryRequest) Send() (*DisableDirectoryOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DisableDirectoryOutput), nil
}

// DisableDirectoryRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Disables the specified directory. Disabled directories cannot be read or
// written to. Only enabled directories can be disabled. Disabled directories
// may be reenabled.
//
//    // Example sending a request using the DisableDirectoryRequest method.
//    req := client.DisableDirectoryRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DisableDirectory
func (c *CloudDirectory) DisableDirectoryRequest(input *DisableDirectoryInput) DisableDirectoryRequest {
	op := &aws.Operation{
		Name:       opDisableDirectory,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/directory/disable",
	}

	if input == nil {
		input = &DisableDirectoryInput{}
	}

	output := &DisableDirectoryOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DisableDirectoryRequest{Request: req, Input: input, Copy: c.DisableDirectoryRequest}
}

const opEnableDirectory = "EnableDirectory"

// EnableDirectoryRequest is a API request type for the EnableDirectory API operation.
type EnableDirectoryRequest struct {
	*aws.Request
	Input *EnableDirectoryInput
	Copy  func(*EnableDirectoryInput) EnableDirectoryRequest
}

// Send marshals and sends the EnableDirectory API request.
func (r EnableDirectoryRequest) Send() (*EnableDirectoryOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*EnableDirectoryOutput), nil
}

// EnableDirectoryRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Enables the specified directory. Only disabled directories can be enabled.
// Once enabled, the directory can then be read and written to.
//
//    // Example sending a request using the EnableDirectoryRequest method.
//    req := client.EnableDirectoryRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/EnableDirectory
func (c *CloudDirectory) EnableDirectoryRequest(input *EnableDirectoryInput) EnableDirectoryRequest {
	op := &aws.Operation{
		Name:       opEnableDirectory,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/directory/enable",
	}

	if input == nil {
		input = &EnableDirectoryInput{}
	}

	output := &EnableDirectoryOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return EnableDirectoryRequest{Request: req, Input: input, Copy: c.EnableDirectoryRequest}
}

const opGetAppliedSchemaVersion = "GetAppliedSchemaVersion"

// GetAppliedSchemaVersionRequest is a API request type for the GetAppliedSchemaVersion API operation.
type GetAppliedSchemaVersionRequest struct {
	*aws.Request
	Input *GetAppliedSchemaVersionInput
	Copy  func(*GetAppliedSchemaVersionInput) GetAppliedSchemaVersionRequest
}

// Send marshals and sends the GetAppliedSchemaVersion API request.
func (r GetAppliedSchemaVersionRequest) Send() (*GetAppliedSchemaVersionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetAppliedSchemaVersionOutput), nil
}

// GetAppliedSchemaVersionRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns current applied schema version ARN, including the minor version in
// use.
//
//    // Example sending a request using the GetAppliedSchemaVersionRequest method.
//    req := client.GetAppliedSchemaVersionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetAppliedSchemaVersion
func (c *CloudDirectory) GetAppliedSchemaVersionRequest(input *GetAppliedSchemaVersionInput) GetAppliedSchemaVersionRequest {
	op := &aws.Operation{
		Name:       opGetAppliedSchemaVersion,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/getappliedschema",
	}

	if input == nil {
		input = &GetAppliedSchemaVersionInput{}
	}

	output := &GetAppliedSchemaVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetAppliedSchemaVersionRequest{Request: req, Input: input, Copy: c.GetAppliedSchemaVersionRequest}
}

const opGetDirectory = "GetDirectory"

// GetDirectoryRequest is a API request type for the GetDirectory API operation.
type GetDirectoryRequest struct {
	*aws.Request
	Input *GetDirectoryInput
	Copy  func(*GetDirectoryInput) GetDirectoryRequest
}

// Send marshals and sends the GetDirectory API request.
func (r GetDirectoryRequest) Send() (*GetDirectoryOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDirectoryOutput), nil
}

// GetDirectoryRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Retrieves metadata about a directory.
//
//    // Example sending a request using the GetDirectoryRequest method.
//    req := client.GetDirectoryRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetDirectory
func (c *CloudDirectory) GetDirectoryRequest(input *GetDirectoryInput) GetDirectoryRequest {
	op := &aws.Operation{
		Name:       opGetDirectory,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/directory/get",
	}

	if input == nil {
		input = &GetDirectoryInput{}
	}

	output := &GetDirectoryOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDirectoryRequest{Request: req, Input: input, Copy: c.GetDirectoryRequest}
}

const opGetFacet = "GetFacet"

// GetFacetRequest is a API request type for the GetFacet API operation.
type GetFacetRequest struct {
	*aws.Request
	Input *GetFacetInput
	Copy  func(*GetFacetInput) GetFacetRequest
}

// Send marshals and sends the GetFacet API request.
func (r GetFacetRequest) Send() (*GetFacetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetFacetOutput), nil
}

// GetFacetRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Gets details of the Facet, such as facet name, attributes, Rules, or ObjectType.
// You can call this on all kinds of schema facets -- published, development,
// or applied.
//
//    // Example sending a request using the GetFacetRequest method.
//    req := client.GetFacetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetFacet
func (c *CloudDirectory) GetFacetRequest(input *GetFacetInput) GetFacetRequest {
	op := &aws.Operation{
		Name:       opGetFacet,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/facet",
	}

	if input == nil {
		input = &GetFacetInput{}
	}

	output := &GetFacetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetFacetRequest{Request: req, Input: input, Copy: c.GetFacetRequest}
}

const opGetObjectAttributes = "GetObjectAttributes"

// GetObjectAttributesRequest is a API request type for the GetObjectAttributes API operation.
type GetObjectAttributesRequest struct {
	*aws.Request
	Input *GetObjectAttributesInput
	Copy  func(*GetObjectAttributesInput) GetObjectAttributesRequest
}

// Send marshals and sends the GetObjectAttributes API request.
func (r GetObjectAttributesRequest) Send() (*GetObjectAttributesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetObjectAttributesOutput), nil
}

// GetObjectAttributesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Retrieves attributes within a facet that are associated with an object.
//
//    // Example sending a request using the GetObjectAttributesRequest method.
//    req := client.GetObjectAttributesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetObjectAttributes
func (c *CloudDirectory) GetObjectAttributesRequest(input *GetObjectAttributesInput) GetObjectAttributesRequest {
	op := &aws.Operation{
		Name:       opGetObjectAttributes,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/attributes/get",
	}

	if input == nil {
		input = &GetObjectAttributesInput{}
	}

	output := &GetObjectAttributesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetObjectAttributesRequest{Request: req, Input: input, Copy: c.GetObjectAttributesRequest}
}

const opGetObjectInformation = "GetObjectInformation"

// GetObjectInformationRequest is a API request type for the GetObjectInformation API operation.
type GetObjectInformationRequest struct {
	*aws.Request
	Input *GetObjectInformationInput
	Copy  func(*GetObjectInformationInput) GetObjectInformationRequest
}

// Send marshals and sends the GetObjectInformation API request.
func (r GetObjectInformationRequest) Send() (*GetObjectInformationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetObjectInformationOutput), nil
}

// GetObjectInformationRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Retrieves metadata about an object.
//
//    // Example sending a request using the GetObjectInformationRequest method.
//    req := client.GetObjectInformationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetObjectInformation
func (c *CloudDirectory) GetObjectInformationRequest(input *GetObjectInformationInput) GetObjectInformationRequest {
	op := &aws.Operation{
		Name:       opGetObjectInformation,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/information",
	}

	if input == nil {
		input = &GetObjectInformationInput{}
	}

	output := &GetObjectInformationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetObjectInformationRequest{Request: req, Input: input, Copy: c.GetObjectInformationRequest}
}

const opGetSchemaAsJson = "GetSchemaAsJson"

// GetSchemaAsJsonRequest is a API request type for the GetSchemaAsJson API operation.
type GetSchemaAsJsonRequest struct {
	*aws.Request
	Input *GetSchemaAsJsonInput
	Copy  func(*GetSchemaAsJsonInput) GetSchemaAsJsonRequest
}

// Send marshals and sends the GetSchemaAsJson API request.
func (r GetSchemaAsJsonRequest) Send() (*GetSchemaAsJsonOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSchemaAsJsonOutput), nil
}

// GetSchemaAsJsonRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Retrieves a JSON representation of the schema. See JSON Schema Format (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_schemas.html#jsonformat)
// for more information.
//
//    // Example sending a request using the GetSchemaAsJsonRequest method.
//    req := client.GetSchemaAsJsonRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetSchemaAsJson
func (c *CloudDirectory) GetSchemaAsJsonRequest(input *GetSchemaAsJsonInput) GetSchemaAsJsonRequest {
	op := &aws.Operation{
		Name:       opGetSchemaAsJson,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/json",
	}

	if input == nil {
		input = &GetSchemaAsJsonInput{}
	}

	output := &GetSchemaAsJsonOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSchemaAsJsonRequest{Request: req, Input: input, Copy: c.GetSchemaAsJsonRequest}
}

const opGetTypedLinkFacetInformation = "GetTypedLinkFacetInformation"

// GetTypedLinkFacetInformationRequest is a API request type for the GetTypedLinkFacetInformation API operation.
type GetTypedLinkFacetInformationRequest struct {
	*aws.Request
	Input *GetTypedLinkFacetInformationInput
	Copy  func(*GetTypedLinkFacetInformationInput) GetTypedLinkFacetInformationRequest
}

// Send marshals and sends the GetTypedLinkFacetInformation API request.
func (r GetTypedLinkFacetInformationRequest) Send() (*GetTypedLinkFacetInformationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTypedLinkFacetInformationOutput), nil
}

// GetTypedLinkFacetInformationRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns the identity attribute order for a specific TypedLinkFacet. For more
// information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the GetTypedLinkFacetInformationRequest method.
//    req := client.GetTypedLinkFacetInformationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetTypedLinkFacetInformation
func (c *CloudDirectory) GetTypedLinkFacetInformationRequest(input *GetTypedLinkFacetInformationInput) GetTypedLinkFacetInformationRequest {
	op := &aws.Operation{
		Name:       opGetTypedLinkFacetInformation,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/facet/get",
	}

	if input == nil {
		input = &GetTypedLinkFacetInformationInput{}
	}

	output := &GetTypedLinkFacetInformationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTypedLinkFacetInformationRequest{Request: req, Input: input, Copy: c.GetTypedLinkFacetInformationRequest}
}

const opListAppliedSchemaArns = "ListAppliedSchemaArns"

// ListAppliedSchemaArnsRequest is a API request type for the ListAppliedSchemaArns API operation.
type ListAppliedSchemaArnsRequest struct {
	*aws.Request
	Input *ListAppliedSchemaArnsInput
	Copy  func(*ListAppliedSchemaArnsInput) ListAppliedSchemaArnsRequest
}

// Send marshals and sends the ListAppliedSchemaArns API request.
func (r ListAppliedSchemaArnsRequest) Send() (*ListAppliedSchemaArnsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListAppliedSchemaArnsOutput), nil
}

// ListAppliedSchemaArnsRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Lists schema major versions applied to a directory. If SchemaArn is provided,
// lists the minor version.
//
//    // Example sending a request using the ListAppliedSchemaArnsRequest method.
//    req := client.ListAppliedSchemaArnsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListAppliedSchemaArns
func (c *CloudDirectory) ListAppliedSchemaArnsRequest(input *ListAppliedSchemaArnsInput) ListAppliedSchemaArnsRequest {
	op := &aws.Operation{
		Name:       opListAppliedSchemaArns,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/applied",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListAppliedSchemaArnsInput{}
	}

	output := &ListAppliedSchemaArnsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListAppliedSchemaArnsRequest{Request: req, Input: input, Copy: c.ListAppliedSchemaArnsRequest}
}

// Paginate pages iterates over the pages of a ListAppliedSchemaArnsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListAppliedSchemaArns operation.
//		req := client.ListAppliedSchemaArnsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListAppliedSchemaArnsRequest) Paginate(opts ...aws.Option) ListAppliedSchemaArnsPager {
	return ListAppliedSchemaArnsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListAppliedSchemaArnsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListAppliedSchemaArnsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListAppliedSchemaArnsPager struct {
	aws.Pager
}

func (p *ListAppliedSchemaArnsPager) CurrentPage() *ListAppliedSchemaArnsOutput {
	return p.Pager.CurrentPage().(*ListAppliedSchemaArnsOutput)
}

const opListAttachedIndices = "ListAttachedIndices"

// ListAttachedIndicesRequest is a API request type for the ListAttachedIndices API operation.
type ListAttachedIndicesRequest struct {
	*aws.Request
	Input *ListAttachedIndicesInput
	Copy  func(*ListAttachedIndicesInput) ListAttachedIndicesRequest
}

// Send marshals and sends the ListAttachedIndices API request.
func (r ListAttachedIndicesRequest) Send() (*ListAttachedIndicesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListAttachedIndicesOutput), nil
}

// ListAttachedIndicesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Lists indices attached to the specified object.
//
//    // Example sending a request using the ListAttachedIndicesRequest method.
//    req := client.ListAttachedIndicesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListAttachedIndices
func (c *CloudDirectory) ListAttachedIndicesRequest(input *ListAttachedIndicesInput) ListAttachedIndicesRequest {
	op := &aws.Operation{
		Name:       opListAttachedIndices,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/indices",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListAttachedIndicesInput{}
	}

	output := &ListAttachedIndicesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListAttachedIndicesRequest{Request: req, Input: input, Copy: c.ListAttachedIndicesRequest}
}

// Paginate pages iterates over the pages of a ListAttachedIndicesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListAttachedIndices operation.
//		req := client.ListAttachedIndicesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListAttachedIndicesRequest) Paginate(opts ...aws.Option) ListAttachedIndicesPager {
	return ListAttachedIndicesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListAttachedIndicesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListAttachedIndicesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListAttachedIndicesPager struct {
	aws.Pager
}

func (p *ListAttachedIndicesPager) CurrentPage() *ListAttachedIndicesOutput {
	return p.Pager.CurrentPage().(*ListAttachedIndicesOutput)
}

const opListDevelopmentSchemaArns = "ListDevelopmentSchemaArns"

// ListDevelopmentSchemaArnsRequest is a API request type for the ListDevelopmentSchemaArns API operation.
type ListDevelopmentSchemaArnsRequest struct {
	*aws.Request
	Input *ListDevelopmentSchemaArnsInput
	Copy  func(*ListDevelopmentSchemaArnsInput) ListDevelopmentSchemaArnsRequest
}

// Send marshals and sends the ListDevelopmentSchemaArns API request.
func (r ListDevelopmentSchemaArnsRequest) Send() (*ListDevelopmentSchemaArnsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListDevelopmentSchemaArnsOutput), nil
}

// ListDevelopmentSchemaArnsRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Retrieves each Amazon Resource Name (ARN) of schemas in the development state.
//
//    // Example sending a request using the ListDevelopmentSchemaArnsRequest method.
//    req := client.ListDevelopmentSchemaArnsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListDevelopmentSchemaArns
func (c *CloudDirectory) ListDevelopmentSchemaArnsRequest(input *ListDevelopmentSchemaArnsInput) ListDevelopmentSchemaArnsRequest {
	op := &aws.Operation{
		Name:       opListDevelopmentSchemaArns,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/development",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListDevelopmentSchemaArnsInput{}
	}

	output := &ListDevelopmentSchemaArnsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListDevelopmentSchemaArnsRequest{Request: req, Input: input, Copy: c.ListDevelopmentSchemaArnsRequest}
}

// Paginate pages iterates over the pages of a ListDevelopmentSchemaArnsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListDevelopmentSchemaArns operation.
//		req := client.ListDevelopmentSchemaArnsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListDevelopmentSchemaArnsRequest) Paginate(opts ...aws.Option) ListDevelopmentSchemaArnsPager {
	return ListDevelopmentSchemaArnsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListDevelopmentSchemaArnsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListDevelopmentSchemaArnsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListDevelopmentSchemaArnsPager struct {
	aws.Pager
}

func (p *ListDevelopmentSchemaArnsPager) CurrentPage() *ListDevelopmentSchemaArnsOutput {
	return p.Pager.CurrentPage().(*ListDevelopmentSchemaArnsOutput)
}

const opListDirectories = "ListDirectories"

// ListDirectoriesRequest is a API request type for the ListDirectories API operation.
type ListDirectoriesRequest struct {
	*aws.Request
	Input *ListDirectoriesInput
	Copy  func(*ListDirectoriesInput) ListDirectoriesRequest
}

// Send marshals and sends the ListDirectories API request.
func (r ListDirectoriesRequest) Send() (*ListDirectoriesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListDirectoriesOutput), nil
}

// ListDirectoriesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Lists directories created within an account.
//
//    // Example sending a request using the ListDirectoriesRequest method.
//    req := client.ListDirectoriesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListDirectories
func (c *CloudDirectory) ListDirectoriesRequest(input *ListDirectoriesInput) ListDirectoriesRequest {
	op := &aws.Operation{
		Name:       opListDirectories,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/directory/list",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListDirectoriesInput{}
	}

	output := &ListDirectoriesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListDirectoriesRequest{Request: req, Input: input, Copy: c.ListDirectoriesRequest}
}

// Paginate pages iterates over the pages of a ListDirectoriesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListDirectories operation.
//		req := client.ListDirectoriesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListDirectoriesRequest) Paginate(opts ...aws.Option) ListDirectoriesPager {
	return ListDirectoriesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListDirectoriesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListDirectoriesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListDirectoriesPager struct {
	aws.Pager
}

func (p *ListDirectoriesPager) CurrentPage() *ListDirectoriesOutput {
	return p.Pager.CurrentPage().(*ListDirectoriesOutput)
}

const opListFacetAttributes = "ListFacetAttributes"

// ListFacetAttributesRequest is a API request type for the ListFacetAttributes API operation.
type ListFacetAttributesRequest struct {
	*aws.Request
	Input *ListFacetAttributesInput
	Copy  func(*ListFacetAttributesInput) ListFacetAttributesRequest
}

// Send marshals and sends the ListFacetAttributes API request.
func (r ListFacetAttributesRequest) Send() (*ListFacetAttributesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListFacetAttributesOutput), nil
}

// ListFacetAttributesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Retrieves attributes attached to the facet.
//
//    // Example sending a request using the ListFacetAttributesRequest method.
//    req := client.ListFacetAttributesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListFacetAttributes
func (c *CloudDirectory) ListFacetAttributesRequest(input *ListFacetAttributesInput) ListFacetAttributesRequest {
	op := &aws.Operation{
		Name:       opListFacetAttributes,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/facet/attributes",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListFacetAttributesInput{}
	}

	output := &ListFacetAttributesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListFacetAttributesRequest{Request: req, Input: input, Copy: c.ListFacetAttributesRequest}
}

// Paginate pages iterates over the pages of a ListFacetAttributesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListFacetAttributes operation.
//		req := client.ListFacetAttributesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListFacetAttributesRequest) Paginate(opts ...aws.Option) ListFacetAttributesPager {
	return ListFacetAttributesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListFacetAttributesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListFacetAttributesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListFacetAttributesPager struct {
	aws.Pager
}

func (p *ListFacetAttributesPager) CurrentPage() *ListFacetAttributesOutput {
	return p.Pager.CurrentPage().(*ListFacetAttributesOutput)
}

const opListFacetNames = "ListFacetNames"

// ListFacetNamesRequest is a API request type for the ListFacetNames API operation.
type ListFacetNamesRequest struct {
	*aws.Request
	Input *ListFacetNamesInput
	Copy  func(*ListFacetNamesInput) ListFacetNamesRequest
}

// Send marshals and sends the ListFacetNames API request.
func (r ListFacetNamesRequest) Send() (*ListFacetNamesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListFacetNamesOutput), nil
}

// ListFacetNamesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Retrieves the names of facets that exist in a schema.
//
//    // Example sending a request using the ListFacetNamesRequest method.
//    req := client.ListFacetNamesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListFacetNames
func (c *CloudDirectory) ListFacetNamesRequest(input *ListFacetNamesInput) ListFacetNamesRequest {
	op := &aws.Operation{
		Name:       opListFacetNames,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/facet/list",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListFacetNamesInput{}
	}

	output := &ListFacetNamesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListFacetNamesRequest{Request: req, Input: input, Copy: c.ListFacetNamesRequest}
}

// Paginate pages iterates over the pages of a ListFacetNamesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListFacetNames operation.
//		req := client.ListFacetNamesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListFacetNamesRequest) Paginate(opts ...aws.Option) ListFacetNamesPager {
	return ListFacetNamesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListFacetNamesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListFacetNamesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListFacetNamesPager struct {
	aws.Pager
}

func (p *ListFacetNamesPager) CurrentPage() *ListFacetNamesOutput {
	return p.Pager.CurrentPage().(*ListFacetNamesOutput)
}

const opListIncomingTypedLinks = "ListIncomingTypedLinks"

// ListIncomingTypedLinksRequest is a API request type for the ListIncomingTypedLinks API operation.
type ListIncomingTypedLinksRequest struct {
	*aws.Request
	Input *ListIncomingTypedLinksInput
	Copy  func(*ListIncomingTypedLinksInput) ListIncomingTypedLinksRequest
}

// Send marshals and sends the ListIncomingTypedLinks API request.
func (r ListIncomingTypedLinksRequest) Send() (*ListIncomingTypedLinksOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListIncomingTypedLinksOutput), nil
}

// ListIncomingTypedLinksRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns a paginated list of all the incoming TypedLinkSpecifier information
// for an object. It also supports filtering by typed link facet and identity
// attributes. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the ListIncomingTypedLinksRequest method.
//    req := client.ListIncomingTypedLinksRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListIncomingTypedLinks
func (c *CloudDirectory) ListIncomingTypedLinksRequest(input *ListIncomingTypedLinksInput) ListIncomingTypedLinksRequest {
	op := &aws.Operation{
		Name:       opListIncomingTypedLinks,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/incoming",
	}

	if input == nil {
		input = &ListIncomingTypedLinksInput{}
	}

	output := &ListIncomingTypedLinksOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListIncomingTypedLinksRequest{Request: req, Input: input, Copy: c.ListIncomingTypedLinksRequest}
}

const opListIndex = "ListIndex"

// ListIndexRequest is a API request type for the ListIndex API operation.
type ListIndexRequest struct {
	*aws.Request
	Input *ListIndexInput
	Copy  func(*ListIndexInput) ListIndexRequest
}

// Send marshals and sends the ListIndex API request.
func (r ListIndexRequest) Send() (*ListIndexOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListIndexOutput), nil
}

// ListIndexRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Lists objects attached to the specified index.
//
//    // Example sending a request using the ListIndexRequest method.
//    req := client.ListIndexRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListIndex
func (c *CloudDirectory) ListIndexRequest(input *ListIndexInput) ListIndexRequest {
	op := &aws.Operation{
		Name:       opListIndex,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/index/targets",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListIndexInput{}
	}

	output := &ListIndexOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListIndexRequest{Request: req, Input: input, Copy: c.ListIndexRequest}
}

// Paginate pages iterates over the pages of a ListIndexRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListIndex operation.
//		req := client.ListIndexRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListIndexRequest) Paginate(opts ...aws.Option) ListIndexPager {
	return ListIndexPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListIndexInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListIndexPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListIndexPager struct {
	aws.Pager
}

func (p *ListIndexPager) CurrentPage() *ListIndexOutput {
	return p.Pager.CurrentPage().(*ListIndexOutput)
}

const opListObjectAttributes = "ListObjectAttributes"

// ListObjectAttributesRequest is a API request type for the ListObjectAttributes API operation.
type ListObjectAttributesRequest struct {
	*aws.Request
	Input *ListObjectAttributesInput
	Copy  func(*ListObjectAttributesInput) ListObjectAttributesRequest
}

// Send marshals and sends the ListObjectAttributes API request.
func (r ListObjectAttributesRequest) Send() (*ListObjectAttributesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListObjectAttributesOutput), nil
}

// ListObjectAttributesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Lists all attributes that are associated with an object.
//
//    // Example sending a request using the ListObjectAttributesRequest method.
//    req := client.ListObjectAttributesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectAttributes
func (c *CloudDirectory) ListObjectAttributesRequest(input *ListObjectAttributesInput) ListObjectAttributesRequest {
	op := &aws.Operation{
		Name:       opListObjectAttributes,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/attributes",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListObjectAttributesInput{}
	}

	output := &ListObjectAttributesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListObjectAttributesRequest{Request: req, Input: input, Copy: c.ListObjectAttributesRequest}
}

// Paginate pages iterates over the pages of a ListObjectAttributesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListObjectAttributes operation.
//		req := client.ListObjectAttributesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListObjectAttributesRequest) Paginate(opts ...aws.Option) ListObjectAttributesPager {
	return ListObjectAttributesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListObjectAttributesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListObjectAttributesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListObjectAttributesPager struct {
	aws.Pager
}

func (p *ListObjectAttributesPager) CurrentPage() *ListObjectAttributesOutput {
	return p.Pager.CurrentPage().(*ListObjectAttributesOutput)
}

const opListObjectChildren = "ListObjectChildren"

// ListObjectChildrenRequest is a API request type for the ListObjectChildren API operation.
type ListObjectChildrenRequest struct {
	*aws.Request
	Input *ListObjectChildrenInput
	Copy  func(*ListObjectChildrenInput) ListObjectChildrenRequest
}

// Send marshals and sends the ListObjectChildren API request.
func (r ListObjectChildrenRequest) Send() (*ListObjectChildrenOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListObjectChildrenOutput), nil
}

// ListObjectChildrenRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns a paginated list of child objects that are associated with a given
// object.
//
//    // Example sending a request using the ListObjectChildrenRequest method.
//    req := client.ListObjectChildrenRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectChildren
func (c *CloudDirectory) ListObjectChildrenRequest(input *ListObjectChildrenInput) ListObjectChildrenRequest {
	op := &aws.Operation{
		Name:       opListObjectChildren,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/children",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListObjectChildrenInput{}
	}

	output := &ListObjectChildrenOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListObjectChildrenRequest{Request: req, Input: input, Copy: c.ListObjectChildrenRequest}
}

// Paginate pages iterates over the pages of a ListObjectChildrenRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListObjectChildren operation.
//		req := client.ListObjectChildrenRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListObjectChildrenRequest) Paginate(opts ...aws.Option) ListObjectChildrenPager {
	return ListObjectChildrenPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListObjectChildrenInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListObjectChildrenPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListObjectChildrenPager struct {
	aws.Pager
}

func (p *ListObjectChildrenPager) CurrentPage() *ListObjectChildrenOutput {
	return p.Pager.CurrentPage().(*ListObjectChildrenOutput)
}

const opListObjectParentPaths = "ListObjectParentPaths"

// ListObjectParentPathsRequest is a API request type for the ListObjectParentPaths API operation.
type ListObjectParentPathsRequest struct {
	*aws.Request
	Input *ListObjectParentPathsInput
	Copy  func(*ListObjectParentPathsInput) ListObjectParentPathsRequest
}

// Send marshals and sends the ListObjectParentPaths API request.
func (r ListObjectParentPathsRequest) Send() (*ListObjectParentPathsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListObjectParentPathsOutput), nil
}

// ListObjectParentPathsRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Retrieves all available parent paths for any object type such as node, leaf
// node, policy node, and index node objects. For more information about objects,
// see Directory Structure (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#dirstructure).
//
// Use this API to evaluate all parents for an object. The call returns all
// objects from the root of the directory up to the requested object. The API
// returns the number of paths based on user-defined MaxResults, in case there
// are multiple paths to the parent. The order of the paths and nodes returned
// is consistent among multiple API calls unless the objects are deleted or
// moved. Paths not leading to the directory root are ignored from the target
// object.
//
//    // Example sending a request using the ListObjectParentPathsRequest method.
//    req := client.ListObjectParentPathsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectParentPaths
func (c *CloudDirectory) ListObjectParentPathsRequest(input *ListObjectParentPathsInput) ListObjectParentPathsRequest {
	op := &aws.Operation{
		Name:       opListObjectParentPaths,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/parentpaths",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListObjectParentPathsInput{}
	}

	output := &ListObjectParentPathsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListObjectParentPathsRequest{Request: req, Input: input, Copy: c.ListObjectParentPathsRequest}
}

// Paginate pages iterates over the pages of a ListObjectParentPathsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListObjectParentPaths operation.
//		req := client.ListObjectParentPathsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListObjectParentPathsRequest) Paginate(opts ...aws.Option) ListObjectParentPathsPager {
	return ListObjectParentPathsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListObjectParentPathsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListObjectParentPathsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListObjectParentPathsPager struct {
	aws.Pager
}

func (p *ListObjectParentPathsPager) CurrentPage() *ListObjectParentPathsOutput {
	return p.Pager.CurrentPage().(*ListObjectParentPathsOutput)
}

const opListObjectParents = "ListObjectParents"

// ListObjectParentsRequest is a API request type for the ListObjectParents API operation.
type ListObjectParentsRequest struct {
	*aws.Request
	Input *ListObjectParentsInput
	Copy  func(*ListObjectParentsInput) ListObjectParentsRequest
}

// Send marshals and sends the ListObjectParents API request.
func (r ListObjectParentsRequest) Send() (*ListObjectParentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListObjectParentsOutput), nil
}

// ListObjectParentsRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Lists parent objects that are associated with a given object in pagination
// fashion.
//
//    // Example sending a request using the ListObjectParentsRequest method.
//    req := client.ListObjectParentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectParents
func (c *CloudDirectory) ListObjectParentsRequest(input *ListObjectParentsInput) ListObjectParentsRequest {
	op := &aws.Operation{
		Name:       opListObjectParents,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/parent",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListObjectParentsInput{}
	}

	output := &ListObjectParentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListObjectParentsRequest{Request: req, Input: input, Copy: c.ListObjectParentsRequest}
}

// Paginate pages iterates over the pages of a ListObjectParentsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListObjectParents operation.
//		req := client.ListObjectParentsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListObjectParentsRequest) Paginate(opts ...aws.Option) ListObjectParentsPager {
	return ListObjectParentsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListObjectParentsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListObjectParentsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListObjectParentsPager struct {
	aws.Pager
}

func (p *ListObjectParentsPager) CurrentPage() *ListObjectParentsOutput {
	return p.Pager.CurrentPage().(*ListObjectParentsOutput)
}

const opListObjectPolicies = "ListObjectPolicies"

// ListObjectPoliciesRequest is a API request type for the ListObjectPolicies API operation.
type ListObjectPoliciesRequest struct {
	*aws.Request
	Input *ListObjectPoliciesInput
	Copy  func(*ListObjectPoliciesInput) ListObjectPoliciesRequest
}

// Send marshals and sends the ListObjectPolicies API request.
func (r ListObjectPoliciesRequest) Send() (*ListObjectPoliciesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListObjectPoliciesOutput), nil
}

// ListObjectPoliciesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns policies attached to an object in pagination fashion.
//
//    // Example sending a request using the ListObjectPoliciesRequest method.
//    req := client.ListObjectPoliciesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectPolicies
func (c *CloudDirectory) ListObjectPoliciesRequest(input *ListObjectPoliciesInput) ListObjectPoliciesRequest {
	op := &aws.Operation{
		Name:       opListObjectPolicies,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/policy",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListObjectPoliciesInput{}
	}

	output := &ListObjectPoliciesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListObjectPoliciesRequest{Request: req, Input: input, Copy: c.ListObjectPoliciesRequest}
}

// Paginate pages iterates over the pages of a ListObjectPoliciesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListObjectPolicies operation.
//		req := client.ListObjectPoliciesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListObjectPoliciesRequest) Paginate(opts ...aws.Option) ListObjectPoliciesPager {
	return ListObjectPoliciesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListObjectPoliciesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListObjectPoliciesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListObjectPoliciesPager struct {
	aws.Pager
}

func (p *ListObjectPoliciesPager) CurrentPage() *ListObjectPoliciesOutput {
	return p.Pager.CurrentPage().(*ListObjectPoliciesOutput)
}

const opListOutgoingTypedLinks = "ListOutgoingTypedLinks"

// ListOutgoingTypedLinksRequest is a API request type for the ListOutgoingTypedLinks API operation.
type ListOutgoingTypedLinksRequest struct {
	*aws.Request
	Input *ListOutgoingTypedLinksInput
	Copy  func(*ListOutgoingTypedLinksInput) ListOutgoingTypedLinksRequest
}

// Send marshals and sends the ListOutgoingTypedLinks API request.
func (r ListOutgoingTypedLinksRequest) Send() (*ListOutgoingTypedLinksOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListOutgoingTypedLinksOutput), nil
}

// ListOutgoingTypedLinksRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns a paginated list of all the outgoing TypedLinkSpecifier information
// for an object. It also supports filtering by typed link facet and identity
// attributes. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the ListOutgoingTypedLinksRequest method.
//    req := client.ListOutgoingTypedLinksRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListOutgoingTypedLinks
func (c *CloudDirectory) ListOutgoingTypedLinksRequest(input *ListOutgoingTypedLinksInput) ListOutgoingTypedLinksRequest {
	op := &aws.Operation{
		Name:       opListOutgoingTypedLinks,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/outgoing",
	}

	if input == nil {
		input = &ListOutgoingTypedLinksInput{}
	}

	output := &ListOutgoingTypedLinksOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListOutgoingTypedLinksRequest{Request: req, Input: input, Copy: c.ListOutgoingTypedLinksRequest}
}

const opListPolicyAttachments = "ListPolicyAttachments"

// ListPolicyAttachmentsRequest is a API request type for the ListPolicyAttachments API operation.
type ListPolicyAttachmentsRequest struct {
	*aws.Request
	Input *ListPolicyAttachmentsInput
	Copy  func(*ListPolicyAttachmentsInput) ListPolicyAttachmentsRequest
}

// Send marshals and sends the ListPolicyAttachments API request.
func (r ListPolicyAttachmentsRequest) Send() (*ListPolicyAttachmentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListPolicyAttachmentsOutput), nil
}

// ListPolicyAttachmentsRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns all of the ObjectIdentifiers to which a given policy is attached.
//
//    // Example sending a request using the ListPolicyAttachmentsRequest method.
//    req := client.ListPolicyAttachmentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListPolicyAttachments
func (c *CloudDirectory) ListPolicyAttachmentsRequest(input *ListPolicyAttachmentsInput) ListPolicyAttachmentsRequest {
	op := &aws.Operation{
		Name:       opListPolicyAttachments,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/policy/attachment",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListPolicyAttachmentsInput{}
	}

	output := &ListPolicyAttachmentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListPolicyAttachmentsRequest{Request: req, Input: input, Copy: c.ListPolicyAttachmentsRequest}
}

// Paginate pages iterates over the pages of a ListPolicyAttachmentsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListPolicyAttachments operation.
//		req := client.ListPolicyAttachmentsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListPolicyAttachmentsRequest) Paginate(opts ...aws.Option) ListPolicyAttachmentsPager {
	return ListPolicyAttachmentsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListPolicyAttachmentsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListPolicyAttachmentsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListPolicyAttachmentsPager struct {
	aws.Pager
}

func (p *ListPolicyAttachmentsPager) CurrentPage() *ListPolicyAttachmentsOutput {
	return p.Pager.CurrentPage().(*ListPolicyAttachmentsOutput)
}

const opListPublishedSchemaArns = "ListPublishedSchemaArns"

// ListPublishedSchemaArnsRequest is a API request type for the ListPublishedSchemaArns API operation.
type ListPublishedSchemaArnsRequest struct {
	*aws.Request
	Input *ListPublishedSchemaArnsInput
	Copy  func(*ListPublishedSchemaArnsInput) ListPublishedSchemaArnsRequest
}

// Send marshals and sends the ListPublishedSchemaArns API request.
func (r ListPublishedSchemaArnsRequest) Send() (*ListPublishedSchemaArnsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListPublishedSchemaArnsOutput), nil
}

// ListPublishedSchemaArnsRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Lists the major version families of each published schema. If a major version
// ARN is provided as SchemaArn, the minor version revisions in that family
// are listed instead.
//
//    // Example sending a request using the ListPublishedSchemaArnsRequest method.
//    req := client.ListPublishedSchemaArnsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListPublishedSchemaArns
func (c *CloudDirectory) ListPublishedSchemaArnsRequest(input *ListPublishedSchemaArnsInput) ListPublishedSchemaArnsRequest {
	op := &aws.Operation{
		Name:       opListPublishedSchemaArns,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/published",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListPublishedSchemaArnsInput{}
	}

	output := &ListPublishedSchemaArnsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListPublishedSchemaArnsRequest{Request: req, Input: input, Copy: c.ListPublishedSchemaArnsRequest}
}

// Paginate pages iterates over the pages of a ListPublishedSchemaArnsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListPublishedSchemaArns operation.
//		req := client.ListPublishedSchemaArnsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListPublishedSchemaArnsRequest) Paginate(opts ...aws.Option) ListPublishedSchemaArnsPager {
	return ListPublishedSchemaArnsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListPublishedSchemaArnsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListPublishedSchemaArnsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListPublishedSchemaArnsPager struct {
	aws.Pager
}

func (p *ListPublishedSchemaArnsPager) CurrentPage() *ListPublishedSchemaArnsOutput {
	return p.Pager.CurrentPage().(*ListPublishedSchemaArnsOutput)
}

const opListTagsForResource = "ListTagsForResource"

// ListTagsForResourceRequest is a API request type for the ListTagsForResource API operation.
type ListTagsForResourceRequest struct {
	*aws.Request
	Input *ListTagsForResourceInput
	Copy  func(*ListTagsForResourceInput) ListTagsForResourceRequest
}

// Send marshals and sends the ListTagsForResource API request.
func (r ListTagsForResourceRequest) Send() (*ListTagsForResourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTagsForResourceOutput), nil
}

// ListTagsForResourceRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns tags for a resource. Tagging is currently supported only for directories
// with a limit of 50 tags per directory. All 50 tags are returned for a given
// directory with this API call.
//
//    // Example sending a request using the ListTagsForResourceRequest method.
//    req := client.ListTagsForResourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTagsForResource
func (c *CloudDirectory) ListTagsForResourceRequest(input *ListTagsForResourceInput) ListTagsForResourceRequest {
	op := &aws.Operation{
		Name:       opListTagsForResource,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/tags",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListTagsForResourceInput{}
	}

	output := &ListTagsForResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTagsForResourceRequest{Request: req, Input: input, Copy: c.ListTagsForResourceRequest}
}

// Paginate pages iterates over the pages of a ListTagsForResourceRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListTagsForResource operation.
//		req := client.ListTagsForResourceRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListTagsForResourceRequest) Paginate(opts ...aws.Option) ListTagsForResourcePager {
	return ListTagsForResourcePager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListTagsForResourceInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListTagsForResourcePager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListTagsForResourcePager struct {
	aws.Pager
}

func (p *ListTagsForResourcePager) CurrentPage() *ListTagsForResourceOutput {
	return p.Pager.CurrentPage().(*ListTagsForResourceOutput)
}

const opListTypedLinkFacetAttributes = "ListTypedLinkFacetAttributes"

// ListTypedLinkFacetAttributesRequest is a API request type for the ListTypedLinkFacetAttributes API operation.
type ListTypedLinkFacetAttributesRequest struct {
	*aws.Request
	Input *ListTypedLinkFacetAttributesInput
	Copy  func(*ListTypedLinkFacetAttributesInput) ListTypedLinkFacetAttributesRequest
}

// Send marshals and sends the ListTypedLinkFacetAttributes API request.
func (r ListTypedLinkFacetAttributesRequest) Send() (*ListTypedLinkFacetAttributesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTypedLinkFacetAttributesOutput), nil
}

// ListTypedLinkFacetAttributesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns a paginated list of all attribute definitions for a particular TypedLinkFacet.
// For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the ListTypedLinkFacetAttributesRequest method.
//    req := client.ListTypedLinkFacetAttributesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTypedLinkFacetAttributes
func (c *CloudDirectory) ListTypedLinkFacetAttributesRequest(input *ListTypedLinkFacetAttributesInput) ListTypedLinkFacetAttributesRequest {
	op := &aws.Operation{
		Name:       opListTypedLinkFacetAttributes,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/facet/attributes",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListTypedLinkFacetAttributesInput{}
	}

	output := &ListTypedLinkFacetAttributesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTypedLinkFacetAttributesRequest{Request: req, Input: input, Copy: c.ListTypedLinkFacetAttributesRequest}
}

// Paginate pages iterates over the pages of a ListTypedLinkFacetAttributesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListTypedLinkFacetAttributes operation.
//		req := client.ListTypedLinkFacetAttributesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListTypedLinkFacetAttributesRequest) Paginate(opts ...aws.Option) ListTypedLinkFacetAttributesPager {
	return ListTypedLinkFacetAttributesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListTypedLinkFacetAttributesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListTypedLinkFacetAttributesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListTypedLinkFacetAttributesPager struct {
	aws.Pager
}

func (p *ListTypedLinkFacetAttributesPager) CurrentPage() *ListTypedLinkFacetAttributesOutput {
	return p.Pager.CurrentPage().(*ListTypedLinkFacetAttributesOutput)
}

const opListTypedLinkFacetNames = "ListTypedLinkFacetNames"

// ListTypedLinkFacetNamesRequest is a API request type for the ListTypedLinkFacetNames API operation.
type ListTypedLinkFacetNamesRequest struct {
	*aws.Request
	Input *ListTypedLinkFacetNamesInput
	Copy  func(*ListTypedLinkFacetNamesInput) ListTypedLinkFacetNamesRequest
}

// Send marshals and sends the ListTypedLinkFacetNames API request.
func (r ListTypedLinkFacetNamesRequest) Send() (*ListTypedLinkFacetNamesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTypedLinkFacetNamesOutput), nil
}

// ListTypedLinkFacetNamesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Returns a paginated list of TypedLink facet names for a particular schema.
// For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the ListTypedLinkFacetNamesRequest method.
//    req := client.ListTypedLinkFacetNamesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTypedLinkFacetNames
func (c *CloudDirectory) ListTypedLinkFacetNamesRequest(input *ListTypedLinkFacetNamesInput) ListTypedLinkFacetNamesRequest {
	op := &aws.Operation{
		Name:       opListTypedLinkFacetNames,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/facet/list",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListTypedLinkFacetNamesInput{}
	}

	output := &ListTypedLinkFacetNamesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTypedLinkFacetNamesRequest{Request: req, Input: input, Copy: c.ListTypedLinkFacetNamesRequest}
}

// Paginate pages iterates over the pages of a ListTypedLinkFacetNamesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListTypedLinkFacetNames operation.
//		req := client.ListTypedLinkFacetNamesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListTypedLinkFacetNamesRequest) Paginate(opts ...aws.Option) ListTypedLinkFacetNamesPager {
	return ListTypedLinkFacetNamesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListTypedLinkFacetNamesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListTypedLinkFacetNamesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListTypedLinkFacetNamesPager struct {
	aws.Pager
}

func (p *ListTypedLinkFacetNamesPager) CurrentPage() *ListTypedLinkFacetNamesOutput {
	return p.Pager.CurrentPage().(*ListTypedLinkFacetNamesOutput)
}

const opLookupPolicy = "LookupPolicy"

// LookupPolicyRequest is a API request type for the LookupPolicy API operation.
type LookupPolicyRequest struct {
	*aws.Request
	Input *LookupPolicyInput
	Copy  func(*LookupPolicyInput) LookupPolicyRequest
}

// Send marshals and sends the LookupPolicy API request.
func (r LookupPolicyRequest) Send() (*LookupPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*LookupPolicyOutput), nil
}

// LookupPolicyRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Lists all policies from the root of the Directory to the object specified.
// If there are no policies present, an empty list is returned. If policies
// are present, and if some objects don't have the policies attached, it returns
// the ObjectIdentifier for such objects. If policies are present, it returns
// ObjectIdentifier, policyId, and policyType. Paths that don't lead to the
// root from the target object are ignored. For more information, see Policies
// (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#policies).
//
//    // Example sending a request using the LookupPolicyRequest method.
//    req := client.LookupPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/LookupPolicy
func (c *CloudDirectory) LookupPolicyRequest(input *LookupPolicyInput) LookupPolicyRequest {
	op := &aws.Operation{
		Name:       opLookupPolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/policy/lookup",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &LookupPolicyInput{}
	}

	output := &LookupPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return LookupPolicyRequest{Request: req, Input: input, Copy: c.LookupPolicyRequest}
}

// Paginate pages iterates over the pages of a LookupPolicyRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a LookupPolicy operation.
//		req := client.LookupPolicyRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *LookupPolicyRequest) Paginate(opts ...aws.Option) LookupPolicyPager {
	return LookupPolicyPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *LookupPolicyInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// LookupPolicyPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type LookupPolicyPager struct {
	aws.Pager
}

func (p *LookupPolicyPager) CurrentPage() *LookupPolicyOutput {
	return p.Pager.CurrentPage().(*LookupPolicyOutput)
}

const opPublishSchema = "PublishSchema"

// PublishSchemaRequest is a API request type for the PublishSchema API operation.
type PublishSchemaRequest struct {
	*aws.Request
	Input *PublishSchemaInput
	Copy  func(*PublishSchemaInput) PublishSchemaRequest
}

// Send marshals and sends the PublishSchema API request.
func (r PublishSchemaRequest) Send() (*PublishSchemaOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PublishSchemaOutput), nil
}

// PublishSchemaRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Publishes a development schema with a major version and a recommended minor
// version.
//
//    // Example sending a request using the PublishSchemaRequest method.
//    req := client.PublishSchemaRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PublishSchema
func (c *CloudDirectory) PublishSchemaRequest(input *PublishSchemaInput) PublishSchemaRequest {
	op := &aws.Operation{
		Name:       opPublishSchema,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/publish",
	}

	if input == nil {
		input = &PublishSchemaInput{}
	}

	output := &PublishSchemaOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PublishSchemaRequest{Request: req, Input: input, Copy: c.PublishSchemaRequest}
}

const opPutSchemaFromJson = "PutSchemaFromJson"

// PutSchemaFromJsonRequest is a API request type for the PutSchemaFromJson API operation.
type PutSchemaFromJsonRequest struct {
	*aws.Request
	Input *PutSchemaFromJsonInput
	Copy  func(*PutSchemaFromJsonInput) PutSchemaFromJsonRequest
}

// Send marshals and sends the PutSchemaFromJson API request.
func (r PutSchemaFromJsonRequest) Send() (*PutSchemaFromJsonOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutSchemaFromJsonOutput), nil
}

// PutSchemaFromJsonRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Allows a schema to be updated using JSON upload. Only available for development
// schemas. See JSON Schema Format (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_schemas.html#jsonformat)
// for more information.
//
//    // Example sending a request using the PutSchemaFromJsonRequest method.
//    req := client.PutSchemaFromJsonRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PutSchemaFromJson
func (c *CloudDirectory) PutSchemaFromJsonRequest(input *PutSchemaFromJsonInput) PutSchemaFromJsonRequest {
	op := &aws.Operation{
		Name:       opPutSchemaFromJson,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/json",
	}

	if input == nil {
		input = &PutSchemaFromJsonInput{}
	}

	output := &PutSchemaFromJsonOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutSchemaFromJsonRequest{Request: req, Input: input, Copy: c.PutSchemaFromJsonRequest}
}

const opRemoveFacetFromObject = "RemoveFacetFromObject"

// RemoveFacetFromObjectRequest is a API request type for the RemoveFacetFromObject API operation.
type RemoveFacetFromObjectRequest struct {
	*aws.Request
	Input *RemoveFacetFromObjectInput
	Copy  func(*RemoveFacetFromObjectInput) RemoveFacetFromObjectRequest
}

// Send marshals and sends the RemoveFacetFromObject API request.
func (r RemoveFacetFromObjectRequest) Send() (*RemoveFacetFromObjectOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RemoveFacetFromObjectOutput), nil
}

// RemoveFacetFromObjectRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Removes the specified facet from the specified object.
//
//    // Example sending a request using the RemoveFacetFromObjectRequest method.
//    req := client.RemoveFacetFromObjectRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/RemoveFacetFromObject
func (c *CloudDirectory) RemoveFacetFromObjectRequest(input *RemoveFacetFromObjectInput) RemoveFacetFromObjectRequest {
	op := &aws.Operation{
		Name:       opRemoveFacetFromObject,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/facets/delete",
	}

	if input == nil {
		input = &RemoveFacetFromObjectInput{}
	}

	output := &RemoveFacetFromObjectOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RemoveFacetFromObjectRequest{Request: req, Input: input, Copy: c.RemoveFacetFromObjectRequest}
}

const opTagResource = "TagResource"

// TagResourceRequest is a API request type for the TagResource API operation.
type TagResourceRequest struct {
	*aws.Request
	Input *TagResourceInput
	Copy  func(*TagResourceInput) TagResourceRequest
}

// Send marshals and sends the TagResource API request.
func (r TagResourceRequest) Send() (*TagResourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TagResourceOutput), nil
}

// TagResourceRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// An API operation for adding tags to a resource.
//
//    // Example sending a request using the TagResourceRequest method.
//    req := client.TagResourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TagResource
func (c *CloudDirectory) TagResourceRequest(input *TagResourceInput) TagResourceRequest {
	op := &aws.Operation{
		Name:       opTagResource,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/tags/add",
	}

	if input == nil {
		input = &TagResourceInput{}
	}

	output := &TagResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TagResourceRequest{Request: req, Input: input, Copy: c.TagResourceRequest}
}

const opUntagResource = "UntagResource"

// UntagResourceRequest is a API request type for the UntagResource API operation.
type UntagResourceRequest struct {
	*aws.Request
	Input *UntagResourceInput
	Copy  func(*UntagResourceInput) UntagResourceRequest
}

// Send marshals and sends the UntagResource API request.
func (r UntagResourceRequest) Send() (*UntagResourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UntagResourceOutput), nil
}

// UntagResourceRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// An API operation for removing tags from a resource.
//
//    // Example sending a request using the UntagResourceRequest method.
//    req := client.UntagResourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UntagResource
func (c *CloudDirectory) UntagResourceRequest(input *UntagResourceInput) UntagResourceRequest {
	op := &aws.Operation{
		Name:       opUntagResource,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/tags/remove",
	}

	if input == nil {
		input = &UntagResourceInput{}
	}

	output := &UntagResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UntagResourceRequest{Request: req, Input: input, Copy: c.UntagResourceRequest}
}

const opUpdateFacet = "UpdateFacet"

// UpdateFacetRequest is a API request type for the UpdateFacet API operation.
type UpdateFacetRequest struct {
	*aws.Request
	Input *UpdateFacetInput
	Copy  func(*UpdateFacetInput) UpdateFacetRequest
}

// Send marshals and sends the UpdateFacet API request.
func (r UpdateFacetRequest) Send() (*UpdateFacetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateFacetOutput), nil
}

// UpdateFacetRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Does the following:
//
// Adds new Attributes, Rules, or ObjectTypes.
//
// Updates existing Attributes, Rules, or ObjectTypes.
//
// Deletes existing Attributes, Rules, or ObjectTypes.
//
//    // Example sending a request using the UpdateFacetRequest method.
//    req := client.UpdateFacetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateFacet
func (c *CloudDirectory) UpdateFacetRequest(input *UpdateFacetInput) UpdateFacetRequest {
	op := &aws.Operation{
		Name:       opUpdateFacet,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/facet",
	}

	if input == nil {
		input = &UpdateFacetInput{}
	}

	output := &UpdateFacetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateFacetRequest{Request: req, Input: input, Copy: c.UpdateFacetRequest}
}

const opUpdateObjectAttributes = "UpdateObjectAttributes"

// UpdateObjectAttributesRequest is a API request type for the UpdateObjectAttributes API operation.
type UpdateObjectAttributesRequest struct {
	*aws.Request
	Input *UpdateObjectAttributesInput
	Copy  func(*UpdateObjectAttributesInput) UpdateObjectAttributesRequest
}

// Send marshals and sends the UpdateObjectAttributes API request.
func (r UpdateObjectAttributesRequest) Send() (*UpdateObjectAttributesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateObjectAttributesOutput), nil
}

// UpdateObjectAttributesRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Updates a given object's attributes.
//
//    // Example sending a request using the UpdateObjectAttributesRequest method.
//    req := client.UpdateObjectAttributesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateObjectAttributes
func (c *CloudDirectory) UpdateObjectAttributesRequest(input *UpdateObjectAttributesInput) UpdateObjectAttributesRequest {
	op := &aws.Operation{
		Name:       opUpdateObjectAttributes,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/object/update",
	}

	if input == nil {
		input = &UpdateObjectAttributesInput{}
	}

	output := &UpdateObjectAttributesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateObjectAttributesRequest{Request: req, Input: input, Copy: c.UpdateObjectAttributesRequest}
}

const opUpdateSchema = "UpdateSchema"

// UpdateSchemaRequest is a API request type for the UpdateSchema API operation.
type UpdateSchemaRequest struct {
	*aws.Request
	Input *UpdateSchemaInput
	Copy  func(*UpdateSchemaInput) UpdateSchemaRequest
}

// Send marshals and sends the UpdateSchema API request.
func (r UpdateSchemaRequest) Send() (*UpdateSchemaOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateSchemaOutput), nil
}

// UpdateSchemaRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Updates the schema name with a new name. Only development schema names can
// be updated.
//
//    // Example sending a request using the UpdateSchemaRequest method.
//    req := client.UpdateSchemaRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateSchema
func (c *CloudDirectory) UpdateSchemaRequest(input *UpdateSchemaInput) UpdateSchemaRequest {
	op := &aws.Operation{
		Name:       opUpdateSchema,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/update",
	}

	if input == nil {
		input = &UpdateSchemaInput{}
	}

	output := &UpdateSchemaOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateSchemaRequest{Request: req, Input: input, Copy: c.UpdateSchemaRequest}
}

const opUpdateTypedLinkFacet = "UpdateTypedLinkFacet"

// UpdateTypedLinkFacetRequest is a API request type for the UpdateTypedLinkFacet API operation.
type UpdateTypedLinkFacetRequest struct {
	*aws.Request
	Input *UpdateTypedLinkFacetInput
	Copy  func(*UpdateTypedLinkFacetInput) UpdateTypedLinkFacetRequest
}

// Send marshals and sends the UpdateTypedLinkFacet API request.
func (r UpdateTypedLinkFacetRequest) Send() (*UpdateTypedLinkFacetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateTypedLinkFacetOutput), nil
}

// UpdateTypedLinkFacetRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Updates a TypedLinkFacet. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
//
//    // Example sending a request using the UpdateTypedLinkFacetRequest method.
//    req := client.UpdateTypedLinkFacetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateTypedLinkFacet
func (c *CloudDirectory) UpdateTypedLinkFacetRequest(input *UpdateTypedLinkFacetInput) UpdateTypedLinkFacetRequest {
	op := &aws.Operation{
		Name:       opUpdateTypedLinkFacet,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/typedlink/facet",
	}

	if input == nil {
		input = &UpdateTypedLinkFacetInput{}
	}

	output := &UpdateTypedLinkFacetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateTypedLinkFacetRequest{Request: req, Input: input, Copy: c.UpdateTypedLinkFacetRequest}
}

const opUpgradeAppliedSchema = "UpgradeAppliedSchema"

// UpgradeAppliedSchemaRequest is a API request type for the UpgradeAppliedSchema API operation.
type UpgradeAppliedSchemaRequest struct {
	*aws.Request
	Input *UpgradeAppliedSchemaInput
	Copy  func(*UpgradeAppliedSchemaInput) UpgradeAppliedSchemaRequest
}

// Send marshals and sends the UpgradeAppliedSchema API request.
func (r UpgradeAppliedSchemaRequest) Send() (*UpgradeAppliedSchemaOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpgradeAppliedSchemaOutput), nil
}

// UpgradeAppliedSchemaRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Upgrades a single directory in-place using the PublishedSchemaArn with schema
// updates found in MinorVersion. Backwards-compatible minor version upgrades
// are instantaneously available for readers on all objects in the directory.
// Note: This is a synchronous API call and upgrades only one schema on a given
// directory per call. To upgrade multiple directories from one schema, you
// would need to call this API on each directory.
//
//    // Example sending a request using the UpgradeAppliedSchemaRequest method.
//    req := client.UpgradeAppliedSchemaRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpgradeAppliedSchema
func (c *CloudDirectory) UpgradeAppliedSchemaRequest(input *UpgradeAppliedSchemaInput) UpgradeAppliedSchemaRequest {
	op := &aws.Operation{
		Name:       opUpgradeAppliedSchema,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/upgradeapplied",
	}

	if input == nil {
		input = &UpgradeAppliedSchemaInput{}
	}

	output := &UpgradeAppliedSchemaOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpgradeAppliedSchemaRequest{Request: req, Input: input, Copy: c.UpgradeAppliedSchemaRequest}
}

const opUpgradePublishedSchema = "UpgradePublishedSchema"

// UpgradePublishedSchemaRequest is a API request type for the UpgradePublishedSchema API operation.
type UpgradePublishedSchemaRequest struct {
	*aws.Request
	Input *UpgradePublishedSchemaInput
	Copy  func(*UpgradePublishedSchemaInput) UpgradePublishedSchemaRequest
}

// Send marshals and sends the UpgradePublishedSchema API request.
func (r UpgradePublishedSchemaRequest) Send() (*UpgradePublishedSchemaOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpgradePublishedSchemaOutput), nil
}

// UpgradePublishedSchemaRequest returns a request value for making API operation for
// Amazon CloudDirectory.
//
// Upgrades a published schema under a new minor version revision using the
// current contents of DevelopmentSchemaArn.
//
//    // Example sending a request using the UpgradePublishedSchemaRequest method.
//    req := client.UpgradePublishedSchemaRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpgradePublishedSchema
func (c *CloudDirectory) UpgradePublishedSchemaRequest(input *UpgradePublishedSchemaInput) UpgradePublishedSchemaRequest {
	op := &aws.Operation{
		Name:       opUpgradePublishedSchema,
		HTTPMethod: "PUT",
		HTTPPath:   "/amazonclouddirectory/2017-01-11/schema/upgradepublished",
	}

	if input == nil {
		input = &UpgradePublishedSchemaInput{}
	}

	output := &UpgradePublishedSchemaOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpgradePublishedSchemaRequest{Request: req, Input: input, Copy: c.UpgradePublishedSchemaRequest}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AddFacetToObjectRequest
type AddFacetToObjectInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// the object resides. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Attributes on the facet that you are adding to the object.
	ObjectAttributeList []AttributeKeyAndValue `type:"list"`

	// A reference to the object you are adding the specified facet to.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifiers for the facet that you are adding to the object. See SchemaFacet
	// for details.
	//
	// SchemaFacet is a required field
	SchemaFacet *SchemaFacet `type:"structure" required:"true"`
}

// String returns the string representation
func (s AddFacetToObjectInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddFacetToObjectInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AddFacetToObjectInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AddFacetToObjectInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.SchemaFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaFacet"))
	}
	if s.ObjectAttributeList != nil {
		for i, v := range s.ObjectAttributeList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ObjectAttributeList", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.SchemaFacet != nil {
		if err := s.SchemaFacet.Validate(); err != nil {
			invalidParams.AddNested("SchemaFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddFacetToObjectInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ObjectAttributeList) > 0 {
		v := s.ObjectAttributeList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ObjectAttributeList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.SchemaFacet != nil {
		v := s.SchemaFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SchemaFacet", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AddFacetToObjectResponse
type AddFacetToObjectOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AddFacetToObjectOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddFacetToObjectOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AddFacetToObjectOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddFacetToObjectOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ApplySchemaRequest
type ApplySchemaInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory into
	// which the schema is copied. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Published schema Amazon Resource Name (ARN) that needs to be copied. For
	// more information, see arns.
	//
	// PublishedSchemaArn is a required field
	PublishedSchemaArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s ApplySchemaInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApplySchemaInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ApplySchemaInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ApplySchemaInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.PublishedSchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("PublishedSchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ApplySchemaInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PublishedSchemaArn != nil {
		v := *s.PublishedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PublishedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ApplySchemaResponse
type ApplySchemaOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The applied schema ARN that is associated with the copied schema in the Directory.
	// You can use this ARN to describe the schema information applied on this directory.
	// For more information, see arns.
	AppliedSchemaArn *string `type:"string"`

	// The ARN that is associated with the Directory. For more information, see
	// arns.
	DirectoryArn *string `type:"string"`
}

// String returns the string representation
func (s ApplySchemaOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApplySchemaOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ApplySchemaOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ApplySchemaOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AppliedSchemaArn != nil {
		v := *s.AppliedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AppliedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachObjectRequest
type AttachObjectInput struct {
	_ struct{} `type:"structure"`

	// The child object reference to be attached to the object.
	//
	// ChildReference is a required field
	ChildReference *ObjectReference `type:"structure" required:"true"`

	// Amazon Resource Name (ARN) that is associated with the Directory where both
	// objects reside. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The link name with which the child object is attached to the parent.
	//
	// LinkName is a required field
	LinkName *string `min:"1" type:"string" required:"true"`

	// The parent object reference.
	//
	// ParentReference is a required field
	ParentReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s AttachObjectInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachObjectInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttachObjectInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttachObjectInput"}

	if s.ChildReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ChildReference"))
	}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.LinkName == nil {
		invalidParams.Add(aws.NewErrParamRequired("LinkName"))
	}
	if s.LinkName != nil && len(*s.LinkName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LinkName", 1))
	}

	if s.ParentReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ParentReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachObjectInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ChildReference != nil {
		v := s.ChildReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ChildReference", v, metadata)
	}
	if s.LinkName != nil {
		v := *s.LinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentReference != nil {
		v := s.ParentReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ParentReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachObjectResponse
type AttachObjectOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The attached ObjectIdentifier, which is the child ObjectIdentifier.
	AttachedObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s AttachObjectOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachObjectOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AttachObjectOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachObjectOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttachedObjectIdentifier != nil {
		v := *s.AttachedObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AttachedObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachPolicyRequest
type AttachPolicyInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// both objects reside. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The reference that identifies the object to which the policy will be attached.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// The reference that is associated with the policy object.
	//
	// PolicyReference is a required field
	PolicyReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s AttachPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttachPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttachPolicyInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.PolicyReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.PolicyReference != nil {
		v := s.PolicyReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "PolicyReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachPolicyResponse
type AttachPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AttachPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AttachPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachToIndexRequest
type AttachToIndexInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the directory where the object and index
	// exist.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// A reference to the index that you are attaching the object to.
	//
	// IndexReference is a required field
	IndexReference *ObjectReference `type:"structure" required:"true"`

	// A reference to the object that you are attaching to the index.
	//
	// TargetReference is a required field
	TargetReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s AttachToIndexInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachToIndexInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttachToIndexInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttachToIndexInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.IndexReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexReference"))
	}

	if s.TargetReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachToIndexInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.IndexReference != nil {
		v := s.IndexReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "IndexReference", v, metadata)
	}
	if s.TargetReference != nil {
		v := s.TargetReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachToIndexResponse
type AttachToIndexOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ObjectIdentifier of the object that was attached to the index.
	AttachedObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s AttachToIndexOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachToIndexOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AttachToIndexOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachToIndexOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttachedObjectIdentifier != nil {
		v := *s.AttachedObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AttachedObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachTypedLinkRequest
type AttachTypedLinkInput struct {
	_ struct{} `type:"structure"`

	// A set of attributes that are associated with the typed link.
	//
	// Attributes is a required field
	Attributes []AttributeNameAndValue `type:"list" required:"true"`

	// The Amazon Resource Name (ARN) of the directory where you want to attach
	// the typed link.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Identifies the source object that the typed link will attach to.
	//
	// SourceObjectReference is a required field
	SourceObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifies the target object that the typed link will attach to.
	//
	// TargetObjectReference is a required field
	TargetObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifies the typed link facet that is associated with the typed link.
	//
	// TypedLinkFacet is a required field
	TypedLinkFacet *TypedLinkSchemaAndFacetName `type:"structure" required:"true"`
}

// String returns the string representation
func (s AttachTypedLinkInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachTypedLinkInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttachTypedLinkInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttachTypedLinkInput"}

	if s.Attributes == nil {
		invalidParams.Add(aws.NewErrParamRequired("Attributes"))
	}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.SourceObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("SourceObjectReference"))
	}

	if s.TargetObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetObjectReference"))
	}

	if s.TypedLinkFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypedLinkFacet"))
	}
	if s.Attributes != nil {
		for i, v := range s.Attributes {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Attributes", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.TypedLinkFacet != nil {
		if err := s.TypedLinkFacet.Validate(); err != nil {
			invalidParams.AddNested("TypedLinkFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachTypedLinkInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SourceObjectReference != nil {
		v := s.SourceObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SourceObjectReference", v, metadata)
	}
	if s.TargetObjectReference != nil {
		v := s.TargetObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetObjectReference", v, metadata)
	}
	if s.TypedLinkFacet != nil {
		v := s.TypedLinkFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TypedLinkFacet", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttachTypedLinkResponse
type AttachTypedLinkOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Returns a typed link specifier as output.
	TypedLinkSpecifier *TypedLinkSpecifier `type:"structure"`
}

// String returns the string representation
func (s AttachTypedLinkOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttachTypedLinkOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AttachTypedLinkOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttachTypedLinkOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TypedLinkSpecifier != nil {
		v := s.TypedLinkSpecifier

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TypedLinkSpecifier", v, metadata)
	}
	return nil
}

// A unique identifier for an attribute.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttributeKey
type AttributeKey struct {
	_ struct{} `type:"structure"`

	// The name of the facet that the attribute exists within.
	//
	// FacetName is a required field
	FacetName *string `min:"1" type:"string" required:"true"`

	// The name of the attribute.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) of the schema that contains the facet and
	// attribute.
	//
	// SchemaArn is a required field
	SchemaArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s AttributeKey) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeKey) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttributeKey) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttributeKey"}

	if s.FacetName == nil {
		invalidParams.Add(aws.NewErrParamRequired("FacetName"))
	}
	if s.FacetName != nil && len(*s.FacetName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FacetName", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttributeKey) MarshalFields(e protocol.FieldEncoder) error {
	if s.FacetName != nil {
		v := *s.FacetName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FacetName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The combination of an attribute key and an attribute value.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttributeKeyAndValue
type AttributeKeyAndValue struct {
	_ struct{} `type:"structure"`

	// The key of the attribute.
	//
	// Key is a required field
	Key *AttributeKey `type:"structure" required:"true"`

	// The value of the attribute.
	//
	// Value is a required field
	Value *TypedAttributeValue `type:"structure" required:"true"`
}

// String returns the string representation
func (s AttributeKeyAndValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeKeyAndValue) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttributeKeyAndValue) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttributeKeyAndValue"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}
	if s.Key != nil {
		if err := s.Key.Validate(); err != nil {
			invalidParams.AddNested("Key", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttributeKeyAndValue) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := s.Key

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Key", v, metadata)
	}
	if s.Value != nil {
		v := s.Value

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Value", v, metadata)
	}
	return nil
}

// Identifies the attribute name and value for a typed link.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/AttributeNameAndValue
type AttributeNameAndValue struct {
	_ struct{} `type:"structure"`

	// The attribute name of the typed link.
	//
	// AttributeName is a required field
	AttributeName *string `min:"1" type:"string" required:"true"`

	// The value for the typed link.
	//
	// Value is a required field
	Value *TypedAttributeValue `type:"structure" required:"true"`
}

// String returns the string representation
func (s AttributeNameAndValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeNameAndValue) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttributeNameAndValue) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttributeNameAndValue"}

	if s.AttributeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeName"))
	}
	if s.AttributeName != nil && len(*s.AttributeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributeName", 1))
	}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttributeNameAndValue) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttributeName != nil {
		v := *s.AttributeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AttributeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Value != nil {
		v := s.Value

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Value", v, metadata)
	}
	return nil
}

// Represents the output of a batch add facet to object operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAddFacetToObject
type BatchAddFacetToObject struct {
	_ struct{} `type:"structure"`

	// The attributes to set on the object.
	//
	// ObjectAttributeList is a required field
	ObjectAttributeList []AttributeKeyAndValue `type:"list" required:"true"`

	// A reference to the object being mutated.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// Represents the facet being added to the object.
	//
	// SchemaFacet is a required field
	SchemaFacet *SchemaFacet `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchAddFacetToObject) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAddFacetToObject) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchAddFacetToObject) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchAddFacetToObject"}

	if s.ObjectAttributeList == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectAttributeList"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.SchemaFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaFacet"))
	}
	if s.ObjectAttributeList != nil {
		for i, v := range s.ObjectAttributeList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ObjectAttributeList", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.SchemaFacet != nil {
		if err := s.SchemaFacet.Validate(); err != nil {
			invalidParams.AddNested("SchemaFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAddFacetToObject) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ObjectAttributeList) > 0 {
		v := s.ObjectAttributeList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ObjectAttributeList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.SchemaFacet != nil {
		v := s.SchemaFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SchemaFacet", v, metadata)
	}
	return nil
}

// The result of a batch add facet to object operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAddFacetToObjectResponse
type BatchAddFacetToObjectResponse struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s BatchAddFacetToObjectResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAddFacetToObjectResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAddFacetToObjectResponse) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Represents the output of an AttachObject operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAttachObject
type BatchAttachObject struct {
	_ struct{} `type:"structure"`

	// The child object reference that is to be attached to the object.
	//
	// ChildReference is a required field
	ChildReference *ObjectReference `type:"structure" required:"true"`

	// The name of the link.
	//
	// LinkName is a required field
	LinkName *string `min:"1" type:"string" required:"true"`

	// The parent object reference.
	//
	// ParentReference is a required field
	ParentReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchAttachObject) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAttachObject) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchAttachObject) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchAttachObject"}

	if s.ChildReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ChildReference"))
	}

	if s.LinkName == nil {
		invalidParams.Add(aws.NewErrParamRequired("LinkName"))
	}
	if s.LinkName != nil && len(*s.LinkName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LinkName", 1))
	}

	if s.ParentReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ParentReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAttachObject) MarshalFields(e protocol.FieldEncoder) error {
	if s.ChildReference != nil {
		v := s.ChildReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ChildReference", v, metadata)
	}
	if s.LinkName != nil {
		v := *s.LinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentReference != nil {
		v := s.ParentReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ParentReference", v, metadata)
	}
	return nil
}

// Represents the output batch AttachObject response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAttachObjectResponse
type BatchAttachObjectResponse struct {
	_ struct{} `type:"structure"`

	// The ObjectIdentifier of the object that has been attached.
	AttachedObjectIdentifier *string `locationName:"attachedObjectIdentifier" type:"string"`
}

// String returns the string representation
func (s BatchAttachObjectResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAttachObjectResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAttachObjectResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttachedObjectIdentifier != nil {
		v := *s.AttachedObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "attachedObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Attaches a policy object to a regular object inside a BatchRead operation. For
// more information, see AttachPolicy and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAttachPolicy
type BatchAttachPolicy struct {
	_ struct{} `type:"structure"`

	// The reference that identifies the object to which the policy will be attached.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// The reference that is associated with the policy object.
	//
	// PolicyReference is a required field
	PolicyReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchAttachPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAttachPolicy) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchAttachPolicy) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchAttachPolicy"}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.PolicyReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAttachPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.PolicyReference != nil {
		v := s.PolicyReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "PolicyReference", v, metadata)
	}
	return nil
}

// Represents the output of an AttachPolicy response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAttachPolicyResponse
type BatchAttachPolicyResponse struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s BatchAttachPolicyResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAttachPolicyResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAttachPolicyResponse) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Attaches the specified object to the specified index inside a BatchRead operation.
// For more information, see AttachToIndex and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAttachToIndex
type BatchAttachToIndex struct {
	_ struct{} `type:"structure"`

	// A reference to the index that you are attaching the object to.
	//
	// IndexReference is a required field
	IndexReference *ObjectReference `type:"structure" required:"true"`

	// A reference to the object that you are attaching to the index.
	//
	// TargetReference is a required field
	TargetReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchAttachToIndex) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAttachToIndex) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchAttachToIndex) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchAttachToIndex"}

	if s.IndexReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexReference"))
	}

	if s.TargetReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAttachToIndex) MarshalFields(e protocol.FieldEncoder) error {
	if s.IndexReference != nil {
		v := s.IndexReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "IndexReference", v, metadata)
	}
	if s.TargetReference != nil {
		v := s.TargetReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetReference", v, metadata)
	}
	return nil
}

// Represents the output of a AttachToIndex response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAttachToIndexResponse
type BatchAttachToIndexResponse struct {
	_ struct{} `type:"structure"`

	// The ObjectIdentifier of the object that was attached to the index.
	AttachedObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s BatchAttachToIndexResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAttachToIndexResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAttachToIndexResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttachedObjectIdentifier != nil {
		v := *s.AttachedObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AttachedObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Attaches a typed link to a specified source and target object inside a BatchRead
// operation. For more information, see AttachTypedLink and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAttachTypedLink
type BatchAttachTypedLink struct {
	_ struct{} `type:"structure"`

	// A set of attributes that are associated with the typed link.
	//
	// Attributes is a required field
	Attributes []AttributeNameAndValue `type:"list" required:"true"`

	// Identifies the source object that the typed link will attach to.
	//
	// SourceObjectReference is a required field
	SourceObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifies the target object that the typed link will attach to.
	//
	// TargetObjectReference is a required field
	TargetObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifies the typed link facet that is associated with the typed link.
	//
	// TypedLinkFacet is a required field
	TypedLinkFacet *TypedLinkSchemaAndFacetName `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchAttachTypedLink) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAttachTypedLink) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchAttachTypedLink) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchAttachTypedLink"}

	if s.Attributes == nil {
		invalidParams.Add(aws.NewErrParamRequired("Attributes"))
	}

	if s.SourceObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("SourceObjectReference"))
	}

	if s.TargetObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetObjectReference"))
	}

	if s.TypedLinkFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypedLinkFacet"))
	}
	if s.Attributes != nil {
		for i, v := range s.Attributes {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Attributes", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.TypedLinkFacet != nil {
		if err := s.TypedLinkFacet.Validate(); err != nil {
			invalidParams.AddNested("TypedLinkFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAttachTypedLink) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SourceObjectReference != nil {
		v := s.SourceObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SourceObjectReference", v, metadata)
	}
	if s.TargetObjectReference != nil {
		v := s.TargetObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetObjectReference", v, metadata)
	}
	if s.TypedLinkFacet != nil {
		v := s.TypedLinkFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TypedLinkFacet", v, metadata)
	}
	return nil
}

// Represents the output of a AttachTypedLink response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchAttachTypedLinkResponse
type BatchAttachTypedLinkResponse struct {
	_ struct{} `type:"structure"`

	// Returns a typed link specifier as output.
	TypedLinkSpecifier *TypedLinkSpecifier `type:"structure"`
}

// String returns the string representation
func (s BatchAttachTypedLinkResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAttachTypedLinkResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchAttachTypedLinkResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.TypedLinkSpecifier != nil {
		v := s.TypedLinkSpecifier

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TypedLinkSpecifier", v, metadata)
	}
	return nil
}

// Creates an index object inside of a BatchRead operation. For more information,
// see CreateIndex and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchCreateIndex
type BatchCreateIndex struct {
	_ struct{} `type:"structure"`

	// The batch reference name. See Batches (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_advanced.html#batches)
	// for more information.
	BatchReferenceName *string `type:"string"`

	// Indicates whether the attribute that is being indexed has unique values or
	// not.
	//
	// IsUnique is a required field
	IsUnique *bool `type:"boolean" required:"true"`

	// The name of the link between the parent object and the index object.
	LinkName *string `min:"1" type:"string"`

	// Specifies the attributes that should be indexed on. Currently only a single
	// attribute is supported.
	//
	// OrderedIndexedAttributeList is a required field
	OrderedIndexedAttributeList []AttributeKey `type:"list" required:"true"`

	// A reference to the parent object that contains the index object.
	ParentReference *ObjectReference `type:"structure"`
}

// String returns the string representation
func (s BatchCreateIndex) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchCreateIndex) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchCreateIndex) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchCreateIndex"}

	if s.IsUnique == nil {
		invalidParams.Add(aws.NewErrParamRequired("IsUnique"))
	}
	if s.LinkName != nil && len(*s.LinkName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LinkName", 1))
	}

	if s.OrderedIndexedAttributeList == nil {
		invalidParams.Add(aws.NewErrParamRequired("OrderedIndexedAttributeList"))
	}
	if s.OrderedIndexedAttributeList != nil {
		for i, v := range s.OrderedIndexedAttributeList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "OrderedIndexedAttributeList", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchCreateIndex) MarshalFields(e protocol.FieldEncoder) error {
	if s.BatchReferenceName != nil {
		v := *s.BatchReferenceName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BatchReferenceName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IsUnique != nil {
		v := *s.IsUnique

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsUnique", protocol.BoolValue(v), metadata)
	}
	if s.LinkName != nil {
		v := *s.LinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OrderedIndexedAttributeList) > 0 {
		v := s.OrderedIndexedAttributeList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "OrderedIndexedAttributeList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ParentReference != nil {
		v := s.ParentReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ParentReference", v, metadata)
	}
	return nil
}

// Represents the output of a CreateIndex response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchCreateIndexResponse
type BatchCreateIndexResponse struct {
	_ struct{} `type:"structure"`

	// The ObjectIdentifier of the index created by this operation.
	ObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s BatchCreateIndexResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchCreateIndexResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchCreateIndexResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the output of a CreateObject operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchCreateObject
type BatchCreateObject struct {
	_ struct{} `type:"structure"`

	// The batch reference name. See Batches (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_advanced.html#batches)
	// for more information.
	BatchReferenceName *string `type:"string"`

	// The name of the link.
	LinkName *string `min:"1" type:"string"`

	// An attribute map, which contains an attribute ARN as the key and attribute
	// value as the map value.
	//
	// ObjectAttributeList is a required field
	ObjectAttributeList []AttributeKeyAndValue `type:"list" required:"true"`

	// If specified, the parent reference to which this object will be attached.
	ParentReference *ObjectReference `type:"structure"`

	// A list of FacetArns that will be associated with the object. For more information,
	// see arns.
	//
	// SchemaFacet is a required field
	SchemaFacet []SchemaFacet `type:"list" required:"true"`
}

// String returns the string representation
func (s BatchCreateObject) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchCreateObject) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchCreateObject) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchCreateObject"}
	if s.LinkName != nil && len(*s.LinkName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LinkName", 1))
	}

	if s.ObjectAttributeList == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectAttributeList"))
	}

	if s.SchemaFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaFacet"))
	}
	if s.ObjectAttributeList != nil {
		for i, v := range s.ObjectAttributeList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ObjectAttributeList", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.SchemaFacet != nil {
		for i, v := range s.SchemaFacet {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "SchemaFacet", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchCreateObject) MarshalFields(e protocol.FieldEncoder) error {
	if s.BatchReferenceName != nil {
		v := *s.BatchReferenceName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BatchReferenceName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LinkName != nil {
		v := *s.LinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ObjectAttributeList) > 0 {
		v := s.ObjectAttributeList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ObjectAttributeList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ParentReference != nil {
		v := s.ParentReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ParentReference", v, metadata)
	}
	if len(s.SchemaFacet) > 0 {
		v := s.SchemaFacet

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SchemaFacet", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Represents the output of a CreateObject response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchCreateObjectResponse
type BatchCreateObjectResponse struct {
	_ struct{} `type:"structure"`

	// The ID that is associated with the object.
	ObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s BatchCreateObjectResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchCreateObjectResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchCreateObjectResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the output of a DeleteObject operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDeleteObject
type BatchDeleteObject struct {
	_ struct{} `type:"structure"`

	// The reference that identifies the object.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchDeleteObject) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDeleteObject) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchDeleteObject) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchDeleteObject"}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDeleteObject) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a DeleteObject response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDeleteObjectResponse
type BatchDeleteObjectResponse struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s BatchDeleteObjectResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDeleteObjectResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDeleteObjectResponse) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Detaches the specified object from the specified index inside a BatchRead
// operation. For more information, see DetachFromIndex and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDetachFromIndex
type BatchDetachFromIndex struct {
	_ struct{} `type:"structure"`

	// A reference to the index object.
	//
	// IndexReference is a required field
	IndexReference *ObjectReference `type:"structure" required:"true"`

	// A reference to the object being detached from the index.
	//
	// TargetReference is a required field
	TargetReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchDetachFromIndex) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDetachFromIndex) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchDetachFromIndex) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchDetachFromIndex"}

	if s.IndexReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexReference"))
	}

	if s.TargetReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDetachFromIndex) MarshalFields(e protocol.FieldEncoder) error {
	if s.IndexReference != nil {
		v := s.IndexReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "IndexReference", v, metadata)
	}
	if s.TargetReference != nil {
		v := s.TargetReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetReference", v, metadata)
	}
	return nil
}

// Represents the output of a DetachFromIndex response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDetachFromIndexResponse
type BatchDetachFromIndexResponse struct {
	_ struct{} `type:"structure"`

	// The ObjectIdentifier of the object that was detached from the index.
	DetachedObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s BatchDetachFromIndexResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDetachFromIndexResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDetachFromIndexResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.DetachedObjectIdentifier != nil {
		v := *s.DetachedObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DetachedObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the output of a DetachObject operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDetachObject
type BatchDetachObject struct {
	_ struct{} `type:"structure"`

	// The batch reference name. See Batches (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_advanced.html#batches)
	// for more information.
	BatchReferenceName *string `type:"string"`

	// The name of the link.
	//
	// LinkName is a required field
	LinkName *string `min:"1" type:"string" required:"true"`

	// Parent reference from which the object with the specified link name is detached.
	//
	// ParentReference is a required field
	ParentReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchDetachObject) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDetachObject) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchDetachObject) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchDetachObject"}

	if s.LinkName == nil {
		invalidParams.Add(aws.NewErrParamRequired("LinkName"))
	}
	if s.LinkName != nil && len(*s.LinkName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LinkName", 1))
	}

	if s.ParentReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ParentReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDetachObject) MarshalFields(e protocol.FieldEncoder) error {
	if s.BatchReferenceName != nil {
		v := *s.BatchReferenceName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BatchReferenceName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LinkName != nil {
		v := *s.LinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentReference != nil {
		v := s.ParentReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ParentReference", v, metadata)
	}
	return nil
}

// Represents the output of a DetachObject response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDetachObjectResponse
type BatchDetachObjectResponse struct {
	_ struct{} `type:"structure"`

	// The ObjectIdentifier of the detached object.
	DetachedObjectIdentifier *string `locationName:"detachedObjectIdentifier" type:"string"`
}

// String returns the string representation
func (s BatchDetachObjectResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDetachObjectResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDetachObjectResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.DetachedObjectIdentifier != nil {
		v := *s.DetachedObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "detachedObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Detaches the specified policy from the specified directory inside a BatchWrite
// operation. For more information, see DetachPolicy and BatchWriteRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDetachPolicy
type BatchDetachPolicy struct {
	_ struct{} `type:"structure"`

	// Reference that identifies the object whose policy object will be detached.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// Reference that identifies the policy object.
	//
	// PolicyReference is a required field
	PolicyReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchDetachPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDetachPolicy) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchDetachPolicy) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchDetachPolicy"}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.PolicyReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDetachPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.PolicyReference != nil {
		v := s.PolicyReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "PolicyReference", v, metadata)
	}
	return nil
}

// Represents the output of a DetachPolicy response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDetachPolicyResponse
type BatchDetachPolicyResponse struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s BatchDetachPolicyResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDetachPolicyResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDetachPolicyResponse) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Detaches a typed link from a specified source and target object inside a
// BatchRead operation. For more information, see DetachTypedLink and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDetachTypedLink
type BatchDetachTypedLink struct {
	_ struct{} `type:"structure"`

	// Used to accept a typed link specifier as input.
	//
	// TypedLinkSpecifier is a required field
	TypedLinkSpecifier *TypedLinkSpecifier `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchDetachTypedLink) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDetachTypedLink) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchDetachTypedLink) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchDetachTypedLink"}

	if s.TypedLinkSpecifier == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypedLinkSpecifier"))
	}
	if s.TypedLinkSpecifier != nil {
		if err := s.TypedLinkSpecifier.Validate(); err != nil {
			invalidParams.AddNested("TypedLinkSpecifier", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDetachTypedLink) MarshalFields(e protocol.FieldEncoder) error {
	if s.TypedLinkSpecifier != nil {
		v := s.TypedLinkSpecifier

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TypedLinkSpecifier", v, metadata)
	}
	return nil
}

// Represents the output of a DetachTypedLink response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchDetachTypedLinkResponse
type BatchDetachTypedLinkResponse struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s BatchDetachTypedLinkResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDetachTypedLinkResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchDetachTypedLinkResponse) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Retrieves attributes within a facet that are associated with an object inside
// an BatchRead operation. For more information, see GetObjectAttributes and
// BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchGetObjectAttributes
type BatchGetObjectAttributes struct {
	_ struct{} `type:"structure"`

	// List of attribute names whose values will be retrieved.
	//
	// AttributeNames is a required field
	AttributeNames []string `type:"list" required:"true"`

	// Reference that identifies the object whose attributes will be retrieved.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifier for the facet whose attributes will be retrieved. See SchemaFacet
	// for details.
	//
	// SchemaFacet is a required field
	SchemaFacet *SchemaFacet `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchGetObjectAttributes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetObjectAttributes) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetObjectAttributes) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchGetObjectAttributes"}

	if s.AttributeNames == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeNames"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.SchemaFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaFacet"))
	}
	if s.SchemaFacet != nil {
		if err := s.SchemaFacet.Validate(); err != nil {
			invalidParams.AddNested("SchemaFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchGetObjectAttributes) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AttributeNames) > 0 {
		v := s.AttributeNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AttributeNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.SchemaFacet != nil {
		v := s.SchemaFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SchemaFacet", v, metadata)
	}
	return nil
}

// Represents the output of a GetObjectAttributes response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchGetObjectAttributesResponse
type BatchGetObjectAttributesResponse struct {
	_ struct{} `type:"structure"`

	// The attribute values that are associated with an object.
	Attributes []AttributeKeyAndValue `type:"list"`
}

// String returns the string representation
func (s BatchGetObjectAttributesResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetObjectAttributesResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchGetObjectAttributesResponse) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Retrieves metadata about an object inside a BatchRead operation. For more
// information, see GetObjectInformation and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchGetObjectInformation
type BatchGetObjectInformation struct {
	_ struct{} `type:"structure"`

	// A reference to the object.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchGetObjectInformation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetObjectInformation) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetObjectInformation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchGetObjectInformation"}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchGetObjectInformation) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a GetObjectInformation response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchGetObjectInformationResponse
type BatchGetObjectInformationResponse struct {
	_ struct{} `type:"structure"`

	// The ObjectIdentifier of the specified object.
	ObjectIdentifier *string `type:"string"`

	// The facets attached to the specified object.
	SchemaFacets []SchemaFacet `type:"list"`
}

// String returns the string representation
func (s BatchGetObjectInformationResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetObjectInformationResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchGetObjectInformationResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SchemaFacets) > 0 {
		v := s.SchemaFacets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SchemaFacets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Lists indices attached to an object inside a BatchRead operation. For more
// information, see ListAttachedIndices and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListAttachedIndices
type BatchListAttachedIndices struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// A reference to the object that has indices attached.
	//
	// TargetReference is a required field
	TargetReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchListAttachedIndices) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListAttachedIndices) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListAttachedIndices) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListAttachedIndices"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.TargetReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListAttachedIndices) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TargetReference != nil {
		v := s.TargetReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetReference", v, metadata)
	}
	return nil
}

// Represents the output of a ListAttachedIndices response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListAttachedIndicesResponse
type BatchListAttachedIndicesResponse struct {
	_ struct{} `type:"structure"`

	// The indices attached to the specified object.
	IndexAttachments []IndexAttachment `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s BatchListAttachedIndicesResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListAttachedIndicesResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListAttachedIndicesResponse) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IndexAttachments) > 0 {
		v := s.IndexAttachments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IndexAttachments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Returns a paginated list of all the incoming TypedLinkSpecifier information
// for an object inside a BatchRead operation. For more information, see ListIncomingTypedLinks
// and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListIncomingTypedLinks
type BatchListIncomingTypedLinks struct {
	_ struct{} `type:"structure"`

	// Provides range filters for multiple attributes. When providing ranges to
	// typed link selection, any inexact ranges must be specified at the end. Any
	// attributes that do not have a range specified are presumed to match the entire
	// range.
	FilterAttributeRanges []TypedLinkAttributeRange `type:"list"`

	// Filters are interpreted in the order of the attributes on the typed link
	// facet, not the order in which they are supplied to any API calls.
	FilterTypedLink *TypedLinkSchemaAndFacetName `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the object whose attributes will be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchListIncomingTypedLinks) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListIncomingTypedLinks) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListIncomingTypedLinks) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListIncomingTypedLinks"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}
	if s.FilterAttributeRanges != nil {
		for i, v := range s.FilterAttributeRanges {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "FilterAttributeRanges", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.FilterTypedLink != nil {
		if err := s.FilterTypedLink.Validate(); err != nil {
			invalidParams.AddNested("FilterTypedLink", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListIncomingTypedLinks) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.FilterAttributeRanges) > 0 {
		v := s.FilterAttributeRanges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FilterAttributeRanges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.FilterTypedLink != nil {
		v := s.FilterTypedLink

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FilterTypedLink", v, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a ListIncomingTypedLinks response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListIncomingTypedLinksResponse
type BatchListIncomingTypedLinksResponse struct {
	_ struct{} `type:"structure"`

	// Returns one or more typed link specifiers as output.
	LinkSpecifiers []TypedLinkSpecifier `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s BatchListIncomingTypedLinksResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListIncomingTypedLinksResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListIncomingTypedLinksResponse) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.LinkSpecifiers) > 0 {
		v := s.LinkSpecifiers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "LinkSpecifiers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Lists objects attached to the specified index inside a BatchRead operation.
// For more information, see ListIndex and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListIndex
type BatchListIndex struct {
	_ struct{} `type:"structure"`

	// The reference to the index to list.
	//
	// IndexReference is a required field
	IndexReference *ObjectReference `type:"structure" required:"true"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Specifies the ranges of indexed values that you want to query.
	RangesOnIndexedValues []ObjectAttributeRange `type:"list"`
}

// String returns the string representation
func (s BatchListIndex) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListIndex) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListIndex) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListIndex"}

	if s.IndexReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexReference"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.RangesOnIndexedValues != nil {
		for i, v := range s.RangesOnIndexedValues {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "RangesOnIndexedValues", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListIndex) MarshalFields(e protocol.FieldEncoder) error {
	if s.IndexReference != nil {
		v := s.IndexReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "IndexReference", v, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RangesOnIndexedValues) > 0 {
		v := s.RangesOnIndexedValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RangesOnIndexedValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Represents the output of a ListIndex response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListIndexResponse
type BatchListIndexResponse struct {
	_ struct{} `type:"structure"`

	// The objects and indexed values attached to the index.
	IndexAttachments []IndexAttachment `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s BatchListIndexResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListIndexResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListIndexResponse) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IndexAttachments) > 0 {
		v := s.IndexAttachments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IndexAttachments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the output of a ListObjectAttributes operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListObjectAttributes
type BatchListObjectAttributes struct {
	_ struct{} `type:"structure"`

	// Used to filter the list of object attributes that are associated with a certain
	// facet.
	FacetFilter *SchemaFacet `type:"structure"`

	// The maximum number of items to be retrieved in a single call. This is an
	// approximate number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Reference of the object whose attributes need to be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchListObjectAttributes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListObjectAttributes) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListObjectAttributes) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListObjectAttributes"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}
	if s.FacetFilter != nil {
		if err := s.FacetFilter.Validate(); err != nil {
			invalidParams.AddNested("FacetFilter", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListObjectAttributes) MarshalFields(e protocol.FieldEncoder) error {
	if s.FacetFilter != nil {
		v := s.FacetFilter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FacetFilter", v, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a ListObjectAttributes response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListObjectAttributesResponse
type BatchListObjectAttributesResponse struct {
	_ struct{} `type:"structure"`

	// The attributes map that is associated with the object. AttributeArn is the
	// key; attribute value is the value.
	Attributes []AttributeKeyAndValue `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s BatchListObjectAttributesResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListObjectAttributesResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListObjectAttributesResponse) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the output of a ListObjectChildren operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListObjectChildren
type BatchListObjectChildren struct {
	_ struct{} `type:"structure"`

	// Maximum number of items to be retrieved in a single call. This is an approximate
	// number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Reference of the object for which child objects are being listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchListObjectChildren) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListObjectChildren) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListObjectChildren) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListObjectChildren"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListObjectChildren) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a ListObjectChildren response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListObjectChildrenResponse
type BatchListObjectChildrenResponse struct {
	_ struct{} `type:"structure"`

	// The children structure, which is a map with the key as the LinkName and ObjectIdentifier
	// as the value.
	Children map[string]string `type:"map"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s BatchListObjectChildrenResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListObjectChildrenResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListObjectChildrenResponse) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Children) > 0 {
		v := s.Children

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Children", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Retrieves all available parent paths for any object type such as node, leaf
// node, policy node, and index node objects inside a BatchRead operation. For
// more information, see ListObjectParentPaths and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListObjectParentPaths
type BatchListObjectParentPaths struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the object whose attributes will be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchListObjectParentPaths) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListObjectParentPaths) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListObjectParentPaths) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListObjectParentPaths"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListObjectParentPaths) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a ListObjectParentPaths response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListObjectParentPathsResponse
type BatchListObjectParentPathsResponse struct {
	_ struct{} `type:"structure"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Returns the path to the ObjectIdentifiers that are associated with the directory.
	PathToObjectIdentifiersList []PathToObjectIdentifiers `type:"list"`
}

// String returns the string representation
func (s BatchListObjectParentPathsResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListObjectParentPathsResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListObjectParentPathsResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PathToObjectIdentifiersList) > 0 {
		v := s.PathToObjectIdentifiersList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "PathToObjectIdentifiersList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Returns policies attached to an object in pagination fashion inside a BatchRead
// operation. For more information, see ListObjectPolicies and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListObjectPolicies
type BatchListObjectPolicies struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the object whose attributes will be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchListObjectPolicies) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListObjectPolicies) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListObjectPolicies) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListObjectPolicies"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListObjectPolicies) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a ListObjectPolicies response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListObjectPoliciesResponse
type BatchListObjectPoliciesResponse struct {
	_ struct{} `type:"structure"`

	// A list of policy ObjectIdentifiers, that are attached to the object.
	AttachedPolicyIds []string `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s BatchListObjectPoliciesResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListObjectPoliciesResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListObjectPoliciesResponse) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AttachedPolicyIds) > 0 {
		v := s.AttachedPolicyIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AttachedPolicyIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Returns a paginated list of all the outgoing TypedLinkSpecifier information
// for an object inside a BatchRead operation. For more information, see ListOutgoingTypedLinks
// and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListOutgoingTypedLinks
type BatchListOutgoingTypedLinks struct {
	_ struct{} `type:"structure"`

	// Provides range filters for multiple attributes. When providing ranges to
	// typed link selection, any inexact ranges must be specified at the end. Any
	// attributes that do not have a range specified are presumed to match the entire
	// range.
	FilterAttributeRanges []TypedLinkAttributeRange `type:"list"`

	// Filters are interpreted in the order of the attributes defined on the typed
	// link facet, not the order they are supplied to any API calls.
	FilterTypedLink *TypedLinkSchemaAndFacetName `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the object whose attributes will be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchListOutgoingTypedLinks) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListOutgoingTypedLinks) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListOutgoingTypedLinks) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListOutgoingTypedLinks"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}
	if s.FilterAttributeRanges != nil {
		for i, v := range s.FilterAttributeRanges {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "FilterAttributeRanges", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.FilterTypedLink != nil {
		if err := s.FilterTypedLink.Validate(); err != nil {
			invalidParams.AddNested("FilterTypedLink", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListOutgoingTypedLinks) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.FilterAttributeRanges) > 0 {
		v := s.FilterAttributeRanges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FilterAttributeRanges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.FilterTypedLink != nil {
		v := s.FilterTypedLink

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FilterTypedLink", v, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a ListOutgoingTypedLinks response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListOutgoingTypedLinksResponse
type BatchListOutgoingTypedLinksResponse struct {
	_ struct{} `type:"structure"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Returns a typed link specifier as output.
	TypedLinkSpecifiers []TypedLinkSpecifier `type:"list"`
}

// String returns the string representation
func (s BatchListOutgoingTypedLinksResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListOutgoingTypedLinksResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListOutgoingTypedLinksResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TypedLinkSpecifiers) > 0 {
		v := s.TypedLinkSpecifiers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TypedLinkSpecifiers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Returns all of the ObjectIdentifiers to which a given policy is attached
// inside a BatchRead operation. For more information, see ListPolicyAttachments
// and BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListPolicyAttachments
type BatchListPolicyAttachments struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the policy object.
	//
	// PolicyReference is a required field
	PolicyReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchListPolicyAttachments) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListPolicyAttachments) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchListPolicyAttachments) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchListPolicyAttachments"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.PolicyReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListPolicyAttachments) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyReference != nil {
		v := s.PolicyReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "PolicyReference", v, metadata)
	}
	return nil
}

// Represents the output of a ListPolicyAttachments response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchListPolicyAttachmentsResponse
type BatchListPolicyAttachmentsResponse struct {
	_ struct{} `type:"structure"`

	// The pagination token.
	NextToken *string `type:"string"`

	// A list of ObjectIdentifiers to which the policy is attached.
	ObjectIdentifiers []string `type:"list"`
}

// String returns the string representation
func (s BatchListPolicyAttachmentsResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchListPolicyAttachmentsResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchListPolicyAttachmentsResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ObjectIdentifiers) > 0 {
		v := s.ObjectIdentifiers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ObjectIdentifiers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Lists all policies from the root of the Directory to the object specified
// inside a BatchRead operation. For more information, see LookupPolicy and
// BatchReadRequest$Operations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchLookupPolicy
type BatchLookupPolicy struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Reference that identifies the object whose policies will be looked up.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchLookupPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchLookupPolicy) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchLookupPolicy) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchLookupPolicy"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchLookupPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a LookupPolicy response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchLookupPolicyResponse
type BatchLookupPolicyResponse struct {
	_ struct{} `type:"structure"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier,
	// and PolicyType. For more information, see Policies (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#policies).
	PolicyToPathList []PolicyToPath `type:"list"`
}

// String returns the string representation
func (s BatchLookupPolicyResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchLookupPolicyResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchLookupPolicyResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PolicyToPathList) > 0 {
		v := s.PolicyToPathList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "PolicyToPathList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The batch read exception structure, which contains the exception type and
// message.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchReadException
type BatchReadException struct {
	_ struct{} `type:"structure"`

	// An exception message that is associated with the failure.
	Message *string `type:"string"`

	// A type of exception, such as InvalidArnException.
	Type BatchReadExceptionType `type:"string" enum:"true"`
}

// String returns the string representation
func (s BatchReadException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchReadException) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchReadException) MarshalFields(e protocol.FieldEncoder) error {
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Message", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchReadRequest
type BatchReadInput struct {
	_ struct{} `type:"structure"`

	// Represents the manner and timing in which the successful write or update
	// of an object is reflected in a subsequent read operation of that same object.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Directory. For
	// more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// A list of operations that are part of the batch.
	//
	// Operations is a required field
	Operations []BatchReadOperation `type:"list" required:"true"`
}

// String returns the string representation
func (s BatchReadInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchReadInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchReadInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchReadInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.Operations == nil {
		invalidParams.Add(aws.NewErrParamRequired("Operations"))
	}
	if s.Operations != nil {
		for i, v := range s.Operations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Operations", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchReadInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Operations) > 0 {
		v := s.Operations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Operations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the output of a BatchRead operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchReadOperation
type BatchReadOperation struct {
	_ struct{} `type:"structure"`

	// Retrieves attributes within a facet that are associated with an object.
	GetObjectAttributes *BatchGetObjectAttributes `type:"structure"`

	// Retrieves metadata about an object.
	GetObjectInformation *BatchGetObjectInformation `type:"structure"`

	// Lists indices attached to an object.
	ListAttachedIndices *BatchListAttachedIndices `type:"structure"`

	// Returns a paginated list of all the incoming TypedLinkSpecifier information
	// for an object. It also supports filtering by typed link facet and identity
	// attributes. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	ListIncomingTypedLinks *BatchListIncomingTypedLinks `type:"structure"`

	// Lists objects attached to the specified index.
	ListIndex *BatchListIndex `type:"structure"`

	// Lists all attributes that are associated with an object.
	ListObjectAttributes *BatchListObjectAttributes `type:"structure"`

	// Returns a paginated list of child objects that are associated with a given
	// object.
	ListObjectChildren *BatchListObjectChildren `type:"structure"`

	// Retrieves all available parent paths for any object type such as node, leaf
	// node, policy node, and index node objects. For more information about objects,
	// see Directory Structure (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#dirstructure).
	ListObjectParentPaths *BatchListObjectParentPaths `type:"structure"`

	// Returns policies attached to an object in pagination fashion.
	ListObjectPolicies *BatchListObjectPolicies `type:"structure"`

	// Returns a paginated list of all the outgoing TypedLinkSpecifier information
	// for an object. It also supports filtering by typed link facet and identity
	// attributes. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	ListOutgoingTypedLinks *BatchListOutgoingTypedLinks `type:"structure"`

	// Returns all of the ObjectIdentifiers to which a given policy is attached.
	ListPolicyAttachments *BatchListPolicyAttachments `type:"structure"`

	// Lists all policies from the root of the Directory to the object specified.
	// If there are no policies present, an empty list is returned. If policies
	// are present, and if some objects don't have the policies attached, it returns
	// the ObjectIdentifier for such objects. If policies are present, it returns
	// ObjectIdentifier, policyId, and policyType. Paths that don't lead to the
	// root from the target object are ignored. For more information, see Policies
	// (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#policies).
	LookupPolicy *BatchLookupPolicy `type:"structure"`
}

// String returns the string representation
func (s BatchReadOperation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchReadOperation) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchReadOperation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchReadOperation"}
	if s.GetObjectAttributes != nil {
		if err := s.GetObjectAttributes.Validate(); err != nil {
			invalidParams.AddNested("GetObjectAttributes", err.(aws.ErrInvalidParams))
		}
	}
	if s.GetObjectInformation != nil {
		if err := s.GetObjectInformation.Validate(); err != nil {
			invalidParams.AddNested("GetObjectInformation", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListAttachedIndices != nil {
		if err := s.ListAttachedIndices.Validate(); err != nil {
			invalidParams.AddNested("ListAttachedIndices", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListIncomingTypedLinks != nil {
		if err := s.ListIncomingTypedLinks.Validate(); err != nil {
			invalidParams.AddNested("ListIncomingTypedLinks", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListIndex != nil {
		if err := s.ListIndex.Validate(); err != nil {
			invalidParams.AddNested("ListIndex", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListObjectAttributes != nil {
		if err := s.ListObjectAttributes.Validate(); err != nil {
			invalidParams.AddNested("ListObjectAttributes", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListObjectChildren != nil {
		if err := s.ListObjectChildren.Validate(); err != nil {
			invalidParams.AddNested("ListObjectChildren", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListObjectParentPaths != nil {
		if err := s.ListObjectParentPaths.Validate(); err != nil {
			invalidParams.AddNested("ListObjectParentPaths", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListObjectPolicies != nil {
		if err := s.ListObjectPolicies.Validate(); err != nil {
			invalidParams.AddNested("ListObjectPolicies", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListOutgoingTypedLinks != nil {
		if err := s.ListOutgoingTypedLinks.Validate(); err != nil {
			invalidParams.AddNested("ListOutgoingTypedLinks", err.(aws.ErrInvalidParams))
		}
	}
	if s.ListPolicyAttachments != nil {
		if err := s.ListPolicyAttachments.Validate(); err != nil {
			invalidParams.AddNested("ListPolicyAttachments", err.(aws.ErrInvalidParams))
		}
	}
	if s.LookupPolicy != nil {
		if err := s.LookupPolicy.Validate(); err != nil {
			invalidParams.AddNested("LookupPolicy", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchReadOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.GetObjectAttributes != nil {
		v := s.GetObjectAttributes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "GetObjectAttributes", v, metadata)
	}
	if s.GetObjectInformation != nil {
		v := s.GetObjectInformation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "GetObjectInformation", v, metadata)
	}
	if s.ListAttachedIndices != nil {
		v := s.ListAttachedIndices

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListAttachedIndices", v, metadata)
	}
	if s.ListIncomingTypedLinks != nil {
		v := s.ListIncomingTypedLinks

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListIncomingTypedLinks", v, metadata)
	}
	if s.ListIndex != nil {
		v := s.ListIndex

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListIndex", v, metadata)
	}
	if s.ListObjectAttributes != nil {
		v := s.ListObjectAttributes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListObjectAttributes", v, metadata)
	}
	if s.ListObjectChildren != nil {
		v := s.ListObjectChildren

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListObjectChildren", v, metadata)
	}
	if s.ListObjectParentPaths != nil {
		v := s.ListObjectParentPaths

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListObjectParentPaths", v, metadata)
	}
	if s.ListObjectPolicies != nil {
		v := s.ListObjectPolicies

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListObjectPolicies", v, metadata)
	}
	if s.ListOutgoingTypedLinks != nil {
		v := s.ListOutgoingTypedLinks

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListOutgoingTypedLinks", v, metadata)
	}
	if s.ListPolicyAttachments != nil {
		v := s.ListPolicyAttachments

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListPolicyAttachments", v, metadata)
	}
	if s.LookupPolicy != nil {
		v := s.LookupPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LookupPolicy", v, metadata)
	}
	return nil
}

// Represents the output of a BatchRead response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchReadOperationResponse
type BatchReadOperationResponse struct {
	_ struct{} `type:"structure"`

	// Identifies which operation in a batch has failed.
	ExceptionResponse *BatchReadException `type:"structure"`

	// Identifies which operation in a batch has succeeded.
	SuccessfulResponse *BatchReadSuccessfulResponse `type:"structure"`
}

// String returns the string representation
func (s BatchReadOperationResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchReadOperationResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchReadOperationResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.ExceptionResponse != nil {
		v := s.ExceptionResponse

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ExceptionResponse", v, metadata)
	}
	if s.SuccessfulResponse != nil {
		v := s.SuccessfulResponse

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SuccessfulResponse", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchReadResponse
type BatchReadOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of all the responses for each batch read.
	Responses []BatchReadOperationResponse `type:"list"`
}

// String returns the string representation
func (s BatchReadOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchReadOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s BatchReadOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchReadOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Responses) > 0 {
		v := s.Responses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Responses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Represents the output of a BatchRead success response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchReadSuccessfulResponse
type BatchReadSuccessfulResponse struct {
	_ struct{} `type:"structure"`

	// Retrieves attributes within a facet that are associated with an object.
	GetObjectAttributes *BatchGetObjectAttributesResponse `type:"structure"`

	// Retrieves metadata about an object.
	GetObjectInformation *BatchGetObjectInformationResponse `type:"structure"`

	// Lists indices attached to an object.
	ListAttachedIndices *BatchListAttachedIndicesResponse `type:"structure"`

	// Returns a paginated list of all the incoming TypedLinkSpecifier information
	// for an object. It also supports filtering by typed link facet and identity
	// attributes. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	ListIncomingTypedLinks *BatchListIncomingTypedLinksResponse `type:"structure"`

	// Lists objects attached to the specified index.
	ListIndex *BatchListIndexResponse `type:"structure"`

	// Lists all attributes that are associated with an object.
	ListObjectAttributes *BatchListObjectAttributesResponse `type:"structure"`

	// Returns a paginated list of child objects that are associated with a given
	// object.
	ListObjectChildren *BatchListObjectChildrenResponse `type:"structure"`

	// Retrieves all available parent paths for any object type such as node, leaf
	// node, policy node, and index node objects. For more information about objects,
	// see Directory Structure (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#dirstructure).
	ListObjectParentPaths *BatchListObjectParentPathsResponse `type:"structure"`

	// Returns policies attached to an object in pagination fashion.
	ListObjectPolicies *BatchListObjectPoliciesResponse `type:"structure"`

	// Returns a paginated list of all the outgoing TypedLinkSpecifier information
	// for an object. It also supports filtering by typed link facet and identity
	// attributes. For more information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	ListOutgoingTypedLinks *BatchListOutgoingTypedLinksResponse `type:"structure"`

	// Returns all of the ObjectIdentifiers to which a given policy is attached.
	ListPolicyAttachments *BatchListPolicyAttachmentsResponse `type:"structure"`

	// Lists all policies from the root of the Directory to the object specified.
	// If there are no policies present, an empty list is returned. If policies
	// are present, and if some objects don't have the policies attached, it returns
	// the ObjectIdentifier for such objects. If policies are present, it returns
	// ObjectIdentifier, policyId, and policyType. Paths that don't lead to the
	// root from the target object are ignored. For more information, see Policies
	// (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#policies).
	LookupPolicy *BatchLookupPolicyResponse `type:"structure"`
}

// String returns the string representation
func (s BatchReadSuccessfulResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchReadSuccessfulResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchReadSuccessfulResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.GetObjectAttributes != nil {
		v := s.GetObjectAttributes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "GetObjectAttributes", v, metadata)
	}
	if s.GetObjectInformation != nil {
		v := s.GetObjectInformation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "GetObjectInformation", v, metadata)
	}
	if s.ListAttachedIndices != nil {
		v := s.ListAttachedIndices

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListAttachedIndices", v, metadata)
	}
	if s.ListIncomingTypedLinks != nil {
		v := s.ListIncomingTypedLinks

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListIncomingTypedLinks", v, metadata)
	}
	if s.ListIndex != nil {
		v := s.ListIndex

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListIndex", v, metadata)
	}
	if s.ListObjectAttributes != nil {
		v := s.ListObjectAttributes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListObjectAttributes", v, metadata)
	}
	if s.ListObjectChildren != nil {
		v := s.ListObjectChildren

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListObjectChildren", v, metadata)
	}
	if s.ListObjectParentPaths != nil {
		v := s.ListObjectParentPaths

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListObjectParentPaths", v, metadata)
	}
	if s.ListObjectPolicies != nil {
		v := s.ListObjectPolicies

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListObjectPolicies", v, metadata)
	}
	if s.ListOutgoingTypedLinks != nil {
		v := s.ListOutgoingTypedLinks

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListOutgoingTypedLinks", v, metadata)
	}
	if s.ListPolicyAttachments != nil {
		v := s.ListPolicyAttachments

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ListPolicyAttachments", v, metadata)
	}
	if s.LookupPolicy != nil {
		v := s.LookupPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LookupPolicy", v, metadata)
	}
	return nil
}

// A batch operation to remove a facet from an object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchRemoveFacetFromObject
type BatchRemoveFacetFromObject struct {
	_ struct{} `type:"structure"`

	// A reference to the object whose facet will be removed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// The facet to remove from the object.
	//
	// SchemaFacet is a required field
	SchemaFacet *SchemaFacet `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchRemoveFacetFromObject) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchRemoveFacetFromObject) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchRemoveFacetFromObject) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchRemoveFacetFromObject"}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.SchemaFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaFacet"))
	}
	if s.SchemaFacet != nil {
		if err := s.SchemaFacet.Validate(); err != nil {
			invalidParams.AddNested("SchemaFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchRemoveFacetFromObject) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.SchemaFacet != nil {
		v := s.SchemaFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SchemaFacet", v, metadata)
	}
	return nil
}

// An empty result that represents success.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchRemoveFacetFromObjectResponse
type BatchRemoveFacetFromObjectResponse struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s BatchRemoveFacetFromObjectResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchRemoveFacetFromObjectResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchRemoveFacetFromObjectResponse) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Represents the output of a BatchUpdate operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchUpdateObjectAttributes
type BatchUpdateObjectAttributes struct {
	_ struct{} `type:"structure"`

	// Attributes update structure.
	//
	// AttributeUpdates is a required field
	AttributeUpdates []ObjectAttributeUpdate `type:"list" required:"true"`

	// Reference that identifies the object.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s BatchUpdateObjectAttributes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchUpdateObjectAttributes) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchUpdateObjectAttributes) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchUpdateObjectAttributes"}

	if s.AttributeUpdates == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeUpdates"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}
	if s.AttributeUpdates != nil {
		for i, v := range s.AttributeUpdates {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AttributeUpdates", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchUpdateObjectAttributes) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AttributeUpdates) > 0 {
		v := s.AttributeUpdates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AttributeUpdates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	return nil
}

// Represents the output of a BatchUpdate response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchUpdateObjectAttributesResponse
type BatchUpdateObjectAttributesResponse struct {
	_ struct{} `type:"structure"`

	// ID that is associated with the object.
	ObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s BatchUpdateObjectAttributesResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchUpdateObjectAttributesResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchUpdateObjectAttributesResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchWriteRequest
type BatchWriteInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory. For
	// more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// A list of operations that are part of the batch.
	//
	// Operations is a required field
	Operations []BatchWriteOperation `type:"list" required:"true"`
}

// String returns the string representation
func (s BatchWriteInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchWriteInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchWriteInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchWriteInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.Operations == nil {
		invalidParams.Add(aws.NewErrParamRequired("Operations"))
	}
	if s.Operations != nil {
		for i, v := range s.Operations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Operations", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchWriteInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Operations) > 0 {
		v := s.Operations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Operations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the output of a BatchWrite operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchWriteOperation
type BatchWriteOperation struct {
	_ struct{} `type:"structure"`

	// A batch operation that adds a facet to an object.
	AddFacetToObject *BatchAddFacetToObject `type:"structure"`

	// Attaches an object to a Directory.
	AttachObject *BatchAttachObject `type:"structure"`

	// Attaches a policy object to a regular object. An object can have a limited
	// number of attached policies.
	AttachPolicy *BatchAttachPolicy `type:"structure"`

	// Attaches the specified object to the specified index.
	AttachToIndex *BatchAttachToIndex `type:"structure"`

	// Attaches a typed link to a specified source and target object. For more information,
	// see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	AttachTypedLink *BatchAttachTypedLink `type:"structure"`

	// Creates an index object. See Indexing (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_indexing.html)
	// for more information.
	CreateIndex *BatchCreateIndex `type:"structure"`

	// Creates an object.
	CreateObject *BatchCreateObject `type:"structure"`

	// Deletes an object in a Directory.
	DeleteObject *BatchDeleteObject `type:"structure"`

	// Detaches the specified object from the specified index.
	DetachFromIndex *BatchDetachFromIndex `type:"structure"`

	// Detaches an object from a Directory.
	DetachObject *BatchDetachObject `type:"structure"`

	// Detaches a policy from a Directory.
	DetachPolicy *BatchDetachPolicy `type:"structure"`

	// Detaches a typed link from a specified source and target object. For more
	// information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	DetachTypedLink *BatchDetachTypedLink `type:"structure"`

	// A batch operation that removes a facet from an object.
	RemoveFacetFromObject *BatchRemoveFacetFromObject `type:"structure"`

	// Updates a given object's attributes.
	UpdateObjectAttributes *BatchUpdateObjectAttributes `type:"structure"`
}

// String returns the string representation
func (s BatchWriteOperation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchWriteOperation) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchWriteOperation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchWriteOperation"}
	if s.AddFacetToObject != nil {
		if err := s.AddFacetToObject.Validate(); err != nil {
			invalidParams.AddNested("AddFacetToObject", err.(aws.ErrInvalidParams))
		}
	}
	if s.AttachObject != nil {
		if err := s.AttachObject.Validate(); err != nil {
			invalidParams.AddNested("AttachObject", err.(aws.ErrInvalidParams))
		}
	}
	if s.AttachPolicy != nil {
		if err := s.AttachPolicy.Validate(); err != nil {
			invalidParams.AddNested("AttachPolicy", err.(aws.ErrInvalidParams))
		}
	}
	if s.AttachToIndex != nil {
		if err := s.AttachToIndex.Validate(); err != nil {
			invalidParams.AddNested("AttachToIndex", err.(aws.ErrInvalidParams))
		}
	}
	if s.AttachTypedLink != nil {
		if err := s.AttachTypedLink.Validate(); err != nil {
			invalidParams.AddNested("AttachTypedLink", err.(aws.ErrInvalidParams))
		}
	}
	if s.CreateIndex != nil {
		if err := s.CreateIndex.Validate(); err != nil {
			invalidParams.AddNested("CreateIndex", err.(aws.ErrInvalidParams))
		}
	}
	if s.CreateObject != nil {
		if err := s.CreateObject.Validate(); err != nil {
			invalidParams.AddNested("CreateObject", err.(aws.ErrInvalidParams))
		}
	}
	if s.DeleteObject != nil {
		if err := s.DeleteObject.Validate(); err != nil {
			invalidParams.AddNested("DeleteObject", err.(aws.ErrInvalidParams))
		}
	}
	if s.DetachFromIndex != nil {
		if err := s.DetachFromIndex.Validate(); err != nil {
			invalidParams.AddNested("DetachFromIndex", err.(aws.ErrInvalidParams))
		}
	}
	if s.DetachObject != nil {
		if err := s.DetachObject.Validate(); err != nil {
			invalidParams.AddNested("DetachObject", err.(aws.ErrInvalidParams))
		}
	}
	if s.DetachPolicy != nil {
		if err := s.DetachPolicy.Validate(); err != nil {
			invalidParams.AddNested("DetachPolicy", err.(aws.ErrInvalidParams))
		}
	}
	if s.DetachTypedLink != nil {
		if err := s.DetachTypedLink.Validate(); err != nil {
			invalidParams.AddNested("DetachTypedLink", err.(aws.ErrInvalidParams))
		}
	}
	if s.RemoveFacetFromObject != nil {
		if err := s.RemoveFacetFromObject.Validate(); err != nil {
			invalidParams.AddNested("RemoveFacetFromObject", err.(aws.ErrInvalidParams))
		}
	}
	if s.UpdateObjectAttributes != nil {
		if err := s.UpdateObjectAttributes.Validate(); err != nil {
			invalidParams.AddNested("UpdateObjectAttributes", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchWriteOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.AddFacetToObject != nil {
		v := s.AddFacetToObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AddFacetToObject", v, metadata)
	}
	if s.AttachObject != nil {
		v := s.AttachObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttachObject", v, metadata)
	}
	if s.AttachPolicy != nil {
		v := s.AttachPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttachPolicy", v, metadata)
	}
	if s.AttachToIndex != nil {
		v := s.AttachToIndex

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttachToIndex", v, metadata)
	}
	if s.AttachTypedLink != nil {
		v := s.AttachTypedLink

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttachTypedLink", v, metadata)
	}
	if s.CreateIndex != nil {
		v := s.CreateIndex

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CreateIndex", v, metadata)
	}
	if s.CreateObject != nil {
		v := s.CreateObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CreateObject", v, metadata)
	}
	if s.DeleteObject != nil {
		v := s.DeleteObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DeleteObject", v, metadata)
	}
	if s.DetachFromIndex != nil {
		v := s.DetachFromIndex

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DetachFromIndex", v, metadata)
	}
	if s.DetachObject != nil {
		v := s.DetachObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DetachObject", v, metadata)
	}
	if s.DetachPolicy != nil {
		v := s.DetachPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DetachPolicy", v, metadata)
	}
	if s.DetachTypedLink != nil {
		v := s.DetachTypedLink

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DetachTypedLink", v, metadata)
	}
	if s.RemoveFacetFromObject != nil {
		v := s.RemoveFacetFromObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "RemoveFacetFromObject", v, metadata)
	}
	if s.UpdateObjectAttributes != nil {
		v := s.UpdateObjectAttributes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "UpdateObjectAttributes", v, metadata)
	}
	return nil
}

// Represents the output of a BatchWrite response operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchWriteOperationResponse
type BatchWriteOperationResponse struct {
	_ struct{} `type:"structure"`

	// The result of an add facet to object batch operation.
	AddFacetToObject *BatchAddFacetToObjectResponse `type:"structure"`

	// Attaches an object to a Directory.
	AttachObject *BatchAttachObjectResponse `type:"structure"`

	// Attaches a policy object to a regular object. An object can have a limited
	// number of attached policies.
	AttachPolicy *BatchAttachPolicyResponse `type:"structure"`

	// Attaches the specified object to the specified index.
	AttachToIndex *BatchAttachToIndexResponse `type:"structure"`

	// Attaches a typed link to a specified source and target object. For more information,
	// see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	AttachTypedLink *BatchAttachTypedLinkResponse `type:"structure"`

	// Creates an index object. See Indexing (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_indexing.html)
	// for more information.
	CreateIndex *BatchCreateIndexResponse `type:"structure"`

	// Creates an object in a Directory.
	CreateObject *BatchCreateObjectResponse `type:"structure"`

	// Deletes an object in a Directory.
	DeleteObject *BatchDeleteObjectResponse `type:"structure"`

	// Detaches the specified object from the specified index.
	DetachFromIndex *BatchDetachFromIndexResponse `type:"structure"`

	// Detaches an object from a Directory.
	DetachObject *BatchDetachObjectResponse `type:"structure"`

	// Detaches a policy from a Directory.
	DetachPolicy *BatchDetachPolicyResponse `type:"structure"`

	// Detaches a typed link from a specified source and target object. For more
	// information, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	DetachTypedLink *BatchDetachTypedLinkResponse `type:"structure"`

	// The result of a batch remove facet from object operation.
	RemoveFacetFromObject *BatchRemoveFacetFromObjectResponse `type:"structure"`

	// Updates a given object’s attributes.
	UpdateObjectAttributes *BatchUpdateObjectAttributesResponse `type:"structure"`
}

// String returns the string representation
func (s BatchWriteOperationResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchWriteOperationResponse) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchWriteOperationResponse) MarshalFields(e protocol.FieldEncoder) error {
	if s.AddFacetToObject != nil {
		v := s.AddFacetToObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AddFacetToObject", v, metadata)
	}
	if s.AttachObject != nil {
		v := s.AttachObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttachObject", v, metadata)
	}
	if s.AttachPolicy != nil {
		v := s.AttachPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttachPolicy", v, metadata)
	}
	if s.AttachToIndex != nil {
		v := s.AttachToIndex

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttachToIndex", v, metadata)
	}
	if s.AttachTypedLink != nil {
		v := s.AttachTypedLink

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttachTypedLink", v, metadata)
	}
	if s.CreateIndex != nil {
		v := s.CreateIndex

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CreateIndex", v, metadata)
	}
	if s.CreateObject != nil {
		v := s.CreateObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CreateObject", v, metadata)
	}
	if s.DeleteObject != nil {
		v := s.DeleteObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DeleteObject", v, metadata)
	}
	if s.DetachFromIndex != nil {
		v := s.DetachFromIndex

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DetachFromIndex", v, metadata)
	}
	if s.DetachObject != nil {
		v := s.DetachObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DetachObject", v, metadata)
	}
	if s.DetachPolicy != nil {
		v := s.DetachPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DetachPolicy", v, metadata)
	}
	if s.DetachTypedLink != nil {
		v := s.DetachTypedLink

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DetachTypedLink", v, metadata)
	}
	if s.RemoveFacetFromObject != nil {
		v := s.RemoveFacetFromObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "RemoveFacetFromObject", v, metadata)
	}
	if s.UpdateObjectAttributes != nil {
		v := s.UpdateObjectAttributes

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "UpdateObjectAttributes", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/BatchWriteResponse
type BatchWriteOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of all the responses for each batch write.
	Responses []BatchWriteOperationResponse `type:"list"`
}

// String returns the string representation
func (s BatchWriteOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchWriteOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s BatchWriteOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchWriteOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Responses) > 0 {
		v := s.Responses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Responses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateDirectoryRequest
type CreateDirectoryInput struct {
	_ struct{} `type:"structure"`

	// The name of the Directory. Should be unique per account, per region.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) of the published schema that will be copied
	// into the data Directory. For more information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateDirectoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDirectoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDirectoryInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDirectoryInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateDirectoryInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateDirectoryResponse
type CreateDirectoryOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the published schema in the Directory. Once a published schema
	// is copied into the directory, it has its own ARN, which is referred to applied
	// schema ARN. For more information, see arns.
	//
	// AppliedSchemaArn is a required field
	AppliedSchemaArn *string `type:"string" required:"true"`

	// The ARN that is associated with the Directory. For more information, see
	// arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `type:"string" required:"true"`

	// The name of the Directory.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The root object node of the created directory.
	//
	// ObjectIdentifier is a required field
	ObjectIdentifier *string `type:"string" required:"true"`
}

// String returns the string representation
func (s CreateDirectoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDirectoryOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateDirectoryOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateDirectoryOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AppliedSchemaArn != nil {
		v := *s.AppliedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AppliedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateFacetRequest
type CreateFacetInput struct {
	_ struct{} `type:"structure"`

	// The attributes that are associated with the Facet.
	Attributes []FacetAttribute `type:"list"`

	// The name of the Facet, which is unique for a given schema.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// Specifies whether a given object created from this facet is of type node,
	// leaf node, policy or index.
	//
	//    * Node: Can have multiple children but one parent.
	//
	//    * Leaf node: Cannot have children but can have multiple parents.
	//
	//    * Policy: Allows you to store a policy document and policy type. For more
	//    information, see Policies (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#policies).
	//
	//    * Index: Can be created with the Index API.
	//
	// ObjectType is a required field
	ObjectType ObjectType `type:"string" required:"true" enum:"true"`

	// The schema ARN in which the new Facet will be created. For more information,
	// see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateFacetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFacetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateFacetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateFacetInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if len(s.ObjectType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ObjectType"))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}
	if s.Attributes != nil {
		for i, v := range s.Attributes {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Attributes", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateFacetInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ObjectType) > 0 {
		v := s.ObjectType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateFacetResponse
type CreateFacetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateFacetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFacetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateFacetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateFacetOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateIndexRequest
type CreateIndexInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the directory where the index should be created.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Indicates whether the attribute that is being indexed has unique values or
	// not.
	//
	// IsUnique is a required field
	IsUnique *bool `type:"boolean" required:"true"`

	// The name of the link between the parent object and the index object.
	LinkName *string `min:"1" type:"string"`

	// Specifies the attributes that should be indexed on. Currently only a single
	// attribute is supported.
	//
	// OrderedIndexedAttributeList is a required field
	OrderedIndexedAttributeList []AttributeKey `type:"list" required:"true"`

	// A reference to the parent object that contains the index object.
	ParentReference *ObjectReference `type:"structure"`
}

// String returns the string representation
func (s CreateIndexInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateIndexInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateIndexInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateIndexInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.IsUnique == nil {
		invalidParams.Add(aws.NewErrParamRequired("IsUnique"))
	}
	if s.LinkName != nil && len(*s.LinkName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LinkName", 1))
	}

	if s.OrderedIndexedAttributeList == nil {
		invalidParams.Add(aws.NewErrParamRequired("OrderedIndexedAttributeList"))
	}
	if s.OrderedIndexedAttributeList != nil {
		for i, v := range s.OrderedIndexedAttributeList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "OrderedIndexedAttributeList", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateIndexInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.IsUnique != nil {
		v := *s.IsUnique

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsUnique", protocol.BoolValue(v), metadata)
	}
	if s.LinkName != nil {
		v := *s.LinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.OrderedIndexedAttributeList) > 0 {
		v := s.OrderedIndexedAttributeList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "OrderedIndexedAttributeList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ParentReference != nil {
		v := s.ParentReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ParentReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateIndexResponse
type CreateIndexOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ObjectIdentifier of the index created by this operation.
	ObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s CreateIndexOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateIndexOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateIndexOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateIndexOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateObjectRequest
type CreateObjectInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory in which
	// the object will be created. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The name of link that is used to attach this object to a parent.
	LinkName *string `min:"1" type:"string"`

	// The attribute map whose attribute ARN contains the key and attribute value
	// as the map value.
	ObjectAttributeList []AttributeKeyAndValue `type:"list"`

	// If specified, the parent reference to which this object will be attached.
	ParentReference *ObjectReference `type:"structure"`

	// A list of schema facets to be associated with the object. Do not provide
	// minor version components. See SchemaFacet for details.
	//
	// SchemaFacets is a required field
	SchemaFacets []SchemaFacet `type:"list" required:"true"`
}

// String returns the string representation
func (s CreateObjectInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateObjectInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateObjectInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateObjectInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.LinkName != nil && len(*s.LinkName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LinkName", 1))
	}

	if s.SchemaFacets == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaFacets"))
	}
	if s.ObjectAttributeList != nil {
		for i, v := range s.ObjectAttributeList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ObjectAttributeList", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.SchemaFacets != nil {
		for i, v := range s.SchemaFacets {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "SchemaFacets", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateObjectInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.LinkName != nil {
		v := *s.LinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ObjectAttributeList) > 0 {
		v := s.ObjectAttributeList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ObjectAttributeList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ParentReference != nil {
		v := s.ParentReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ParentReference", v, metadata)
	}
	if len(s.SchemaFacets) > 0 {
		v := s.SchemaFacets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SchemaFacets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateObjectResponse
type CreateObjectOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The identifier that is associated with the object.
	ObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s CreateObjectOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateObjectOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateObjectOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateObjectOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateSchemaRequest
type CreateSchemaInput struct {
	_ struct{} `type:"structure"`

	// The name that is associated with the schema. This is unique to each account
	// and in each region.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateSchemaInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateSchemaInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateSchemaInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateSchemaInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateSchemaInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateSchemaResponse
type CreateSchemaOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) that is associated with the schema. For more
	// information, see arns.
	SchemaArn *string `type:"string"`
}

// String returns the string representation
func (s CreateSchemaOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateSchemaOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateSchemaOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateSchemaOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateTypedLinkFacetRequest
type CreateTypedLinkFacetInput struct {
	_ struct{} `type:"structure"`

	// Facet structure that is associated with the typed link facet.
	//
	// Facet is a required field
	Facet *TypedLinkFacet `type:"structure" required:"true"`

	// The Amazon Resource Name (ARN) that is associated with the schema. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateTypedLinkFacetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTypedLinkFacetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTypedLinkFacetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTypedLinkFacetInput"}

	if s.Facet == nil {
		invalidParams.Add(aws.NewErrParamRequired("Facet"))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}
	if s.Facet != nil {
		if err := s.Facet.Validate(); err != nil {
			invalidParams.AddNested("Facet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTypedLinkFacetInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Facet != nil {
		v := s.Facet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Facet", v, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/CreateTypedLinkFacetResponse
type CreateTypedLinkFacetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateTypedLinkFacetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTypedLinkFacetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTypedLinkFacetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTypedLinkFacetOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteDirectoryRequest
type DeleteDirectoryInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the directory to delete.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDirectoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDirectoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteDirectoryInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteDirectoryInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDirectoryInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteDirectoryResponse
type DeleteDirectoryOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the deleted directory.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDirectoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDirectoryOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteDirectoryOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDirectoryOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteFacetRequest
type DeleteFacetInput struct {
	_ struct{} `type:"structure"`

	// The name of the facet to delete.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Facet. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteFacetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFacetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteFacetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteFacetInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteFacetInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteFacetResponse
type DeleteFacetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteFacetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFacetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteFacetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteFacetOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteObjectRequest
type DeleteObjectInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// the object resides. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// A reference that identifies the object.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s DeleteObjectInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteObjectInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteObjectInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteObjectInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteObjectInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteObjectResponse
type DeleteObjectOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteObjectOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteObjectOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteObjectOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteObjectOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteSchemaRequest
type DeleteSchemaInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the development schema. For more information,
	// see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteSchemaInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSchemaInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteSchemaInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteSchemaInput"}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteSchemaInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteSchemaResponse
type DeleteSchemaOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The input ARN that is returned as part of the response. For more information,
	// see arns.
	SchemaArn *string `type:"string"`
}

// String returns the string representation
func (s DeleteSchemaOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSchemaOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteSchemaOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteSchemaOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteTypedLinkFacetRequest
type DeleteTypedLinkFacetInput struct {
	_ struct{} `type:"structure"`

	// The unique name of the typed link facet.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The Amazon Resource Name (ARN) that is associated with the schema. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteTypedLinkFacetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTypedLinkFacetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTypedLinkFacetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTypedLinkFacetInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTypedLinkFacetInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DeleteTypedLinkFacetResponse
type DeleteTypedLinkFacetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteTypedLinkFacetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTypedLinkFacetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTypedLinkFacetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTypedLinkFacetOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachFromIndexRequest
type DetachFromIndexInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the directory the index and object exist
	// in.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// A reference to the index object.
	//
	// IndexReference is a required field
	IndexReference *ObjectReference `type:"structure" required:"true"`

	// A reference to the object being detached from the index.
	//
	// TargetReference is a required field
	TargetReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s DetachFromIndexInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachFromIndexInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DetachFromIndexInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DetachFromIndexInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.IndexReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexReference"))
	}

	if s.TargetReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachFromIndexInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.IndexReference != nil {
		v := s.IndexReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "IndexReference", v, metadata)
	}
	if s.TargetReference != nil {
		v := s.TargetReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachFromIndexResponse
type DetachFromIndexOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ObjectIdentifier of the object that was detached from the index.
	DetachedObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s DetachFromIndexOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachFromIndexOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DetachFromIndexOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachFromIndexOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DetachedObjectIdentifier != nil {
		v := *s.DetachedObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DetachedObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachObjectRequest
type DetachObjectInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// objects reside. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The link name associated with the object that needs to be detached.
	//
	// LinkName is a required field
	LinkName *string `min:"1" type:"string" required:"true"`

	// The parent reference from which the object with the specified link name is
	// detached.
	//
	// ParentReference is a required field
	ParentReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s DetachObjectInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachObjectInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DetachObjectInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DetachObjectInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.LinkName == nil {
		invalidParams.Add(aws.NewErrParamRequired("LinkName"))
	}
	if s.LinkName != nil && len(*s.LinkName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LinkName", 1))
	}

	if s.ParentReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ParentReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachObjectInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.LinkName != nil {
		v := *s.LinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentReference != nil {
		v := s.ParentReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ParentReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachObjectResponse
type DetachObjectOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ObjectIdentifier that was detached from the object.
	DetachedObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s DetachObjectOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachObjectOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DetachObjectOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachObjectOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DetachedObjectIdentifier != nil {
		v := *s.DetachedObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DetachedObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachPolicyRequest
type DetachPolicyInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// both objects reside. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Reference that identifies the object whose policy object will be detached.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// Reference that identifies the policy object.
	//
	// PolicyReference is a required field
	PolicyReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s DetachPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DetachPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DetachPolicyInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.PolicyReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.PolicyReference != nil {
		v := s.PolicyReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "PolicyReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachPolicyResponse
type DetachPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DetachPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DetachPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachTypedLinkRequest
type DetachTypedLinkInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the directory where you want to detach
	// the typed link.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Used to accept a typed link specifier as input.
	//
	// TypedLinkSpecifier is a required field
	TypedLinkSpecifier *TypedLinkSpecifier `type:"structure" required:"true"`
}

// String returns the string representation
func (s DetachTypedLinkInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachTypedLinkInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DetachTypedLinkInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DetachTypedLinkInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.TypedLinkSpecifier == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypedLinkSpecifier"))
	}
	if s.TypedLinkSpecifier != nil {
		if err := s.TypedLinkSpecifier.Validate(); err != nil {
			invalidParams.AddNested("TypedLinkSpecifier", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachTypedLinkInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.TypedLinkSpecifier != nil {
		v := s.TypedLinkSpecifier

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TypedLinkSpecifier", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DetachTypedLinkOutput
type DetachTypedLinkOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DetachTypedLinkOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DetachTypedLinkOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DetachTypedLinkOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DetachTypedLinkOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Directory structure that includes the directory name and directory ARN.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/Directory
type Directory struct {
	_ struct{} `type:"structure"`

	// The date and time when the directory was created.
	CreationDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The Amazon Resource Name (ARN) that is associated with the directory. For
	// more information, see arns.
	DirectoryArn *string `type:"string"`

	// The name of the directory.
	Name *string `min:"1" type:"string"`

	// The state of the directory. Can be either Enabled, Disabled, or Deleted.
	State DirectoryState `type:"string" enum:"true"`
}

// String returns the string representation
func (s Directory) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Directory) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Directory) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDateTime != nil {
		v := *s.CreationDateTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDateTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DisableDirectoryRequest
type DisableDirectoryInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the directory to disable.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s DisableDirectoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DisableDirectoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DisableDirectoryInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DisableDirectoryInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DisableDirectoryInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/DisableDirectoryResponse
type DisableDirectoryOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the directory that has been disabled.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DisableDirectoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DisableDirectoryOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DisableDirectoryOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DisableDirectoryOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/EnableDirectoryRequest
type EnableDirectoryInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the directory to enable.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s EnableDirectoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EnableDirectoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *EnableDirectoryInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "EnableDirectoryInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EnableDirectoryInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/EnableDirectoryResponse
type EnableDirectoryOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the enabled directory.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s EnableDirectoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EnableDirectoryOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s EnableDirectoryOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EnableDirectoryOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A structure that contains Name, ARN, Attributes, Rules, and ObjectTypes.
// See Facets (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/whatarefacets.html)
// for more information.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/Facet
type Facet struct {
	_ struct{} `type:"structure"`

	// The name of the Facet.
	Name *string `min:"1" type:"string"`

	// The object type that is associated with the facet. See CreateFacetRequest$ObjectType
	// for more details.
	ObjectType ObjectType `type:"string" enum:"true"`
}

// String returns the string representation
func (s Facet) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Facet) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Facet) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ObjectType) > 0 {
		v := s.ObjectType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// An attribute that is associated with the Facet.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/FacetAttribute
type FacetAttribute struct {
	_ struct{} `type:"structure"`

	// A facet attribute consists of either a definition or a reference. This structure
	// contains the attribute definition. See Attribute References (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_advanced.html#attributereferences)
	// for more information.
	AttributeDefinition *FacetAttributeDefinition `type:"structure"`

	// An attribute reference that is associated with the attribute. See Attribute
	// References (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_advanced.html#attributereferences)
	// for more information.
	AttributeReference *FacetAttributeReference `type:"structure"`

	// The name of the facet attribute.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The required behavior of the FacetAttribute.
	RequiredBehavior RequiredAttributeBehavior `type:"string" enum:"true"`
}

// String returns the string representation
func (s FacetAttribute) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FacetAttribute) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FacetAttribute) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FacetAttribute"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.AttributeDefinition != nil {
		if err := s.AttributeDefinition.Validate(); err != nil {
			invalidParams.AddNested("AttributeDefinition", err.(aws.ErrInvalidParams))
		}
	}
	if s.AttributeReference != nil {
		if err := s.AttributeReference.Validate(); err != nil {
			invalidParams.AddNested("AttributeReference", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FacetAttribute) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttributeDefinition != nil {
		v := s.AttributeDefinition

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttributeDefinition", v, metadata)
	}
	if s.AttributeReference != nil {
		v := s.AttributeReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttributeReference", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RequiredBehavior) > 0 {
		v := s.RequiredBehavior

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RequiredBehavior", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// A facet attribute definition. See Attribute References (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_advanced.html#attributereferences)
// for more information.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/FacetAttributeDefinition
type FacetAttributeDefinition struct {
	_ struct{} `type:"structure"`

	// The default value of the attribute (if configured).
	DefaultValue *TypedAttributeValue `type:"structure"`

	// Whether the attribute is mutable or not.
	IsImmutable *bool `type:"boolean"`

	// Validation rules attached to the attribute definition.
	Rules map[string]Rule `type:"map"`

	// The type of the attribute.
	//
	// Type is a required field
	Type FacetAttributeType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s FacetAttributeDefinition) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FacetAttributeDefinition) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FacetAttributeDefinition) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FacetAttributeDefinition"}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FacetAttributeDefinition) MarshalFields(e protocol.FieldEncoder) error {
	if s.DefaultValue != nil {
		v := s.DefaultValue

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DefaultValue", v, metadata)
	}
	if s.IsImmutable != nil {
		v := *s.IsImmutable

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsImmutable", protocol.BoolValue(v), metadata)
	}
	if len(s.Rules) > 0 {
		v := s.Rules

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Rules", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The facet attribute reference that specifies the attribute definition that
// contains the attribute facet name and attribute name.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/FacetAttributeReference
type FacetAttributeReference struct {
	_ struct{} `type:"structure"`

	// The target attribute name that is associated with the facet reference. See
	// Attribute References (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_advanced.html#attributereferences)
	// for more information.
	//
	// TargetAttributeName is a required field
	TargetAttributeName *string `min:"1" type:"string" required:"true"`

	// The target facet name that is associated with the facet reference. See Attribute
	// References (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_advanced.html#attributereferences)
	// for more information.
	//
	// TargetFacetName is a required field
	TargetFacetName *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s FacetAttributeReference) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FacetAttributeReference) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FacetAttributeReference) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FacetAttributeReference"}

	if s.TargetAttributeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetAttributeName"))
	}
	if s.TargetAttributeName != nil && len(*s.TargetAttributeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TargetAttributeName", 1))
	}

	if s.TargetFacetName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetFacetName"))
	}
	if s.TargetFacetName != nil && len(*s.TargetFacetName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TargetFacetName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FacetAttributeReference) MarshalFields(e protocol.FieldEncoder) error {
	if s.TargetAttributeName != nil {
		v := *s.TargetAttributeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetAttributeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TargetFacetName != nil {
		v := *s.TargetFacetName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetFacetName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A structure that contains information used to update an attribute.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/FacetAttributeUpdate
type FacetAttributeUpdate struct {
	_ struct{} `type:"structure"`

	// The action to perform when updating the attribute.
	Action UpdateActionType `type:"string" enum:"true"`

	// The attribute to update.
	Attribute *FacetAttribute `type:"structure"`
}

// String returns the string representation
func (s FacetAttributeUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FacetAttributeUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FacetAttributeUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FacetAttributeUpdate"}
	if s.Attribute != nil {
		if err := s.Attribute.Validate(); err != nil {
			invalidParams.AddNested("Attribute", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FacetAttributeUpdate) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Action) > 0 {
		v := s.Action

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Action", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Attribute != nil {
		v := s.Attribute

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Attribute", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetAppliedSchemaVersionRequest
type GetAppliedSchemaVersionInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the applied schema.
	//
	// SchemaArn is a required field
	SchemaArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s GetAppliedSchemaVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetAppliedSchemaVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetAppliedSchemaVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetAppliedSchemaVersionInput"}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetAppliedSchemaVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetAppliedSchemaVersionResponse
type GetAppliedSchemaVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Current applied schema ARN, including the minor version in use if one was
	// provided.
	AppliedSchemaArn *string `type:"string"`
}

// String returns the string representation
func (s GetAppliedSchemaVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetAppliedSchemaVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetAppliedSchemaVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetAppliedSchemaVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AppliedSchemaArn != nil {
		v := *s.AppliedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AppliedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetDirectoryRequest
type GetDirectoryInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the directory.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDirectoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDirectoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDirectoryInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDirectoryInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDirectoryInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetDirectoryResponse
type GetDirectoryOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Metadata about the directory.
	//
	// Directory is a required field
	Directory *Directory `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetDirectoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDirectoryOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDirectoryOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDirectoryOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Directory != nil {
		v := s.Directory

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Directory", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetFacetRequest
type GetFacetInput struct {
	_ struct{} `type:"structure"`

	// The name of the facet to retrieve.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Facet. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s GetFacetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFacetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetFacetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetFacetInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetFacetInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetFacetResponse
type GetFacetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Facet structure that is associated with the facet.
	Facet *Facet `type:"structure"`
}

// String returns the string representation
func (s GetFacetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFacetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetFacetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetFacetOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Facet != nil {
		v := s.Facet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Facet", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetObjectAttributesRequest
type GetObjectAttributesInput struct {
	_ struct{} `type:"structure"`

	// List of attribute names whose values will be retrieved.
	//
	// AttributeNames is a required field
	AttributeNames []string `type:"list" required:"true"`

	// The consistency level at which to retrieve the attributes on an object.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// the object resides.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Reference that identifies the object whose attributes will be retrieved.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifier for the facet whose attributes will be retrieved. See SchemaFacet
	// for details.
	//
	// SchemaFacet is a required field
	SchemaFacet *SchemaFacet `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetObjectAttributesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetObjectAttributesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetObjectAttributesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetObjectAttributesInput"}

	if s.AttributeNames == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeNames"))
	}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.SchemaFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaFacet"))
	}
	if s.SchemaFacet != nil {
		if err := s.SchemaFacet.Validate(); err != nil {
			invalidParams.AddNested("SchemaFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetObjectAttributesInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.AttributeNames) > 0 {
		v := s.AttributeNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AttributeNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.SchemaFacet != nil {
		v := s.SchemaFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SchemaFacet", v, metadata)
	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetObjectAttributesResponse
type GetObjectAttributesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The attributes that are associated with the object.
	Attributes []AttributeKeyAndValue `type:"list"`
}

// String returns the string representation
func (s GetObjectAttributesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetObjectAttributesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetObjectAttributesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetObjectAttributesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetObjectInformationRequest
type GetObjectInformationInput struct {
	_ struct{} `type:"structure"`

	// The consistency level at which to retrieve the object information.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The ARN of the directory being retrieved.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// A reference to the object.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetObjectInformationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetObjectInformationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetObjectInformationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetObjectInformationInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetObjectInformationInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetObjectInformationResponse
type GetObjectInformationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ObjectIdentifier of the specified object.
	ObjectIdentifier *string `type:"string"`

	// The facets attached to the specified object. Although the response does not
	// include minor version information, the most recently applied minor version
	// of each Facet is in effect. See GetAppliedSchemaVersion for details.
	SchemaFacets []SchemaFacet `type:"list"`
}

// String returns the string representation
func (s GetObjectInformationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetObjectInformationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetObjectInformationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetObjectInformationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SchemaFacets) > 0 {
		v := s.SchemaFacets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SchemaFacets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetSchemaAsJsonRequest
type GetSchemaAsJsonInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the schema to retrieve.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s GetSchemaAsJsonInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSchemaAsJsonInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSchemaAsJsonInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSchemaAsJsonInput"}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSchemaAsJsonInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetSchemaAsJsonResponse
type GetSchemaAsJsonOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The JSON representation of the schema document.
	Document *string `type:"string"`

	// The name of the retrieved schema.
	Name *string `min:"1" type:"string"`
}

// String returns the string representation
func (s GetSchemaAsJsonOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSchemaAsJsonOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSchemaAsJsonOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSchemaAsJsonOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Document != nil {
		v := *s.Document

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Document", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetTypedLinkFacetInformationRequest
type GetTypedLinkFacetInformationInput struct {
	_ struct{} `type:"structure"`

	// The unique name of the typed link facet.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The Amazon Resource Name (ARN) that is associated with the schema. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s GetTypedLinkFacetInformationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTypedLinkFacetInformationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTypedLinkFacetInformationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTypedLinkFacetInformationInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTypedLinkFacetInformationInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/GetTypedLinkFacetInformationResponse
type GetTypedLinkFacetInformationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The order of identity attributes for the facet, from most significant to
	// least significant. The ability to filter typed links considers the order
	// that the attributes are defined on the typed link facet. When providing ranges
	// to typed link selection, any inexact ranges must be specified at the end.
	// Any attributes that do not have a range specified are presumed to match the
	// entire range. Filters are interpreted in the order of the attributes on the
	// typed link facet, not the order in which they are supplied to any API calls.
	// For more information about identity attributes, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	IdentityAttributeOrder []string `type:"list"`
}

// String returns the string representation
func (s GetTypedLinkFacetInformationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTypedLinkFacetInformationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTypedLinkFacetInformationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTypedLinkFacetInformationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IdentityAttributeOrder) > 0 {
		v := s.IdentityAttributeOrder

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IdentityAttributeOrder", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Represents an index and an attached object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/IndexAttachment
type IndexAttachment struct {
	_ struct{} `type:"structure"`

	// The indexed attribute values.
	IndexedAttributes []AttributeKeyAndValue `type:"list"`

	// In response to ListIndex, the ObjectIdentifier of the object attached to
	// the index. In response to ListAttachedIndices, the ObjectIdentifier of the
	// index attached to the object. This field will always contain the ObjectIdentifier
	// of the object on the opposite side of the attachment specified in the query.
	ObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s IndexAttachment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s IndexAttachment) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s IndexAttachment) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IndexedAttributes) > 0 {
		v := s.IndexedAttributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IndexedAttributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListAppliedSchemaArnsRequest
type ListAppliedSchemaArnsInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the directory you are listing.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `type:"string" required:"true"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The response for ListAppliedSchemaArns when this parameter is used will list
	// all minor version ARNs for a major version.
	SchemaArn *string `type:"string"`
}

// String returns the string representation
func (s ListAppliedSchemaArnsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAppliedSchemaArnsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListAppliedSchemaArnsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListAppliedSchemaArnsInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListAppliedSchemaArnsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListAppliedSchemaArnsResponse
type ListAppliedSchemaArnsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token.
	NextToken *string `type:"string"`

	// The ARNs of schemas that are applied to the directory.
	SchemaArns []string `type:"list"`
}

// String returns the string representation
func (s ListAppliedSchemaArnsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAppliedSchemaArnsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListAppliedSchemaArnsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListAppliedSchemaArnsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SchemaArns) > 0 {
		v := s.SchemaArns

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SchemaArns", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListAttachedIndicesRequest
type ListAttachedIndicesInput struct {
	_ struct{} `type:"structure"`

	// The consistency level to use for this operation.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The ARN of the directory.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// A reference to the object that has indices attached.
	//
	// TargetReference is a required field
	TargetReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListAttachedIndicesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAttachedIndicesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListAttachedIndicesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListAttachedIndicesInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.TargetReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListAttachedIndicesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TargetReference != nil {
		v := s.TargetReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetReference", v, metadata)
	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListAttachedIndicesResponse
type ListAttachedIndicesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The indices attached to the specified object.
	IndexAttachments []IndexAttachment `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListAttachedIndicesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAttachedIndicesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListAttachedIndicesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListAttachedIndicesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IndexAttachments) > 0 {
		v := s.IndexAttachments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IndexAttachments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListDevelopmentSchemaArnsRequest
type ListDevelopmentSchemaArnsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListDevelopmentSchemaArnsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListDevelopmentSchemaArnsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListDevelopmentSchemaArnsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListDevelopmentSchemaArnsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListDevelopmentSchemaArnsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListDevelopmentSchemaArnsResponse
type ListDevelopmentSchemaArnsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token.
	NextToken *string `type:"string"`

	// The ARNs of retrieved development schemas.
	SchemaArns []string `type:"list"`
}

// String returns the string representation
func (s ListDevelopmentSchemaArnsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListDevelopmentSchemaArnsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListDevelopmentSchemaArnsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListDevelopmentSchemaArnsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SchemaArns) > 0 {
		v := s.SchemaArns

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SchemaArns", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListDirectoriesRequest
type ListDirectoriesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The state of the directories in the list. Can be either Enabled, Disabled,
	// or Deleted.
	State DirectoryState `locationName:"state" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListDirectoriesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListDirectoriesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListDirectoriesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListDirectoriesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListDirectoriesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "state", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListDirectoriesResponse
type ListDirectoriesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Lists all directories that are associated with your account in pagination
	// fashion.
	//
	// Directories is a required field
	Directories []Directory `type:"list" required:"true"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListDirectoriesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListDirectoriesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListDirectoriesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListDirectoriesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Directories) > 0 {
		v := s.Directories

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Directories", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListFacetAttributesRequest
type ListFacetAttributesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The name of the facet whose attributes will be retrieved.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The ARN of the schema where the facet resides.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s ListFacetAttributesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListFacetAttributesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListFacetAttributesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListFacetAttributesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListFacetAttributesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListFacetAttributesResponse
type ListFacetAttributesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The attributes attached to the facet.
	Attributes []FacetAttribute `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListFacetAttributesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListFacetAttributesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListFacetAttributesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListFacetAttributesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListFacetNamesRequest
type ListFacetNamesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The Amazon Resource Name (ARN) to retrieve facet names from.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s ListFacetNamesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListFacetNamesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListFacetNamesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListFacetNamesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListFacetNamesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListFacetNamesResponse
type ListFacetNamesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The names of facets that exist within the schema.
	FacetNames []string `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListFacetNamesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListFacetNamesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListFacetNamesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListFacetNamesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.FacetNames) > 0 {
		v := s.FacetNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FacetNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListIncomingTypedLinksRequest
type ListIncomingTypedLinksInput struct {
	_ struct{} `type:"structure"`

	// The consistency level to execute the request at.
	ConsistencyLevel ConsistencyLevel `type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) of the directory where you want to list the
	// typed links.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Provides range filters for multiple attributes. When providing ranges to
	// typed link selection, any inexact ranges must be specified at the end. Any
	// attributes that do not have a range specified are presumed to match the entire
	// range.
	FilterAttributeRanges []TypedLinkAttributeRange `type:"list"`

	// Filters are interpreted in the order of the attributes on the typed link
	// facet, not the order in which they are supplied to any API calls.
	FilterTypedLink *TypedLinkSchemaAndFacetName `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Reference that identifies the object whose attributes will be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListIncomingTypedLinksInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListIncomingTypedLinksInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListIncomingTypedLinksInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListIncomingTypedLinksInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}
	if s.FilterAttributeRanges != nil {
		for i, v := range s.FilterAttributeRanges {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "FilterAttributeRanges", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.FilterTypedLink != nil {
		if err := s.FilterTypedLink.Validate(); err != nil {
			invalidParams.AddNested("FilterTypedLink", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListIncomingTypedLinksInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ConsistencyLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.FilterAttributeRanges) > 0 {
		v := s.FilterAttributeRanges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FilterAttributeRanges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.FilterTypedLink != nil {
		v := s.FilterTypedLink

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FilterTypedLink", v, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListIncomingTypedLinksResponse
type ListIncomingTypedLinksOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Returns one or more typed link specifiers as output.
	LinkSpecifiers []TypedLinkSpecifier `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListIncomingTypedLinksOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListIncomingTypedLinksOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListIncomingTypedLinksOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListIncomingTypedLinksOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.LinkSpecifiers) > 0 {
		v := s.LinkSpecifiers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "LinkSpecifiers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListIndexRequest
type ListIndexInput struct {
	_ struct{} `type:"structure"`

	// The consistency level to execute the request at.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The ARN of the directory that the index exists in.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The reference to the index to list.
	//
	// IndexReference is a required field
	IndexReference *ObjectReference `type:"structure" required:"true"`

	// The maximum number of objects in a single page to retrieve from the index
	// during a request. For more information, see AWS Directory Service Limits
	// (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/limits.html#limits_cd).
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Specifies the ranges of indexed values that you want to query.
	RangesOnIndexedValues []ObjectAttributeRange `type:"list"`
}

// String returns the string representation
func (s ListIndexInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListIndexInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListIndexInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListIndexInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.IndexReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexReference"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}
	if s.RangesOnIndexedValues != nil {
		for i, v := range s.RangesOnIndexedValues {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "RangesOnIndexedValues", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListIndexInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.IndexReference != nil {
		v := s.IndexReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "IndexReference", v, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RangesOnIndexedValues) > 0 {
		v := s.RangesOnIndexedValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RangesOnIndexedValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListIndexResponse
type ListIndexOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The objects and indexed values attached to the index.
	IndexAttachments []IndexAttachment `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListIndexOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListIndexOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListIndexOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListIndexOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IndexAttachments) > 0 {
		v := s.IndexAttachments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IndexAttachments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectAttributesRequest
type ListObjectAttributesInput struct {
	_ struct{} `type:"structure"`

	// Represents the manner and timing in which the successful write or update
	// of an object is reflected in a subsequent read operation of that same object.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// the object resides. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Used to filter the list of object attributes that are associated with a certain
	// facet.
	FacetFilter *SchemaFacet `type:"structure"`

	// The maximum number of items to be retrieved in a single call. This is an
	// approximate number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the object whose attributes will be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListObjectAttributesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectAttributesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListObjectAttributesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListObjectAttributesInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}
	if s.FacetFilter != nil {
		if err := s.FacetFilter.Validate(); err != nil {
			invalidParams.AddNested("FacetFilter", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectAttributesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.FacetFilter != nil {
		v := s.FacetFilter

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FacetFilter", v, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectAttributesResponse
type ListObjectAttributesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Attributes map that is associated with the object. AttributeArn is the key,
	// and attribute value is the value.
	Attributes []AttributeKeyAndValue `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListObjectAttributesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectAttributesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListObjectAttributesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectAttributesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectChildrenRequest
type ListObjectChildrenInput struct {
	_ struct{} `type:"structure"`

	// Represents the manner and timing in which the successful write or update
	// of an object is reflected in a subsequent read operation of that same object.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// the object resides. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The maximum number of items to be retrieved in a single call. This is an
	// approximate number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the object for which child objects are being
	// listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListObjectChildrenInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectChildrenInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListObjectChildrenInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListObjectChildrenInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectChildrenInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectChildrenResponse
type ListObjectChildrenOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Children structure, which is a map with key as the LinkName and ObjectIdentifier
	// as the value.
	Children map[string]string `type:"map"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListObjectChildrenOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectChildrenOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListObjectChildrenOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectChildrenOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Children) > 0 {
		v := s.Children

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Children", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectParentPathsRequest
type ListObjectParentPathsInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the directory to which the parent path applies.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The maximum number of items to be retrieved in a single call. This is an
	// approximate number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the object whose parent paths are listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListObjectParentPathsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectParentPathsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListObjectParentPathsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListObjectParentPathsInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectParentPathsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectParentPathsResponse
type ListObjectParentPathsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token.
	NextToken *string `type:"string"`

	// Returns the path to the ObjectIdentifiers that are associated with the directory.
	PathToObjectIdentifiersList []PathToObjectIdentifiers `type:"list"`
}

// String returns the string representation
func (s ListObjectParentPathsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectParentPathsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListObjectParentPathsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectParentPathsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PathToObjectIdentifiersList) > 0 {
		v := s.PathToObjectIdentifiersList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "PathToObjectIdentifiersList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectParentsRequest
type ListObjectParentsInput struct {
	_ struct{} `type:"structure"`

	// Represents the manner and timing in which the successful write or update
	// of an object is reflected in a subsequent read operation of that same object.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// the object resides. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The maximum number of items to be retrieved in a single call. This is an
	// approximate number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the object for which parent objects are being
	// listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListObjectParentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectParentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListObjectParentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListObjectParentsInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectParentsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectParentsResponse
type ListObjectParentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token.
	NextToken *string `type:"string"`

	// The parent structure, which is a map with key as the ObjectIdentifier and
	// LinkName as the value.
	Parents map[string]string `type:"map"`
}

// String returns the string representation
func (s ListObjectParentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectParentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListObjectParentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectParentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Parents) > 0 {
		v := s.Parents

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Parents", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectPoliciesRequest
type ListObjectPoliciesInput struct {
	_ struct{} `type:"structure"`

	// Represents the manner and timing in which the successful write or update
	// of an object is reflected in a subsequent read operation of that same object.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// objects reside. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The maximum number of items to be retrieved in a single call. This is an
	// approximate number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// Reference that identifies the object for which policies will be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListObjectPoliciesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectPoliciesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListObjectPoliciesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListObjectPoliciesInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectPoliciesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListObjectPoliciesResponse
type ListObjectPoliciesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of policy ObjectIdentifiers, that are attached to the object.
	AttachedPolicyIds []string `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListObjectPoliciesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListObjectPoliciesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListObjectPoliciesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListObjectPoliciesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AttachedPolicyIds) > 0 {
		v := s.AttachedPolicyIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AttachedPolicyIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListOutgoingTypedLinksRequest
type ListOutgoingTypedLinksInput struct {
	_ struct{} `type:"structure"`

	// The consistency level to execute the request at.
	ConsistencyLevel ConsistencyLevel `type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) of the directory where you want to list the
	// typed links.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// Provides range filters for multiple attributes. When providing ranges to
	// typed link selection, any inexact ranges must be specified at the end. Any
	// attributes that do not have a range specified are presumed to match the entire
	// range.
	FilterAttributeRanges []TypedLinkAttributeRange `type:"list"`

	// Filters are interpreted in the order of the attributes defined on the typed
	// link facet, not the order they are supplied to any API calls.
	FilterTypedLink *TypedLinkSchemaAndFacetName `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// A reference that identifies the object whose attributes will be listed.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListOutgoingTypedLinksInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListOutgoingTypedLinksInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListOutgoingTypedLinksInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListOutgoingTypedLinksInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}
	if s.FilterAttributeRanges != nil {
		for i, v := range s.FilterAttributeRanges {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "FilterAttributeRanges", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.FilterTypedLink != nil {
		if err := s.FilterTypedLink.Validate(); err != nil {
			invalidParams.AddNested("FilterTypedLink", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListOutgoingTypedLinksInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ConsistencyLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.FilterAttributeRanges) > 0 {
		v := s.FilterAttributeRanges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FilterAttributeRanges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.FilterTypedLink != nil {
		v := s.FilterTypedLink

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FilterTypedLink", v, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListOutgoingTypedLinksResponse
type ListOutgoingTypedLinksOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token.
	NextToken *string `type:"string"`

	// Returns a typed link specifier as output.
	TypedLinkSpecifiers []TypedLinkSpecifier `type:"list"`
}

// String returns the string representation
func (s ListOutgoingTypedLinksOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListOutgoingTypedLinksOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListOutgoingTypedLinksOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListOutgoingTypedLinksOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TypedLinkSpecifiers) > 0 {
		v := s.TypedLinkSpecifiers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TypedLinkSpecifiers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListPolicyAttachmentsRequest
type ListPolicyAttachmentsInput struct {
	_ struct{} `type:"structure"`

	// Represents the manner and timing in which the successful write or update
	// of an object is reflected in a subsequent read operation of that same object.
	ConsistencyLevel ConsistencyLevel `location:"header" locationName:"x-amz-consistency-level" type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// objects reside. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The maximum number of items to be retrieved in a single call. This is an
	// approximate number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The reference that identifies the policy object.
	//
	// PolicyReference is a required field
	PolicyReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListPolicyAttachmentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPolicyAttachmentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPolicyAttachmentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListPolicyAttachmentsInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.PolicyReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("PolicyReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPolicyAttachmentsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyReference != nil {
		v := s.PolicyReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "PolicyReference", v, metadata)
	}
	if len(s.ConsistencyLevel) > 0 {
		v := s.ConsistencyLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-consistency-level", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListPolicyAttachmentsResponse
type ListPolicyAttachmentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token.
	NextToken *string `type:"string"`

	// A list of ObjectIdentifiers to which the policy is attached.
	ObjectIdentifiers []string `type:"list"`
}

// String returns the string representation
func (s ListPolicyAttachmentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPolicyAttachmentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListPolicyAttachmentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPolicyAttachmentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ObjectIdentifiers) > 0 {
		v := s.ObjectIdentifiers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ObjectIdentifiers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListPublishedSchemaArnsRequest
type ListPublishedSchemaArnsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The response for ListPublishedSchemaArns when this parameter is used will
	// list all minor version ARNs for a major version.
	SchemaArn *string `type:"string"`
}

// String returns the string representation
func (s ListPublishedSchemaArnsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPublishedSchemaArnsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPublishedSchemaArnsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListPublishedSchemaArnsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPublishedSchemaArnsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListPublishedSchemaArnsResponse
type ListPublishedSchemaArnsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token.
	NextToken *string `type:"string"`

	// The ARNs of published schemas.
	SchemaArns []string `type:"list"`
}

// String returns the string representation
func (s ListPublishedSchemaArnsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPublishedSchemaArnsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListPublishedSchemaArnsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListPublishedSchemaArnsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SchemaArns) > 0 {
		v := s.SchemaArns

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SchemaArns", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTagsForResourceRequest
type ListTagsForResourceInput struct {
	_ struct{} `type:"structure"`

	// The MaxResults parameter sets the maximum number of results returned in a
	// single page. This is for future use and is not supported currently.
	MaxResults *int64 `min:"50" type:"integer"`

	// The pagination token. This is for future use. Currently pagination is not
	// supported for tagging.
	NextToken *string `type:"string"`

	// The Amazon Resource Name (ARN) of the resource. Tagging is only supported
	// for directories.
	//
	// ResourceArn is a required field
	ResourceArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s ListTagsForResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsForResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTagsForResourceInput"}
	if s.MaxResults != nil && *s.MaxResults < 50 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 50))
	}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsForResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTagsForResourceResponse
type ListTagsForResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The token to use to retrieve the next page of results. This value is null
	// when there are no more results to return.
	NextToken *string `type:"string"`

	// A list of tag key value pairs that are associated with the response.
	Tags []Tag `type:"list"`
}

// String returns the string representation
func (s ListTagsForResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTagsForResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsForResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Tags", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTypedLinkFacetAttributesRequest
type ListTypedLinkFacetAttributesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The unique name of the typed link facet.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The Amazon Resource Name (ARN) that is associated with the schema. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTypedLinkFacetAttributesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTypedLinkFacetAttributesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTypedLinkFacetAttributesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTypedLinkFacetAttributesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTypedLinkFacetAttributesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTypedLinkFacetAttributesResponse
type ListTypedLinkFacetAttributesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An ordered set of attributes associate with the typed link.
	Attributes []TypedLinkAttributeDefinition `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListTypedLinkFacetAttributesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTypedLinkFacetAttributesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTypedLinkFacetAttributesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTypedLinkFacetAttributesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTypedLinkFacetNamesRequest
type ListTypedLinkFacetNamesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results to retrieve.
	MaxResults *int64 `min:"1" type:"integer"`

	// The pagination token.
	NextToken *string `type:"string"`

	// The Amazon Resource Name (ARN) that is associated with the schema. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTypedLinkFacetNamesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTypedLinkFacetNamesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTypedLinkFacetNamesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTypedLinkFacetNamesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTypedLinkFacetNamesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ListTypedLinkFacetNamesResponse
type ListTypedLinkFacetNamesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The names of typed link facets that exist within the schema.
	FacetNames []string `type:"list"`

	// The pagination token.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListTypedLinkFacetNamesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTypedLinkFacetNamesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTypedLinkFacetNamesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTypedLinkFacetNamesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.FacetNames) > 0 {
		v := s.FacetNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FacetNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/LookupPolicyRequest
type LookupPolicyInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the Directory. For
	// more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The maximum number of items to be retrieved in a single call. This is an
	// approximate number.
	MaxResults *int64 `min:"1" type:"integer"`

	// The token to request the next page of results.
	NextToken *string `type:"string"`

	// Reference that identifies the object whose policies will be looked up.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s LookupPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LookupPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LookupPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LookupPolicyInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LookupPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/LookupPolicyResponse
type LookupPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The pagination token.
	NextToken *string `type:"string"`

	// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier,
	// and PolicyType. For more information, see Policies (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#policies).
	PolicyToPathList []PolicyToPath `type:"list"`
}

// String returns the string representation
func (s LookupPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LookupPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s LookupPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LookupPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.PolicyToPathList) > 0 {
		v := s.PolicyToPathList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "PolicyToPathList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The action to take on the object attribute.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ObjectAttributeAction
type ObjectAttributeAction struct {
	_ struct{} `type:"structure"`

	// A type that can be either Update or Delete.
	ObjectAttributeActionType UpdateActionType `type:"string" enum:"true"`

	// The value that you want to update to.
	ObjectAttributeUpdateValue *TypedAttributeValue `type:"structure"`
}

// String returns the string representation
func (s ObjectAttributeAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ObjectAttributeAction) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectAttributeAction) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ObjectAttributeActionType) > 0 {
		v := s.ObjectAttributeActionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectAttributeActionType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ObjectAttributeUpdateValue != nil {
		v := s.ObjectAttributeUpdateValue

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectAttributeUpdateValue", v, metadata)
	}
	return nil
}

// A range of attributes.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ObjectAttributeRange
type ObjectAttributeRange struct {
	_ struct{} `type:"structure"`

	// The key of the attribute that the attribute range covers.
	AttributeKey *AttributeKey `type:"structure"`

	// The range of attribute values being selected.
	Range *TypedAttributeValueRange `type:"structure"`
}

// String returns the string representation
func (s ObjectAttributeRange) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ObjectAttributeRange) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ObjectAttributeRange) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ObjectAttributeRange"}
	if s.AttributeKey != nil {
		if err := s.AttributeKey.Validate(); err != nil {
			invalidParams.AddNested("AttributeKey", err.(aws.ErrInvalidParams))
		}
	}
	if s.Range != nil {
		if err := s.Range.Validate(); err != nil {
			invalidParams.AddNested("Range", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectAttributeRange) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttributeKey != nil {
		v := s.AttributeKey

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AttributeKey", v, metadata)
	}
	if s.Range != nil {
		v := s.Range

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Range", v, metadata)
	}
	return nil
}

// Structure that contains attribute update information.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ObjectAttributeUpdate
type ObjectAttributeUpdate struct {
	_ struct{} `type:"structure"`

	// The action to perform as part of the attribute update.
	ObjectAttributeAction *ObjectAttributeAction `type:"structure"`

	// The key of the attribute being updated.
	ObjectAttributeKey *AttributeKey `type:"structure"`
}

// String returns the string representation
func (s ObjectAttributeUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ObjectAttributeUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ObjectAttributeUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ObjectAttributeUpdate"}
	if s.ObjectAttributeKey != nil {
		if err := s.ObjectAttributeKey.Validate(); err != nil {
			invalidParams.AddNested("ObjectAttributeKey", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectAttributeUpdate) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectAttributeAction != nil {
		v := s.ObjectAttributeAction

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectAttributeAction", v, metadata)
	}
	if s.ObjectAttributeKey != nil {
		v := s.ObjectAttributeKey

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectAttributeKey", v, metadata)
	}
	return nil
}

// The reference that identifies an object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/ObjectReference
type ObjectReference struct {
	_ struct{} `type:"structure"`

	// A path selector supports easy selection of an object by the parent/child
	// links leading to it from the directory root. Use the link names from each
	// parent/child link to construct the path. Path selectors start with a slash
	// (/) and link names are separated by slashes. For more information about paths,
	// see Accessing Objects (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#accessingobjects).
	// You can identify an object in one of the following ways:
	//
	//    * $ObjectIdentifier - An object identifier is an opaque string provided
	//    by Amazon Cloud Directory. When creating objects, the system will provide
	//    you with the identifier of the created object. An object’s identifier
	//    is immutable and no two objects will ever share the same object identifier
	//
	//    * /some/path - Identifies the object based on path
	//
	//    * #SomeBatchReference - Identifies the object in a batch call
	Selector *string `type:"string"`
}

// String returns the string representation
func (s ObjectReference) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ObjectReference) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ObjectReference) MarshalFields(e protocol.FieldEncoder) error {
	if s.Selector != nil {
		v := *s.Selector

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Selector", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Returns the path to the ObjectIdentifiers that is associated with the directory.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PathToObjectIdentifiers
type PathToObjectIdentifiers struct {
	_ struct{} `type:"structure"`

	// Lists ObjectIdentifiers starting from directory root to the object in the
	// request.
	ObjectIdentifiers []string `type:"list"`

	// The path that is used to identify the object starting from directory root.
	Path *string `type:"string"`
}

// String returns the string representation
func (s PathToObjectIdentifiers) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PathToObjectIdentifiers) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PathToObjectIdentifiers) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ObjectIdentifiers) > 0 {
		v := s.ObjectIdentifiers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ObjectIdentifiers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the PolicyType, PolicyId, and the ObjectIdentifier to which it is
// attached. For more information, see Policies (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/cd_key_concepts.html#policies).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PolicyAttachment
type PolicyAttachment struct {
	_ struct{} `type:"structure"`

	// The ObjectIdentifier that is associated with PolicyAttachment.
	ObjectIdentifier *string `type:"string"`

	// The ID of PolicyAttachment.
	PolicyId *string `type:"string"`

	// The type of policy that can be associated with PolicyAttachment.
	PolicyType *string `type:"string"`
}

// String returns the string representation
func (s PolicyAttachment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PolicyAttachment) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PolicyAttachment) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyId != nil {
		v := *s.PolicyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PolicyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PolicyType != nil {
		v := *s.PolicyType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PolicyType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Used when a regular object exists in a Directory and you want to find all
// of the policies that are associated with that object and the parent to that
// object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PolicyToPath
type PolicyToPath struct {
	_ struct{} `type:"structure"`

	// The path that is referenced from the root.
	Path *string `type:"string"`

	// List of policy objects.
	Policies []PolicyAttachment `type:"list"`
}

// String returns the string representation
func (s PolicyToPath) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PolicyToPath) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PolicyToPath) MarshalFields(e protocol.FieldEncoder) error {
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Policies) > 0 {
		v := s.Policies

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Policies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PublishSchemaRequest
type PublishSchemaInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the development schema.
	// For more information, see arns.
	//
	// DevelopmentSchemaArn is a required field
	DevelopmentSchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The minor version under which the schema will be published. This parameter
	// is recommended. Schemas have both a major and minor version associated with
	// them.
	MinorVersion *string `min:"1" type:"string"`

	// The new name under which the schema will be published. If this is not provided,
	// the development schema is considered.
	Name *string `min:"1" type:"string"`

	// The major version under which the schema will be published. Schemas have
	// both a major and minor version associated with them.
	//
	// Version is a required field
	Version *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s PublishSchemaInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PublishSchemaInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PublishSchemaInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PublishSchemaInput"}

	if s.DevelopmentSchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DevelopmentSchemaArn"))
	}
	if s.MinorVersion != nil && len(*s.MinorVersion) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MinorVersion", 1))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PublishSchemaInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MinorVersion != nil {
		v := *s.MinorVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MinorVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DevelopmentSchemaArn != nil {
		v := *s.DevelopmentSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PublishSchemaResponse
type PublishSchemaOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN that is associated with the published schema. For more information,
	// see arns.
	PublishedSchemaArn *string `type:"string"`
}

// String returns the string representation
func (s PublishSchemaOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PublishSchemaOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PublishSchemaOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PublishSchemaOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.PublishedSchemaArn != nil {
		v := *s.PublishedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PublishedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PutSchemaFromJsonRequest
type PutSchemaFromJsonInput struct {
	_ struct{} `type:"structure"`

	// The replacement JSON schema.
	//
	// Document is a required field
	Document *string `type:"string" required:"true"`

	// The ARN of the schema to update.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s PutSchemaFromJsonInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutSchemaFromJsonInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutSchemaFromJsonInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutSchemaFromJsonInput"}

	if s.Document == nil {
		invalidParams.Add(aws.NewErrParamRequired("Document"))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutSchemaFromJsonInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Document != nil {
		v := *s.Document

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Document", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/PutSchemaFromJsonResponse
type PutSchemaFromJsonOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the schema to update.
	Arn *string `type:"string"`
}

// String returns the string representation
func (s PutSchemaFromJsonOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutSchemaFromJsonOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutSchemaFromJsonOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutSchemaFromJsonOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/RemoveFacetFromObjectRequest
type RemoveFacetFromObjectInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the directory in which the object resides.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// A reference to the object to remove the facet from.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`

	// The facet to remove. See SchemaFacet for details.
	//
	// SchemaFacet is a required field
	SchemaFacet *SchemaFacet `type:"structure" required:"true"`
}

// String returns the string representation
func (s RemoveFacetFromObjectInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveFacetFromObjectInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RemoveFacetFromObjectInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RemoveFacetFromObjectInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}

	if s.SchemaFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaFacet"))
	}
	if s.SchemaFacet != nil {
		if err := s.SchemaFacet.Validate(); err != nil {
			invalidParams.AddNested("SchemaFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveFacetFromObjectInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.SchemaFacet != nil {
		v := s.SchemaFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SchemaFacet", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/RemoveFacetFromObjectResponse
type RemoveFacetFromObjectOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s RemoveFacetFromObjectOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveFacetFromObjectOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RemoveFacetFromObjectOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveFacetFromObjectOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Contains an Amazon Resource Name (ARN) and parameters that are associated
// with the rule.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/Rule
type Rule struct {
	_ struct{} `type:"structure"`

	// The minimum and maximum parameters that are associated with the rule.
	Parameters map[string]string `type:"map"`

	// The type of attribute validation rule.
	Type RuleType `type:"string" enum:"true"`
}

// String returns the string representation
func (s Rule) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Rule) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Rule) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// A facet.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/SchemaFacet
type SchemaFacet struct {
	_ struct{} `type:"structure"`

	// The name of the facet.
	FacetName *string `min:"1" type:"string"`

	// The ARN of the schema that contains the facet with no minor component. See
	// arns and In-Place Schema Upgrade (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/inplaceschemaupgrade.html)
	// for a description of when to provide minor versions.
	SchemaArn *string `type:"string"`
}

// String returns the string representation
func (s SchemaFacet) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SchemaFacet) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SchemaFacet) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SchemaFacet"}
	if s.FacetName != nil && len(*s.FacetName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FacetName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SchemaFacet) MarshalFields(e protocol.FieldEncoder) error {
	if s.FacetName != nil {
		v := *s.FacetName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FacetName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The tag structure that contains a tag key and value.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/Tag
type Tag struct {
	_ struct{} `type:"structure"`

	// The key that is associated with the tag.
	Key *string `type:"string"`

	// The value that is associated with the tag.
	Value *string `type:"string"`
}

// String returns the string representation
func (s Tag) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Tag) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Tag) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TagResourceRequest
type TagResourceInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the resource. Tagging is only supported
	// for directories.
	//
	// ResourceArn is a required field
	ResourceArn *string `type:"string" required:"true"`

	// A list of tag key-value pairs.
	//
	// Tags is a required field
	Tags []Tag `type:"list" required:"true"`
}

// String returns the string representation
func (s TagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TagResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TagResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if s.Tags == nil {
		invalidParams.Add(aws.NewErrParamRequired("Tags"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TagResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Tags", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TagResourceResponse
type TagResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s TagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TagResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TagResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Represents the data for a typed attribute. You can set one, and only one,
// of the elements. Each attribute in an item is a name-value pair. Attributes
// have a single value.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TypedAttributeValue
type TypedAttributeValue struct {
	_ struct{} `type:"structure"`

	// A binary data value.
	//
	// BinaryValue is automatically base64 encoded/decoded by the SDK.
	BinaryValue []byte `type:"blob"`

	// A Boolean data value.
	BooleanValue *bool `type:"boolean"`

	// A date and time value.
	DatetimeValue *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A number data value.
	NumberValue *string `type:"string"`

	// A string data value.
	StringValue *string `type:"string"`
}

// String returns the string representation
func (s TypedAttributeValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TypedAttributeValue) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TypedAttributeValue) MarshalFields(e protocol.FieldEncoder) error {
	if s.BinaryValue != nil {
		v := s.BinaryValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BinaryValue", protocol.QuotedValue{ValueMarshaler: protocol.BytesValue(v)}, metadata)
	}
	if s.BooleanValue != nil {
		v := *s.BooleanValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BooleanValue", protocol.BoolValue(v), metadata)
	}
	if s.DatetimeValue != nil {
		v := *s.DatetimeValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DatetimeValue", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.NumberValue != nil {
		v := *s.NumberValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StringValue != nil {
		v := *s.StringValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StringValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A range of attribute values. For more information, see Range Filters (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#rangefilters).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TypedAttributeValueRange
type TypedAttributeValueRange struct {
	_ struct{} `type:"structure"`

	// The inclusive or exclusive range end.
	//
	// EndMode is a required field
	EndMode RangeMode `type:"string" required:"true" enum:"true"`

	// The attribute value to terminate the range at.
	EndValue *TypedAttributeValue `type:"structure"`

	// The inclusive or exclusive range start.
	//
	// StartMode is a required field
	StartMode RangeMode `type:"string" required:"true" enum:"true"`

	// The value to start the range at.
	StartValue *TypedAttributeValue `type:"structure"`
}

// String returns the string representation
func (s TypedAttributeValueRange) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TypedAttributeValueRange) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TypedAttributeValueRange) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TypedAttributeValueRange"}
	if len(s.EndMode) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("EndMode"))
	}
	if len(s.StartMode) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("StartMode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TypedAttributeValueRange) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.EndMode) > 0 {
		v := s.EndMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndMode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.EndValue != nil {
		v := s.EndValue

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EndValue", v, metadata)
	}
	if len(s.StartMode) > 0 {
		v := s.StartMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartMode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StartValue != nil {
		v := s.StartValue

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "StartValue", v, metadata)
	}
	return nil
}

// A typed link attribute definition.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TypedLinkAttributeDefinition
type TypedLinkAttributeDefinition struct {
	_ struct{} `type:"structure"`

	// The default value of the attribute (if configured).
	DefaultValue *TypedAttributeValue `type:"structure"`

	// Whether the attribute is mutable or not.
	IsImmutable *bool `type:"boolean"`

	// The unique name of the typed link attribute.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The required behavior of the TypedLinkAttributeDefinition.
	//
	// RequiredBehavior is a required field
	RequiredBehavior RequiredAttributeBehavior `type:"string" required:"true" enum:"true"`

	// Validation rules that are attached to the attribute definition.
	Rules map[string]Rule `type:"map"`

	// The type of the attribute.
	//
	// Type is a required field
	Type FacetAttributeType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s TypedLinkAttributeDefinition) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TypedLinkAttributeDefinition) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TypedLinkAttributeDefinition) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TypedLinkAttributeDefinition"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if len(s.RequiredBehavior) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("RequiredBehavior"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TypedLinkAttributeDefinition) MarshalFields(e protocol.FieldEncoder) error {
	if s.DefaultValue != nil {
		v := s.DefaultValue

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DefaultValue", v, metadata)
	}
	if s.IsImmutable != nil {
		v := *s.IsImmutable

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsImmutable", protocol.BoolValue(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RequiredBehavior) > 0 {
		v := s.RequiredBehavior

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RequiredBehavior", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Rules) > 0 {
		v := s.Rules

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Rules", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Identifies the range of attributes that are used by a specified filter.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TypedLinkAttributeRange
type TypedLinkAttributeRange struct {
	_ struct{} `type:"structure"`

	// The unique name of the typed link attribute.
	AttributeName *string `min:"1" type:"string"`

	// The range of attribute values that are being selected.
	//
	// Range is a required field
	Range *TypedAttributeValueRange `type:"structure" required:"true"`
}

// String returns the string representation
func (s TypedLinkAttributeRange) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TypedLinkAttributeRange) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TypedLinkAttributeRange) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TypedLinkAttributeRange"}
	if s.AttributeName != nil && len(*s.AttributeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributeName", 1))
	}

	if s.Range == nil {
		invalidParams.Add(aws.NewErrParamRequired("Range"))
	}
	if s.Range != nil {
		if err := s.Range.Validate(); err != nil {
			invalidParams.AddNested("Range", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TypedLinkAttributeRange) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttributeName != nil {
		v := *s.AttributeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AttributeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Range != nil {
		v := s.Range

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Range", v, metadata)
	}
	return nil
}

// Defines the typed links structure and its attributes. To create a typed link
// facet, use the CreateTypedLinkFacet API.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TypedLinkFacet
type TypedLinkFacet struct {
	_ struct{} `type:"structure"`

	// A set of key-value pairs associated with the typed link. Typed link attributes
	// are used when you have data values that are related to the link itself, and
	// not to one of the two objects being linked. Identity attributes also serve
	// to distinguish the link from others of the same type between the same objects.
	//
	// Attributes is a required field
	Attributes []TypedLinkAttributeDefinition `type:"list" required:"true"`

	// The set of attributes that distinguish links made from this facet from each
	// other, in the order of significance. Listing typed links can filter on the
	// values of these attributes. See ListOutgoingTypedLinks and ListIncomingTypedLinks
	// for details.
	//
	// IdentityAttributeOrder is a required field
	IdentityAttributeOrder []string `type:"list" required:"true"`

	// The unique name of the typed link facet.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`
}

// String returns the string representation
func (s TypedLinkFacet) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TypedLinkFacet) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TypedLinkFacet) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TypedLinkFacet"}

	if s.Attributes == nil {
		invalidParams.Add(aws.NewErrParamRequired("Attributes"))
	}

	if s.IdentityAttributeOrder == nil {
		invalidParams.Add(aws.NewErrParamRequired("IdentityAttributeOrder"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Attributes != nil {
		for i, v := range s.Attributes {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Attributes", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TypedLinkFacet) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Attributes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.IdentityAttributeOrder) > 0 {
		v := s.IdentityAttributeOrder

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IdentityAttributeOrder", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A typed link facet attribute update.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TypedLinkFacetAttributeUpdate
type TypedLinkFacetAttributeUpdate struct {
	_ struct{} `type:"structure"`

	// The action to perform when updating the attribute.
	//
	// Action is a required field
	Action UpdateActionType `type:"string" required:"true" enum:"true"`

	// The attribute to update.
	//
	// Attribute is a required field
	Attribute *TypedLinkAttributeDefinition `type:"structure" required:"true"`
}

// String returns the string representation
func (s TypedLinkFacetAttributeUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TypedLinkFacetAttributeUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TypedLinkFacetAttributeUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TypedLinkFacetAttributeUpdate"}
	if len(s.Action) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Action"))
	}

	if s.Attribute == nil {
		invalidParams.Add(aws.NewErrParamRequired("Attribute"))
	}
	if s.Attribute != nil {
		if err := s.Attribute.Validate(); err != nil {
			invalidParams.AddNested("Attribute", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TypedLinkFacetAttributeUpdate) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Action) > 0 {
		v := s.Action

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Action", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Attribute != nil {
		v := s.Attribute

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Attribute", v, metadata)
	}
	return nil
}

// Identifies the schema Amazon Resource Name (ARN) and facet name for the typed
// link.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TypedLinkSchemaAndFacetName
type TypedLinkSchemaAndFacetName struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that is associated with the schema. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `type:"string" required:"true"`

	// The unique name of the typed link facet.
	//
	// TypedLinkName is a required field
	TypedLinkName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s TypedLinkSchemaAndFacetName) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TypedLinkSchemaAndFacetName) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TypedLinkSchemaAndFacetName) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TypedLinkSchemaAndFacetName"}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if s.TypedLinkName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypedLinkName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TypedLinkSchemaAndFacetName) MarshalFields(e protocol.FieldEncoder) error {
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypedLinkName != nil {
		v := *s.TypedLinkName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TypedLinkName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains all the information that is used to uniquely identify a typed link.
// The parameters discussed in this topic are used to uniquely specify the typed
// link being operated on. The AttachTypedLink API returns a typed link specifier
// while the DetachTypedLink API accepts one as input. Similarly, the ListIncomingTypedLinks
// and ListOutgoingTypedLinks API operations provide typed link specifiers as
// output. You can also construct a typed link specifier from scratch.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/TypedLinkSpecifier
type TypedLinkSpecifier struct {
	_ struct{} `type:"structure"`

	// Identifies the attribute value to update.
	//
	// IdentityAttributeValues is a required field
	IdentityAttributeValues []AttributeNameAndValue `type:"list" required:"true"`

	// Identifies the source object that the typed link will attach to.
	//
	// SourceObjectReference is a required field
	SourceObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifies the target object that the typed link will attach to.
	//
	// TargetObjectReference is a required field
	TargetObjectReference *ObjectReference `type:"structure" required:"true"`

	// Identifies the typed link facet that is associated with the typed link.
	//
	// TypedLinkFacet is a required field
	TypedLinkFacet *TypedLinkSchemaAndFacetName `type:"structure" required:"true"`
}

// String returns the string representation
func (s TypedLinkSpecifier) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TypedLinkSpecifier) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TypedLinkSpecifier) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TypedLinkSpecifier"}

	if s.IdentityAttributeValues == nil {
		invalidParams.Add(aws.NewErrParamRequired("IdentityAttributeValues"))
	}

	if s.SourceObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("SourceObjectReference"))
	}

	if s.TargetObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetObjectReference"))
	}

	if s.TypedLinkFacet == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypedLinkFacet"))
	}
	if s.IdentityAttributeValues != nil {
		for i, v := range s.IdentityAttributeValues {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "IdentityAttributeValues", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.TypedLinkFacet != nil {
		if err := s.TypedLinkFacet.Validate(); err != nil {
			invalidParams.AddNested("TypedLinkFacet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TypedLinkSpecifier) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.IdentityAttributeValues) > 0 {
		v := s.IdentityAttributeValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IdentityAttributeValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SourceObjectReference != nil {
		v := s.SourceObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SourceObjectReference", v, metadata)
	}
	if s.TargetObjectReference != nil {
		v := s.TargetObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TargetObjectReference", v, metadata)
	}
	if s.TypedLinkFacet != nil {
		v := s.TypedLinkFacet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TypedLinkFacet", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UntagResourceRequest
type UntagResourceInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the resource. Tagging is only supported
	// for directories.
	//
	// ResourceArn is a required field
	ResourceArn *string `type:"string" required:"true"`

	// Keys of the tag that need to be removed from the resource.
	//
	// TagKeys is a required field
	TagKeys []string `type:"list" required:"true"`
}

// String returns the string representation
func (s UntagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UntagResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UntagResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if s.TagKeys == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UntagResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TagKeys) > 0 {
		v := s.TagKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TagKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UntagResourceResponse
type UntagResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UntagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UntagResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UntagResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateFacetRequest
type UpdateFacetInput struct {
	_ struct{} `type:"structure"`

	// List of attributes that need to be updated in a given schema Facet. Each
	// attribute is followed by AttributeAction, which specifies the type of update
	// operation to perform.
	AttributeUpdates []FacetAttributeUpdate `type:"list"`

	// The name of the facet.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The object type that is associated with the facet. See CreateFacetRequest$ObjectType
	// for more details.
	ObjectType ObjectType `type:"string" enum:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Facet. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateFacetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFacetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateFacetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateFacetInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}
	if s.AttributeUpdates != nil {
		for i, v := range s.AttributeUpdates {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AttributeUpdates", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateFacetInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.AttributeUpdates) > 0 {
		v := s.AttributeUpdates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AttributeUpdates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ObjectType) > 0 {
		v := s.ObjectType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateFacetResponse
type UpdateFacetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateFacetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFacetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateFacetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateFacetOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateObjectAttributesRequest
type UpdateObjectAttributesInput struct {
	_ struct{} `type:"structure"`

	// The attributes update structure.
	//
	// AttributeUpdates is a required field
	AttributeUpdates []ObjectAttributeUpdate `type:"list" required:"true"`

	// The Amazon Resource Name (ARN) that is associated with the Directory where
	// the object resides. For more information, see arns.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`

	// The reference that identifies the object.
	//
	// ObjectReference is a required field
	ObjectReference *ObjectReference `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateObjectAttributesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateObjectAttributesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateObjectAttributesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateObjectAttributesInput"}

	if s.AttributeUpdates == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeUpdates"))
	}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.ObjectReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectReference"))
	}
	if s.AttributeUpdates != nil {
		for i, v := range s.AttributeUpdates {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AttributeUpdates", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateObjectAttributesInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.AttributeUpdates) > 0 {
		v := s.AttributeUpdates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AttributeUpdates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ObjectReference != nil {
		v := s.ObjectReference

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ObjectReference", v, metadata)
	}
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateObjectAttributesResponse
type UpdateObjectAttributesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ObjectIdentifier of the updated object.
	ObjectIdentifier *string `type:"string"`
}

// String returns the string representation
func (s UpdateObjectAttributesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateObjectAttributesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateObjectAttributesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateObjectAttributesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ObjectIdentifier != nil {
		v := *s.ObjectIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectIdentifier", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateSchemaRequest
type UpdateSchemaInput struct {
	_ struct{} `type:"structure"`

	// The name of the schema.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) of the development schema. For more information,
	// see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateSchemaInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateSchemaInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateSchemaInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateSchemaInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateSchemaInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateSchemaResponse
type UpdateSchemaOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN that is associated with the updated schema. For more information,
	// see arns.
	SchemaArn *string `type:"string"`
}

// String returns the string representation
func (s UpdateSchemaOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateSchemaOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateSchemaOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateSchemaOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateTypedLinkFacetRequest
type UpdateTypedLinkFacetInput struct {
	_ struct{} `type:"structure"`

	// Attributes update structure.
	//
	// AttributeUpdates is a required field
	AttributeUpdates []TypedLinkFacetAttributeUpdate `type:"list" required:"true"`

	// The order of identity attributes for the facet, from most significant to
	// least significant. The ability to filter typed links considers the order
	// that the attributes are defined on the typed link facet. When providing ranges
	// to a typed link selection, any inexact ranges must be specified at the end.
	// Any attributes that do not have a range specified are presumed to match the
	// entire range. Filters are interpreted in the order of the attributes on the
	// typed link facet, not the order in which they are supplied to any API calls.
	// For more information about identity attributes, see Typed link (http://docs.aws.amazon.com/directoryservice/latest/admin-guide/objectsandlinks.html#typedlink).
	//
	// IdentityAttributeOrder is a required field
	IdentityAttributeOrder []string `type:"list" required:"true"`

	// The unique name of the typed link facet.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The Amazon Resource Name (ARN) that is associated with the schema. For more
	// information, see arns.
	//
	// SchemaArn is a required field
	SchemaArn *string `location:"header" locationName:"x-amz-data-partition" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateTypedLinkFacetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTypedLinkFacetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateTypedLinkFacetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateTypedLinkFacetInput"}

	if s.AttributeUpdates == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeUpdates"))
	}

	if s.IdentityAttributeOrder == nil {
		invalidParams.Add(aws.NewErrParamRequired("IdentityAttributeOrder"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.SchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("SchemaArn"))
	}
	if s.AttributeUpdates != nil {
		for i, v := range s.AttributeUpdates {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AttributeUpdates", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateTypedLinkFacetInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.AttributeUpdates) > 0 {
		v := s.AttributeUpdates

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AttributeUpdates", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.IdentityAttributeOrder) > 0 {
		v := s.IdentityAttributeOrder

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "IdentityAttributeOrder", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SchemaArn != nil {
		v := *s.SchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "x-amz-data-partition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpdateTypedLinkFacetResponse
type UpdateTypedLinkFacetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateTypedLinkFacetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTypedLinkFacetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateTypedLinkFacetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateTypedLinkFacetOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpgradeAppliedSchemaRequest
type UpgradeAppliedSchemaInput struct {
	_ struct{} `type:"structure"`

	// The ARN for the directory to which the upgraded schema will be applied.
	//
	// DirectoryArn is a required field
	DirectoryArn *string `type:"string" required:"true"`

	// Used for testing whether the major version schemas are backward compatible
	// or not. If schema compatibility fails, an exception would be thrown else
	// the call would succeed but no changes will be saved. This parameter is optional.
	DryRun *bool `type:"boolean"`

	// The revision of the published schema to upgrade the directory to.
	//
	// PublishedSchemaArn is a required field
	PublishedSchemaArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s UpgradeAppliedSchemaInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpgradeAppliedSchemaInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpgradeAppliedSchemaInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpgradeAppliedSchemaInput"}

	if s.DirectoryArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DirectoryArn"))
	}

	if s.PublishedSchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("PublishedSchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpgradeAppliedSchemaInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DryRun != nil {
		v := *s.DryRun

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DryRun", protocol.BoolValue(v), metadata)
	}
	if s.PublishedSchemaArn != nil {
		v := *s.PublishedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PublishedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpgradeAppliedSchemaResponse
type UpgradeAppliedSchemaOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the directory that is returned as part of the response.
	DirectoryArn *string `type:"string"`

	// The ARN of the upgraded schema that is returned as part of the response.
	UpgradedSchemaArn *string `type:"string"`
}

// String returns the string representation
func (s UpgradeAppliedSchemaOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpgradeAppliedSchemaOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpgradeAppliedSchemaOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpgradeAppliedSchemaOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DirectoryArn != nil {
		v := *s.DirectoryArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DirectoryArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UpgradedSchemaArn != nil {
		v := *s.UpgradedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpgradePublishedSchemaRequest
type UpgradePublishedSchemaInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the development schema with the changes used for the upgrade.
	//
	// DevelopmentSchemaArn is a required field
	DevelopmentSchemaArn *string `type:"string" required:"true"`

	// Used for testing whether the Development schema provided is backwards compatible,
	// or not, with the publish schema provided by the user to be upgraded. If schema
	// compatibility fails, an exception would be thrown else the call would succeed.
	// This parameter is optional and defaults to false.
	DryRun *bool `type:"boolean"`

	// Identifies the minor version of the published schema that will be created.
	// This parameter is NOT optional.
	//
	// MinorVersion is a required field
	MinorVersion *string `min:"1" type:"string" required:"true"`

	// The ARN of the published schema to be upgraded.
	//
	// PublishedSchemaArn is a required field
	PublishedSchemaArn *string `type:"string" required:"true"`
}

// String returns the string representation
func (s UpgradePublishedSchemaInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpgradePublishedSchemaInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpgradePublishedSchemaInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpgradePublishedSchemaInput"}

	if s.DevelopmentSchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("DevelopmentSchemaArn"))
	}

	if s.MinorVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("MinorVersion"))
	}
	if s.MinorVersion != nil && len(*s.MinorVersion) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MinorVersion", 1))
	}

	if s.PublishedSchemaArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("PublishedSchemaArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpgradePublishedSchemaInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DevelopmentSchemaArn != nil {
		v := *s.DevelopmentSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DevelopmentSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DryRun != nil {
		v := *s.DryRun

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DryRun", protocol.BoolValue(v), metadata)
	}
	if s.MinorVersion != nil {
		v := *s.MinorVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MinorVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PublishedSchemaArn != nil {
		v := *s.PublishedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PublishedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/clouddirectory-2016-05-10/UpgradePublishedSchemaResponse
type UpgradePublishedSchemaOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ARN of the upgraded schema that is returned as part of the response.
	UpgradedSchemaArn *string `type:"string"`
}

// String returns the string representation
func (s UpgradePublishedSchemaOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpgradePublishedSchemaOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpgradePublishedSchemaOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpgradePublishedSchemaOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.UpgradedSchemaArn != nil {
		v := *s.UpgradedSchemaArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradedSchemaArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type BatchReadExceptionType string

// Enum values for BatchReadExceptionType
const (
	BatchReadExceptionTypeValidationException             BatchReadExceptionType = "ValidationException"
	BatchReadExceptionTypeInvalidArnException             BatchReadExceptionType = "InvalidArnException"
	BatchReadExceptionTypeResourceNotFoundException       BatchReadExceptionType = "ResourceNotFoundException"
	BatchReadExceptionTypeInvalidNextTokenException       BatchReadExceptionType = "InvalidNextTokenException"
	BatchReadExceptionTypeAccessDeniedException           BatchReadExceptionType = "AccessDeniedException"
	BatchReadExceptionTypeNotNodeException                BatchReadExceptionType = "NotNodeException"
	BatchReadExceptionTypeFacetValidationException        BatchReadExceptionType = "FacetValidationException"
	BatchReadExceptionTypeCannotListParentOfRootException BatchReadExceptionType = "CannotListParentOfRootException"
	BatchReadExceptionTypeNotIndexException               BatchReadExceptionType = "NotIndexException"
	BatchReadExceptionTypeNotPolicyException              BatchReadExceptionType = "NotPolicyException"
	BatchReadExceptionTypeDirectoryNotEnabledException    BatchReadExceptionType = "DirectoryNotEnabledException"
	BatchReadExceptionTypeLimitExceededException          BatchReadExceptionType = "LimitExceededException"
	BatchReadExceptionTypeInternalServiceException        BatchReadExceptionType = "InternalServiceException"
)

func (enum BatchReadExceptionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BatchReadExceptionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type BatchWriteExceptionType string

// Enum values for BatchWriteExceptionType
const (
	BatchWriteExceptionTypeInternalServiceException         BatchWriteExceptionType = "InternalServiceException"
	BatchWriteExceptionTypeValidationException              BatchWriteExceptionType = "ValidationException"
	BatchWriteExceptionTypeInvalidArnException              BatchWriteExceptionType = "InvalidArnException"
	BatchWriteExceptionTypeLinkNameAlreadyInUseException    BatchWriteExceptionType = "LinkNameAlreadyInUseException"
	BatchWriteExceptionTypeStillContainsLinksException      BatchWriteExceptionType = "StillContainsLinksException"
	BatchWriteExceptionTypeFacetValidationException         BatchWriteExceptionType = "FacetValidationException"
	BatchWriteExceptionTypeObjectNotDetachedException       BatchWriteExceptionType = "ObjectNotDetachedException"
	BatchWriteExceptionTypeResourceNotFoundException        BatchWriteExceptionType = "ResourceNotFoundException"
	BatchWriteExceptionTypeAccessDeniedException            BatchWriteExceptionType = "AccessDeniedException"
	BatchWriteExceptionTypeInvalidAttachmentException       BatchWriteExceptionType = "InvalidAttachmentException"
	BatchWriteExceptionTypeNotIndexException                BatchWriteExceptionType = "NotIndexException"
	BatchWriteExceptionTypeNotNodeException                 BatchWriteExceptionType = "NotNodeException"
	BatchWriteExceptionTypeIndexedAttributeMissingException BatchWriteExceptionType = "IndexedAttributeMissingException"
	BatchWriteExceptionTypeObjectAlreadyDetachedException   BatchWriteExceptionType = "ObjectAlreadyDetachedException"
	BatchWriteExceptionTypeNotPolicyException               BatchWriteExceptionType = "NotPolicyException"
	BatchWriteExceptionTypeDirectoryNotEnabledException     BatchWriteExceptionType = "DirectoryNotEnabledException"
	BatchWriteExceptionTypeLimitExceededException           BatchWriteExceptionType = "LimitExceededException"
	BatchWriteExceptionTypeUnsupportedIndexTypeException    BatchWriteExceptionType = "UnsupportedIndexTypeException"
)

func (enum BatchWriteExceptionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BatchWriteExceptionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ConsistencyLevel string

// Enum values for ConsistencyLevel
const (
	ConsistencyLevelSerializable ConsistencyLevel = "SERIALIZABLE"
	ConsistencyLevelEventual     ConsistencyLevel = "EVENTUAL"
)

func (enum ConsistencyLevel) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ConsistencyLevel) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DirectoryState string

// Enum values for DirectoryState
const (
	DirectoryStateEnabled  DirectoryState = "ENABLED"
	DirectoryStateDisabled DirectoryState = "DISABLED"
	DirectoryStateDeleted  DirectoryState = "DELETED"
)

func (enum DirectoryState) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DirectoryState) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type FacetAttributeType string

// Enum values for FacetAttributeType
const (
	FacetAttributeTypeString   FacetAttributeType = "STRING"
	FacetAttributeTypeBinary   FacetAttributeType = "BINARY"
	FacetAttributeTypeBoolean  FacetAttributeType = "BOOLEAN"
	FacetAttributeTypeNumber   FacetAttributeType = "NUMBER"
	FacetAttributeTypeDatetime FacetAttributeType = "DATETIME"
)

func (enum FacetAttributeType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum FacetAttributeType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ObjectType string

// Enum values for ObjectType
const (
	ObjectTypeNode     ObjectType = "NODE"
	ObjectTypeLeafNode ObjectType = "LEAF_NODE"
	ObjectTypePolicy   ObjectType = "POLICY"
	ObjectTypeIndex    ObjectType = "INDEX"
)

func (enum ObjectType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ObjectType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RangeMode string

// Enum values for RangeMode
const (
	RangeModeFirst                   RangeMode = "FIRST"
	RangeModeLast                    RangeMode = "LAST"
	RangeModeLastBeforeMissingValues RangeMode = "LAST_BEFORE_MISSING_VALUES"
	RangeModeInclusive               RangeMode = "INCLUSIVE"
	RangeModeExclusive               RangeMode = "EXCLUSIVE"
)

func (enum RangeMode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RangeMode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RequiredAttributeBehavior string

// Enum values for RequiredAttributeBehavior
const (
	RequiredAttributeBehaviorRequiredAlways RequiredAttributeBehavior = "REQUIRED_ALWAYS"
	RequiredAttributeBehaviorNotRequired    RequiredAttributeBehavior = "NOT_REQUIRED"
)

func (enum RequiredAttributeBehavior) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RequiredAttributeBehavior) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RuleType string

// Enum values for RuleType
const (
	RuleTypeBinaryLength     RuleType = "BINARY_LENGTH"
	RuleTypeNumberComparison RuleType = "NUMBER_COMPARISON"
	RuleTypeStringFromSet    RuleType = "STRING_FROM_SET"
	RuleTypeStringLength     RuleType = "STRING_LENGTH"
)

func (enum RuleType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RuleType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type UpdateActionType string

// Enum values for UpdateActionType
const (
	UpdateActionTypeCreateOrUpdate UpdateActionType = "CREATE_OR_UPDATE"
	UpdateActionTypeDelete         UpdateActionType = "DELETE"
)

func (enum UpdateActionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum UpdateActionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
