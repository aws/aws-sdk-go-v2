// Code generated by smithy-go-codegen DO NOT EDIT.

package elasticloadbalancingv2

import (
	"bytes"
	"context"
	"encoding/xml"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithytime "github.com/awslabs/smithy-go/time"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	smithyxml "github.com/awslabs/smithy-go/xml"
	"io"
	"strconv"
	"strings"
)

type awsAwsquery_deserializeOpAddListenerCertificates struct {
}

func (*awsAwsquery_deserializeOpAddListenerCertificates) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpAddListenerCertificates) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorAddListenerCertificates(response)
	}
	output := &AddListenerCertificatesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentAddListenerCertificatesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorAddListenerCertificates(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("CertificateNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorCertificateNotFoundException(response, errorBody)

	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyCertificatesException", errorCode):
		return awsAwsquery_deserializeErrorTooManyCertificatesException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpAddTags struct {
}

func (*awsAwsquery_deserializeOpAddTags) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpAddTags) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorAddTags(response)
	}
	output := &AddTagsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentAddTagsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorAddTags(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("DuplicateTagKeysException", errorCode):
		return awsAwsquery_deserializeErrorDuplicateTagKeysException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyTagsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTagsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpCreateListener struct {
}

func (*awsAwsquery_deserializeOpCreateListener) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpCreateListener) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorCreateListener(response)
	}
	output := &CreateListenerOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentCreateListenerOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorCreateListener(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ALPNPolicyNotSupportedException", errorCode):
		return awsAwsquery_deserializeErrorALPNPolicyNotSupportedException(response, errorBody)

	case strings.EqualFold("CertificateNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorCertificateNotFoundException(response, errorBody)

	case strings.EqualFold("DuplicateListenerException", errorCode):
		return awsAwsquery_deserializeErrorDuplicateListenerException(response, errorBody)

	case strings.EqualFold("IncompatibleProtocolsException", errorCode):
		return awsAwsquery_deserializeErrorIncompatibleProtocolsException(response, errorBody)

	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("InvalidLoadBalancerActionException", errorCode):
		return awsAwsquery_deserializeErrorInvalidLoadBalancerActionException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	case strings.EqualFold("SSLPolicyNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorSSLPolicyNotFoundException(response, errorBody)

	case strings.EqualFold("TargetGroupAssociationLimitException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupAssociationLimitException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyActionsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyActionsException(response, errorBody)

	case strings.EqualFold("TooManyCertificatesException", errorCode):
		return awsAwsquery_deserializeErrorTooManyCertificatesException(response, errorBody)

	case strings.EqualFold("TooManyListenersException", errorCode):
		return awsAwsquery_deserializeErrorTooManyListenersException(response, errorBody)

	case strings.EqualFold("TooManyRegistrationsForTargetIdException", errorCode):
		return awsAwsquery_deserializeErrorTooManyRegistrationsForTargetIdException(response, errorBody)

	case strings.EqualFold("TooManyTargetsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTargetsException(response, errorBody)

	case strings.EqualFold("TooManyUniqueTargetGroupsPerLoadBalancerException", errorCode):
		return awsAwsquery_deserializeErrorTooManyUniqueTargetGroupsPerLoadBalancerException(response, errorBody)

	case strings.EqualFold("UnsupportedProtocolException", errorCode):
		return awsAwsquery_deserializeErrorUnsupportedProtocolException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpCreateLoadBalancer struct {
}

func (*awsAwsquery_deserializeOpCreateLoadBalancer) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpCreateLoadBalancer) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorCreateLoadBalancer(response)
	}
	output := &CreateLoadBalancerOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentCreateLoadBalancerOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorCreateLoadBalancer(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("AllocationIdNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorAllocationIdNotFoundException(response, errorBody)

	case strings.EqualFold("AvailabilityZoneNotSupportedException", errorCode):
		return awsAwsquery_deserializeErrorAvailabilityZoneNotSupportedException(response, errorBody)

	case strings.EqualFold("DuplicateLoadBalancerNameException", errorCode):
		return awsAwsquery_deserializeErrorDuplicateLoadBalancerNameException(response, errorBody)

	case strings.EqualFold("DuplicateTagKeysException", errorCode):
		return awsAwsquery_deserializeErrorDuplicateTagKeysException(response, errorBody)

	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("InvalidSchemeException", errorCode):
		return awsAwsquery_deserializeErrorInvalidSchemeException(response, errorBody)

	case strings.EqualFold("InvalidSecurityGroupException", errorCode):
		return awsAwsquery_deserializeErrorInvalidSecurityGroupException(response, errorBody)

	case strings.EqualFold("InvalidSubnetException", errorCode):
		return awsAwsquery_deserializeErrorInvalidSubnetException(response, errorBody)

	case strings.EqualFold("OperationNotPermittedException", errorCode):
		return awsAwsquery_deserializeErrorOperationNotPermittedException(response, errorBody)

	case strings.EqualFold("ResourceInUseException", errorCode):
		return awsAwsquery_deserializeErrorResourceInUseException(response, errorBody)

	case strings.EqualFold("SubnetNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorSubnetNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyLoadBalancersException", errorCode):
		return awsAwsquery_deserializeErrorTooManyLoadBalancersException(response, errorBody)

	case strings.EqualFold("TooManyTagsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTagsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpCreateRule struct {
}

func (*awsAwsquery_deserializeOpCreateRule) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpCreateRule) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorCreateRule(response)
	}
	output := &CreateRuleOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentCreateRuleOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorCreateRule(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("IncompatibleProtocolsException", errorCode):
		return awsAwsquery_deserializeErrorIncompatibleProtocolsException(response, errorBody)

	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("InvalidLoadBalancerActionException", errorCode):
		return awsAwsquery_deserializeErrorInvalidLoadBalancerActionException(response, errorBody)

	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	case strings.EqualFold("PriorityInUseException", errorCode):
		return awsAwsquery_deserializeErrorPriorityInUseException(response, errorBody)

	case strings.EqualFold("TargetGroupAssociationLimitException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupAssociationLimitException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyActionsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyActionsException(response, errorBody)

	case strings.EqualFold("TooManyRegistrationsForTargetIdException", errorCode):
		return awsAwsquery_deserializeErrorTooManyRegistrationsForTargetIdException(response, errorBody)

	case strings.EqualFold("TooManyRulesException", errorCode):
		return awsAwsquery_deserializeErrorTooManyRulesException(response, errorBody)

	case strings.EqualFold("TooManyTargetGroupsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTargetGroupsException(response, errorBody)

	case strings.EqualFold("TooManyTargetsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTargetsException(response, errorBody)

	case strings.EqualFold("TooManyUniqueTargetGroupsPerLoadBalancerException", errorCode):
		return awsAwsquery_deserializeErrorTooManyUniqueTargetGroupsPerLoadBalancerException(response, errorBody)

	case strings.EqualFold("UnsupportedProtocolException", errorCode):
		return awsAwsquery_deserializeErrorUnsupportedProtocolException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpCreateTargetGroup struct {
}

func (*awsAwsquery_deserializeOpCreateTargetGroup) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpCreateTargetGroup) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorCreateTargetGroup(response)
	}
	output := &CreateTargetGroupOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentCreateTargetGroupOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorCreateTargetGroup(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("DuplicateTargetGroupNameException", errorCode):
		return awsAwsquery_deserializeErrorDuplicateTargetGroupNameException(response, errorBody)

	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("TooManyTargetGroupsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTargetGroupsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteListener struct {
}

func (*awsAwsquery_deserializeOpDeleteListener) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteListener) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteListener(response)
	}
	output := &DeleteListenerOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDeleteListenerOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteListener(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteLoadBalancer struct {
}

func (*awsAwsquery_deserializeOpDeleteLoadBalancer) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteLoadBalancer) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteLoadBalancer(response)
	}
	output := &DeleteLoadBalancerOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDeleteLoadBalancerOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteLoadBalancer(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	case strings.EqualFold("OperationNotPermittedException", errorCode):
		return awsAwsquery_deserializeErrorOperationNotPermittedException(response, errorBody)

	case strings.EqualFold("ResourceInUseException", errorCode):
		return awsAwsquery_deserializeErrorResourceInUseException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteRule struct {
}

func (*awsAwsquery_deserializeOpDeleteRule) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteRule) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteRule(response)
	}
	output := &DeleteRuleOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDeleteRuleOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteRule(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("OperationNotPermittedException", errorCode):
		return awsAwsquery_deserializeErrorOperationNotPermittedException(response, errorBody)

	case strings.EqualFold("RuleNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorRuleNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeleteTargetGroup struct {
}

func (*awsAwsquery_deserializeOpDeleteTargetGroup) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteTargetGroup) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteTargetGroup(response)
	}
	output := &DeleteTargetGroupOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDeleteTargetGroupOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteTargetGroup(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ResourceInUseException", errorCode):
		return awsAwsquery_deserializeErrorResourceInUseException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDeregisterTargets struct {
}

func (*awsAwsquery_deserializeOpDeregisterTargets) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeregisterTargets) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeregisterTargets(response)
	}
	output := &DeregisterTargetsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDeregisterTargetsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeregisterTargets(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidTargetException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTargetException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeAccountLimits struct {
}

func (*awsAwsquery_deserializeOpDescribeAccountLimits) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeAccountLimits) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeAccountLimits(response)
	}
	output := &DescribeAccountLimitsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeAccountLimitsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeAccountLimits(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeListenerCertificates struct {
}

func (*awsAwsquery_deserializeOpDescribeListenerCertificates) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeListenerCertificates) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeListenerCertificates(response)
	}
	output := &DescribeListenerCertificatesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeListenerCertificatesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeListenerCertificates(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeListeners struct {
}

func (*awsAwsquery_deserializeOpDescribeListeners) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeListeners) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeListeners(response)
	}
	output := &DescribeListenersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeListenersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeListeners(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	case strings.EqualFold("UnsupportedProtocolException", errorCode):
		return awsAwsquery_deserializeErrorUnsupportedProtocolException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeLoadBalancerAttributes struct {
}

func (*awsAwsquery_deserializeOpDescribeLoadBalancerAttributes) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeLoadBalancerAttributes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeLoadBalancerAttributes(response)
	}
	output := &DescribeLoadBalancerAttributesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeLoadBalancerAttributesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeLoadBalancerAttributes(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeLoadBalancers struct {
}

func (*awsAwsquery_deserializeOpDescribeLoadBalancers) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeLoadBalancers) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeLoadBalancers(response)
	}
	output := &DescribeLoadBalancersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeLoadBalancersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeLoadBalancers(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeRules struct {
}

func (*awsAwsquery_deserializeOpDescribeRules) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeRules) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeRules(response)
	}
	output := &DescribeRulesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeRulesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeRules(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	case strings.EqualFold("RuleNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorRuleNotFoundException(response, errorBody)

	case strings.EqualFold("UnsupportedProtocolException", errorCode):
		return awsAwsquery_deserializeErrorUnsupportedProtocolException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeSSLPolicies struct {
}

func (*awsAwsquery_deserializeOpDescribeSSLPolicies) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeSSLPolicies) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeSSLPolicies(response)
	}
	output := &DescribeSSLPoliciesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeSSLPoliciesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeSSLPolicies(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("SSLPolicyNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorSSLPolicyNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeTags struct {
}

func (*awsAwsquery_deserializeOpDescribeTags) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeTags) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeTags(response)
	}
	output := &DescribeTagsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeTagsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeTags(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	case strings.EqualFold("RuleNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorRuleNotFoundException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeTargetGroupAttributes struct {
}

func (*awsAwsquery_deserializeOpDescribeTargetGroupAttributes) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeTargetGroupAttributes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeTargetGroupAttributes(response)
	}
	output := &DescribeTargetGroupAttributesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeTargetGroupAttributesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeTargetGroupAttributes(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeTargetGroups struct {
}

func (*awsAwsquery_deserializeOpDescribeTargetGroups) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeTargetGroups) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeTargetGroups(response)
	}
	output := &DescribeTargetGroupsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeTargetGroupsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeTargetGroups(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpDescribeTargetHealth struct {
}

func (*awsAwsquery_deserializeOpDescribeTargetHealth) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDescribeTargetHealth) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDescribeTargetHealth(response)
	}
	output := &DescribeTargetHealthOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentDescribeTargetHealthOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDescribeTargetHealth(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("HealthUnavailableException", errorCode):
		return awsAwsquery_deserializeErrorHealthUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidTargetException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTargetException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpModifyListener struct {
}

func (*awsAwsquery_deserializeOpModifyListener) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpModifyListener) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorModifyListener(response)
	}
	output := &ModifyListenerOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentModifyListenerOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorModifyListener(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ALPNPolicyNotSupportedException", errorCode):
		return awsAwsquery_deserializeErrorALPNPolicyNotSupportedException(response, errorBody)

	case strings.EqualFold("CertificateNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorCertificateNotFoundException(response, errorBody)

	case strings.EqualFold("DuplicateListenerException", errorCode):
		return awsAwsquery_deserializeErrorDuplicateListenerException(response, errorBody)

	case strings.EqualFold("IncompatibleProtocolsException", errorCode):
		return awsAwsquery_deserializeErrorIncompatibleProtocolsException(response, errorBody)

	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("InvalidLoadBalancerActionException", errorCode):
		return awsAwsquery_deserializeErrorInvalidLoadBalancerActionException(response, errorBody)

	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	case strings.EqualFold("SSLPolicyNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorSSLPolicyNotFoundException(response, errorBody)

	case strings.EqualFold("TargetGroupAssociationLimitException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupAssociationLimitException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyActionsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyActionsException(response, errorBody)

	case strings.EqualFold("TooManyCertificatesException", errorCode):
		return awsAwsquery_deserializeErrorTooManyCertificatesException(response, errorBody)

	case strings.EqualFold("TooManyListenersException", errorCode):
		return awsAwsquery_deserializeErrorTooManyListenersException(response, errorBody)

	case strings.EqualFold("TooManyRegistrationsForTargetIdException", errorCode):
		return awsAwsquery_deserializeErrorTooManyRegistrationsForTargetIdException(response, errorBody)

	case strings.EqualFold("TooManyTargetsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTargetsException(response, errorBody)

	case strings.EqualFold("TooManyUniqueTargetGroupsPerLoadBalancerException", errorCode):
		return awsAwsquery_deserializeErrorTooManyUniqueTargetGroupsPerLoadBalancerException(response, errorBody)

	case strings.EqualFold("UnsupportedProtocolException", errorCode):
		return awsAwsquery_deserializeErrorUnsupportedProtocolException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpModifyLoadBalancerAttributes struct {
}

func (*awsAwsquery_deserializeOpModifyLoadBalancerAttributes) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpModifyLoadBalancerAttributes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorModifyLoadBalancerAttributes(response)
	}
	output := &ModifyLoadBalancerAttributesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentModifyLoadBalancerAttributesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorModifyLoadBalancerAttributes(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpModifyRule struct {
}

func (*awsAwsquery_deserializeOpModifyRule) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpModifyRule) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorModifyRule(response)
	}
	output := &ModifyRuleOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentModifyRuleOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorModifyRule(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("IncompatibleProtocolsException", errorCode):
		return awsAwsquery_deserializeErrorIncompatibleProtocolsException(response, errorBody)

	case strings.EqualFold("InvalidLoadBalancerActionException", errorCode):
		return awsAwsquery_deserializeErrorInvalidLoadBalancerActionException(response, errorBody)

	case strings.EqualFold("OperationNotPermittedException", errorCode):
		return awsAwsquery_deserializeErrorOperationNotPermittedException(response, errorBody)

	case strings.EqualFold("RuleNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorRuleNotFoundException(response, errorBody)

	case strings.EqualFold("TargetGroupAssociationLimitException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupAssociationLimitException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyActionsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyActionsException(response, errorBody)

	case strings.EqualFold("TooManyRegistrationsForTargetIdException", errorCode):
		return awsAwsquery_deserializeErrorTooManyRegistrationsForTargetIdException(response, errorBody)

	case strings.EqualFold("TooManyTargetsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTargetsException(response, errorBody)

	case strings.EqualFold("TooManyUniqueTargetGroupsPerLoadBalancerException", errorCode):
		return awsAwsquery_deserializeErrorTooManyUniqueTargetGroupsPerLoadBalancerException(response, errorBody)

	case strings.EqualFold("UnsupportedProtocolException", errorCode):
		return awsAwsquery_deserializeErrorUnsupportedProtocolException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpModifyTargetGroup struct {
}

func (*awsAwsquery_deserializeOpModifyTargetGroup) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpModifyTargetGroup) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorModifyTargetGroup(response)
	}
	output := &ModifyTargetGroupOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentModifyTargetGroupOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorModifyTargetGroup(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpModifyTargetGroupAttributes struct {
}

func (*awsAwsquery_deserializeOpModifyTargetGroupAttributes) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpModifyTargetGroupAttributes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorModifyTargetGroupAttributes(response)
	}
	output := &ModifyTargetGroupAttributesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentModifyTargetGroupAttributesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorModifyTargetGroupAttributes(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpRegisterTargets struct {
}

func (*awsAwsquery_deserializeOpRegisterTargets) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpRegisterTargets) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorRegisterTargets(response)
	}
	output := &RegisterTargetsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentRegisterTargetsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorRegisterTargets(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidTargetException", errorCode):
		return awsAwsquery_deserializeErrorInvalidTargetException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyRegistrationsForTargetIdException", errorCode):
		return awsAwsquery_deserializeErrorTooManyRegistrationsForTargetIdException(response, errorBody)

	case strings.EqualFold("TooManyTargetsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTargetsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpRemoveListenerCertificates struct {
}

func (*awsAwsquery_deserializeOpRemoveListenerCertificates) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpRemoveListenerCertificates) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorRemoveListenerCertificates(response)
	}
	output := &RemoveListenerCertificatesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentRemoveListenerCertificatesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorRemoveListenerCertificates(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	case strings.EqualFold("OperationNotPermittedException", errorCode):
		return awsAwsquery_deserializeErrorOperationNotPermittedException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpRemoveTags struct {
}

func (*awsAwsquery_deserializeOpRemoveTags) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpRemoveTags) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorRemoveTags(response)
	}
	output := &RemoveTagsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentRemoveTagsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorRemoveTags(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ListenerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorListenerNotFoundException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	case strings.EqualFold("RuleNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorRuleNotFoundException(response, errorBody)

	case strings.EqualFold("TargetGroupNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorTargetGroupNotFoundException(response, errorBody)

	case strings.EqualFold("TooManyTagsException", errorCode):
		return awsAwsquery_deserializeErrorTooManyTagsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpSetIpAddressType struct {
}

func (*awsAwsquery_deserializeOpSetIpAddressType) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpSetIpAddressType) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorSetIpAddressType(response)
	}
	output := &SetIpAddressTypeOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentSetIpAddressTypeOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorSetIpAddressType(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("InvalidSubnetException", errorCode):
		return awsAwsquery_deserializeErrorInvalidSubnetException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpSetRulePriorities struct {
}

func (*awsAwsquery_deserializeOpSetRulePriorities) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpSetRulePriorities) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorSetRulePriorities(response)
	}
	output := &SetRulePrioritiesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentSetRulePrioritiesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorSetRulePriorities(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("OperationNotPermittedException", errorCode):
		return awsAwsquery_deserializeErrorOperationNotPermittedException(response, errorBody)

	case strings.EqualFold("PriorityInUseException", errorCode):
		return awsAwsquery_deserializeErrorPriorityInUseException(response, errorBody)

	case strings.EqualFold("RuleNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorRuleNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpSetSecurityGroups struct {
}

func (*awsAwsquery_deserializeOpSetSecurityGroups) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpSetSecurityGroups) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorSetSecurityGroups(response)
	}
	output := &SetSecurityGroupsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentSetSecurityGroupsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorSetSecurityGroups(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("InvalidSecurityGroupException", errorCode):
		return awsAwsquery_deserializeErrorInvalidSecurityGroupException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsquery_deserializeOpSetSubnets struct {
}

func (*awsAwsquery_deserializeOpSetSubnets) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpSetSubnets) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorSetSubnets(response)
	}
	output := &SetSubnetsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeOpDocumentSetSubnetsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorSetSubnets(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("AllocationIdNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorAllocationIdNotFoundException(response, errorBody)

	case strings.EqualFold("AvailabilityZoneNotSupportedException", errorCode):
		return awsAwsquery_deserializeErrorAvailabilityZoneNotSupportedException(response, errorBody)

	case strings.EqualFold("InvalidConfigurationRequestException", errorCode):
		return awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response, errorBody)

	case strings.EqualFold("InvalidSubnetException", errorCode):
		return awsAwsquery_deserializeErrorInvalidSubnetException(response, errorBody)

	case strings.EqualFold("LoadBalancerNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response, errorBody)

	case strings.EqualFold("SubnetNotFoundException", errorCode):
		return awsAwsquery_deserializeErrorSubnetNotFoundException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsAwsquery_deserializeErrorAllocationIdNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.AllocationIdNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentAllocationIdNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorALPNPolicyNotSupportedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ALPNPolicyNotSupportedException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentALPNPolicyNotSupportedException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorAvailabilityZoneNotSupportedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.AvailabilityZoneNotSupportedException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentAvailabilityZoneNotSupportedException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorCertificateNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.CertificateNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentCertificateNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorDuplicateListenerException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DuplicateListenerException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDuplicateListenerException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorDuplicateLoadBalancerNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DuplicateLoadBalancerNameException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDuplicateLoadBalancerNameException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorDuplicateTagKeysException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DuplicateTagKeysException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDuplicateTagKeysException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorDuplicateTargetGroupNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DuplicateTargetGroupNameException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentDuplicateTargetGroupNameException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorHealthUnavailableException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.HealthUnavailableException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentHealthUnavailableException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorIncompatibleProtocolsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.IncompatibleProtocolsException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentIncompatibleProtocolsException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorInvalidConfigurationRequestException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidConfigurationRequestException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentInvalidConfigurationRequestException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorInvalidLoadBalancerActionException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidLoadBalancerActionException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentInvalidLoadBalancerActionException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorInvalidSchemeException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidSchemeException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentInvalidSchemeException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorInvalidSecurityGroupException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidSecurityGroupException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentInvalidSecurityGroupException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorInvalidSubnetException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidSubnetException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentInvalidSubnetException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorInvalidTargetException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidTargetException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentInvalidTargetException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorListenerNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ListenerNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentListenerNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorLoadBalancerNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.LoadBalancerNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentLoadBalancerNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorOperationNotPermittedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.OperationNotPermittedException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentOperationNotPermittedException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorPriorityInUseException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.PriorityInUseException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentPriorityInUseException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorResourceInUseException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ResourceInUseException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentResourceInUseException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorRuleNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.RuleNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentRuleNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorSSLPolicyNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.SSLPolicyNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentSSLPolicyNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorSubnetNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.SubnetNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentSubnetNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTargetGroupAssociationLimitException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TargetGroupAssociationLimitException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTargetGroupAssociationLimitException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTargetGroupNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TargetGroupNotFoundException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTargetGroupNotFoundException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyActionsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyActionsException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyActionsException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyCertificatesException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyCertificatesException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyCertificatesException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyListenersException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyListenersException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyListenersException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyLoadBalancersException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyLoadBalancersException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyLoadBalancersException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyRegistrationsForTargetIdException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyRegistrationsForTargetIdException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyRegistrationsForTargetIdException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyRulesException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyRulesException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyRulesException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyTagsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyTagsException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyTagsException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyTargetGroupsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyTargetGroupsException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyTargetGroupsException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyTargetsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyTargetsException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyTargetsException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorTooManyUniqueTargetGroupsPerLoadBalancerException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyUniqueTargetGroupsPerLoadBalancerException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentTooManyUniqueTargetGroupsPerLoadBalancerException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeErrorUnsupportedProtocolException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.UnsupportedProtocolException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsAwsquery_deserializeDocumentUnsupportedProtocolException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsAwsquery_deserializeDocumentAction(v **types.Action, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Action
	if *v == nil {
		sv = &types.Action{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AuthenticateCognitoConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAuthenticateCognitoActionConfig(&sv.AuthenticateCognitoConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("AuthenticateOidcConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAuthenticateOidcActionConfig(&sv.AuthenticateOidcConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("FixedResponseConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentFixedResponseActionConfig(&sv.FixedResponseConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("ForwardConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentForwardActionConfig(&sv.ForwardConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Order", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Order = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("RedirectConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentRedirectActionConfig(&sv.RedirectConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TargetGroupArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TargetGroupArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TargetGroupArn = &xtv
			}

		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.ActionTypeEnum(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentActions(v *[]*types.Action, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Action
	if *v == nil {
		sv = make([]*types.Action, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.Action
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentAction(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentActionsUnwrapped(v *[]*types.Action, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Action
	if *v == nil {
		sv = make([]*types.Action, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Action
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentAction(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentAllocationIdNotFoundException(v **types.AllocationIdNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AllocationIdNotFoundException
	if *v == nil {
		sv = &types.AllocationIdNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAlpnPolicyName(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAlpnPolicyNameUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentALPNPolicyNotSupportedException(v **types.ALPNPolicyNotSupportedException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ALPNPolicyNotSupportedException
	if *v == nil {
		sv = &types.ALPNPolicyNotSupportedException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAuthenticateCognitoActionAuthenticationRequestExtraParams(v *map[string]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv map[string]*string
	if *v == nil {
		sv = make(map[string]*string, 0)
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if strings.EqualFold("entry", t.Name.Local) {
			entryDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAuthenticateCognitoActionAuthenticationRequestExtraParamsUnwrapped(&sv, entryDecoder); err != nil {
				return err
			}
		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAuthenticateCognitoActionAuthenticationRequestExtraParamsUnwrapped(v *map[string]*string, decoder smithyxml.NodeDecoder) error {
	var sv map[string]*string
	if *v == nil {
		sv = make(map[string]*string, 0)
	} else {
		sv = *v
	}

	var ek *string
	var ev *string
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			sv[*ek] = ev
			break
		}
		switch {
		case strings.EqualFold("key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					ek = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				ek = &xtv
			}

		case strings.EqualFold("value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					ev = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				ev = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentAuthenticateCognitoActionConfig(v **types.AuthenticateCognitoActionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AuthenticateCognitoActionConfig
	if *v == nil {
		sv = &types.AuthenticateCognitoActionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AuthenticationRequestExtraParams", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAuthenticateCognitoActionAuthenticationRequestExtraParams(&sv.AuthenticationRequestExtraParams, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("OnUnauthenticatedRequest", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.OnUnauthenticatedRequest = types.AuthenticateCognitoActionConditionalBehaviorEnum(xtv)
			}

		case strings.EqualFold("Scope", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Scope = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Scope = &xtv
			}

		case strings.EqualFold("SessionCookieName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SessionCookieName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SessionCookieName = &xtv
			}

		case strings.EqualFold("SessionTimeout", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.SessionTimeout = &i64
			}

		case strings.EqualFold("UserPoolArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.UserPoolArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.UserPoolArn = &xtv
			}

		case strings.EqualFold("UserPoolClientId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.UserPoolClientId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.UserPoolClientId = &xtv
			}

		case strings.EqualFold("UserPoolDomain", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.UserPoolDomain = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.UserPoolDomain = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAuthenticateOidcActionAuthenticationRequestExtraParams(v *map[string]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv map[string]*string
	if *v == nil {
		sv = make(map[string]*string, 0)
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if strings.EqualFold("entry", t.Name.Local) {
			entryDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAuthenticateOidcActionAuthenticationRequestExtraParamsUnwrapped(&sv, entryDecoder); err != nil {
				return err
			}
		}
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAuthenticateOidcActionAuthenticationRequestExtraParamsUnwrapped(v *map[string]*string, decoder smithyxml.NodeDecoder) error {
	var sv map[string]*string
	if *v == nil {
		sv = make(map[string]*string, 0)
	} else {
		sv = *v
	}

	var ek *string
	var ev *string
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			sv[*ek] = ev
			break
		}
		switch {
		case strings.EqualFold("key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					ek = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				ek = &xtv
			}

		case strings.EqualFold("value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					ev = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				ev = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentAuthenticateOidcActionConfig(v **types.AuthenticateOidcActionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AuthenticateOidcActionConfig
	if *v == nil {
		sv = &types.AuthenticateOidcActionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AuthenticationRequestExtraParams", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAuthenticateOidcActionAuthenticationRequestExtraParams(&sv.AuthenticationRequestExtraParams, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("AuthorizationEndpoint", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.AuthorizationEndpoint = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.AuthorizationEndpoint = &xtv
			}

		case strings.EqualFold("ClientId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ClientId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ClientId = &xtv
			}

		case strings.EqualFold("ClientSecret", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ClientSecret = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ClientSecret = &xtv
			}

		case strings.EqualFold("Issuer", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Issuer = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Issuer = &xtv
			}

		case strings.EqualFold("OnUnauthenticatedRequest", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.OnUnauthenticatedRequest = types.AuthenticateOidcActionConditionalBehaviorEnum(xtv)
			}

		case strings.EqualFold("Scope", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Scope = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Scope = &xtv
			}

		case strings.EqualFold("SessionCookieName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SessionCookieName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SessionCookieName = &xtv
			}

		case strings.EqualFold("SessionTimeout", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.SessionTimeout = &i64
			}

		case strings.EqualFold("TokenEndpoint", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TokenEndpoint = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TokenEndpoint = &xtv
			}

		case strings.EqualFold("UseExistingClientSecret", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected AuthenticateOidcActionUseExistingClientSecret to be of type *bool, got %T instead", val)
				}
				sv.UseExistingClientSecret = &xtv
			}

		case strings.EqualFold("UserInfoEndpoint", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.UserInfoEndpoint = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.UserInfoEndpoint = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAvailabilityZone(v **types.AvailabilityZone, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AvailabilityZone
	if *v == nil {
		sv = &types.AvailabilityZone{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("LoadBalancerAddresses", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLoadBalancerAddresses(&sv.LoadBalancerAddresses, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("SubnetId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SubnetId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SubnetId = &xtv
			}

		case strings.EqualFold("ZoneName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ZoneName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ZoneName = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAvailabilityZoneNotSupportedException(v **types.AvailabilityZoneNotSupportedException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AvailabilityZoneNotSupportedException
	if *v == nil {
		sv = &types.AvailabilityZoneNotSupportedException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAvailabilityZones(v *[]*types.AvailabilityZone, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.AvailabilityZone
	if *v == nil {
		sv = make([]*types.AvailabilityZone, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.AvailabilityZone
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentAvailabilityZone(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentAvailabilityZonesUnwrapped(v *[]*types.AvailabilityZone, decoder smithyxml.NodeDecoder) error {
	var sv []*types.AvailabilityZone
	if *v == nil {
		sv = make([]*types.AvailabilityZone, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.AvailabilityZone
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentAvailabilityZone(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentCertificate(v **types.Certificate, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Certificate
	if *v == nil {
		sv = &types.Certificate{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("CertificateArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CertificateArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CertificateArn = &xtv
			}

		case strings.EqualFold("IsDefault", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Default to be of type *bool, got %T instead", val)
				}
				sv.IsDefault = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentCertificateList(v *[]*types.Certificate, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Certificate
	if *v == nil {
		sv = make([]*types.Certificate, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.Certificate
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentCertificate(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentCertificateListUnwrapped(v *[]*types.Certificate, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Certificate
	if *v == nil {
		sv = make([]*types.Certificate, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Certificate
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentCertificate(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentCertificateNotFoundException(v **types.CertificateNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.CertificateNotFoundException
	if *v == nil {
		sv = &types.CertificateNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentCipher(v **types.Cipher, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Cipher
	if *v == nil {
		sv = &types.Cipher{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("Priority", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Priority = ptr.Int32(int32(i64))
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentCiphers(v *[]*types.Cipher, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Cipher
	if *v == nil {
		sv = make([]*types.Cipher, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.Cipher
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentCipher(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentCiphersUnwrapped(v *[]*types.Cipher, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Cipher
	if *v == nil {
		sv = make([]*types.Cipher, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Cipher
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentCipher(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentDuplicateListenerException(v **types.DuplicateListenerException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DuplicateListenerException
	if *v == nil {
		sv = &types.DuplicateListenerException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDuplicateLoadBalancerNameException(v **types.DuplicateLoadBalancerNameException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DuplicateLoadBalancerNameException
	if *v == nil {
		sv = &types.DuplicateLoadBalancerNameException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDuplicateTagKeysException(v **types.DuplicateTagKeysException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DuplicateTagKeysException
	if *v == nil {
		sv = &types.DuplicateTagKeysException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentDuplicateTargetGroupNameException(v **types.DuplicateTargetGroupNameException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DuplicateTargetGroupNameException
	if *v == nil {
		sv = &types.DuplicateTargetGroupNameException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentFixedResponseActionConfig(v **types.FixedResponseActionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.FixedResponseActionConfig
	if *v == nil {
		sv = &types.FixedResponseActionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ContentType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ContentType = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ContentType = &xtv
			}

		case strings.EqualFold("MessageBody", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MessageBody = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MessageBody = &xtv
			}

		case strings.EqualFold("StatusCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.StatusCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.StatusCode = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentForwardActionConfig(v **types.ForwardActionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ForwardActionConfig
	if *v == nil {
		sv = &types.ForwardActionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TargetGroups", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetGroupList(&sv.TargetGroups, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TargetGroupStickinessConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetGroupStickinessConfig(&sv.TargetGroupStickinessConfig, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentHealthUnavailableException(v **types.HealthUnavailableException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HealthUnavailableException
	if *v == nil {
		sv = &types.HealthUnavailableException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentHostHeaderConditionConfig(v **types.HostHeaderConditionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostHeaderConditionConfig
	if *v == nil {
		sv = &types.HostHeaderConditionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Values", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListOfString(&sv.Values, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentHttpHeaderConditionConfig(v **types.HttpHeaderConditionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HttpHeaderConditionConfig
	if *v == nil {
		sv = &types.HttpHeaderConditionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HttpHeaderName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HttpHeaderName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HttpHeaderName = &xtv
			}

		case strings.EqualFold("Values", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListOfString(&sv.Values, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentHttpRequestMethodConditionConfig(v **types.HttpRequestMethodConditionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HttpRequestMethodConditionConfig
	if *v == nil {
		sv = &types.HttpRequestMethodConditionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Values", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListOfString(&sv.Values, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentIncompatibleProtocolsException(v **types.IncompatibleProtocolsException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.IncompatibleProtocolsException
	if *v == nil {
		sv = &types.IncompatibleProtocolsException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentInvalidConfigurationRequestException(v **types.InvalidConfigurationRequestException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidConfigurationRequestException
	if *v == nil {
		sv = &types.InvalidConfigurationRequestException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentInvalidLoadBalancerActionException(v **types.InvalidLoadBalancerActionException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidLoadBalancerActionException
	if *v == nil {
		sv = &types.InvalidLoadBalancerActionException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentInvalidSchemeException(v **types.InvalidSchemeException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidSchemeException
	if *v == nil {
		sv = &types.InvalidSchemeException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentInvalidSecurityGroupException(v **types.InvalidSecurityGroupException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidSecurityGroupException
	if *v == nil {
		sv = &types.InvalidSecurityGroupException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentInvalidSubnetException(v **types.InvalidSubnetException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidSubnetException
	if *v == nil {
		sv = &types.InvalidSubnetException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentInvalidTargetException(v **types.InvalidTargetException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidTargetException
	if *v == nil {
		sv = &types.InvalidTargetException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLimit(v **types.Limit, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Limit
	if *v == nil {
		sv = &types.Limit{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Max", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Max = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Max = &xtv
			}

		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLimits(v *[]*types.Limit, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Limit
	if *v == nil {
		sv = make([]*types.Limit, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.Limit
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentLimit(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLimitsUnwrapped(v *[]*types.Limit, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Limit
	if *v == nil {
		sv = make([]*types.Limit, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Limit
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentLimit(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentListener(v **types.Listener, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Listener
	if *v == nil {
		sv = &types.Listener{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AlpnPolicy", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAlpnPolicyName(&sv.AlpnPolicy, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Certificates", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentCertificateList(&sv.Certificates, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("DefaultActions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentActions(&sv.DefaultActions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("ListenerArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ListenerArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ListenerArn = &xtv
			}

		case strings.EqualFold("LoadBalancerArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.LoadBalancerArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.LoadBalancerArn = &xtv
			}

		case strings.EqualFold("Port", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Port = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("Protocol", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Protocol = types.ProtocolEnum(xtv)
			}

		case strings.EqualFold("SslPolicy", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SslPolicy = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SslPolicy = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListenerNotFoundException(v **types.ListenerNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ListenerNotFoundException
	if *v == nil {
		sv = &types.ListenerNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListeners(v *[]*types.Listener, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Listener
	if *v == nil {
		sv = make([]*types.Listener, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.Listener
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentListener(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListenersUnwrapped(v *[]*types.Listener, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Listener
	if *v == nil {
		sv = make([]*types.Listener, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Listener
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentListener(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentListOfString(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListOfStringUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentLoadBalancer(v **types.LoadBalancer, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LoadBalancer
	if *v == nil {
		sv = &types.LoadBalancer{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AvailabilityZones", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAvailabilityZones(&sv.AvailabilityZones, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("CanonicalHostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CanonicalHostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CanonicalHostedZoneId = &xtv
			}

		case strings.EqualFold("CreatedTime", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				t, err := smithytime.ParseDateTime(xtv)
				if err != nil {
					return err
				}
				sv.CreatedTime = &t
			}

		case strings.EqualFold("DNSName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.DNSName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DNSName = &xtv
			}

		case strings.EqualFold("IpAddressType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.IpAddressType = types.IpAddressType(xtv)
			}

		case strings.EqualFold("LoadBalancerArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.LoadBalancerArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.LoadBalancerArn = &xtv
			}

		case strings.EqualFold("LoadBalancerName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.LoadBalancerName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.LoadBalancerName = &xtv
			}

		case strings.EqualFold("Scheme", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Scheme = types.LoadBalancerSchemeEnum(xtv)
			}

		case strings.EqualFold("SecurityGroups", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSecurityGroups(&sv.SecurityGroups, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("State", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLoadBalancerState(&sv.State, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.LoadBalancerTypeEnum(xtv)
			}

		case strings.EqualFold("VpcId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.VpcId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.VpcId = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLoadBalancerAddress(v **types.LoadBalancerAddress, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LoadBalancerAddress
	if *v == nil {
		sv = &types.LoadBalancerAddress{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AllocationId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.AllocationId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.AllocationId = &xtv
			}

		case strings.EqualFold("IpAddress", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.IpAddress = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.IpAddress = &xtv
			}

		case strings.EqualFold("PrivateIPv4Address", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.PrivateIPv4Address = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.PrivateIPv4Address = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLoadBalancerAddresses(v *[]*types.LoadBalancerAddress, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.LoadBalancerAddress
	if *v == nil {
		sv = make([]*types.LoadBalancerAddress, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.LoadBalancerAddress
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentLoadBalancerAddress(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLoadBalancerAddressesUnwrapped(v *[]*types.LoadBalancerAddress, decoder smithyxml.NodeDecoder) error {
	var sv []*types.LoadBalancerAddress
	if *v == nil {
		sv = make([]*types.LoadBalancerAddress, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.LoadBalancerAddress
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentLoadBalancerAddress(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentLoadBalancerArns(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLoadBalancerArnsUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentLoadBalancerAttribute(v **types.LoadBalancerAttribute, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LoadBalancerAttribute
	if *v == nil {
		sv = &types.LoadBalancerAttribute{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Key = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Key = &xtv
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Value = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Value = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLoadBalancerAttributes(v *[]*types.LoadBalancerAttribute, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.LoadBalancerAttribute
	if *v == nil {
		sv = make([]*types.LoadBalancerAttribute, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.LoadBalancerAttribute
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentLoadBalancerAttribute(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLoadBalancerAttributesUnwrapped(v *[]*types.LoadBalancerAttribute, decoder smithyxml.NodeDecoder) error {
	var sv []*types.LoadBalancerAttribute
	if *v == nil {
		sv = make([]*types.LoadBalancerAttribute, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.LoadBalancerAttribute
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentLoadBalancerAttribute(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentLoadBalancerNotFoundException(v **types.LoadBalancerNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LoadBalancerNotFoundException
	if *v == nil {
		sv = &types.LoadBalancerNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLoadBalancers(v *[]*types.LoadBalancer, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.LoadBalancer
	if *v == nil {
		sv = make([]*types.LoadBalancer, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.LoadBalancer
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentLoadBalancer(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentLoadBalancersUnwrapped(v *[]*types.LoadBalancer, decoder smithyxml.NodeDecoder) error {
	var sv []*types.LoadBalancer
	if *v == nil {
		sv = make([]*types.LoadBalancer, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.LoadBalancer
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentLoadBalancer(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentLoadBalancerState(v **types.LoadBalancerState, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LoadBalancerState
	if *v == nil {
		sv = &types.LoadBalancerState{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Code", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Code = types.LoadBalancerStateEnum(xtv)
			}

		case strings.EqualFold("Reason", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Reason = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Reason = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentMatcher(v **types.Matcher, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Matcher
	if *v == nil {
		sv = &types.Matcher{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HttpCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HttpCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HttpCode = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentOperationNotPermittedException(v **types.OperationNotPermittedException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.OperationNotPermittedException
	if *v == nil {
		sv = &types.OperationNotPermittedException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentPathPatternConditionConfig(v **types.PathPatternConditionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.PathPatternConditionConfig
	if *v == nil {
		sv = &types.PathPatternConditionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Values", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListOfString(&sv.Values, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentPriorityInUseException(v **types.PriorityInUseException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.PriorityInUseException
	if *v == nil {
		sv = &types.PriorityInUseException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentQueryStringConditionConfig(v **types.QueryStringConditionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.QueryStringConditionConfig
	if *v == nil {
		sv = &types.QueryStringConditionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Values", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentQueryStringKeyValuePairList(&sv.Values, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentQueryStringKeyValuePair(v **types.QueryStringKeyValuePair, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.QueryStringKeyValuePair
	if *v == nil {
		sv = &types.QueryStringKeyValuePair{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Key = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Key = &xtv
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Value = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Value = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentQueryStringKeyValuePairList(v *[]*types.QueryStringKeyValuePair, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.QueryStringKeyValuePair
	if *v == nil {
		sv = make([]*types.QueryStringKeyValuePair, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.QueryStringKeyValuePair
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentQueryStringKeyValuePair(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentQueryStringKeyValuePairListUnwrapped(v *[]*types.QueryStringKeyValuePair, decoder smithyxml.NodeDecoder) error {
	var sv []*types.QueryStringKeyValuePair
	if *v == nil {
		sv = make([]*types.QueryStringKeyValuePair, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.QueryStringKeyValuePair
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentQueryStringKeyValuePair(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentRedirectActionConfig(v **types.RedirectActionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.RedirectActionConfig
	if *v == nil {
		sv = &types.RedirectActionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Host", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Host = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Host = &xtv
			}

		case strings.EqualFold("Path", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Path = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Path = &xtv
			}

		case strings.EqualFold("Port", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Port = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Port = &xtv
			}

		case strings.EqualFold("Protocol", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Protocol = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Protocol = &xtv
			}

		case strings.EqualFold("Query", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Query = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Query = &xtv
			}

		case strings.EqualFold("StatusCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.StatusCode = types.RedirectActionStatusCodeEnum(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentResourceInUseException(v **types.ResourceInUseException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ResourceInUseException
	if *v == nil {
		sv = &types.ResourceInUseException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentRule(v **types.Rule, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Rule
	if *v == nil {
		sv = &types.Rule{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Actions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentActions(&sv.Actions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Conditions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentRuleConditionList(&sv.Conditions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("IsDefault", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected IsDefault to be of type *bool, got %T instead", val)
				}
				sv.IsDefault = &xtv
			}

		case strings.EqualFold("Priority", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Priority = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Priority = &xtv
			}

		case strings.EqualFold("RuleArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.RuleArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.RuleArn = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentRuleCondition(v **types.RuleCondition, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.RuleCondition
	if *v == nil {
		sv = &types.RuleCondition{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Field", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Field = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Field = &xtv
			}

		case strings.EqualFold("HostHeaderConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentHostHeaderConditionConfig(&sv.HostHeaderConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("HttpHeaderConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentHttpHeaderConditionConfig(&sv.HttpHeaderConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("HttpRequestMethodConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentHttpRequestMethodConditionConfig(&sv.HttpRequestMethodConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("PathPatternConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentPathPatternConditionConfig(&sv.PathPatternConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("QueryStringConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentQueryStringConditionConfig(&sv.QueryStringConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("SourceIpConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSourceIpConditionConfig(&sv.SourceIpConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Values", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListOfString(&sv.Values, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentRuleConditionList(v *[]*types.RuleCondition, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.RuleCondition
	if *v == nil {
		sv = make([]*types.RuleCondition, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.RuleCondition
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentRuleCondition(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentRuleConditionListUnwrapped(v *[]*types.RuleCondition, decoder smithyxml.NodeDecoder) error {
	var sv []*types.RuleCondition
	if *v == nil {
		sv = make([]*types.RuleCondition, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.RuleCondition
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentRuleCondition(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentRuleNotFoundException(v **types.RuleNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.RuleNotFoundException
	if *v == nil {
		sv = &types.RuleNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentRules(v *[]*types.Rule, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Rule
	if *v == nil {
		sv = make([]*types.Rule, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.Rule
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentRule(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentRulesUnwrapped(v *[]*types.Rule, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Rule
	if *v == nil {
		sv = make([]*types.Rule, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Rule
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentRule(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentSecurityGroups(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSecurityGroupsUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentSourceIpConditionConfig(v **types.SourceIpConditionConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.SourceIpConditionConfig
	if *v == nil {
		sv = &types.SourceIpConditionConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Values", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListOfString(&sv.Values, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSslPolicies(v *[]*types.SslPolicy, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.SslPolicy
	if *v == nil {
		sv = make([]*types.SslPolicy, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.SslPolicy
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentSslPolicy(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSslPoliciesUnwrapped(v *[]*types.SslPolicy, decoder smithyxml.NodeDecoder) error {
	var sv []*types.SslPolicy
	if *v == nil {
		sv = make([]*types.SslPolicy, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.SslPolicy
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentSslPolicy(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentSslPolicy(v **types.SslPolicy, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.SslPolicy
	if *v == nil {
		sv = &types.SslPolicy{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Ciphers", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentCiphers(&sv.Ciphers, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("SslProtocols", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSslProtocols(&sv.SslProtocols, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSSLPolicyNotFoundException(v **types.SSLPolicyNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.SSLPolicyNotFoundException
	if *v == nil {
		sv = &types.SSLPolicyNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSslProtocols(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSslProtocolsUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentSubnetNotFoundException(v **types.SubnetNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.SubnetNotFoundException
	if *v == nil {
		sv = &types.SubnetNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTag(v **types.Tag, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Tag
	if *v == nil {
		sv = &types.Tag{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Key = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Key = &xtv
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Value = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Value = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTagDescription(v **types.TagDescription, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TagDescription
	if *v == nil {
		sv = &types.TagDescription{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ResourceArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ResourceArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ResourceArn = &xtv
			}

		case strings.EqualFold("Tags", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTagList(&sv.Tags, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTagDescriptions(v *[]*types.TagDescription, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.TagDescription
	if *v == nil {
		sv = make([]*types.TagDescription, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.TagDescription
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentTagDescription(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTagDescriptionsUnwrapped(v *[]*types.TagDescription, decoder smithyxml.NodeDecoder) error {
	var sv []*types.TagDescription
	if *v == nil {
		sv = make([]*types.TagDescription, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.TagDescription
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentTagDescription(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentTagList(v *[]*types.Tag, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Tag
	if *v == nil {
		sv = make([]*types.Tag, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.Tag
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentTag(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTagListUnwrapped(v *[]*types.Tag, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Tag
	if *v == nil {
		sv = make([]*types.Tag, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Tag
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentTag(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentTargetDescription(v **types.TargetDescription, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetDescription
	if *v == nil {
		sv = &types.TargetDescription{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AvailabilityZone", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.AvailabilityZone = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.AvailabilityZone = &xtv
			}

		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		case strings.EqualFold("Port", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Port = ptr.Int32(int32(i64))
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroup(v **types.TargetGroup, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetGroup
	if *v == nil {
		sv = &types.TargetGroup{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthCheckEnabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected HealthCheckEnabled to be of type *bool, got %T instead", val)
				}
				sv.HealthCheckEnabled = &xtv
			}

		case strings.EqualFold("HealthCheckIntervalSeconds", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.HealthCheckIntervalSeconds = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("HealthCheckPath", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HealthCheckPath = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HealthCheckPath = &xtv
			}

		case strings.EqualFold("HealthCheckPort", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HealthCheckPort = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HealthCheckPort = &xtv
			}

		case strings.EqualFold("HealthCheckProtocol", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HealthCheckProtocol = types.ProtocolEnum(xtv)
			}

		case strings.EqualFold("HealthCheckTimeoutSeconds", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.HealthCheckTimeoutSeconds = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("HealthyThresholdCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.HealthyThresholdCount = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("LoadBalancerArns", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLoadBalancerArns(&sv.LoadBalancerArns, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Matcher", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentMatcher(&sv.Matcher, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Port", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Port = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("Protocol", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Protocol = types.ProtocolEnum(xtv)
			}

		case strings.EqualFold("TargetGroupArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TargetGroupArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TargetGroupArn = &xtv
			}

		case strings.EqualFold("TargetGroupName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TargetGroupName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TargetGroupName = &xtv
			}

		case strings.EqualFold("TargetType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TargetType = types.TargetTypeEnum(xtv)
			}

		case strings.EqualFold("UnhealthyThresholdCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.UnhealthyThresholdCount = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("VpcId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.VpcId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.VpcId = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroupAssociationLimitException(v **types.TargetGroupAssociationLimitException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetGroupAssociationLimitException
	if *v == nil {
		sv = &types.TargetGroupAssociationLimitException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroupAttribute(v **types.TargetGroupAttribute, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetGroupAttribute
	if *v == nil {
		sv = &types.TargetGroupAttribute{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Key = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Key = &xtv
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Value = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Value = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroupAttributes(v *[]*types.TargetGroupAttribute, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.TargetGroupAttribute
	if *v == nil {
		sv = make([]*types.TargetGroupAttribute, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.TargetGroupAttribute
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentTargetGroupAttribute(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroupAttributesUnwrapped(v *[]*types.TargetGroupAttribute, decoder smithyxml.NodeDecoder) error {
	var sv []*types.TargetGroupAttribute
	if *v == nil {
		sv = make([]*types.TargetGroupAttribute, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.TargetGroupAttribute
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentTargetGroupAttribute(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentTargetGroupList(v *[]*types.TargetGroupTuple, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.TargetGroupTuple
	if *v == nil {
		sv = make([]*types.TargetGroupTuple, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.TargetGroupTuple
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentTargetGroupTuple(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroupListUnwrapped(v *[]*types.TargetGroupTuple, decoder smithyxml.NodeDecoder) error {
	var sv []*types.TargetGroupTuple
	if *v == nil {
		sv = make([]*types.TargetGroupTuple, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.TargetGroupTuple
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentTargetGroupTuple(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentTargetGroupNotFoundException(v **types.TargetGroupNotFoundException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetGroupNotFoundException
	if *v == nil {
		sv = &types.TargetGroupNotFoundException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroups(v *[]*types.TargetGroup, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.TargetGroup
	if *v == nil {
		sv = make([]*types.TargetGroup, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.TargetGroup
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentTargetGroup(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroupsUnwrapped(v *[]*types.TargetGroup, decoder smithyxml.NodeDecoder) error {
	var sv []*types.TargetGroup
	if *v == nil {
		sv = make([]*types.TargetGroup, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.TargetGroup
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentTargetGroup(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentTargetGroupStickinessConfig(v **types.TargetGroupStickinessConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetGroupStickinessConfig
	if *v == nil {
		sv = &types.TargetGroupStickinessConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("DurationSeconds", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.DurationSeconds = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("Enabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected TargetGroupStickinessEnabled to be of type *bool, got %T instead", val)
				}
				sv.Enabled = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetGroupTuple(v **types.TargetGroupTuple, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetGroupTuple
	if *v == nil {
		sv = &types.TargetGroupTuple{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TargetGroupArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TargetGroupArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TargetGroupArn = &xtv
			}

		case strings.EqualFold("Weight", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Weight = ptr.Int32(int32(i64))
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetHealth(v **types.TargetHealth, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetHealth
	if *v == nil {
		sv = &types.TargetHealth{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Description", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Description = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Description = &xtv
			}

		case strings.EqualFold("Reason", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Reason = types.TargetHealthReasonEnum(xtv)
			}

		case strings.EqualFold("State", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.State = types.TargetHealthStateEnum(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetHealthDescription(v **types.TargetHealthDescription, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TargetHealthDescription
	if *v == nil {
		sv = &types.TargetHealthDescription{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthCheckPort", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HealthCheckPort = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HealthCheckPort = &xtv
			}

		case strings.EqualFold("Target", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetDescription(&sv.Target, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TargetHealth", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetHealth(&sv.TargetHealth, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetHealthDescriptions(v *[]*types.TargetHealthDescription, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.TargetHealthDescription
	if *v == nil {
		sv = make([]*types.TargetHealthDescription, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *types.TargetHealthDescription
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentTargetHealthDescription(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTargetHealthDescriptionsUnwrapped(v *[]*types.TargetHealthDescription, decoder smithyxml.NodeDecoder) error {
	var sv []*types.TargetHealthDescription
	if *v == nil {
		sv = make([]*types.TargetHealthDescription, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.TargetHealthDescription
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsAwsquery_deserializeDocumentTargetHealthDescription(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentTooManyActionsException(v **types.TooManyActionsException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyActionsException
	if *v == nil {
		sv = &types.TooManyActionsException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyCertificatesException(v **types.TooManyCertificatesException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyCertificatesException
	if *v == nil {
		sv = &types.TooManyCertificatesException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyListenersException(v **types.TooManyListenersException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyListenersException
	if *v == nil {
		sv = &types.TooManyListenersException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyLoadBalancersException(v **types.TooManyLoadBalancersException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyLoadBalancersException
	if *v == nil {
		sv = &types.TooManyLoadBalancersException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyRegistrationsForTargetIdException(v **types.TooManyRegistrationsForTargetIdException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyRegistrationsForTargetIdException
	if *v == nil {
		sv = &types.TooManyRegistrationsForTargetIdException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyRulesException(v **types.TooManyRulesException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyRulesException
	if *v == nil {
		sv = &types.TooManyRulesException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyTagsException(v **types.TooManyTagsException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyTagsException
	if *v == nil {
		sv = &types.TooManyTagsException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyTargetGroupsException(v **types.TooManyTargetGroupsException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyTargetGroupsException
	if *v == nil {
		sv = &types.TooManyTargetGroupsException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyTargetsException(v **types.TooManyTargetsException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyTargetsException
	if *v == nil {
		sv = &types.TooManyTargetsException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentTooManyUniqueTargetGroupsPerLoadBalancerException(v **types.TooManyUniqueTargetGroupsPerLoadBalancerException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyUniqueTargetGroupsPerLoadBalancerException
	if *v == nil {
		sv = &types.TooManyUniqueTargetGroupsPerLoadBalancerException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentUnsupportedProtocolException(v **types.UnsupportedProtocolException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.UnsupportedProtocolException
	if *v == nil {
		sv = &types.UnsupportedProtocolException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentAddListenerCertificatesOutput(v **AddListenerCertificatesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *AddListenerCertificatesOutput
	if *v == nil {
		sv = &AddListenerCertificatesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Certificates", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentCertificateList(&sv.Certificates, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentAddTagsOutput(v **AddTagsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *AddTagsOutput
	if *v == nil {
		sv = &AddTagsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentCreateListenerOutput(v **CreateListenerOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateListenerOutput
	if *v == nil {
		sv = &CreateListenerOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Listeners", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListeners(&sv.Listeners, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentCreateLoadBalancerOutput(v **CreateLoadBalancerOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateLoadBalancerOutput
	if *v == nil {
		sv = &CreateLoadBalancerOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("LoadBalancers", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLoadBalancers(&sv.LoadBalancers, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentCreateRuleOutput(v **CreateRuleOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateRuleOutput
	if *v == nil {
		sv = &CreateRuleOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Rules", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentRules(&sv.Rules, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentCreateTargetGroupOutput(v **CreateTargetGroupOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateTargetGroupOutput
	if *v == nil {
		sv = &CreateTargetGroupOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TargetGroups", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetGroups(&sv.TargetGroups, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDeleteListenerOutput(v **DeleteListenerOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteListenerOutput
	if *v == nil {
		sv = &DeleteListenerOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDeleteLoadBalancerOutput(v **DeleteLoadBalancerOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteLoadBalancerOutput
	if *v == nil {
		sv = &DeleteLoadBalancerOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDeleteRuleOutput(v **DeleteRuleOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteRuleOutput
	if *v == nil {
		sv = &DeleteRuleOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDeleteTargetGroupOutput(v **DeleteTargetGroupOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteTargetGroupOutput
	if *v == nil {
		sv = &DeleteTargetGroupOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDeregisterTargetsOutput(v **DeregisterTargetsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeregisterTargetsOutput
	if *v == nil {
		sv = &DeregisterTargetsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeAccountLimitsOutput(v **DescribeAccountLimitsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeAccountLimitsOutput
	if *v == nil {
		sv = &DescribeAccountLimitsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Limits", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLimits(&sv.Limits, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeListenerCertificatesOutput(v **DescribeListenerCertificatesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeListenerCertificatesOutput
	if *v == nil {
		sv = &DescribeListenerCertificatesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Certificates", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentCertificateList(&sv.Certificates, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeListenersOutput(v **DescribeListenersOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeListenersOutput
	if *v == nil {
		sv = &DescribeListenersOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Listeners", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListeners(&sv.Listeners, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeLoadBalancerAttributesOutput(v **DescribeLoadBalancerAttributesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeLoadBalancerAttributesOutput
	if *v == nil {
		sv = &DescribeLoadBalancerAttributesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Attributes", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLoadBalancerAttributes(&sv.Attributes, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeLoadBalancersOutput(v **DescribeLoadBalancersOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeLoadBalancersOutput
	if *v == nil {
		sv = &DescribeLoadBalancersOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("LoadBalancers", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLoadBalancers(&sv.LoadBalancers, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeRulesOutput(v **DescribeRulesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeRulesOutput
	if *v == nil {
		sv = &DescribeRulesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		case strings.EqualFold("Rules", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentRules(&sv.Rules, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeSSLPoliciesOutput(v **DescribeSSLPoliciesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeSSLPoliciesOutput
	if *v == nil {
		sv = &DescribeSSLPoliciesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		case strings.EqualFold("SslPolicies", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSslPolicies(&sv.SslPolicies, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeTagsOutput(v **DescribeTagsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeTagsOutput
	if *v == nil {
		sv = &DescribeTagsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TagDescriptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTagDescriptions(&sv.TagDescriptions, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeTargetGroupAttributesOutput(v **DescribeTargetGroupAttributesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeTargetGroupAttributesOutput
	if *v == nil {
		sv = &DescribeTargetGroupAttributesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Attributes", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetGroupAttributes(&sv.Attributes, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeTargetGroupsOutput(v **DescribeTargetGroupsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeTargetGroupsOutput
	if *v == nil {
		sv = &DescribeTargetGroupsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		case strings.EqualFold("TargetGroups", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetGroups(&sv.TargetGroups, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentDescribeTargetHealthOutput(v **DescribeTargetHealthOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DescribeTargetHealthOutput
	if *v == nil {
		sv = &DescribeTargetHealthOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TargetHealthDescriptions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetHealthDescriptions(&sv.TargetHealthDescriptions, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentModifyListenerOutput(v **ModifyListenerOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ModifyListenerOutput
	if *v == nil {
		sv = &ModifyListenerOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Listeners", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentListeners(&sv.Listeners, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentModifyLoadBalancerAttributesOutput(v **ModifyLoadBalancerAttributesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ModifyLoadBalancerAttributesOutput
	if *v == nil {
		sv = &ModifyLoadBalancerAttributesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Attributes", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentLoadBalancerAttributes(&sv.Attributes, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentModifyRuleOutput(v **ModifyRuleOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ModifyRuleOutput
	if *v == nil {
		sv = &ModifyRuleOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Rules", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentRules(&sv.Rules, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentModifyTargetGroupAttributesOutput(v **ModifyTargetGroupAttributesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ModifyTargetGroupAttributesOutput
	if *v == nil {
		sv = &ModifyTargetGroupAttributesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Attributes", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetGroupAttributes(&sv.Attributes, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentModifyTargetGroupOutput(v **ModifyTargetGroupOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ModifyTargetGroupOutput
	if *v == nil {
		sv = &ModifyTargetGroupOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TargetGroups", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentTargetGroups(&sv.TargetGroups, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentRegisterTargetsOutput(v **RegisterTargetsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *RegisterTargetsOutput
	if *v == nil {
		sv = &RegisterTargetsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentRemoveListenerCertificatesOutput(v **RemoveListenerCertificatesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *RemoveListenerCertificatesOutput
	if *v == nil {
		sv = &RemoveListenerCertificatesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentRemoveTagsOutput(v **RemoveTagsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *RemoveTagsOutput
	if *v == nil {
		sv = &RemoveTagsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentSetIpAddressTypeOutput(v **SetIpAddressTypeOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *SetIpAddressTypeOutput
	if *v == nil {
		sv = &SetIpAddressTypeOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("IpAddressType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.IpAddressType = types.IpAddressType(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentSetRulePrioritiesOutput(v **SetRulePrioritiesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *SetRulePrioritiesOutput
	if *v == nil {
		sv = &SetRulePrioritiesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Rules", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentRules(&sv.Rules, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentSetSecurityGroupsOutput(v **SetSecurityGroupsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *SetSecurityGroupsOutput
	if *v == nil {
		sv = &SetSecurityGroupsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("SecurityGroupIds", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentSecurityGroups(&sv.SecurityGroupIds, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentSetSubnetsOutput(v **SetSubnetsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *SetSubnetsOutput
	if *v == nil {
		sv = &SetSubnetsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AvailabilityZones", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsAwsquery_deserializeDocumentAvailabilityZones(&sv.AvailabilityZones, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}
