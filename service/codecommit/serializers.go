// Code generated by smithy-go-codegen DO NOT EDIT.

package codecommit

import (
	"bytes"
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/codecommit/types"
	smithy "github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/httpbinding"
	smithyjson "github.com/awslabs/smithy-go/json"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

type awsAwsjson11_serializeOpAssociateApprovalRuleTemplateWithRepository struct {
}

func (*awsAwsjson11_serializeOpAssociateApprovalRuleTemplateWithRepository) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpAssociateApprovalRuleTemplateWithRepository) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*AssociateApprovalRuleTemplateWithRepositoryInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.AssociateApprovalRuleTemplateWithRepository")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentAssociateApprovalRuleTemplateWithRepositoryInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpBatchAssociateApprovalRuleTemplateWithRepositories struct {
}

func (*awsAwsjson11_serializeOpBatchAssociateApprovalRuleTemplateWithRepositories) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpBatchAssociateApprovalRuleTemplateWithRepositories) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchAssociateApprovalRuleTemplateWithRepositoriesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.BatchAssociateApprovalRuleTemplateWithRepositories")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentBatchAssociateApprovalRuleTemplateWithRepositoriesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpBatchDescribeMergeConflicts struct {
}

func (*awsAwsjson11_serializeOpBatchDescribeMergeConflicts) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpBatchDescribeMergeConflicts) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchDescribeMergeConflictsInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.BatchDescribeMergeConflicts")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentBatchDescribeMergeConflictsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpBatchDisassociateApprovalRuleTemplateFromRepositories struct {
}

func (*awsAwsjson11_serializeOpBatchDisassociateApprovalRuleTemplateFromRepositories) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpBatchDisassociateApprovalRuleTemplateFromRepositories) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchDisassociateApprovalRuleTemplateFromRepositoriesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.BatchDisassociateApprovalRuleTemplateFromRepositories")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentBatchDisassociateApprovalRuleTemplateFromRepositoriesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpBatchGetCommits struct {
}

func (*awsAwsjson11_serializeOpBatchGetCommits) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpBatchGetCommits) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchGetCommitsInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.BatchGetCommits")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentBatchGetCommitsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpBatchGetRepositories struct {
}

func (*awsAwsjson11_serializeOpBatchGetRepositories) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpBatchGetRepositories) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BatchGetRepositoriesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.BatchGetRepositories")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentBatchGetRepositoriesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpCreateApprovalRuleTemplate struct {
}

func (*awsAwsjson11_serializeOpCreateApprovalRuleTemplate) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpCreateApprovalRuleTemplate) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateApprovalRuleTemplateInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.CreateApprovalRuleTemplate")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentCreateApprovalRuleTemplateInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpCreateBranch struct {
}

func (*awsAwsjson11_serializeOpCreateBranch) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpCreateBranch) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateBranchInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.CreateBranch")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentCreateBranchInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpCreateCommit struct {
}

func (*awsAwsjson11_serializeOpCreateCommit) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpCreateCommit) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateCommitInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.CreateCommit")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentCreateCommitInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpCreatePullRequest struct {
}

func (*awsAwsjson11_serializeOpCreatePullRequest) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpCreatePullRequest) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreatePullRequestInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.CreatePullRequest")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentCreatePullRequestInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpCreatePullRequestApprovalRule struct {
}

func (*awsAwsjson11_serializeOpCreatePullRequestApprovalRule) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpCreatePullRequestApprovalRule) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreatePullRequestApprovalRuleInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.CreatePullRequestApprovalRule")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentCreatePullRequestApprovalRuleInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpCreateRepository struct {
}

func (*awsAwsjson11_serializeOpCreateRepository) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpCreateRepository) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateRepositoryInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.CreateRepository")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentCreateRepositoryInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpCreateUnreferencedMergeCommit struct {
}

func (*awsAwsjson11_serializeOpCreateUnreferencedMergeCommit) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpCreateUnreferencedMergeCommit) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateUnreferencedMergeCommitInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.CreateUnreferencedMergeCommit")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentCreateUnreferencedMergeCommitInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDeleteApprovalRuleTemplate struct {
}

func (*awsAwsjson11_serializeOpDeleteApprovalRuleTemplate) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDeleteApprovalRuleTemplate) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteApprovalRuleTemplateInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DeleteApprovalRuleTemplate")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDeleteApprovalRuleTemplateInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDeleteBranch struct {
}

func (*awsAwsjson11_serializeOpDeleteBranch) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDeleteBranch) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteBranchInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DeleteBranch")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDeleteBranchInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDeleteCommentContent struct {
}

func (*awsAwsjson11_serializeOpDeleteCommentContent) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDeleteCommentContent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteCommentContentInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DeleteCommentContent")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDeleteCommentContentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDeleteFile struct {
}

func (*awsAwsjson11_serializeOpDeleteFile) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDeleteFile) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteFileInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DeleteFile")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDeleteFileInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDeletePullRequestApprovalRule struct {
}

func (*awsAwsjson11_serializeOpDeletePullRequestApprovalRule) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDeletePullRequestApprovalRule) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeletePullRequestApprovalRuleInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DeletePullRequestApprovalRule")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDeletePullRequestApprovalRuleInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDeleteRepository struct {
}

func (*awsAwsjson11_serializeOpDeleteRepository) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDeleteRepository) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteRepositoryInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DeleteRepository")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDeleteRepositoryInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDescribeMergeConflicts struct {
}

func (*awsAwsjson11_serializeOpDescribeMergeConflicts) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDescribeMergeConflicts) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeMergeConflictsInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DescribeMergeConflicts")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDescribeMergeConflictsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDescribePullRequestEvents struct {
}

func (*awsAwsjson11_serializeOpDescribePullRequestEvents) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDescribePullRequestEvents) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribePullRequestEventsInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DescribePullRequestEvents")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDescribePullRequestEventsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpDisassociateApprovalRuleTemplateFromRepository struct {
}

func (*awsAwsjson11_serializeOpDisassociateApprovalRuleTemplateFromRepository) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpDisassociateApprovalRuleTemplateFromRepository) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DisassociateApprovalRuleTemplateFromRepositoryInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.DisassociateApprovalRuleTemplateFromRepository")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentDisassociateApprovalRuleTemplateFromRepositoryInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpEvaluatePullRequestApprovalRules struct {
}

func (*awsAwsjson11_serializeOpEvaluatePullRequestApprovalRules) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpEvaluatePullRequestApprovalRules) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*EvaluatePullRequestApprovalRulesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.EvaluatePullRequestApprovalRules")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentEvaluatePullRequestApprovalRulesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetApprovalRuleTemplate struct {
}

func (*awsAwsjson11_serializeOpGetApprovalRuleTemplate) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetApprovalRuleTemplate) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetApprovalRuleTemplateInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetApprovalRuleTemplate")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetApprovalRuleTemplateInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetBlob struct {
}

func (*awsAwsjson11_serializeOpGetBlob) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetBlob) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetBlobInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetBlob")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetBlobInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetBranch struct {
}

func (*awsAwsjson11_serializeOpGetBranch) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetBranch) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetBranchInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetBranch")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetBranchInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetComment struct {
}

func (*awsAwsjson11_serializeOpGetComment) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetComment) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetCommentInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetComment")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetCommentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetCommentReactions struct {
}

func (*awsAwsjson11_serializeOpGetCommentReactions) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetCommentReactions) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetCommentReactionsInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetCommentReactions")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetCommentReactionsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetCommentsForComparedCommit struct {
}

func (*awsAwsjson11_serializeOpGetCommentsForComparedCommit) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetCommentsForComparedCommit) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetCommentsForComparedCommitInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetCommentsForComparedCommit")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetCommentsForComparedCommitInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetCommentsForPullRequest struct {
}

func (*awsAwsjson11_serializeOpGetCommentsForPullRequest) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetCommentsForPullRequest) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetCommentsForPullRequestInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetCommentsForPullRequest")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetCommentsForPullRequestInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetCommit struct {
}

func (*awsAwsjson11_serializeOpGetCommit) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetCommit) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetCommitInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetCommit")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetCommitInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetDifferences struct {
}

func (*awsAwsjson11_serializeOpGetDifferences) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetDifferences) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetDifferencesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetDifferences")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetDifferencesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetFile struct {
}

func (*awsAwsjson11_serializeOpGetFile) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetFile) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetFileInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetFile")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetFileInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetFolder struct {
}

func (*awsAwsjson11_serializeOpGetFolder) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetFolder) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetFolderInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetFolder")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetFolderInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetMergeCommit struct {
}

func (*awsAwsjson11_serializeOpGetMergeCommit) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetMergeCommit) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetMergeCommitInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetMergeCommit")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetMergeCommitInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetMergeConflicts struct {
}

func (*awsAwsjson11_serializeOpGetMergeConflicts) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetMergeConflicts) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetMergeConflictsInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetMergeConflicts")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetMergeConflictsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetMergeOptions struct {
}

func (*awsAwsjson11_serializeOpGetMergeOptions) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetMergeOptions) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetMergeOptionsInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetMergeOptions")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetMergeOptionsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetPullRequest struct {
}

func (*awsAwsjson11_serializeOpGetPullRequest) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetPullRequest) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetPullRequestInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetPullRequest")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetPullRequestInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetPullRequestApprovalStates struct {
}

func (*awsAwsjson11_serializeOpGetPullRequestApprovalStates) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetPullRequestApprovalStates) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetPullRequestApprovalStatesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetPullRequestApprovalStates")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetPullRequestApprovalStatesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetPullRequestOverrideState struct {
}

func (*awsAwsjson11_serializeOpGetPullRequestOverrideState) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetPullRequestOverrideState) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetPullRequestOverrideStateInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetPullRequestOverrideState")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetPullRequestOverrideStateInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetRepository struct {
}

func (*awsAwsjson11_serializeOpGetRepository) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetRepository) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetRepositoryInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetRepository")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetRepositoryInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpGetRepositoryTriggers struct {
}

func (*awsAwsjson11_serializeOpGetRepositoryTriggers) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpGetRepositoryTriggers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetRepositoryTriggersInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.GetRepositoryTriggers")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentGetRepositoryTriggersInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpListApprovalRuleTemplates struct {
}

func (*awsAwsjson11_serializeOpListApprovalRuleTemplates) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpListApprovalRuleTemplates) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListApprovalRuleTemplatesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.ListApprovalRuleTemplates")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentListApprovalRuleTemplatesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpListAssociatedApprovalRuleTemplatesForRepository struct {
}

func (*awsAwsjson11_serializeOpListAssociatedApprovalRuleTemplatesForRepository) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpListAssociatedApprovalRuleTemplatesForRepository) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListAssociatedApprovalRuleTemplatesForRepositoryInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.ListAssociatedApprovalRuleTemplatesForRepository")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentListAssociatedApprovalRuleTemplatesForRepositoryInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpListBranches struct {
}

func (*awsAwsjson11_serializeOpListBranches) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpListBranches) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListBranchesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.ListBranches")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentListBranchesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpListPullRequests struct {
}

func (*awsAwsjson11_serializeOpListPullRequests) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpListPullRequests) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListPullRequestsInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.ListPullRequests")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentListPullRequestsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpListRepositories struct {
}

func (*awsAwsjson11_serializeOpListRepositories) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpListRepositories) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListRepositoriesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.ListRepositories")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentListRepositoriesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpListRepositoriesForApprovalRuleTemplate struct {
}

func (*awsAwsjson11_serializeOpListRepositoriesForApprovalRuleTemplate) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpListRepositoriesForApprovalRuleTemplate) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListRepositoriesForApprovalRuleTemplateInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.ListRepositoriesForApprovalRuleTemplate")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentListRepositoriesForApprovalRuleTemplateInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpListTagsForResource struct {
}

func (*awsAwsjson11_serializeOpListTagsForResource) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpListTagsForResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListTagsForResourceInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.ListTagsForResource")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentListTagsForResourceInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpMergeBranchesByFastForward struct {
}

func (*awsAwsjson11_serializeOpMergeBranchesByFastForward) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpMergeBranchesByFastForward) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*MergeBranchesByFastForwardInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.MergeBranchesByFastForward")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentMergeBranchesByFastForwardInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpMergeBranchesBySquash struct {
}

func (*awsAwsjson11_serializeOpMergeBranchesBySquash) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpMergeBranchesBySquash) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*MergeBranchesBySquashInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.MergeBranchesBySquash")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentMergeBranchesBySquashInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpMergeBranchesByThreeWay struct {
}

func (*awsAwsjson11_serializeOpMergeBranchesByThreeWay) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpMergeBranchesByThreeWay) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*MergeBranchesByThreeWayInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.MergeBranchesByThreeWay")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentMergeBranchesByThreeWayInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpMergePullRequestByFastForward struct {
}

func (*awsAwsjson11_serializeOpMergePullRequestByFastForward) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpMergePullRequestByFastForward) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*MergePullRequestByFastForwardInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.MergePullRequestByFastForward")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentMergePullRequestByFastForwardInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpMergePullRequestBySquash struct {
}

func (*awsAwsjson11_serializeOpMergePullRequestBySquash) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpMergePullRequestBySquash) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*MergePullRequestBySquashInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.MergePullRequestBySquash")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentMergePullRequestBySquashInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpMergePullRequestByThreeWay struct {
}

func (*awsAwsjson11_serializeOpMergePullRequestByThreeWay) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpMergePullRequestByThreeWay) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*MergePullRequestByThreeWayInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.MergePullRequestByThreeWay")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentMergePullRequestByThreeWayInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpOverridePullRequestApprovalRules struct {
}

func (*awsAwsjson11_serializeOpOverridePullRequestApprovalRules) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpOverridePullRequestApprovalRules) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*OverridePullRequestApprovalRulesInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.OverridePullRequestApprovalRules")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentOverridePullRequestApprovalRulesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpPostCommentForComparedCommit struct {
}

func (*awsAwsjson11_serializeOpPostCommentForComparedCommit) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpPostCommentForComparedCommit) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PostCommentForComparedCommitInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.PostCommentForComparedCommit")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentPostCommentForComparedCommitInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpPostCommentForPullRequest struct {
}

func (*awsAwsjson11_serializeOpPostCommentForPullRequest) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpPostCommentForPullRequest) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PostCommentForPullRequestInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.PostCommentForPullRequest")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentPostCommentForPullRequestInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpPostCommentReply struct {
}

func (*awsAwsjson11_serializeOpPostCommentReply) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpPostCommentReply) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PostCommentReplyInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.PostCommentReply")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentPostCommentReplyInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpPutCommentReaction struct {
}

func (*awsAwsjson11_serializeOpPutCommentReaction) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpPutCommentReaction) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PutCommentReactionInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.PutCommentReaction")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentPutCommentReactionInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpPutFile struct {
}

func (*awsAwsjson11_serializeOpPutFile) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpPutFile) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PutFileInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.PutFile")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentPutFileInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpPutRepositoryTriggers struct {
}

func (*awsAwsjson11_serializeOpPutRepositoryTriggers) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpPutRepositoryTriggers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PutRepositoryTriggersInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.PutRepositoryTriggers")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentPutRepositoryTriggersInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpTagResource struct {
}

func (*awsAwsjson11_serializeOpTagResource) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpTagResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*TagResourceInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.TagResource")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentTagResourceInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpTestRepositoryTriggers struct {
}

func (*awsAwsjson11_serializeOpTestRepositoryTriggers) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpTestRepositoryTriggers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*TestRepositoryTriggersInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.TestRepositoryTriggers")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentTestRepositoryTriggersInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUntagResource struct {
}

func (*awsAwsjson11_serializeOpUntagResource) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUntagResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UntagResourceInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UntagResource")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUntagResourceInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdateApprovalRuleTemplateContent struct {
}

func (*awsAwsjson11_serializeOpUpdateApprovalRuleTemplateContent) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdateApprovalRuleTemplateContent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateApprovalRuleTemplateContentInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdateApprovalRuleTemplateContent")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdateApprovalRuleTemplateContentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdateApprovalRuleTemplateDescription struct {
}

func (*awsAwsjson11_serializeOpUpdateApprovalRuleTemplateDescription) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdateApprovalRuleTemplateDescription) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateApprovalRuleTemplateDescriptionInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdateApprovalRuleTemplateDescription")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdateApprovalRuleTemplateDescriptionInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdateApprovalRuleTemplateName struct {
}

func (*awsAwsjson11_serializeOpUpdateApprovalRuleTemplateName) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdateApprovalRuleTemplateName) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateApprovalRuleTemplateNameInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdateApprovalRuleTemplateName")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdateApprovalRuleTemplateNameInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdateComment struct {
}

func (*awsAwsjson11_serializeOpUpdateComment) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdateComment) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateCommentInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdateComment")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdateCommentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdateDefaultBranch struct {
}

func (*awsAwsjson11_serializeOpUpdateDefaultBranch) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdateDefaultBranch) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateDefaultBranchInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdateDefaultBranch")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdateDefaultBranchInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdatePullRequestApprovalRuleContent struct {
}

func (*awsAwsjson11_serializeOpUpdatePullRequestApprovalRuleContent) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdatePullRequestApprovalRuleContent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdatePullRequestApprovalRuleContentInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdatePullRequestApprovalRuleContent")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdatePullRequestApprovalRuleContentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdatePullRequestApprovalState struct {
}

func (*awsAwsjson11_serializeOpUpdatePullRequestApprovalState) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdatePullRequestApprovalState) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdatePullRequestApprovalStateInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdatePullRequestApprovalState")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdatePullRequestApprovalStateInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdatePullRequestDescription struct {
}

func (*awsAwsjson11_serializeOpUpdatePullRequestDescription) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdatePullRequestDescription) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdatePullRequestDescriptionInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdatePullRequestDescription")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdatePullRequestDescriptionInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdatePullRequestStatus struct {
}

func (*awsAwsjson11_serializeOpUpdatePullRequestStatus) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdatePullRequestStatus) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdatePullRequestStatusInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdatePullRequestStatus")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdatePullRequestStatusInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdatePullRequestTitle struct {
}

func (*awsAwsjson11_serializeOpUpdatePullRequestTitle) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdatePullRequestTitle) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdatePullRequestTitleInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdatePullRequestTitle")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdatePullRequestTitleInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdateRepositoryDescription struct {
}

func (*awsAwsjson11_serializeOpUpdateRepositoryDescription) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdateRepositoryDescription) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateRepositoryDescriptionInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdateRepositoryDescription")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdateRepositoryDescriptionInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}

type awsAwsjson11_serializeOpUpdateRepositoryName struct {
}

func (*awsAwsjson11_serializeOpUpdateRepositoryName) ID() string {
	return "OperationSerializer"
}

func (m *awsAwsjson11_serializeOpUpdateRepositoryName) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateRepositoryNameInput)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	request.Request.URL.Path = "/"
	request.Request.Method = "POST"
	httpBindingEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	httpBindingEncoder.SetHeader("Content-Type").String("application/x-amz-json-1.1")
	httpBindingEncoder.SetHeader("X-Amz-Target").String("CodeCommit_20150413.UpdateRepositoryName")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsAwsjson11_serializeDocumentUpdateRepositoryNameInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = httpBindingEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsAwsjson11_serializeDocumentBranchNameList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsAwsjson11_serializeDocumentCommitIdsInputList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsAwsjson11_serializeDocumentConflictResolution(v *types.ConflictResolution, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DeleteFiles != nil {
		ok := object.Key("deleteFiles")
		if err := awsAwsjson11_serializeDocumentDeleteFileEntries(v.DeleteFiles, ok); err != nil {
			return err
		}
	}

	if v.ReplaceContents != nil {
		ok := object.Key("replaceContents")
		if err := awsAwsjson11_serializeDocumentReplaceContentEntries(v.ReplaceContents, ok); err != nil {
			return err
		}
	}

	if v.SetFileModes != nil {
		ok := object.Key("setFileModes")
		if err := awsAwsjson11_serializeDocumentSetFileModeEntries(v.SetFileModes, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentDeleteFileEntries(v []*types.DeleteFileEntry, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsAwsjson11_serializeDocumentDeleteFileEntry(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsAwsjson11_serializeDocumentDeleteFileEntry(v *types.DeleteFileEntry, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	return nil
}

func awsAwsjson11_serializeDocumentFilePaths(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsAwsjson11_serializeDocumentLocation(v *types.Location, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	if v.FilePosition != nil {
		ok := object.Key("filePosition")
		ok.Long(*v.FilePosition)
	}

	if len(v.RelativeFileVersion) > 0 {
		ok := object.Key("relativeFileVersion")
		ok.String(string(v.RelativeFileVersion))
	}

	return nil
}

func awsAwsjson11_serializeDocumentPutFileEntries(v []*types.PutFileEntry, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsAwsjson11_serializeDocumentPutFileEntry(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsAwsjson11_serializeDocumentPutFileEntry(v *types.PutFileEntry, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.FileContent != nil {
		ok := object.Key("fileContent")
		ok.Base64EncodeBytes(v.FileContent)
	}

	if len(v.FileMode) > 0 {
		ok := object.Key("fileMode")
		ok.String(string(v.FileMode))
	}

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	if v.SourceFile != nil {
		ok := object.Key("sourceFile")
		if err := awsAwsjson11_serializeDocumentSourceFileSpecifier(v.SourceFile, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentReplaceContentEntries(v []*types.ReplaceContentEntry, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsAwsjson11_serializeDocumentReplaceContentEntry(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsAwsjson11_serializeDocumentReplaceContentEntry(v *types.ReplaceContentEntry, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Content != nil {
		ok := object.Key("content")
		ok.Base64EncodeBytes(v.Content)
	}

	if len(v.FileMode) > 0 {
		ok := object.Key("fileMode")
		ok.String(string(v.FileMode))
	}

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	if len(v.ReplacementType) > 0 {
		ok := object.Key("replacementType")
		ok.String(string(v.ReplacementType))
	}

	return nil
}

func awsAwsjson11_serializeDocumentRepositoryNameList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsAwsjson11_serializeDocumentRepositoryTrigger(v *types.RepositoryTrigger, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Branches != nil {
		ok := object.Key("branches")
		if err := awsAwsjson11_serializeDocumentBranchNameList(v.Branches, ok); err != nil {
			return err
		}
	}

	if v.CustomData != nil {
		ok := object.Key("customData")
		ok.String(*v.CustomData)
	}

	if v.DestinationArn != nil {
		ok := object.Key("destinationArn")
		ok.String(*v.DestinationArn)
	}

	if v.Events != nil {
		ok := object.Key("events")
		if err := awsAwsjson11_serializeDocumentRepositoryTriggerEventList(v.Events, ok); err != nil {
			return err
		}
	}

	if v.Name != nil {
		ok := object.Key("name")
		ok.String(*v.Name)
	}

	return nil
}

func awsAwsjson11_serializeDocumentRepositoryTriggerEventList(v []types.RepositoryTriggerEventEnum, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		av.String(string(v[i]))
	}
	return nil
}

func awsAwsjson11_serializeDocumentRepositoryTriggersList(v []*types.RepositoryTrigger, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsAwsjson11_serializeDocumentRepositoryTrigger(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsAwsjson11_serializeDocumentSetFileModeEntries(v []*types.SetFileModeEntry, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsAwsjson11_serializeDocumentSetFileModeEntry(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsAwsjson11_serializeDocumentSetFileModeEntry(v *types.SetFileModeEntry, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.FileMode) > 0 {
		ok := object.Key("fileMode")
		ok.String(string(v.FileMode))
	}

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	return nil
}

func awsAwsjson11_serializeDocumentSourceFileSpecifier(v *types.SourceFileSpecifier, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	if v.IsMove != nil {
		ok := object.Key("isMove")
		ok.Boolean(*v.IsMove)
	}

	return nil
}

func awsAwsjson11_serializeDocumentTagKeysList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsAwsjson11_serializeDocumentTagsMap(v map[string]*string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		if vv := v[key]; vv == nil {
			om.Null()
			continue
		}
		om.String(*v[key])
	}
	return nil
}

func awsAwsjson11_serializeDocumentTarget(v *types.Target, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DestinationReference != nil {
		ok := object.Key("destinationReference")
		ok.String(*v.DestinationReference)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceReference != nil {
		ok := object.Key("sourceReference")
		ok.String(*v.SourceReference)
	}

	return nil
}

func awsAwsjson11_serializeDocumentTargetList(v []*types.Target, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsAwsjson11_serializeDocumentTarget(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsAwsjson11_serializeDocumentAssociateApprovalRuleTemplateWithRepositoryInput(v *AssociateApprovalRuleTemplateWithRepositoryInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentBatchAssociateApprovalRuleTemplateWithRepositoriesInput(v *BatchAssociateApprovalRuleTemplateWithRepositoriesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	if v.RepositoryNames != nil {
		ok := object.Key("repositoryNames")
		if err := awsAwsjson11_serializeDocumentRepositoryNameList(v.RepositoryNames, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentBatchDescribeMergeConflictsInput(v *BatchDescribeMergeConflictsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.FilePaths != nil {
		ok := object.Key("filePaths")
		if err := awsAwsjson11_serializeDocumentFilePaths(v.FilePaths, ok); err != nil {
			return err
		}
	}

	if v.MaxConflictFiles != nil {
		ok := object.Key("maxConflictFiles")
		ok.Integer(*v.MaxConflictFiles)
	}

	if v.MaxMergeHunks != nil {
		ok := object.Key("maxMergeHunks")
		ok.Integer(*v.MaxMergeHunks)
	}

	if len(v.MergeOption) > 0 {
		ok := object.Key("mergeOption")
		ok.String(string(v.MergeOption))
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	return nil
}

func awsAwsjson11_serializeDocumentBatchDisassociateApprovalRuleTemplateFromRepositoriesInput(v *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	if v.RepositoryNames != nil {
		ok := object.Key("repositoryNames")
		if err := awsAwsjson11_serializeDocumentRepositoryNameList(v.RepositoryNames, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentBatchGetCommitsInput(v *BatchGetCommitsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommitIds != nil {
		ok := object.Key("commitIds")
		if err := awsAwsjson11_serializeDocumentCommitIdsInputList(v.CommitIds, ok); err != nil {
			return err
		}
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentBatchGetRepositoriesInput(v *BatchGetRepositoriesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RepositoryNames != nil {
		ok := object.Key("repositoryNames")
		if err := awsAwsjson11_serializeDocumentRepositoryNameList(v.RepositoryNames, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentCreateApprovalRuleTemplateInput(v *CreateApprovalRuleTemplateInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateContent != nil {
		ok := object.Key("approvalRuleTemplateContent")
		ok.String(*v.ApprovalRuleTemplateContent)
	}

	if v.ApprovalRuleTemplateDescription != nil {
		ok := object.Key("approvalRuleTemplateDescription")
		ok.String(*v.ApprovalRuleTemplateDescription)
	}

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentCreateBranchInput(v *CreateBranchInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BranchName != nil {
		ok := object.Key("branchName")
		ok.String(*v.BranchName)
	}

	if v.CommitId != nil {
		ok := object.Key("commitId")
		ok.String(*v.CommitId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentCreateCommitInput(v *CreateCommitInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AuthorName != nil {
		ok := object.Key("authorName")
		ok.String(*v.AuthorName)
	}

	if v.BranchName != nil {
		ok := object.Key("branchName")
		ok.String(*v.BranchName)
	}

	if v.CommitMessage != nil {
		ok := object.Key("commitMessage")
		ok.String(*v.CommitMessage)
	}

	if v.DeleteFiles != nil {
		ok := object.Key("deleteFiles")
		if err := awsAwsjson11_serializeDocumentDeleteFileEntries(v.DeleteFiles, ok); err != nil {
			return err
		}
	}

	if v.Email != nil {
		ok := object.Key("email")
		ok.String(*v.Email)
	}

	if v.KeepEmptyFolders != nil {
		ok := object.Key("keepEmptyFolders")
		ok.Boolean(*v.KeepEmptyFolders)
	}

	if v.ParentCommitId != nil {
		ok := object.Key("parentCommitId")
		ok.String(*v.ParentCommitId)
	}

	if v.PutFiles != nil {
		ok := object.Key("putFiles")
		if err := awsAwsjson11_serializeDocumentPutFileEntries(v.PutFiles, ok); err != nil {
			return err
		}
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SetFileModes != nil {
		ok := object.Key("setFileModes")
		if err := awsAwsjson11_serializeDocumentSetFileModeEntries(v.SetFileModes, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentCreatePullRequestApprovalRuleInput(v *CreatePullRequestApprovalRuleInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleContent != nil {
		ok := object.Key("approvalRuleContent")
		ok.String(*v.ApprovalRuleContent)
	}

	if v.ApprovalRuleName != nil {
		ok := object.Key("approvalRuleName")
		ok.String(*v.ApprovalRuleName)
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentCreatePullRequestInput(v *CreatePullRequestInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ClientRequestToken != nil {
		ok := object.Key("clientRequestToken")
		ok.String(*v.ClientRequestToken)
	}

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.Targets != nil {
		ok := object.Key("targets")
		if err := awsAwsjson11_serializeDocumentTargetList(v.Targets, ok); err != nil {
			return err
		}
	}

	if v.Title != nil {
		ok := object.Key("title")
		ok.String(*v.Title)
	}

	return nil
}

func awsAwsjson11_serializeDocumentCreateRepositoryInput(v *CreateRepositoryInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RepositoryDescription != nil {
		ok := object.Key("repositoryDescription")
		ok.String(*v.RepositoryDescription)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.Tags != nil {
		ok := object.Key("tags")
		if err := awsAwsjson11_serializeDocumentTagsMap(v.Tags, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentCreateUnreferencedMergeCommitInput(v *CreateUnreferencedMergeCommitInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AuthorName != nil {
		ok := object.Key("authorName")
		ok.String(*v.AuthorName)
	}

	if v.CommitMessage != nil {
		ok := object.Key("commitMessage")
		ok.String(*v.CommitMessage)
	}

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if v.ConflictResolution != nil {
		ok := object.Key("conflictResolution")
		if err := awsAwsjson11_serializeDocumentConflictResolution(v.ConflictResolution, ok); err != nil {
			return err
		}
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.Email != nil {
		ok := object.Key("email")
		ok.String(*v.Email)
	}

	if v.KeepEmptyFolders != nil {
		ok := object.Key("keepEmptyFolders")
		ok.Boolean(*v.KeepEmptyFolders)
	}

	if len(v.MergeOption) > 0 {
		ok := object.Key("mergeOption")
		ok.String(string(v.MergeOption))
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDeleteApprovalRuleTemplateInput(v *DeleteApprovalRuleTemplateInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDeleteBranchInput(v *DeleteBranchInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BranchName != nil {
		ok := object.Key("branchName")
		ok.String(*v.BranchName)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDeleteCommentContentInput(v *DeleteCommentContentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommentId != nil {
		ok := object.Key("commentId")
		ok.String(*v.CommentId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDeleteFileInput(v *DeleteFileInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BranchName != nil {
		ok := object.Key("branchName")
		ok.String(*v.BranchName)
	}

	if v.CommitMessage != nil {
		ok := object.Key("commitMessage")
		ok.String(*v.CommitMessage)
	}

	if v.Email != nil {
		ok := object.Key("email")
		ok.String(*v.Email)
	}

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	if v.KeepEmptyFolders != nil {
		ok := object.Key("keepEmptyFolders")
		ok.Boolean(*v.KeepEmptyFolders)
	}

	if v.Name != nil {
		ok := object.Key("name")
		ok.String(*v.Name)
	}

	if v.ParentCommitId != nil {
		ok := object.Key("parentCommitId")
		ok.String(*v.ParentCommitId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDeletePullRequestApprovalRuleInput(v *DeletePullRequestApprovalRuleInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleName != nil {
		ok := object.Key("approvalRuleName")
		ok.String(*v.ApprovalRuleName)
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDeleteRepositoryInput(v *DeleteRepositoryInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDescribeMergeConflictsInput(v *DescribeMergeConflictsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	if v.MaxMergeHunks != nil {
		ok := object.Key("maxMergeHunks")
		ok.Integer(*v.MaxMergeHunks)
	}

	if len(v.MergeOption) > 0 {
		ok := object.Key("mergeOption")
		ok.String(string(v.MergeOption))
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDescribePullRequestEventsInput(v *DescribePullRequestEventsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ActorArn != nil {
		ok := object.Key("actorArn")
		ok.String(*v.ActorArn)
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if len(v.PullRequestEventType) > 0 {
		ok := object.Key("pullRequestEventType")
		ok.String(string(v.PullRequestEventType))
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentDisassociateApprovalRuleTemplateFromRepositoryInput(v *DisassociateApprovalRuleTemplateFromRepositoryInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentEvaluatePullRequestApprovalRulesInput(v *EvaluatePullRequestApprovalRulesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RevisionId != nil {
		ok := object.Key("revisionId")
		ok.String(*v.RevisionId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetApprovalRuleTemplateInput(v *GetApprovalRuleTemplateInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetBlobInput(v *GetBlobInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BlobId != nil {
		ok := object.Key("blobId")
		ok.String(*v.BlobId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetBranchInput(v *GetBranchInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BranchName != nil {
		ok := object.Key("branchName")
		ok.String(*v.BranchName)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetCommentInput(v *GetCommentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommentId != nil {
		ok := object.Key("commentId")
		ok.String(*v.CommentId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetCommentReactionsInput(v *GetCommentReactionsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommentId != nil {
		ok := object.Key("commentId")
		ok.String(*v.CommentId)
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.ReactionUserArn != nil {
		ok := object.Key("reactionUserArn")
		ok.String(*v.ReactionUserArn)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetCommentsForComparedCommitInput(v *GetCommentsForComparedCommitInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AfterCommitId != nil {
		ok := object.Key("afterCommitId")
		ok.String(*v.AfterCommitId)
	}

	if v.BeforeCommitId != nil {
		ok := object.Key("beforeCommitId")
		ok.String(*v.BeforeCommitId)
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetCommentsForPullRequestInput(v *GetCommentsForPullRequestInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AfterCommitId != nil {
		ok := object.Key("afterCommitId")
		ok.String(*v.AfterCommitId)
	}

	if v.BeforeCommitId != nil {
		ok := object.Key("beforeCommitId")
		ok.String(*v.BeforeCommitId)
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetCommitInput(v *GetCommitInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommitId != nil {
		ok := object.Key("commitId")
		ok.String(*v.CommitId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetDifferencesInput(v *GetDifferencesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AfterCommitSpecifier != nil {
		ok := object.Key("afterCommitSpecifier")
		ok.String(*v.AfterCommitSpecifier)
	}

	if v.AfterPath != nil {
		ok := object.Key("afterPath")
		ok.String(*v.AfterPath)
	}

	if v.BeforeCommitSpecifier != nil {
		ok := object.Key("beforeCommitSpecifier")
		ok.String(*v.BeforeCommitSpecifier)
	}

	if v.BeforePath != nil {
		ok := object.Key("beforePath")
		ok.String(*v.BeforePath)
	}

	if v.MaxResults != nil {
		ok := object.Key("MaxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("NextToken")
		ok.String(*v.NextToken)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetFileInput(v *GetFileInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommitSpecifier != nil {
		ok := object.Key("commitSpecifier")
		ok.String(*v.CommitSpecifier)
	}

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetFolderInput(v *GetFolderInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommitSpecifier != nil {
		ok := object.Key("commitSpecifier")
		ok.String(*v.CommitSpecifier)
	}

	if v.FolderPath != nil {
		ok := object.Key("folderPath")
		ok.String(*v.FolderPath)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetMergeCommitInput(v *GetMergeCommitInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetMergeConflictsInput(v *GetMergeConflictsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.MaxConflictFiles != nil {
		ok := object.Key("maxConflictFiles")
		ok.Integer(*v.MaxConflictFiles)
	}

	if len(v.MergeOption) > 0 {
		ok := object.Key("mergeOption")
		ok.String(string(v.MergeOption))
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetMergeOptionsInput(v *GetMergeOptionsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetPullRequestApprovalStatesInput(v *GetPullRequestApprovalStatesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RevisionId != nil {
		ok := object.Key("revisionId")
		ok.String(*v.RevisionId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetPullRequestInput(v *GetPullRequestInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetPullRequestOverrideStateInput(v *GetPullRequestOverrideStateInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RevisionId != nil {
		ok := object.Key("revisionId")
		ok.String(*v.RevisionId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetRepositoryInput(v *GetRepositoryInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentGetRepositoryTriggersInput(v *GetRepositoryTriggersInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentListApprovalRuleTemplatesInput(v *ListApprovalRuleTemplatesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	return nil
}

func awsAwsjson11_serializeDocumentListAssociatedApprovalRuleTemplatesForRepositoryInput(v *ListAssociatedApprovalRuleTemplatesForRepositoryInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentListBranchesInput(v *ListBranchesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentListPullRequestsInput(v *ListPullRequestsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AuthorArn != nil {
		ok := object.Key("authorArn")
		ok.String(*v.AuthorArn)
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if len(v.PullRequestStatus) > 0 {
		ok := object.Key("pullRequestStatus")
		ok.String(string(v.PullRequestStatus))
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentListRepositoriesForApprovalRuleTemplateInput(v *ListRepositoriesForApprovalRuleTemplateInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	return nil
}

func awsAwsjson11_serializeDocumentListRepositoriesInput(v *ListRepositoriesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	if len(v.SortBy) > 0 {
		ok := object.Key("sortBy")
		ok.String(string(v.SortBy))
	}

	return nil
}

func awsAwsjson11_serializeDocumentListTagsForResourceInput(v *ListTagsForResourceInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.ResourceArn != nil {
		ok := object.Key("resourceArn")
		ok.String(*v.ResourceArn)
	}

	return nil
}

func awsAwsjson11_serializeDocumentMergeBranchesByFastForwardInput(v *MergeBranchesByFastForwardInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	if v.TargetBranch != nil {
		ok := object.Key("targetBranch")
		ok.String(*v.TargetBranch)
	}

	return nil
}

func awsAwsjson11_serializeDocumentMergeBranchesBySquashInput(v *MergeBranchesBySquashInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AuthorName != nil {
		ok := object.Key("authorName")
		ok.String(*v.AuthorName)
	}

	if v.CommitMessage != nil {
		ok := object.Key("commitMessage")
		ok.String(*v.CommitMessage)
	}

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if v.ConflictResolution != nil {
		ok := object.Key("conflictResolution")
		if err := awsAwsjson11_serializeDocumentConflictResolution(v.ConflictResolution, ok); err != nil {
			return err
		}
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.Email != nil {
		ok := object.Key("email")
		ok.String(*v.Email)
	}

	if v.KeepEmptyFolders != nil {
		ok := object.Key("keepEmptyFolders")
		ok.Boolean(*v.KeepEmptyFolders)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	if v.TargetBranch != nil {
		ok := object.Key("targetBranch")
		ok.String(*v.TargetBranch)
	}

	return nil
}

func awsAwsjson11_serializeDocumentMergeBranchesByThreeWayInput(v *MergeBranchesByThreeWayInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AuthorName != nil {
		ok := object.Key("authorName")
		ok.String(*v.AuthorName)
	}

	if v.CommitMessage != nil {
		ok := object.Key("commitMessage")
		ok.String(*v.CommitMessage)
	}

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if v.ConflictResolution != nil {
		ok := object.Key("conflictResolution")
		if err := awsAwsjson11_serializeDocumentConflictResolution(v.ConflictResolution, ok); err != nil {
			return err
		}
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.DestinationCommitSpecifier != nil {
		ok := object.Key("destinationCommitSpecifier")
		ok.String(*v.DestinationCommitSpecifier)
	}

	if v.Email != nil {
		ok := object.Key("email")
		ok.String(*v.Email)
	}

	if v.KeepEmptyFolders != nil {
		ok := object.Key("keepEmptyFolders")
		ok.Boolean(*v.KeepEmptyFolders)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitSpecifier != nil {
		ok := object.Key("sourceCommitSpecifier")
		ok.String(*v.SourceCommitSpecifier)
	}

	if v.TargetBranch != nil {
		ok := object.Key("targetBranch")
		ok.String(*v.TargetBranch)
	}

	return nil
}

func awsAwsjson11_serializeDocumentMergePullRequestByFastForwardInput(v *MergePullRequestByFastForwardInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitId != nil {
		ok := object.Key("sourceCommitId")
		ok.String(*v.SourceCommitId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentMergePullRequestBySquashInput(v *MergePullRequestBySquashInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AuthorName != nil {
		ok := object.Key("authorName")
		ok.String(*v.AuthorName)
	}

	if v.CommitMessage != nil {
		ok := object.Key("commitMessage")
		ok.String(*v.CommitMessage)
	}

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if v.ConflictResolution != nil {
		ok := object.Key("conflictResolution")
		if err := awsAwsjson11_serializeDocumentConflictResolution(v.ConflictResolution, ok); err != nil {
			return err
		}
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.Email != nil {
		ok := object.Key("email")
		ok.String(*v.Email)
	}

	if v.KeepEmptyFolders != nil {
		ok := object.Key("keepEmptyFolders")
		ok.Boolean(*v.KeepEmptyFolders)
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitId != nil {
		ok := object.Key("sourceCommitId")
		ok.String(*v.SourceCommitId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentMergePullRequestByThreeWayInput(v *MergePullRequestByThreeWayInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AuthorName != nil {
		ok := object.Key("authorName")
		ok.String(*v.AuthorName)
	}

	if v.CommitMessage != nil {
		ok := object.Key("commitMessage")
		ok.String(*v.CommitMessage)
	}

	if len(v.ConflictDetailLevel) > 0 {
		ok := object.Key("conflictDetailLevel")
		ok.String(string(v.ConflictDetailLevel))
	}

	if v.ConflictResolution != nil {
		ok := object.Key("conflictResolution")
		if err := awsAwsjson11_serializeDocumentConflictResolution(v.ConflictResolution, ok); err != nil {
			return err
		}
	}

	if len(v.ConflictResolutionStrategy) > 0 {
		ok := object.Key("conflictResolutionStrategy")
		ok.String(string(v.ConflictResolutionStrategy))
	}

	if v.Email != nil {
		ok := object.Key("email")
		ok.String(*v.Email)
	}

	if v.KeepEmptyFolders != nil {
		ok := object.Key("keepEmptyFolders")
		ok.Boolean(*v.KeepEmptyFolders)
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.SourceCommitId != nil {
		ok := object.Key("sourceCommitId")
		ok.String(*v.SourceCommitId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentOverridePullRequestApprovalRulesInput(v *OverridePullRequestApprovalRulesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.OverrideStatus) > 0 {
		ok := object.Key("overrideStatus")
		ok.String(string(v.OverrideStatus))
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RevisionId != nil {
		ok := object.Key("revisionId")
		ok.String(*v.RevisionId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentPostCommentForComparedCommitInput(v *PostCommentForComparedCommitInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AfterCommitId != nil {
		ok := object.Key("afterCommitId")
		ok.String(*v.AfterCommitId)
	}

	if v.BeforeCommitId != nil {
		ok := object.Key("beforeCommitId")
		ok.String(*v.BeforeCommitId)
	}

	if v.ClientRequestToken != nil {
		ok := object.Key("clientRequestToken")
		ok.String(*v.ClientRequestToken)
	}

	if v.Content != nil {
		ok := object.Key("content")
		ok.String(*v.Content)
	}

	if v.Location != nil {
		ok := object.Key("location")
		if err := awsAwsjson11_serializeDocumentLocation(v.Location, ok); err != nil {
			return err
		}
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentPostCommentForPullRequestInput(v *PostCommentForPullRequestInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AfterCommitId != nil {
		ok := object.Key("afterCommitId")
		ok.String(*v.AfterCommitId)
	}

	if v.BeforeCommitId != nil {
		ok := object.Key("beforeCommitId")
		ok.String(*v.BeforeCommitId)
	}

	if v.ClientRequestToken != nil {
		ok := object.Key("clientRequestToken")
		ok.String(*v.ClientRequestToken)
	}

	if v.Content != nil {
		ok := object.Key("content")
		ok.String(*v.Content)
	}

	if v.Location != nil {
		ok := object.Key("location")
		if err := awsAwsjson11_serializeDocumentLocation(v.Location, ok); err != nil {
			return err
		}
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentPostCommentReplyInput(v *PostCommentReplyInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ClientRequestToken != nil {
		ok := object.Key("clientRequestToken")
		ok.String(*v.ClientRequestToken)
	}

	if v.Content != nil {
		ok := object.Key("content")
		ok.String(*v.Content)
	}

	if v.InReplyTo != nil {
		ok := object.Key("inReplyTo")
		ok.String(*v.InReplyTo)
	}

	return nil
}

func awsAwsjson11_serializeDocumentPutCommentReactionInput(v *PutCommentReactionInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommentId != nil {
		ok := object.Key("commentId")
		ok.String(*v.CommentId)
	}

	if v.ReactionValue != nil {
		ok := object.Key("reactionValue")
		ok.String(*v.ReactionValue)
	}

	return nil
}

func awsAwsjson11_serializeDocumentPutFileInput(v *PutFileInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BranchName != nil {
		ok := object.Key("branchName")
		ok.String(*v.BranchName)
	}

	if v.CommitMessage != nil {
		ok := object.Key("commitMessage")
		ok.String(*v.CommitMessage)
	}

	if v.Email != nil {
		ok := object.Key("email")
		ok.String(*v.Email)
	}

	if v.FileContent != nil {
		ok := object.Key("fileContent")
		ok.Base64EncodeBytes(v.FileContent)
	}

	if len(v.FileMode) > 0 {
		ok := object.Key("fileMode")
		ok.String(string(v.FileMode))
	}

	if v.FilePath != nil {
		ok := object.Key("filePath")
		ok.String(*v.FilePath)
	}

	if v.Name != nil {
		ok := object.Key("name")
		ok.String(*v.Name)
	}

	if v.ParentCommitId != nil {
		ok := object.Key("parentCommitId")
		ok.String(*v.ParentCommitId)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentPutRepositoryTriggersInput(v *PutRepositoryTriggersInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.Triggers != nil {
		ok := object.Key("triggers")
		if err := awsAwsjson11_serializeDocumentRepositoryTriggersList(v.Triggers, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentTagResourceInput(v *TagResourceInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ResourceArn != nil {
		ok := object.Key("resourceArn")
		ok.String(*v.ResourceArn)
	}

	if v.Tags != nil {
		ok := object.Key("tags")
		if err := awsAwsjson11_serializeDocumentTagsMap(v.Tags, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentTestRepositoryTriggersInput(v *TestRepositoryTriggersInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	if v.Triggers != nil {
		ok := object.Key("triggers")
		if err := awsAwsjson11_serializeDocumentRepositoryTriggersList(v.Triggers, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentUntagResourceInput(v *UntagResourceInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ResourceArn != nil {
		ok := object.Key("resourceArn")
		ok.String(*v.ResourceArn)
	}

	if v.TagKeys != nil {
		ok := object.Key("tagKeys")
		if err := awsAwsjson11_serializeDocumentTagKeysList(v.TagKeys, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdateApprovalRuleTemplateContentInput(v *UpdateApprovalRuleTemplateContentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	if v.ExistingRuleContentSha256 != nil {
		ok := object.Key("existingRuleContentSha256")
		ok.String(*v.ExistingRuleContentSha256)
	}

	if v.NewRuleContent != nil {
		ok := object.Key("newRuleContent")
		ok.String(*v.NewRuleContent)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdateApprovalRuleTemplateDescriptionInput(v *UpdateApprovalRuleTemplateDescriptionInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleTemplateDescription != nil {
		ok := object.Key("approvalRuleTemplateDescription")
		ok.String(*v.ApprovalRuleTemplateDescription)
	}

	if v.ApprovalRuleTemplateName != nil {
		ok := object.Key("approvalRuleTemplateName")
		ok.String(*v.ApprovalRuleTemplateName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdateApprovalRuleTemplateNameInput(v *UpdateApprovalRuleTemplateNameInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.NewApprovalRuleTemplateName != nil {
		ok := object.Key("newApprovalRuleTemplateName")
		ok.String(*v.NewApprovalRuleTemplateName)
	}

	if v.OldApprovalRuleTemplateName != nil {
		ok := object.Key("oldApprovalRuleTemplateName")
		ok.String(*v.OldApprovalRuleTemplateName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdateCommentInput(v *UpdateCommentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CommentId != nil {
		ok := object.Key("commentId")
		ok.String(*v.CommentId)
	}

	if v.Content != nil {
		ok := object.Key("content")
		ok.String(*v.Content)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdateDefaultBranchInput(v *UpdateDefaultBranchInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DefaultBranchName != nil {
		ok := object.Key("defaultBranchName")
		ok.String(*v.DefaultBranchName)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdatePullRequestApprovalRuleContentInput(v *UpdatePullRequestApprovalRuleContentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ApprovalRuleName != nil {
		ok := object.Key("approvalRuleName")
		ok.String(*v.ApprovalRuleName)
	}

	if v.ExistingRuleContentSha256 != nil {
		ok := object.Key("existingRuleContentSha256")
		ok.String(*v.ExistingRuleContentSha256)
	}

	if v.NewRuleContent != nil {
		ok := object.Key("newRuleContent")
		ok.String(*v.NewRuleContent)
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdatePullRequestApprovalStateInput(v *UpdatePullRequestApprovalStateInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.ApprovalState) > 0 {
		ok := object.Key("approvalState")
		ok.String(string(v.ApprovalState))
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.RevisionId != nil {
		ok := object.Key("revisionId")
		ok.String(*v.RevisionId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdatePullRequestDescriptionInput(v *UpdatePullRequestDescriptionInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdatePullRequestStatusInput(v *UpdatePullRequestStatusInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if len(v.PullRequestStatus) > 0 {
		ok := object.Key("pullRequestStatus")
		ok.String(string(v.PullRequestStatus))
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdatePullRequestTitleInput(v *UpdatePullRequestTitleInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.PullRequestId != nil {
		ok := object.Key("pullRequestId")
		ok.String(*v.PullRequestId)
	}

	if v.Title != nil {
		ok := object.Key("title")
		ok.String(*v.Title)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdateRepositoryDescriptionInput(v *UpdateRepositoryDescriptionInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RepositoryDescription != nil {
		ok := object.Key("repositoryDescription")
		ok.String(*v.RepositoryDescription)
	}

	if v.RepositoryName != nil {
		ok := object.Key("repositoryName")
		ok.String(*v.RepositoryName)
	}

	return nil
}

func awsAwsjson11_serializeDocumentUpdateRepositoryNameInput(v *UpdateRepositoryNameInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.NewName != nil {
		ok := object.Key("newName")
		ok.String(*v.NewName)
	}

	if v.OldName != nil {
		ok := object.Key("oldName")
		ok.String(*v.OldName)
	}

	return nil
}
