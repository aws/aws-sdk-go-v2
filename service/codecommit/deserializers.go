// Code generated by smithy-go-codegen DO NOT EDIT.

package codecommit

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws/protocol/restjson"
	"github.com/aws/aws-sdk-go-v2/service/codecommit/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	smithyjson "github.com/awslabs/smithy-go/json"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithytime "github.com/awslabs/smithy-go/time"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	"io"
	"strings"
)

type awsAwsjson11_deserializeOpAssociateApprovalRuleTemplateWithRepository struct {
}

func (*awsAwsjson11_deserializeOpAssociateApprovalRuleTemplateWithRepository) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpAssociateApprovalRuleTemplateWithRepository) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorAssociateApprovalRuleTemplateWithRepository(response)
	}
	output := &AssociateApprovalRuleTemplateWithRepositoryOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentAssociateApprovalRuleTemplateWithRepositoryOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorAssociateApprovalRuleTemplateWithRepository(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("MaximumRuleTemplatesAssociatedWithRepositoryException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumRuleTemplatesAssociatedWithRepositoryException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpBatchAssociateApprovalRuleTemplateWithRepositories struct {
}

func (*awsAwsjson11_deserializeOpBatchAssociateApprovalRuleTemplateWithRepositories) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpBatchAssociateApprovalRuleTemplateWithRepositories) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorBatchAssociateApprovalRuleTemplateWithRepositories(response)
	}
	output := &BatchAssociateApprovalRuleTemplateWithRepositoriesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentBatchAssociateApprovalRuleTemplateWithRepositoriesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorBatchAssociateApprovalRuleTemplateWithRepositories(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	case strings.EqualFold("MaximumRepositoryNamesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumRepositoryNamesExceededException(response, errorBody)

	case strings.EqualFold("RepositoryNamesRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNamesRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpBatchDescribeMergeConflicts struct {
}

func (*awsAwsjson11_deserializeOpBatchDescribeMergeConflicts) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpBatchDescribeMergeConflicts) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorBatchDescribeMergeConflicts(response)
	}
	output := &BatchDescribeMergeConflictsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentBatchDescribeMergeConflictsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorBatchDescribeMergeConflicts(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxConflictFilesException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxConflictFilesException(response, errorBody)

	case strings.EqualFold("InvalidMaxMergeHunksException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxMergeHunksException(response, errorBody)

	case strings.EqualFold("InvalidMergeOptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMergeOptionException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("MergeOptionRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorMergeOptionRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpBatchDisassociateApprovalRuleTemplateFromRepositories struct {
}

func (*awsAwsjson11_deserializeOpBatchDisassociateApprovalRuleTemplateFromRepositories) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpBatchDisassociateApprovalRuleTemplateFromRepositories) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorBatchDisassociateApprovalRuleTemplateFromRepositories(response)
	}
	output := &BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentBatchDisassociateApprovalRuleTemplateFromRepositoriesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorBatchDisassociateApprovalRuleTemplateFromRepositories(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	case strings.EqualFold("MaximumRepositoryNamesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumRepositoryNamesExceededException(response, errorBody)

	case strings.EqualFold("RepositoryNamesRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNamesRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpBatchGetCommits struct {
}

func (*awsAwsjson11_deserializeOpBatchGetCommits) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpBatchGetCommits) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorBatchGetCommits(response)
	}
	output := &BatchGetCommitsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentBatchGetCommitsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorBatchGetCommits(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitIdsLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdsLimitExceededException(response, errorBody)

	case strings.EqualFold("CommitIdsListRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdsListRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpBatchGetRepositories struct {
}

func (*awsAwsjson11_deserializeOpBatchGetRepositories) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpBatchGetRepositories) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorBatchGetRepositories(response)
	}
	output := &BatchGetRepositoriesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentBatchGetRepositoriesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorBatchGetRepositories(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("MaximumRepositoryNamesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumRepositoryNamesExceededException(response, errorBody)

	case strings.EqualFold("RepositoryNamesRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNamesRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpCreateApprovalRuleTemplate struct {
}

func (*awsAwsjson11_deserializeOpCreateApprovalRuleTemplate) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpCreateApprovalRuleTemplate) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorCreateApprovalRuleTemplate(response)
	}
	output := &CreateApprovalRuleTemplateOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentCreateApprovalRuleTemplateOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorCreateApprovalRuleTemplate(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateContentRequiredException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameAlreadyExistsException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameAlreadyExistsException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateContentException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateDescriptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateDescriptionException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	case strings.EqualFold("NumberOfRuleTemplatesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNumberOfRuleTemplatesExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpCreateBranch struct {
}

func (*awsAwsjson11_deserializeOpCreateBranch) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpCreateBranch) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorCreateBranch(response)
	}
	output := &CreateBranchOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentCreateBranchOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorCreateBranch(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchNameExistsException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameExistsException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpCreateCommit struct {
}

func (*awsAwsjson11_deserializeOpCreateCommit) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpCreateCommit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorCreateCommit(response)
	}
	output := &CreateCommitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentCreateCommitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorCreateCommit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBranchDoesNotExistException(response, errorBody)

	case strings.EqualFold("BranchNameIsTagNameException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameIsTagNameException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("CommitMessageLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response, errorBody)

	case strings.EqualFold("DirectoryNameConflictsWithFileNameException", errorCode):
		return awsAwsjson11_deserializeErrorDirectoryNameConflictsWithFileNameException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileContentAndSourceFileSpecifiedException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentAndSourceFileSpecifiedException(response, errorBody)

	case strings.EqualFold("FileContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("FileDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorFileDoesNotExistException(response, errorBody)

	case strings.EqualFold("FileEntryRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorFileEntryRequiredException(response, errorBody)

	case strings.EqualFold("FileModeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorFileModeRequiredException(response, errorBody)

	case strings.EqualFold("FileNameConflictsWithDirectoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorFileNameConflictsWithDirectoryNameException(response, errorBody)

	case strings.EqualFold("FilePathConflictsWithSubmodulePathException", errorCode):
		return awsAwsjson11_deserializeErrorFilePathConflictsWithSubmodulePathException(response, errorBody)

	case strings.EqualFold("FolderContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFolderContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidDeletionParameterException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidDeletionParameterException(response, errorBody)

	case strings.EqualFold("InvalidEmailException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidEmailException(response, errorBody)

	case strings.EqualFold("InvalidFileModeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileModeException(response, errorBody)

	case strings.EqualFold("InvalidParentCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidParentCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("MaximumFileEntriesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileEntriesExceededException(response, errorBody)

	case strings.EqualFold("NameLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNameLengthExceededException(response, errorBody)

	case strings.EqualFold("NoChangeException", errorCode):
		return awsAwsjson11_deserializeErrorNoChangeException(response, errorBody)

	case strings.EqualFold("ParentCommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("ParentCommitIdOutdatedException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitIdOutdatedException(response, errorBody)

	case strings.EqualFold("ParentCommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("PutFileEntryConflictException", errorCode):
		return awsAwsjson11_deserializeErrorPutFileEntryConflictException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("RestrictedSourceFileException", errorCode):
		return awsAwsjson11_deserializeErrorRestrictedSourceFileException(response, errorBody)

	case strings.EqualFold("SamePathRequestException", errorCode):
		return awsAwsjson11_deserializeErrorSamePathRequestException(response, errorBody)

	case strings.EqualFold("SourceFileOrContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorSourceFileOrContentRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpCreatePullRequest struct {
}

func (*awsAwsjson11_deserializeOpCreatePullRequest) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpCreatePullRequest) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorCreatePullRequest(response)
	}
	output := &CreatePullRequestOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentCreatePullRequestOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorCreatePullRequest(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ClientRequestTokenRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorClientRequestTokenRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("IdempotencyParameterMismatchException", errorCode):
		return awsAwsjson11_deserializeErrorIdempotencyParameterMismatchException(response, errorBody)

	case strings.EqualFold("InvalidClientRequestTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidClientRequestTokenException(response, errorBody)

	case strings.EqualFold("InvalidDescriptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidDescriptionException(response, errorBody)

	case strings.EqualFold("InvalidReferenceNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReferenceNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidTargetException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTargetException(response, errorBody)

	case strings.EqualFold("InvalidTargetsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTargetsException(response, errorBody)

	case strings.EqualFold("InvalidTitleException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTitleException(response, errorBody)

	case strings.EqualFold("MaximumOpenPullRequestsExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumOpenPullRequestsExceededException(response, errorBody)

	case strings.EqualFold("MultipleRepositoriesInPullRequestException", errorCode):
		return awsAwsjson11_deserializeErrorMultipleRepositoriesInPullRequestException(response, errorBody)

	case strings.EqualFold("ReferenceDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorReferenceDoesNotExistException(response, errorBody)

	case strings.EqualFold("ReferenceNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReferenceNameRequiredException(response, errorBody)

	case strings.EqualFold("ReferenceTypeNotSupportedException", errorCode):
		return awsAwsjson11_deserializeErrorReferenceTypeNotSupportedException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("SourceAndDestinationAreSameException", errorCode):
		return awsAwsjson11_deserializeErrorSourceAndDestinationAreSameException(response, errorBody)

	case strings.EqualFold("TargetRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorTargetRequiredException(response, errorBody)

	case strings.EqualFold("TargetsRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorTargetsRequiredException(response, errorBody)

	case strings.EqualFold("TitleRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorTitleRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpCreatePullRequestApprovalRule struct {
}

func (*awsAwsjson11_deserializeOpCreatePullRequestApprovalRule) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpCreatePullRequestApprovalRule) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorCreatePullRequestApprovalRule(response)
	}
	output := &CreatePullRequestApprovalRuleOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentCreatePullRequestApprovalRuleOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorCreatePullRequestApprovalRule(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleContentRequiredException(response, errorBody)

	case strings.EqualFold("ApprovalRuleNameAlreadyExistsException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleNameAlreadyExistsException(response, errorBody)

	case strings.EqualFold("ApprovalRuleNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleNameRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleContentException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleNameException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("NumberOfRulesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNumberOfRulesExceededException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpCreateRepository struct {
}

func (*awsAwsjson11_deserializeOpCreateRepository) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpCreateRepository) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorCreateRepository(response)
	}
	output := &CreateRepositoryOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentCreateRepositoryOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorCreateRepository(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryDescriptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryDescriptionException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidSystemTagUsageException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidSystemTagUsageException(response, errorBody)

	case strings.EqualFold("InvalidTagsMapException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTagsMapException(response, errorBody)

	case strings.EqualFold("RepositoryLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryLimitExceededException(response, errorBody)

	case strings.EqualFold("RepositoryNameExistsException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameExistsException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TagPolicyException", errorCode):
		return awsAwsjson11_deserializeErrorTagPolicyException(response, errorBody)

	case strings.EqualFold("TooManyTagsException", errorCode):
		return awsAwsjson11_deserializeErrorTooManyTagsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpCreateUnreferencedMergeCommit struct {
}

func (*awsAwsjson11_deserializeOpCreateUnreferencedMergeCommit) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpCreateUnreferencedMergeCommit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorCreateUnreferencedMergeCommit(response)
	}
	output := &CreateUnreferencedMergeCommitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentCreateUnreferencedMergeCommitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorCreateUnreferencedMergeCommit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitMessageLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("ConcurrentReferenceUpdateException", errorCode):
		return awsAwsjson11_deserializeErrorConcurrentReferenceUpdateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("FileModeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorFileModeRequiredException(response, errorBody)

	case strings.EqualFold("FolderContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFolderContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidEmailException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidEmailException(response, errorBody)

	case strings.EqualFold("InvalidFileModeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileModeException(response, errorBody)

	case strings.EqualFold("InvalidMergeOptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMergeOptionException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidReplacementContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementContentException(response, errorBody)

	case strings.EqualFold("InvalidReplacementTypeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementTypeException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("ManualMergeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorManualMergeRequiredException(response, errorBody)

	case strings.EqualFold("MaximumConflictResolutionEntriesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumConflictResolutionEntriesExceededException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("MergeOptionRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorMergeOptionRequiredException(response, errorBody)

	case strings.EqualFold("MultipleConflictResolutionEntriesException", errorCode):
		return awsAwsjson11_deserializeErrorMultipleConflictResolutionEntriesException(response, errorBody)

	case strings.EqualFold("NameLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNameLengthExceededException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementContentRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementTypeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementTypeRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDeleteApprovalRuleTemplate struct {
}

func (*awsAwsjson11_deserializeOpDeleteApprovalRuleTemplate) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDeleteApprovalRuleTemplate) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDeleteApprovalRuleTemplate(response)
	}
	output := &DeleteApprovalRuleTemplateOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentDeleteApprovalRuleTemplateOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDeleteApprovalRuleTemplate(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateInUseException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateInUseException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDeleteBranch struct {
}

func (*awsAwsjson11_deserializeOpDeleteBranch) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDeleteBranch) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDeleteBranch(response)
	}
	output := &DeleteBranchOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentDeleteBranchOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDeleteBranch(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("DefaultBranchCannotBeDeletedException", errorCode):
		return awsAwsjson11_deserializeErrorDefaultBranchCannotBeDeletedException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDeleteCommentContent struct {
}

func (*awsAwsjson11_deserializeOpDeleteCommentContent) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDeleteCommentContent) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDeleteCommentContent(response)
	}
	output := &DeleteCommentContentOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentDeleteCommentContentOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDeleteCommentContent(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommentDeletedException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDeletedException(response, errorBody)

	case strings.EqualFold("CommentDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommentIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentIdRequiredException(response, errorBody)

	case strings.EqualFold("InvalidCommentIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommentIdException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDeleteFile struct {
}

func (*awsAwsjson11_deserializeOpDeleteFile) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDeleteFile) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDeleteFile(response)
	}
	output := &DeleteFileOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentDeleteFileOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDeleteFile(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBranchDoesNotExistException(response, errorBody)

	case strings.EqualFold("BranchNameIsTagNameException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameIsTagNameException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("CommitMessageLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorFileDoesNotExistException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidEmailException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidEmailException(response, errorBody)

	case strings.EqualFold("InvalidParentCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidParentCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("NameLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNameLengthExceededException(response, errorBody)

	case strings.EqualFold("ParentCommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("ParentCommitIdOutdatedException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitIdOutdatedException(response, errorBody)

	case strings.EqualFold("ParentCommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDeletePullRequestApprovalRule struct {
}

func (*awsAwsjson11_deserializeOpDeletePullRequestApprovalRule) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDeletePullRequestApprovalRule) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDeletePullRequestApprovalRule(response)
	}
	output := &DeletePullRequestApprovalRuleOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentDeletePullRequestApprovalRuleOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDeletePullRequestApprovalRule(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleNameRequiredException(response, errorBody)

	case strings.EqualFold("CannotDeleteApprovalRuleFromTemplateException", errorCode):
		return awsAwsjson11_deserializeErrorCannotDeleteApprovalRuleFromTemplateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleNameException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDeleteRepository struct {
}

func (*awsAwsjson11_deserializeOpDeleteRepository) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDeleteRepository) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDeleteRepository(response)
	}
	output := &DeleteRepositoryOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentDeleteRepositoryOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDeleteRepository(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDescribeMergeConflicts struct {
}

func (*awsAwsjson11_deserializeOpDescribeMergeConflicts) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDescribeMergeConflicts) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDescribeMergeConflicts(response)
	}
	output := &DescribeMergeConflictsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentDescribeMergeConflictsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDescribeMergeConflicts(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorFileDoesNotExistException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxMergeHunksException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxMergeHunksException(response, errorBody)

	case strings.EqualFold("InvalidMergeOptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMergeOptionException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("MergeOptionRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorMergeOptionRequiredException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDescribePullRequestEvents struct {
}

func (*awsAwsjson11_deserializeOpDescribePullRequestEvents) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDescribePullRequestEvents) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDescribePullRequestEvents(response)
	}
	output := &DescribePullRequestEventsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentDescribePullRequestEventsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDescribePullRequestEvents(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ActorDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorActorDoesNotExistException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidActorArnException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidActorArnException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestEventTypeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestEventTypeException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpDisassociateApprovalRuleTemplateFromRepository struct {
}

func (*awsAwsjson11_deserializeOpDisassociateApprovalRuleTemplateFromRepository) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpDisassociateApprovalRuleTemplateFromRepository) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorDisassociateApprovalRuleTemplateFromRepository(response)
	}
	output := &DisassociateApprovalRuleTemplateFromRepositoryOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentDisassociateApprovalRuleTemplateFromRepositoryOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorDisassociateApprovalRuleTemplateFromRepository(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpEvaluatePullRequestApprovalRules struct {
}

func (*awsAwsjson11_deserializeOpEvaluatePullRequestApprovalRules) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpEvaluatePullRequestApprovalRules) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorEvaluatePullRequestApprovalRules(response)
	}
	output := &EvaluatePullRequestApprovalRulesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentEvaluatePullRequestApprovalRulesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorEvaluatePullRequestApprovalRules(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRevisionIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRevisionIdException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("RevisionIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRevisionIdRequiredException(response, errorBody)

	case strings.EqualFold("RevisionNotCurrentException", errorCode):
		return awsAwsjson11_deserializeErrorRevisionNotCurrentException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetApprovalRuleTemplate struct {
}

func (*awsAwsjson11_deserializeOpGetApprovalRuleTemplate) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetApprovalRuleTemplate) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetApprovalRuleTemplate(response)
	}
	output := &GetApprovalRuleTemplateOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetApprovalRuleTemplateOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetApprovalRuleTemplate(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetBlob struct {
}

func (*awsAwsjson11_deserializeOpGetBlob) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetBlob) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetBlob(response)
	}
	output := &GetBlobOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetBlobOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetBlob(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BlobIdDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBlobIdDoesNotExistException(response, errorBody)

	case strings.EqualFold("BlobIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBlobIdRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileTooLargeException", errorCode):
		return awsAwsjson11_deserializeErrorFileTooLargeException(response, errorBody)

	case strings.EqualFold("InvalidBlobIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBlobIdException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetBranch struct {
}

func (*awsAwsjson11_deserializeOpGetBranch) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetBranch) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetBranch(response)
	}
	output := &GetBranchOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetBranchOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetBranch(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBranchDoesNotExistException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetComment struct {
}

func (*awsAwsjson11_deserializeOpGetComment) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetComment) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetComment(response)
	}
	output := &GetCommentOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetCommentOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetComment(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommentDeletedException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDeletedException(response, errorBody)

	case strings.EqualFold("CommentDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommentIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentIdRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommentIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommentIdException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetCommentReactions struct {
}

func (*awsAwsjson11_deserializeOpGetCommentReactions) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetCommentReactions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetCommentReactions(response)
	}
	output := &GetCommentReactionsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetCommentReactionsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetCommentReactions(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommentDeletedException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDeletedException(response, errorBody)

	case strings.EqualFold("CommentDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommentIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentIdRequiredException(response, errorBody)

	case strings.EqualFold("InvalidCommentIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommentIdException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	case strings.EqualFold("InvalidReactionUserArnException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReactionUserArnException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetCommentsForComparedCommit struct {
}

func (*awsAwsjson11_deserializeOpGetCommentsForComparedCommit) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetCommentsForComparedCommit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetCommentsForComparedCommit(response)
	}
	output := &GetCommentsForComparedCommitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetCommentsForComparedCommitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetCommentsForComparedCommit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetCommentsForPullRequest struct {
}

func (*awsAwsjson11_deserializeOpGetCommentsForPullRequest) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetCommentsForPullRequest) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetCommentsForPullRequest(response)
	}
	output := &GetCommentsForPullRequestOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetCommentsForPullRequestOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetCommentsForPullRequest(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryNotAssociatedWithPullRequestException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNotAssociatedWithPullRequestException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetCommit struct {
}

func (*awsAwsjson11_deserializeOpGetCommit) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetCommit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetCommit(response)
	}
	output := &GetCommitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetCommitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetCommit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitIdDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetDifferences struct {
}

func (*awsAwsjson11_deserializeOpGetDifferences) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetDifferences) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetDifferences(response)
	}
	output := &GetDifferencesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetDifferencesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetDifferences(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("PathDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPathDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetFile struct {
}

func (*awsAwsjson11_deserializeOpGetFile) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetFile) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetFile(response)
	}
	output := &GetFileOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetFileOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetFile(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorFileDoesNotExistException(response, errorBody)

	case strings.EqualFold("FileTooLargeException", errorCode):
		return awsAwsjson11_deserializeErrorFileTooLargeException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetFolder struct {
}

func (*awsAwsjson11_deserializeOpGetFolder) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetFolder) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetFolder(response)
	}
	output := &GetFolderOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetFolderOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetFolder(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FolderDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorFolderDoesNotExistException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetMergeCommit struct {
}

func (*awsAwsjson11_deserializeOpGetMergeCommit) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetMergeCommit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetMergeCommit(response)
	}
	output := &GetMergeCommitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetMergeCommitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetMergeCommit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetMergeConflicts struct {
}

func (*awsAwsjson11_deserializeOpGetMergeConflicts) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetMergeConflicts) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetMergeConflicts(response)
	}
	output := &GetMergeConflictsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetMergeConflictsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetMergeConflicts(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidDestinationCommitSpecifierException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidDestinationCommitSpecifierException(response, errorBody)

	case strings.EqualFold("InvalidMaxConflictFilesException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxConflictFilesException(response, errorBody)

	case strings.EqualFold("InvalidMergeOptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMergeOptionException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidSourceCommitSpecifierException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidSourceCommitSpecifierException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("MergeOptionRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorMergeOptionRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetMergeOptions struct {
}

func (*awsAwsjson11_deserializeOpGetMergeOptions) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetMergeOptions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetMergeOptions(response)
	}
	output := &GetMergeOptionsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetMergeOptionsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetMergeOptions(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetPullRequest struct {
}

func (*awsAwsjson11_deserializeOpGetPullRequest) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetPullRequest) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetPullRequest(response)
	}
	output := &GetPullRequestOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetPullRequestOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetPullRequest(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetPullRequestApprovalStates struct {
}

func (*awsAwsjson11_deserializeOpGetPullRequestApprovalStates) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetPullRequestApprovalStates) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetPullRequestApprovalStates(response)
	}
	output := &GetPullRequestApprovalStatesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetPullRequestApprovalStatesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetPullRequestApprovalStates(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRevisionIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRevisionIdException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("RevisionIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRevisionIdRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetPullRequestOverrideState struct {
}

func (*awsAwsjson11_deserializeOpGetPullRequestOverrideState) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetPullRequestOverrideState) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetPullRequestOverrideState(response)
	}
	output := &GetPullRequestOverrideStateOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetPullRequestOverrideStateOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetPullRequestOverrideState(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRevisionIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRevisionIdException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("RevisionIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRevisionIdRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetRepository struct {
}

func (*awsAwsjson11_deserializeOpGetRepository) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetRepository) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetRepository(response)
	}
	output := &GetRepositoryOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetRepositoryOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetRepository(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpGetRepositoryTriggers struct {
}

func (*awsAwsjson11_deserializeOpGetRepositoryTriggers) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpGetRepositoryTriggers) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorGetRepositoryTriggers(response)
	}
	output := &GetRepositoryTriggersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentGetRepositoryTriggersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorGetRepositoryTriggers(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpListApprovalRuleTemplates struct {
}

func (*awsAwsjson11_deserializeOpListApprovalRuleTemplates) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpListApprovalRuleTemplates) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorListApprovalRuleTemplates(response)
	}
	output := &ListApprovalRuleTemplatesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentListApprovalRuleTemplatesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorListApprovalRuleTemplates(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpListAssociatedApprovalRuleTemplatesForRepository struct {
}

func (*awsAwsjson11_deserializeOpListAssociatedApprovalRuleTemplatesForRepository) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpListAssociatedApprovalRuleTemplatesForRepository) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorListAssociatedApprovalRuleTemplatesForRepository(response)
	}
	output := &ListAssociatedApprovalRuleTemplatesForRepositoryOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentListAssociatedApprovalRuleTemplatesForRepositoryOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorListAssociatedApprovalRuleTemplatesForRepository(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpListBranches struct {
}

func (*awsAwsjson11_deserializeOpListBranches) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpListBranches) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorListBranches(response)
	}
	output := &ListBranchesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentListBranchesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorListBranches(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpListPullRequests struct {
}

func (*awsAwsjson11_deserializeOpListPullRequests) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpListPullRequests) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorListPullRequests(response)
	}
	output := &ListPullRequestsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentListPullRequestsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorListPullRequests(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("AuthorDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorAuthorDoesNotExistException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidAuthorArnException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidAuthorArnException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestStatusException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestStatusException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpListRepositories struct {
}

func (*awsAwsjson11_deserializeOpListRepositories) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpListRepositories) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorListRepositories(response)
	}
	output := &ListRepositoriesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentListRepositoriesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorListRepositories(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidOrderException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidOrderException(response, errorBody)

	case strings.EqualFold("InvalidSortByException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidSortByException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpListRepositoriesForApprovalRuleTemplate struct {
}

func (*awsAwsjson11_deserializeOpListRepositoriesForApprovalRuleTemplate) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpListRepositoriesForApprovalRuleTemplate) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorListRepositoriesForApprovalRuleTemplate(response)
	}
	output := &ListRepositoriesForApprovalRuleTemplateOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentListRepositoriesForApprovalRuleTemplateOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorListRepositoriesForApprovalRuleTemplate(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	case strings.EqualFold("InvalidContinuationTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response, errorBody)

	case strings.EqualFold("InvalidMaxResultsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidMaxResultsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpListTagsForResource struct {
}

func (*awsAwsjson11_deserializeOpListTagsForResource) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpListTagsForResource) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorListTagsForResource(response)
	}
	output := &ListTagsForResourceOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentListTagsForResourceOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorListTagsForResource(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidResourceArnException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidResourceArnException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("ResourceArnRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorResourceArnRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpMergeBranchesByFastForward struct {
}

func (*awsAwsjson11_deserializeOpMergeBranchesByFastForward) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpMergeBranchesByFastForward) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorMergeBranchesByFastForward(response)
	}
	output := &MergeBranchesByFastForwardOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentMergeBranchesByFastForwardOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorMergeBranchesByFastForward(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBranchDoesNotExistException(response, errorBody)

	case strings.EqualFold("BranchNameIsTagNameException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameIsTagNameException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("ConcurrentReferenceUpdateException", errorCode):
		return awsAwsjson11_deserializeErrorConcurrentReferenceUpdateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidTargetBranchException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTargetBranchException(response, errorBody)

	case strings.EqualFold("ManualMergeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorManualMergeRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpMergeBranchesBySquash struct {
}

func (*awsAwsjson11_deserializeOpMergeBranchesBySquash) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpMergeBranchesBySquash) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorMergeBranchesBySquash(response)
	}
	output := &MergeBranchesBySquashOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentMergeBranchesBySquashOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorMergeBranchesBySquash(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBranchDoesNotExistException(response, errorBody)

	case strings.EqualFold("BranchNameIsTagNameException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameIsTagNameException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitMessageLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("ConcurrentReferenceUpdateException", errorCode):
		return awsAwsjson11_deserializeErrorConcurrentReferenceUpdateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("FileModeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorFileModeRequiredException(response, errorBody)

	case strings.EqualFold("FolderContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFolderContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidEmailException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidEmailException(response, errorBody)

	case strings.EqualFold("InvalidFileModeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileModeException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidReplacementContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementContentException(response, errorBody)

	case strings.EqualFold("InvalidReplacementTypeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementTypeException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidTargetBranchException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTargetBranchException(response, errorBody)

	case strings.EqualFold("ManualMergeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorManualMergeRequiredException(response, errorBody)

	case strings.EqualFold("MaximumConflictResolutionEntriesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumConflictResolutionEntriesExceededException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("MultipleConflictResolutionEntriesException", errorCode):
		return awsAwsjson11_deserializeErrorMultipleConflictResolutionEntriesException(response, errorBody)

	case strings.EqualFold("NameLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNameLengthExceededException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementContentRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementTypeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementTypeRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpMergeBranchesByThreeWay struct {
}

func (*awsAwsjson11_deserializeOpMergeBranchesByThreeWay) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpMergeBranchesByThreeWay) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorMergeBranchesByThreeWay(response)
	}
	output := &MergeBranchesByThreeWayOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentMergeBranchesByThreeWayOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorMergeBranchesByThreeWay(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBranchDoesNotExistException(response, errorBody)

	case strings.EqualFold("BranchNameIsTagNameException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameIsTagNameException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitMessageLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response, errorBody)

	case strings.EqualFold("CommitRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitRequiredException(response, errorBody)

	case strings.EqualFold("ConcurrentReferenceUpdateException", errorCode):
		return awsAwsjson11_deserializeErrorConcurrentReferenceUpdateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("FileModeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorFileModeRequiredException(response, errorBody)

	case strings.EqualFold("FolderContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFolderContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidCommitException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidEmailException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidEmailException(response, errorBody)

	case strings.EqualFold("InvalidFileModeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileModeException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidReplacementContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementContentException(response, errorBody)

	case strings.EqualFold("InvalidReplacementTypeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementTypeException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidTargetBranchException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTargetBranchException(response, errorBody)

	case strings.EqualFold("ManualMergeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorManualMergeRequiredException(response, errorBody)

	case strings.EqualFold("MaximumConflictResolutionEntriesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumConflictResolutionEntriesExceededException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("MultipleConflictResolutionEntriesException", errorCode):
		return awsAwsjson11_deserializeErrorMultipleConflictResolutionEntriesException(response, errorBody)

	case strings.EqualFold("NameLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNameLengthExceededException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementContentRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementTypeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementTypeRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpMergePullRequestByFastForward struct {
}

func (*awsAwsjson11_deserializeOpMergePullRequestByFastForward) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpMergePullRequestByFastForward) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorMergePullRequestByFastForward(response)
	}
	output := &MergePullRequestByFastForwardOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentMergePullRequestByFastForwardOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorMergePullRequestByFastForward(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ConcurrentReferenceUpdateException", errorCode):
		return awsAwsjson11_deserializeErrorConcurrentReferenceUpdateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("ManualMergeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorManualMergeRequiredException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestApprovalRulesNotSatisfiedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestApprovalRulesNotSatisfiedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("ReferenceDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorReferenceDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryNotAssociatedWithPullRequestException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNotAssociatedWithPullRequestException(response, errorBody)

	case strings.EqualFold("TipOfSourceReferenceIsDifferentException", errorCode):
		return awsAwsjson11_deserializeErrorTipOfSourceReferenceIsDifferentException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpMergePullRequestBySquash struct {
}

func (*awsAwsjson11_deserializeOpMergePullRequestBySquash) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpMergePullRequestBySquash) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorMergePullRequestBySquash(response)
	}
	output := &MergePullRequestBySquashOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentMergePullRequestBySquashOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorMergePullRequestBySquash(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitMessageLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response, errorBody)

	case strings.EqualFold("ConcurrentReferenceUpdateException", errorCode):
		return awsAwsjson11_deserializeErrorConcurrentReferenceUpdateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("FolderContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFolderContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidEmailException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidEmailException(response, errorBody)

	case strings.EqualFold("InvalidFileModeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileModeException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidReplacementContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementContentException(response, errorBody)

	case strings.EqualFold("InvalidReplacementTypeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementTypeException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("ManualMergeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorManualMergeRequiredException(response, errorBody)

	case strings.EqualFold("MaximumConflictResolutionEntriesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumConflictResolutionEntriesExceededException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("MultipleConflictResolutionEntriesException", errorCode):
		return awsAwsjson11_deserializeErrorMultipleConflictResolutionEntriesException(response, errorBody)

	case strings.EqualFold("NameLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNameLengthExceededException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestApprovalRulesNotSatisfiedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestApprovalRulesNotSatisfiedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementContentRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementTypeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementTypeRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryNotAssociatedWithPullRequestException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNotAssociatedWithPullRequestException(response, errorBody)

	case strings.EqualFold("TipOfSourceReferenceIsDifferentException", errorCode):
		return awsAwsjson11_deserializeErrorTipOfSourceReferenceIsDifferentException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpMergePullRequestByThreeWay struct {
}

func (*awsAwsjson11_deserializeOpMergePullRequestByThreeWay) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpMergePullRequestByThreeWay) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorMergePullRequestByThreeWay(response)
	}
	output := &MergePullRequestByThreeWayOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentMergePullRequestByThreeWayOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorMergePullRequestByThreeWay(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommitMessageLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response, errorBody)

	case strings.EqualFold("ConcurrentReferenceUpdateException", errorCode):
		return awsAwsjson11_deserializeErrorConcurrentReferenceUpdateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("FolderContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFolderContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidConflictDetailLevelException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionException(response, errorBody)

	case strings.EqualFold("InvalidConflictResolutionStrategyException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response, errorBody)

	case strings.EqualFold("InvalidEmailException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidEmailException(response, errorBody)

	case strings.EqualFold("InvalidFileModeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileModeException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidReplacementContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementContentException(response, errorBody)

	case strings.EqualFold("InvalidReplacementTypeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReplacementTypeException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("ManualMergeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorManualMergeRequiredException(response, errorBody)

	case strings.EqualFold("MaximumConflictResolutionEntriesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumConflictResolutionEntriesExceededException(response, errorBody)

	case strings.EqualFold("MaximumFileContentToLoadExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response, errorBody)

	case strings.EqualFold("MaximumItemsToCompareExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response, errorBody)

	case strings.EqualFold("MultipleConflictResolutionEntriesException", errorCode):
		return awsAwsjson11_deserializeErrorMultipleConflictResolutionEntriesException(response, errorBody)

	case strings.EqualFold("NameLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNameLengthExceededException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestApprovalRulesNotSatisfiedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestApprovalRulesNotSatisfiedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementContentRequiredException(response, errorBody)

	case strings.EqualFold("ReplacementTypeRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReplacementTypeRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryNotAssociatedWithPullRequestException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNotAssociatedWithPullRequestException(response, errorBody)

	case strings.EqualFold("TipOfSourceReferenceIsDifferentException", errorCode):
		return awsAwsjson11_deserializeErrorTipOfSourceReferenceIsDifferentException(response, errorBody)

	case strings.EqualFold("TipsDivergenceExceededException", errorCode):
		return awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpOverridePullRequestApprovalRules struct {
}

func (*awsAwsjson11_deserializeOpOverridePullRequestApprovalRules) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpOverridePullRequestApprovalRules) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorOverridePullRequestApprovalRules(response)
	}
	output := &OverridePullRequestApprovalRulesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentOverridePullRequestApprovalRulesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorOverridePullRequestApprovalRules(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidOverrideStatusException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidOverrideStatusException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRevisionIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRevisionIdException(response, errorBody)

	case strings.EqualFold("OverrideAlreadySetException", errorCode):
		return awsAwsjson11_deserializeErrorOverrideAlreadySetException(response, errorBody)

	case strings.EqualFold("OverrideStatusRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorOverrideStatusRequiredException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("RevisionIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRevisionIdRequiredException(response, errorBody)

	case strings.EqualFold("RevisionNotCurrentException", errorCode):
		return awsAwsjson11_deserializeErrorRevisionNotCurrentException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpPostCommentForComparedCommit struct {
}

func (*awsAwsjson11_deserializeOpPostCommentForComparedCommit) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPostCommentForComparedCommit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPostCommentForComparedCommit(response)
	}
	output := &PostCommentForComparedCommitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentPostCommentForComparedCommitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPostCommentForComparedCommit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BeforeCommitIdAndAfterCommitIdAreSameException", errorCode):
		return awsAwsjson11_deserializeErrorBeforeCommitIdAndAfterCommitIdAreSameException(response, errorBody)

	case strings.EqualFold("ClientRequestTokenRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorClientRequestTokenRequiredException(response, errorBody)

	case strings.EqualFold("CommentContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentContentRequiredException(response, errorBody)

	case strings.EqualFold("CommentContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommentContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("IdempotencyParameterMismatchException", errorCode):
		return awsAwsjson11_deserializeErrorIdempotencyParameterMismatchException(response, errorBody)

	case strings.EqualFold("InvalidClientRequestTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidClientRequestTokenException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidFileLocationException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileLocationException(response, errorBody)

	case strings.EqualFold("InvalidFilePositionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFilePositionException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidRelativeFileVersionEnumException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRelativeFileVersionEnumException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("PathDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPathDoesNotExistException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpPostCommentForPullRequest struct {
}

func (*awsAwsjson11_deserializeOpPostCommentForPullRequest) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPostCommentForPullRequest) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPostCommentForPullRequest(response)
	}
	output := &PostCommentForPullRequestOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentPostCommentForPullRequestOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPostCommentForPullRequest(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BeforeCommitIdAndAfterCommitIdAreSameException", errorCode):
		return awsAwsjson11_deserializeErrorBeforeCommitIdAndAfterCommitIdAreSameException(response, errorBody)

	case strings.EqualFold("ClientRequestTokenRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorClientRequestTokenRequiredException(response, errorBody)

	case strings.EqualFold("CommentContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentContentRequiredException(response, errorBody)

	case strings.EqualFold("CommentContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommentContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("CommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("IdempotencyParameterMismatchException", errorCode):
		return awsAwsjson11_deserializeErrorIdempotencyParameterMismatchException(response, errorBody)

	case strings.EqualFold("InvalidClientRequestTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidClientRequestTokenException(response, errorBody)

	case strings.EqualFold("InvalidCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidFileLocationException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileLocationException(response, errorBody)

	case strings.EqualFold("InvalidFilePositionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFilePositionException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRelativeFileVersionEnumException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRelativeFileVersionEnumException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("PathDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPathDoesNotExistException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryNotAssociatedWithPullRequestException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNotAssociatedWithPullRequestException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpPostCommentReply struct {
}

func (*awsAwsjson11_deserializeOpPostCommentReply) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPostCommentReply) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPostCommentReply(response)
	}
	output := &PostCommentReplyOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentPostCommentReplyOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPostCommentReply(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ClientRequestTokenRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorClientRequestTokenRequiredException(response, errorBody)

	case strings.EqualFold("CommentContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentContentRequiredException(response, errorBody)

	case strings.EqualFold("CommentContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommentContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("CommentDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommentIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentIdRequiredException(response, errorBody)

	case strings.EqualFold("IdempotencyParameterMismatchException", errorCode):
		return awsAwsjson11_deserializeErrorIdempotencyParameterMismatchException(response, errorBody)

	case strings.EqualFold("InvalidClientRequestTokenException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidClientRequestTokenException(response, errorBody)

	case strings.EqualFold("InvalidCommentIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommentIdException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpPutCommentReaction struct {
}

func (*awsAwsjson11_deserializeOpPutCommentReaction) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPutCommentReaction) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPutCommentReaction(response)
	}
	output := &PutCommentReactionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentPutCommentReactionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPutCommentReaction(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommentDeletedException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDeletedException(response, errorBody)

	case strings.EqualFold("CommentDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommentIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentIdRequiredException(response, errorBody)

	case strings.EqualFold("InvalidCommentIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommentIdException(response, errorBody)

	case strings.EqualFold("InvalidReactionValueException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidReactionValueException(response, errorBody)

	case strings.EqualFold("ReactionLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorReactionLimitExceededException(response, errorBody)

	case strings.EqualFold("ReactionValueRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorReactionValueRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpPutFile struct {
}

func (*awsAwsjson11_deserializeOpPutFile) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPutFile) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPutFile(response)
	}
	output := &PutFileOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentPutFileOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPutFile(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBranchDoesNotExistException(response, errorBody)

	case strings.EqualFold("BranchNameIsTagNameException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameIsTagNameException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("CommitMessageLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response, errorBody)

	case strings.EqualFold("DirectoryNameConflictsWithFileNameException", errorCode):
		return awsAwsjson11_deserializeErrorDirectoryNameConflictsWithFileNameException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("FileContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentRequiredException(response, errorBody)

	case strings.EqualFold("FileContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFileContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("FileNameConflictsWithDirectoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorFileNameConflictsWithDirectoryNameException(response, errorBody)

	case strings.EqualFold("FilePathConflictsWithSubmodulePathException", errorCode):
		return awsAwsjson11_deserializeErrorFilePathConflictsWithSubmodulePathException(response, errorBody)

	case strings.EqualFold("FolderContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorFolderContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidDeletionParameterException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidDeletionParameterException(response, errorBody)

	case strings.EqualFold("InvalidEmailException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidEmailException(response, errorBody)

	case strings.EqualFold("InvalidFileModeException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidFileModeException(response, errorBody)

	case strings.EqualFold("InvalidParentCommitIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidParentCommitIdException(response, errorBody)

	case strings.EqualFold("InvalidPathException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPathException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("NameLengthExceededException", errorCode):
		return awsAwsjson11_deserializeErrorNameLengthExceededException(response, errorBody)

	case strings.EqualFold("ParentCommitDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitDoesNotExistException(response, errorBody)

	case strings.EqualFold("ParentCommitIdOutdatedException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitIdOutdatedException(response, errorBody)

	case strings.EqualFold("ParentCommitIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorParentCommitIdRequiredException(response, errorBody)

	case strings.EqualFold("PathRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPathRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("SameFileContentException", errorCode):
		return awsAwsjson11_deserializeErrorSameFileContentException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpPutRepositoryTriggers struct {
}

func (*awsAwsjson11_deserializeOpPutRepositoryTriggers) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpPutRepositoryTriggers) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorPutRepositoryTriggers(response)
	}
	output := &PutRepositoryTriggersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentPutRepositoryTriggersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorPutRepositoryTriggers(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerCustomDataException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerCustomDataException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerDestinationArnException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerDestinationArnException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerEventsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerEventsException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerRegionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerRegionException(response, errorBody)

	case strings.EqualFold("MaximumBranchesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumBranchesExceededException(response, errorBody)

	case strings.EqualFold("MaximumRepositoryTriggersExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumRepositoryTriggersExceededException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggerBranchNameListRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggerBranchNameListRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggerDestinationArnRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggerDestinationArnRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggerEventsListRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggerEventsListRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggerNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggerNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggersListRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggersListRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpTagResource struct {
}

func (*awsAwsjson11_deserializeOpTagResource) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpTagResource) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorTagResource(response)
	}
	output := &TagResourceOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentTagResourceOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorTagResource(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidResourceArnException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidResourceArnException(response, errorBody)

	case strings.EqualFold("InvalidSystemTagUsageException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidSystemTagUsageException(response, errorBody)

	case strings.EqualFold("InvalidTagsMapException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTagsMapException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("ResourceArnRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorResourceArnRequiredException(response, errorBody)

	case strings.EqualFold("TagPolicyException", errorCode):
		return awsAwsjson11_deserializeErrorTagPolicyException(response, errorBody)

	case strings.EqualFold("TagsMapRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorTagsMapRequiredException(response, errorBody)

	case strings.EqualFold("TooManyTagsException", errorCode):
		return awsAwsjson11_deserializeErrorTooManyTagsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpTestRepositoryTriggers struct {
}

func (*awsAwsjson11_deserializeOpTestRepositoryTriggers) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpTestRepositoryTriggers) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorTestRepositoryTriggers(response)
	}
	output := &TestRepositoryTriggersOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentTestRepositoryTriggersOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorTestRepositoryTriggers(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerCustomDataException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerCustomDataException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerDestinationArnException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerDestinationArnException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerEventsException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerEventsException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryTriggerRegionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryTriggerRegionException(response, errorBody)

	case strings.EqualFold("MaximumBranchesExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumBranchesExceededException(response, errorBody)

	case strings.EqualFold("MaximumRepositoryTriggersExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumRepositoryTriggersExceededException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggerBranchNameListRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggerBranchNameListRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggerDestinationArnRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggerDestinationArnRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggerEventsListRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggerEventsListRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggerNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggerNameRequiredException(response, errorBody)

	case strings.EqualFold("RepositoryTriggersListRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryTriggersListRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUntagResource struct {
}

func (*awsAwsjson11_deserializeOpUntagResource) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUntagResource) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUntagResource(response)
	}
	output := &UntagResourceOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentUntagResourceOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUntagResource(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("InvalidResourceArnException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidResourceArnException(response, errorBody)

	case strings.EqualFold("InvalidSystemTagUsageException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidSystemTagUsageException(response, errorBody)

	case strings.EqualFold("InvalidTagKeysListException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTagKeysListException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("ResourceArnRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorResourceArnRequiredException(response, errorBody)

	case strings.EqualFold("TagKeysListRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorTagKeysListRequiredException(response, errorBody)

	case strings.EqualFold("TagPolicyException", errorCode):
		return awsAwsjson11_deserializeErrorTagPolicyException(response, errorBody)

	case strings.EqualFold("TooManyTagsException", errorCode):
		return awsAwsjson11_deserializeErrorTooManyTagsException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateContent struct {
}

func (*awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateContent) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateContent) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdateApprovalRuleTemplateContent(response)
	}
	output := &UpdateApprovalRuleTemplateContentOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentUpdateApprovalRuleTemplateContentOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdateApprovalRuleTemplateContent(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateContentRequiredException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateContentException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	case strings.EqualFold("InvalidRuleContentSha256Exception", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRuleContentSha256Exception(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateDescription struct {
}

func (*awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateDescription) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateDescription) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdateApprovalRuleTemplateDescription(response)
	}
	output := &UpdateApprovalRuleTemplateDescriptionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentUpdateApprovalRuleTemplateDescriptionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdateApprovalRuleTemplateDescription(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateDescriptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateDescriptionException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateName struct {
}

func (*awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateName) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdateApprovalRuleTemplateName) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdateApprovalRuleTemplateName(response)
	}
	output := &UpdateApprovalRuleTemplateNameOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentUpdateApprovalRuleTemplateNameOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdateApprovalRuleTemplateName(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleTemplateDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameAlreadyExistsException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameAlreadyExistsException(response, errorBody)

	case strings.EqualFold("ApprovalRuleTemplateNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleTemplateNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdateComment struct {
}

func (*awsAwsjson11_deserializeOpUpdateComment) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdateComment) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdateComment(response)
	}
	output := &UpdateCommentOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentUpdateCommentOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdateComment(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("CommentContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentContentRequiredException(response, errorBody)

	case strings.EqualFold("CommentContentSizeLimitExceededException", errorCode):
		return awsAwsjson11_deserializeErrorCommentContentSizeLimitExceededException(response, errorBody)

	case strings.EqualFold("CommentDeletedException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDeletedException(response, errorBody)

	case strings.EqualFold("CommentDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorCommentDoesNotExistException(response, errorBody)

	case strings.EqualFold("CommentIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorCommentIdRequiredException(response, errorBody)

	case strings.EqualFold("CommentNotCreatedByCallerException", errorCode):
		return awsAwsjson11_deserializeErrorCommentNotCreatedByCallerException(response, errorBody)

	case strings.EqualFold("InvalidCommentIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidCommentIdException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdateDefaultBranch struct {
}

func (*awsAwsjson11_deserializeOpUpdateDefaultBranch) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdateDefaultBranch) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdateDefaultBranch(response)
	}
	output := &UpdateDefaultBranchOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentUpdateDefaultBranchOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdateDefaultBranch(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("BranchDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorBranchDoesNotExistException(response, errorBody)

	case strings.EqualFold("BranchNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorBranchNameRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidBranchNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidBranchNameException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdatePullRequestApprovalRuleContent struct {
}

func (*awsAwsjson11_deserializeOpUpdatePullRequestApprovalRuleContent) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdatePullRequestApprovalRuleContent) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdatePullRequestApprovalRuleContent(response)
	}
	output := &UpdatePullRequestApprovalRuleContentOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentUpdatePullRequestApprovalRuleContentOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdatePullRequestApprovalRuleContent(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalRuleContentRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleContentRequiredException(response, errorBody)

	case strings.EqualFold("ApprovalRuleDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleDoesNotExistException(response, errorBody)

	case strings.EqualFold("ApprovalRuleNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalRuleNameRequiredException(response, errorBody)

	case strings.EqualFold("CannotModifyApprovalRuleFromTemplateException", errorCode):
		return awsAwsjson11_deserializeErrorCannotModifyApprovalRuleFromTemplateException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleContentException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleContentException(response, errorBody)

	case strings.EqualFold("InvalidApprovalRuleNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalRuleNameException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRuleContentSha256Exception", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRuleContentSha256Exception(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdatePullRequestApprovalState struct {
}

func (*awsAwsjson11_deserializeOpUpdatePullRequestApprovalState) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdatePullRequestApprovalState) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdatePullRequestApprovalState(response)
	}
	output := &UpdatePullRequestApprovalStateOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentUpdatePullRequestApprovalStateOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdatePullRequestApprovalState(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("ApprovalStateRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorApprovalStateRequiredException(response, errorBody)

	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidApprovalStateException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidApprovalStateException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidRevisionIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRevisionIdException(response, errorBody)

	case strings.EqualFold("MaximumNumberOfApprovalsExceededException", errorCode):
		return awsAwsjson11_deserializeErrorMaximumNumberOfApprovalsExceededException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestCannotBeApprovedByAuthorException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestCannotBeApprovedByAuthorException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("RevisionIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRevisionIdRequiredException(response, errorBody)

	case strings.EqualFold("RevisionNotCurrentException", errorCode):
		return awsAwsjson11_deserializeErrorRevisionNotCurrentException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdatePullRequestDescription struct {
}

func (*awsAwsjson11_deserializeOpUpdatePullRequestDescription) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdatePullRequestDescription) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdatePullRequestDescription(response)
	}
	output := &UpdatePullRequestDescriptionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentUpdatePullRequestDescriptionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdatePullRequestDescription(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("InvalidDescriptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidDescriptionException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdatePullRequestStatus struct {
}

func (*awsAwsjson11_deserializeOpUpdatePullRequestStatus) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdatePullRequestStatus) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdatePullRequestStatus(response)
	}
	output := &UpdatePullRequestStatusOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentUpdatePullRequestStatusOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdatePullRequestStatus(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestStatusException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestStatusException(response, errorBody)

	case strings.EqualFold("InvalidPullRequestStatusUpdateException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestStatusUpdateException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("PullRequestStatusRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestStatusRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdatePullRequestTitle struct {
}

func (*awsAwsjson11_deserializeOpUpdatePullRequestTitle) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdatePullRequestTitle) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdatePullRequestTitle(response)
	}
	output := &UpdatePullRequestTitleOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeOpDocumentUpdatePullRequestTitleOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdatePullRequestTitle(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("InvalidPullRequestIdException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response, errorBody)

	case strings.EqualFold("InvalidTitleException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidTitleException(response, errorBody)

	case strings.EqualFold("PullRequestAlreadyClosedException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response, errorBody)

	case strings.EqualFold("PullRequestDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response, errorBody)

	case strings.EqualFold("PullRequestIdRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response, errorBody)

	case strings.EqualFold("TitleRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorTitleRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdateRepositoryDescription struct {
}

func (*awsAwsjson11_deserializeOpUpdateRepositoryDescription) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdateRepositoryDescription) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdateRepositoryDescription(response)
	}
	output := &UpdateRepositoryDescriptionOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentUpdateRepositoryDescriptionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdateRepositoryDescription(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("EncryptionIntegrityChecksFailedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyAccessDeniedException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response, errorBody)

	case strings.EqualFold("EncryptionKeyDisabledException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response, errorBody)

	case strings.EqualFold("EncryptionKeyNotFoundException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response, errorBody)

	case strings.EqualFold("EncryptionKeyUnavailableException", errorCode):
		return awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryDescriptionException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryDescriptionException(response, errorBody)

	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsAwsjson11_deserializeOpUpdateRepositoryName struct {
}

func (*awsAwsjson11_deserializeOpUpdateRepositoryName) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsjson11_deserializeOpUpdateRepositoryName) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsjson11_deserializeOpErrorUpdateRepositoryName(response)
	}
	output := &UpdateRepositoryNameOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(response.Body, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	err = awsAwsjson11_deserializeDocumentUpdateRepositoryNameOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsAwsjson11_deserializeOpErrorUpdateRepositoryName(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	code := response.Header.Get("X-Amzn-ErrorType")
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	code, message, err := restjson.GetErrorInfo(decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	if len(code) != 0 {
		errorCode = restjson.SanitizeErrorCode(code)
	}
	if len(message) != 0 {
		errorMessage = message
	}

	switch {
	case strings.EqualFold("InvalidRepositoryNameException", errorCode):
		return awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response, errorBody)

	case strings.EqualFold("RepositoryDoesNotExistException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response, errorBody)

	case strings.EqualFold("RepositoryNameExistsException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameExistsException(response, errorBody)

	case strings.EqualFold("RepositoryNameRequiredException", errorCode):
		return awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsAwsjson11_deserializeErrorActorDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ActorDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentActorDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleContentRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleContentRequiredException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleContentRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleNameAlreadyExistsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleNameAlreadyExistsException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleNameAlreadyExistsException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleNameRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleNameRequiredException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleNameRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleTemplateContentRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleTemplateContentRequiredException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleTemplateContentRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleTemplateDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleTemplateDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleTemplateDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleTemplateInUseException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleTemplateInUseException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleTemplateInUseException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleTemplateNameAlreadyExistsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleTemplateNameAlreadyExistsException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleTemplateNameAlreadyExistsException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalRuleTemplateNameRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalRuleTemplateNameRequiredException{}
	err := awsAwsjson11_deserializeDocumentApprovalRuleTemplateNameRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorApprovalStateRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ApprovalStateRequiredException{}
	err := awsAwsjson11_deserializeDocumentApprovalStateRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorAuthorDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.AuthorDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentAuthorDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorBeforeCommitIdAndAfterCommitIdAreSameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.BeforeCommitIdAndAfterCommitIdAreSameException{}
	err := awsAwsjson11_deserializeDocumentBeforeCommitIdAndAfterCommitIdAreSameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorBlobIdDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.BlobIdDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentBlobIdDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorBlobIdRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.BlobIdRequiredException{}
	err := awsAwsjson11_deserializeDocumentBlobIdRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorBranchDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.BranchDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentBranchDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorBranchNameExistsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.BranchNameExistsException{}
	err := awsAwsjson11_deserializeDocumentBranchNameExistsException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorBranchNameIsTagNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.BranchNameIsTagNameException{}
	err := awsAwsjson11_deserializeDocumentBranchNameIsTagNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorBranchNameRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.BranchNameRequiredException{}
	err := awsAwsjson11_deserializeDocumentBranchNameRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCannotDeleteApprovalRuleFromTemplateException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CannotDeleteApprovalRuleFromTemplateException{}
	err := awsAwsjson11_deserializeDocumentCannotDeleteApprovalRuleFromTemplateException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCannotModifyApprovalRuleFromTemplateException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CannotModifyApprovalRuleFromTemplateException{}
	err := awsAwsjson11_deserializeDocumentCannotModifyApprovalRuleFromTemplateException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorClientRequestTokenRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ClientRequestTokenRequiredException{}
	err := awsAwsjson11_deserializeDocumentClientRequestTokenRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommentContentRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommentContentRequiredException{}
	err := awsAwsjson11_deserializeDocumentCommentContentRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommentContentSizeLimitExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommentContentSizeLimitExceededException{}
	err := awsAwsjson11_deserializeDocumentCommentContentSizeLimitExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommentDeletedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommentDeletedException{}
	err := awsAwsjson11_deserializeDocumentCommentDeletedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommentDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommentDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentCommentDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommentIdRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommentIdRequiredException{}
	err := awsAwsjson11_deserializeDocumentCommentIdRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommentNotCreatedByCallerException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommentNotCreatedByCallerException{}
	err := awsAwsjson11_deserializeDocumentCommentNotCreatedByCallerException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommitDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommitDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentCommitDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommitIdDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommitIdDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentCommitIdDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommitIdRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommitIdRequiredException{}
	err := awsAwsjson11_deserializeDocumentCommitIdRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommitIdsLimitExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommitIdsLimitExceededException{}
	err := awsAwsjson11_deserializeDocumentCommitIdsLimitExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommitIdsListRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommitIdsListRequiredException{}
	err := awsAwsjson11_deserializeDocumentCommitIdsListRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommitMessageLengthExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommitMessageLengthExceededException{}
	err := awsAwsjson11_deserializeDocumentCommitMessageLengthExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorCommitRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.CommitRequiredException{}
	err := awsAwsjson11_deserializeDocumentCommitRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorConcurrentReferenceUpdateException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ConcurrentReferenceUpdateException{}
	err := awsAwsjson11_deserializeDocumentConcurrentReferenceUpdateException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorDefaultBranchCannotBeDeletedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.DefaultBranchCannotBeDeletedException{}
	err := awsAwsjson11_deserializeDocumentDefaultBranchCannotBeDeletedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorDirectoryNameConflictsWithFileNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.DirectoryNameConflictsWithFileNameException{}
	err := awsAwsjson11_deserializeDocumentDirectoryNameConflictsWithFileNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorEncryptionIntegrityChecksFailedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.EncryptionIntegrityChecksFailedException{}
	err := awsAwsjson11_deserializeDocumentEncryptionIntegrityChecksFailedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorEncryptionKeyAccessDeniedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.EncryptionKeyAccessDeniedException{}
	err := awsAwsjson11_deserializeDocumentEncryptionKeyAccessDeniedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorEncryptionKeyDisabledException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.EncryptionKeyDisabledException{}
	err := awsAwsjson11_deserializeDocumentEncryptionKeyDisabledException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorEncryptionKeyNotFoundException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.EncryptionKeyNotFoundException{}
	err := awsAwsjson11_deserializeDocumentEncryptionKeyNotFoundException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorEncryptionKeyUnavailableException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.EncryptionKeyUnavailableException{}
	err := awsAwsjson11_deserializeDocumentEncryptionKeyUnavailableException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFileContentAndSourceFileSpecifiedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FileContentAndSourceFileSpecifiedException{}
	err := awsAwsjson11_deserializeDocumentFileContentAndSourceFileSpecifiedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFileContentRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FileContentRequiredException{}
	err := awsAwsjson11_deserializeDocumentFileContentRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFileContentSizeLimitExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FileContentSizeLimitExceededException{}
	err := awsAwsjson11_deserializeDocumentFileContentSizeLimitExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFileDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FileDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentFileDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFileEntryRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FileEntryRequiredException{}
	err := awsAwsjson11_deserializeDocumentFileEntryRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFileModeRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FileModeRequiredException{}
	err := awsAwsjson11_deserializeDocumentFileModeRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFileNameConflictsWithDirectoryNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FileNameConflictsWithDirectoryNameException{}
	err := awsAwsjson11_deserializeDocumentFileNameConflictsWithDirectoryNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFilePathConflictsWithSubmodulePathException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FilePathConflictsWithSubmodulePathException{}
	err := awsAwsjson11_deserializeDocumentFilePathConflictsWithSubmodulePathException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFileTooLargeException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FileTooLargeException{}
	err := awsAwsjson11_deserializeDocumentFileTooLargeException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFolderContentSizeLimitExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FolderContentSizeLimitExceededException{}
	err := awsAwsjson11_deserializeDocumentFolderContentSizeLimitExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorFolderDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.FolderDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentFolderDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorIdempotencyParameterMismatchException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.IdempotencyParameterMismatchException{}
	err := awsAwsjson11_deserializeDocumentIdempotencyParameterMismatchException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidActorArnException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidActorArnException{}
	err := awsAwsjson11_deserializeDocumentInvalidActorArnException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidApprovalRuleContentException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidApprovalRuleContentException{}
	err := awsAwsjson11_deserializeDocumentInvalidApprovalRuleContentException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidApprovalRuleNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidApprovalRuleNameException{}
	err := awsAwsjson11_deserializeDocumentInvalidApprovalRuleNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateContentException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidApprovalRuleTemplateContentException{}
	err := awsAwsjson11_deserializeDocumentInvalidApprovalRuleTemplateContentException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateDescriptionException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidApprovalRuleTemplateDescriptionException{}
	err := awsAwsjson11_deserializeDocumentInvalidApprovalRuleTemplateDescriptionException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidApprovalRuleTemplateNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidApprovalRuleTemplateNameException{}
	err := awsAwsjson11_deserializeDocumentInvalidApprovalRuleTemplateNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidApprovalStateException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidApprovalStateException{}
	err := awsAwsjson11_deserializeDocumentInvalidApprovalStateException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidAuthorArnException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidAuthorArnException{}
	err := awsAwsjson11_deserializeDocumentInvalidAuthorArnException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidBlobIdException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidBlobIdException{}
	err := awsAwsjson11_deserializeDocumentInvalidBlobIdException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidBranchNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidBranchNameException{}
	err := awsAwsjson11_deserializeDocumentInvalidBranchNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidClientRequestTokenException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidClientRequestTokenException{}
	err := awsAwsjson11_deserializeDocumentInvalidClientRequestTokenException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidCommentIdException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidCommentIdException{}
	err := awsAwsjson11_deserializeDocumentInvalidCommentIdException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidCommitException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidCommitException{}
	err := awsAwsjson11_deserializeDocumentInvalidCommitException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidCommitIdException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidCommitIdException{}
	err := awsAwsjson11_deserializeDocumentInvalidCommitIdException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidConflictDetailLevelException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidConflictDetailLevelException{}
	err := awsAwsjson11_deserializeDocumentInvalidConflictDetailLevelException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidConflictResolutionException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidConflictResolutionException{}
	err := awsAwsjson11_deserializeDocumentInvalidConflictResolutionException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidConflictResolutionStrategyException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidConflictResolutionStrategyException{}
	err := awsAwsjson11_deserializeDocumentInvalidConflictResolutionStrategyException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidContinuationTokenException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidContinuationTokenException{}
	err := awsAwsjson11_deserializeDocumentInvalidContinuationTokenException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidDeletionParameterException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidDeletionParameterException{}
	err := awsAwsjson11_deserializeDocumentInvalidDeletionParameterException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidDescriptionException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidDescriptionException{}
	err := awsAwsjson11_deserializeDocumentInvalidDescriptionException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidDestinationCommitSpecifierException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidDestinationCommitSpecifierException{}
	err := awsAwsjson11_deserializeDocumentInvalidDestinationCommitSpecifierException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidEmailException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidEmailException{}
	err := awsAwsjson11_deserializeDocumentInvalidEmailException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidFileLocationException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidFileLocationException{}
	err := awsAwsjson11_deserializeDocumentInvalidFileLocationException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidFileModeException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidFileModeException{}
	err := awsAwsjson11_deserializeDocumentInvalidFileModeException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidFilePositionException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidFilePositionException{}
	err := awsAwsjson11_deserializeDocumentInvalidFilePositionException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidMaxConflictFilesException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidMaxConflictFilesException{}
	err := awsAwsjson11_deserializeDocumentInvalidMaxConflictFilesException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidMaxMergeHunksException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidMaxMergeHunksException{}
	err := awsAwsjson11_deserializeDocumentInvalidMaxMergeHunksException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidMaxResultsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidMaxResultsException{}
	err := awsAwsjson11_deserializeDocumentInvalidMaxResultsException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidMergeOptionException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidMergeOptionException{}
	err := awsAwsjson11_deserializeDocumentInvalidMergeOptionException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidOrderException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidOrderException{}
	err := awsAwsjson11_deserializeDocumentInvalidOrderException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidOverrideStatusException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidOverrideStatusException{}
	err := awsAwsjson11_deserializeDocumentInvalidOverrideStatusException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidParentCommitIdException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidParentCommitIdException{}
	err := awsAwsjson11_deserializeDocumentInvalidParentCommitIdException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidPathException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidPathException{}
	err := awsAwsjson11_deserializeDocumentInvalidPathException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidPullRequestEventTypeException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidPullRequestEventTypeException{}
	err := awsAwsjson11_deserializeDocumentInvalidPullRequestEventTypeException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidPullRequestIdException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidPullRequestIdException{}
	err := awsAwsjson11_deserializeDocumentInvalidPullRequestIdException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidPullRequestStatusException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidPullRequestStatusException{}
	err := awsAwsjson11_deserializeDocumentInvalidPullRequestStatusException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidPullRequestStatusUpdateException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidPullRequestStatusUpdateException{}
	err := awsAwsjson11_deserializeDocumentInvalidPullRequestStatusUpdateException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidReactionUserArnException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidReactionUserArnException{}
	err := awsAwsjson11_deserializeDocumentInvalidReactionUserArnException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidReactionValueException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidReactionValueException{}
	err := awsAwsjson11_deserializeDocumentInvalidReactionValueException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidReferenceNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidReferenceNameException{}
	err := awsAwsjson11_deserializeDocumentInvalidReferenceNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRelativeFileVersionEnumException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRelativeFileVersionEnumException{}
	err := awsAwsjson11_deserializeDocumentInvalidRelativeFileVersionEnumException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidReplacementContentException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidReplacementContentException{}
	err := awsAwsjson11_deserializeDocumentInvalidReplacementContentException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidReplacementTypeException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidReplacementTypeException{}
	err := awsAwsjson11_deserializeDocumentInvalidReplacementTypeException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRepositoryDescriptionException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRepositoryDescriptionException{}
	err := awsAwsjson11_deserializeDocumentInvalidRepositoryDescriptionException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRepositoryNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRepositoryNameException{}
	err := awsAwsjson11_deserializeDocumentInvalidRepositoryNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRepositoryTriggerBranchNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRepositoryTriggerBranchNameException{}
	err := awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerBranchNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRepositoryTriggerCustomDataException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRepositoryTriggerCustomDataException{}
	err := awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerCustomDataException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRepositoryTriggerDestinationArnException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRepositoryTriggerDestinationArnException{}
	err := awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerDestinationArnException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRepositoryTriggerEventsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRepositoryTriggerEventsException{}
	err := awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerEventsException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRepositoryTriggerNameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRepositoryTriggerNameException{}
	err := awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerNameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRepositoryTriggerRegionException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRepositoryTriggerRegionException{}
	err := awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerRegionException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidResourceArnException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidResourceArnException{}
	err := awsAwsjson11_deserializeDocumentInvalidResourceArnException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRevisionIdException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRevisionIdException{}
	err := awsAwsjson11_deserializeDocumentInvalidRevisionIdException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidRuleContentSha256Exception(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidRuleContentSha256Exception{}
	err := awsAwsjson11_deserializeDocumentInvalidRuleContentSha256Exception(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidSortByException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidSortByException{}
	err := awsAwsjson11_deserializeDocumentInvalidSortByException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidSourceCommitSpecifierException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidSourceCommitSpecifierException{}
	err := awsAwsjson11_deserializeDocumentInvalidSourceCommitSpecifierException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidSystemTagUsageException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidSystemTagUsageException{}
	err := awsAwsjson11_deserializeDocumentInvalidSystemTagUsageException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidTagKeysListException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidTagKeysListException{}
	err := awsAwsjson11_deserializeDocumentInvalidTagKeysListException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidTagsMapException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidTagsMapException{}
	err := awsAwsjson11_deserializeDocumentInvalidTagsMapException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidTargetBranchException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidTargetBranchException{}
	err := awsAwsjson11_deserializeDocumentInvalidTargetBranchException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidTargetException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidTargetException{}
	err := awsAwsjson11_deserializeDocumentInvalidTargetException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidTargetsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidTargetsException{}
	err := awsAwsjson11_deserializeDocumentInvalidTargetsException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorInvalidTitleException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.InvalidTitleException{}
	err := awsAwsjson11_deserializeDocumentInvalidTitleException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorManualMergeRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ManualMergeRequiredException{}
	err := awsAwsjson11_deserializeDocumentManualMergeRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumBranchesExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumBranchesExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumBranchesExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumConflictResolutionEntriesExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumConflictResolutionEntriesExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumConflictResolutionEntriesExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumFileContentToLoadExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumFileContentToLoadExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumFileContentToLoadExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumFileEntriesExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumFileEntriesExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumFileEntriesExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumItemsToCompareExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumItemsToCompareExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumItemsToCompareExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumNumberOfApprovalsExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumNumberOfApprovalsExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumNumberOfApprovalsExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumOpenPullRequestsExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumOpenPullRequestsExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumOpenPullRequestsExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumRepositoryNamesExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumRepositoryNamesExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumRepositoryNamesExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumRepositoryTriggersExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumRepositoryTriggersExceededException{}
	err := awsAwsjson11_deserializeDocumentMaximumRepositoryTriggersExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMaximumRuleTemplatesAssociatedWithRepositoryException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MaximumRuleTemplatesAssociatedWithRepositoryException{}
	err := awsAwsjson11_deserializeDocumentMaximumRuleTemplatesAssociatedWithRepositoryException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMergeOptionRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MergeOptionRequiredException{}
	err := awsAwsjson11_deserializeDocumentMergeOptionRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMultipleConflictResolutionEntriesException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MultipleConflictResolutionEntriesException{}
	err := awsAwsjson11_deserializeDocumentMultipleConflictResolutionEntriesException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorMultipleRepositoriesInPullRequestException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.MultipleRepositoriesInPullRequestException{}
	err := awsAwsjson11_deserializeDocumentMultipleRepositoriesInPullRequestException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorNameLengthExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.NameLengthExceededException{}
	err := awsAwsjson11_deserializeDocumentNameLengthExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorNoChangeException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.NoChangeException{}
	err := awsAwsjson11_deserializeDocumentNoChangeException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorNumberOfRulesExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.NumberOfRulesExceededException{}
	err := awsAwsjson11_deserializeDocumentNumberOfRulesExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorNumberOfRuleTemplatesExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.NumberOfRuleTemplatesExceededException{}
	err := awsAwsjson11_deserializeDocumentNumberOfRuleTemplatesExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorOverrideAlreadySetException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.OverrideAlreadySetException{}
	err := awsAwsjson11_deserializeDocumentOverrideAlreadySetException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorOverrideStatusRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.OverrideStatusRequiredException{}
	err := awsAwsjson11_deserializeDocumentOverrideStatusRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorParentCommitDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ParentCommitDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentParentCommitDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorParentCommitIdOutdatedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ParentCommitIdOutdatedException{}
	err := awsAwsjson11_deserializeDocumentParentCommitIdOutdatedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorParentCommitIdRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ParentCommitIdRequiredException{}
	err := awsAwsjson11_deserializeDocumentParentCommitIdRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPathDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PathDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentPathDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPathRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PathRequiredException{}
	err := awsAwsjson11_deserializeDocumentPathRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPullRequestAlreadyClosedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PullRequestAlreadyClosedException{}
	err := awsAwsjson11_deserializeDocumentPullRequestAlreadyClosedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPullRequestApprovalRulesNotSatisfiedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PullRequestApprovalRulesNotSatisfiedException{}
	err := awsAwsjson11_deserializeDocumentPullRequestApprovalRulesNotSatisfiedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPullRequestCannotBeApprovedByAuthorException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PullRequestCannotBeApprovedByAuthorException{}
	err := awsAwsjson11_deserializeDocumentPullRequestCannotBeApprovedByAuthorException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPullRequestDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PullRequestDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentPullRequestDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPullRequestIdRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PullRequestIdRequiredException{}
	err := awsAwsjson11_deserializeDocumentPullRequestIdRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPullRequestStatusRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PullRequestStatusRequiredException{}
	err := awsAwsjson11_deserializeDocumentPullRequestStatusRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorPutFileEntryConflictException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.PutFileEntryConflictException{}
	err := awsAwsjson11_deserializeDocumentPutFileEntryConflictException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorReactionLimitExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ReactionLimitExceededException{}
	err := awsAwsjson11_deserializeDocumentReactionLimitExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorReactionValueRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ReactionValueRequiredException{}
	err := awsAwsjson11_deserializeDocumentReactionValueRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorReferenceDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ReferenceDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentReferenceDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorReferenceNameRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ReferenceNameRequiredException{}
	err := awsAwsjson11_deserializeDocumentReferenceNameRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorReferenceTypeNotSupportedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ReferenceTypeNotSupportedException{}
	err := awsAwsjson11_deserializeDocumentReferenceTypeNotSupportedException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorReplacementContentRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ReplacementContentRequiredException{}
	err := awsAwsjson11_deserializeDocumentReplacementContentRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorReplacementTypeRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ReplacementTypeRequiredException{}
	err := awsAwsjson11_deserializeDocumentReplacementTypeRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryDoesNotExistException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryDoesNotExistException{}
	err := awsAwsjson11_deserializeDocumentRepositoryDoesNotExistException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryLimitExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryLimitExceededException{}
	err := awsAwsjson11_deserializeDocumentRepositoryLimitExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryNameExistsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryNameExistsException{}
	err := awsAwsjson11_deserializeDocumentRepositoryNameExistsException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryNameRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryNameRequiredException{}
	err := awsAwsjson11_deserializeDocumentRepositoryNameRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryNamesRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryNamesRequiredException{}
	err := awsAwsjson11_deserializeDocumentRepositoryNamesRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryNotAssociatedWithPullRequestException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryNotAssociatedWithPullRequestException{}
	err := awsAwsjson11_deserializeDocumentRepositoryNotAssociatedWithPullRequestException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryTriggerBranchNameListRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryTriggerBranchNameListRequiredException{}
	err := awsAwsjson11_deserializeDocumentRepositoryTriggerBranchNameListRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryTriggerDestinationArnRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryTriggerDestinationArnRequiredException{}
	err := awsAwsjson11_deserializeDocumentRepositoryTriggerDestinationArnRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryTriggerEventsListRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryTriggerEventsListRequiredException{}
	err := awsAwsjson11_deserializeDocumentRepositoryTriggerEventsListRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryTriggerNameRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryTriggerNameRequiredException{}
	err := awsAwsjson11_deserializeDocumentRepositoryTriggerNameRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRepositoryTriggersListRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RepositoryTriggersListRequiredException{}
	err := awsAwsjson11_deserializeDocumentRepositoryTriggersListRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorResourceArnRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.ResourceArnRequiredException{}
	err := awsAwsjson11_deserializeDocumentResourceArnRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRestrictedSourceFileException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RestrictedSourceFileException{}
	err := awsAwsjson11_deserializeDocumentRestrictedSourceFileException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRevisionIdRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RevisionIdRequiredException{}
	err := awsAwsjson11_deserializeDocumentRevisionIdRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorRevisionNotCurrentException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.RevisionNotCurrentException{}
	err := awsAwsjson11_deserializeDocumentRevisionNotCurrentException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorSameFileContentException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.SameFileContentException{}
	err := awsAwsjson11_deserializeDocumentSameFileContentException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorSamePathRequestException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.SamePathRequestException{}
	err := awsAwsjson11_deserializeDocumentSamePathRequestException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorSourceAndDestinationAreSameException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.SourceAndDestinationAreSameException{}
	err := awsAwsjson11_deserializeDocumentSourceAndDestinationAreSameException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorSourceFileOrContentRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.SourceFileOrContentRequiredException{}
	err := awsAwsjson11_deserializeDocumentSourceFileOrContentRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTagKeysListRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TagKeysListRequiredException{}
	err := awsAwsjson11_deserializeDocumentTagKeysListRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTagPolicyException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TagPolicyException{}
	err := awsAwsjson11_deserializeDocumentTagPolicyException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTagsMapRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TagsMapRequiredException{}
	err := awsAwsjson11_deserializeDocumentTagsMapRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTargetRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TargetRequiredException{}
	err := awsAwsjson11_deserializeDocumentTargetRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTargetsRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TargetsRequiredException{}
	err := awsAwsjson11_deserializeDocumentTargetsRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTipOfSourceReferenceIsDifferentException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TipOfSourceReferenceIsDifferentException{}
	err := awsAwsjson11_deserializeDocumentTipOfSourceReferenceIsDifferentException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTipsDivergenceExceededException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TipsDivergenceExceededException{}
	err := awsAwsjson11_deserializeDocumentTipsDivergenceExceededException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTitleRequiredException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TitleRequiredException{}
	err := awsAwsjson11_deserializeDocumentTitleRequiredException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeErrorTooManyTagsException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)

	body := io.TeeReader(errorBody, ringBuffer)
	decoder := json.NewDecoder(body)
	decoder.UseNumber()

	output := &types.TooManyTagsException{}
	err := awsAwsjson11_deserializeDocumentTooManyTagsException(&output, decoder)

	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	errorBody.Seek(0, io.SeekStart)
	return output
}

func awsAwsjson11_deserializeDocumentActorDoesNotExistException(v **types.ActorDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ActorDoesNotExistException
	if *v == nil {
		sv = &types.ActorDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApproval(v **types.Approval, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Approval
	if *v == nil {
		sv = &types.Approval{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalState":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalState to be of type string, got %T instead", val)
				}
				sv.ApprovalState = types.ApprovalState(jtv)
			}

		case "userArn":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.UserArn = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalList(v *[]*types.Approval, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.Approval
	if *v == nil {
		cv = []*types.Approval{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.Approval
		if err := awsAwsjson11_deserializeDocumentApproval(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRule(v **types.ApprovalRule, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRule
	if *v == nil {
		sv = &types.ApprovalRule{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleContent":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleContent to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleContent = &jtv
			}

		case "approvalRuleId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleId to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleId = &jtv
			}

		case "approvalRuleName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleName to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleName = &jtv
			}

		case "creationDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected CreationDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.CreationDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "lastModifiedDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected LastModifiedDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.LastModifiedDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "lastModifiedUser":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.LastModifiedUser = &jtv
			}

		case "originApprovalRuleTemplate":
			if err := awsAwsjson11_deserializeDocumentOriginApprovalRuleTemplate(&sv.OriginApprovalRuleTemplate, decoder); err != nil {
				return err
			}

		case "ruleContentSha256":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RuleContentSha256 to be of type string, got %T instead", val)
				}
				sv.RuleContentSha256 = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleContentRequiredException(v **types.ApprovalRuleContentRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleContentRequiredException
	if *v == nil {
		sv = &types.ApprovalRuleContentRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleDoesNotExistException(v **types.ApprovalRuleDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleDoesNotExistException
	if *v == nil {
		sv = &types.ApprovalRuleDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleEventMetadata(v **types.ApprovalRuleEventMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleEventMetadata
	if *v == nil {
		sv = &types.ApprovalRuleEventMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleContent":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleContent to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleContent = &jtv
			}

		case "approvalRuleId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleId to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleId = &jtv
			}

		case "approvalRuleName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleName to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleNameAlreadyExistsException(v **types.ApprovalRuleNameAlreadyExistsException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleNameAlreadyExistsException
	if *v == nil {
		sv = &types.ApprovalRuleNameAlreadyExistsException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleNameRequiredException(v **types.ApprovalRuleNameRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleNameRequiredException
	if *v == nil {
		sv = &types.ApprovalRuleNameRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleOverriddenEventMetadata(v **types.ApprovalRuleOverriddenEventMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleOverriddenEventMetadata
	if *v == nil {
		sv = &types.ApprovalRuleOverriddenEventMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "overrideStatus":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected OverrideStatus to be of type string, got %T instead", val)
				}
				sv.OverrideStatus = types.OverrideStatus(jtv)
			}

		case "revisionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RevisionId to be of type string, got %T instead", val)
				}
				sv.RevisionId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRulesList(v *[]*types.ApprovalRule, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.ApprovalRule
	if *v == nil {
		cv = []*types.ApprovalRule{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.ApprovalRule
		if err := awsAwsjson11_deserializeDocumentApprovalRule(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRulesNotSatisfiedList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected ApprovalRuleName to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRulesSatisfiedList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected ApprovalRuleName to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleTemplate(v **types.ApprovalRuleTemplate, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleTemplate
	if *v == nil {
		sv = &types.ApprovalRuleTemplate{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplateContent":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleTemplateContent to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleTemplateContent = &jtv
			}

		case "approvalRuleTemplateDescription":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleTemplateDescription to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleTemplateDescription = &jtv
			}

		case "approvalRuleTemplateId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleTemplateId to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleTemplateId = &jtv
			}

		case "approvalRuleTemplateName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleTemplateName to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleTemplateName = &jtv
			}

		case "creationDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected CreationDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.CreationDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "lastModifiedDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected LastModifiedDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.LastModifiedDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "lastModifiedUser":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.LastModifiedUser = &jtv
			}

		case "ruleContentSha256":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RuleContentSha256 to be of type string, got %T instead", val)
				}
				sv.RuleContentSha256 = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleTemplateContentRequiredException(v **types.ApprovalRuleTemplateContentRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleTemplateContentRequiredException
	if *v == nil {
		sv = &types.ApprovalRuleTemplateContentRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleTemplateDoesNotExistException(v **types.ApprovalRuleTemplateDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleTemplateDoesNotExistException
	if *v == nil {
		sv = &types.ApprovalRuleTemplateDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleTemplateInUseException(v **types.ApprovalRuleTemplateInUseException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleTemplateInUseException
	if *v == nil {
		sv = &types.ApprovalRuleTemplateInUseException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleTemplateNameAlreadyExistsException(v **types.ApprovalRuleTemplateNameAlreadyExistsException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleTemplateNameAlreadyExistsException
	if *v == nil {
		sv = &types.ApprovalRuleTemplateNameAlreadyExistsException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleTemplateNameList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected ApprovalRuleTemplateName to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalRuleTemplateNameRequiredException(v **types.ApprovalRuleTemplateNameRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalRuleTemplateNameRequiredException
	if *v == nil {
		sv = &types.ApprovalRuleTemplateNameRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalStateChangedEventMetadata(v **types.ApprovalStateChangedEventMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalStateChangedEventMetadata
	if *v == nil {
		sv = &types.ApprovalStateChangedEventMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalStatus":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalState to be of type string, got %T instead", val)
				}
				sv.ApprovalStatus = types.ApprovalState(jtv)
			}

		case "revisionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RevisionId to be of type string, got %T instead", val)
				}
				sv.RevisionId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentApprovalStateRequiredException(v **types.ApprovalStateRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ApprovalStateRequiredException
	if *v == nil {
		sv = &types.ApprovalStateRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentAuthorDoesNotExistException(v **types.AuthorDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.AuthorDoesNotExistException
	if *v == nil {
		sv = &types.AuthorDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBatchAssociateApprovalRuleTemplateWithRepositoriesError(v **types.BatchAssociateApprovalRuleTemplateWithRepositoriesError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BatchAssociateApprovalRuleTemplateWithRepositoriesError
	if *v == nil {
		sv = &types.BatchAssociateApprovalRuleTemplateWithRepositoriesError{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "errorCode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ErrorCode to be of type string, got %T instead", val)
				}
				sv.ErrorCode = &jtv
			}

		case "errorMessage":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ErrorMessage to be of type string, got %T instead", val)
				}
				sv.ErrorMessage = &jtv
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBatchAssociateApprovalRuleTemplateWithRepositoriesErrorsList(v *[]*types.BatchAssociateApprovalRuleTemplateWithRepositoriesError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.BatchAssociateApprovalRuleTemplateWithRepositoriesError
	if *v == nil {
		cv = []*types.BatchAssociateApprovalRuleTemplateWithRepositoriesError{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.BatchAssociateApprovalRuleTemplateWithRepositoriesError
		if err := awsAwsjson11_deserializeDocumentBatchAssociateApprovalRuleTemplateWithRepositoriesError(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentBatchDescribeMergeConflictsError(v **types.BatchDescribeMergeConflictsError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BatchDescribeMergeConflictsError
	if *v == nil {
		sv = &types.BatchDescribeMergeConflictsError{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "exceptionName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ExceptionName to be of type string, got %T instead", val)
				}
				sv.ExceptionName = &jtv
			}

		case "filePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.FilePath = &jtv
			}

		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBatchDescribeMergeConflictsErrors(v *[]*types.BatchDescribeMergeConflictsError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.BatchDescribeMergeConflictsError
	if *v == nil {
		cv = []*types.BatchDescribeMergeConflictsError{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.BatchDescribeMergeConflictsError
		if err := awsAwsjson11_deserializeDocumentBatchDescribeMergeConflictsError(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentBatchDisassociateApprovalRuleTemplateFromRepositoriesError(v **types.BatchDisassociateApprovalRuleTemplateFromRepositoriesError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BatchDisassociateApprovalRuleTemplateFromRepositoriesError
	if *v == nil {
		sv = &types.BatchDisassociateApprovalRuleTemplateFromRepositoriesError{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "errorCode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ErrorCode to be of type string, got %T instead", val)
				}
				sv.ErrorCode = &jtv
			}

		case "errorMessage":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ErrorMessage to be of type string, got %T instead", val)
				}
				sv.ErrorMessage = &jtv
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBatchDisassociateApprovalRuleTemplateFromRepositoriesErrorsList(v *[]*types.BatchDisassociateApprovalRuleTemplateFromRepositoriesError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.BatchDisassociateApprovalRuleTemplateFromRepositoriesError
	if *v == nil {
		cv = []*types.BatchDisassociateApprovalRuleTemplateFromRepositoriesError{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.BatchDisassociateApprovalRuleTemplateFromRepositoriesError
		if err := awsAwsjson11_deserializeDocumentBatchDisassociateApprovalRuleTemplateFromRepositoriesError(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentBatchGetCommitsError(v **types.BatchGetCommitsError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BatchGetCommitsError
	if *v == nil {
		sv = &types.BatchGetCommitsError{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "errorCode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ErrorCode to be of type string, got %T instead", val)
				}
				sv.ErrorCode = &jtv
			}

		case "errorMessage":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ErrorMessage to be of type string, got %T instead", val)
				}
				sv.ErrorMessage = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBatchGetCommitsErrorsList(v *[]*types.BatchGetCommitsError, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.BatchGetCommitsError
	if *v == nil {
		cv = []*types.BatchGetCommitsError{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.BatchGetCommitsError
		if err := awsAwsjson11_deserializeDocumentBatchGetCommitsError(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentBeforeCommitIdAndAfterCommitIdAreSameException(v **types.BeforeCommitIdAndAfterCommitIdAreSameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BeforeCommitIdAndAfterCommitIdAreSameException
	if *v == nil {
		sv = &types.BeforeCommitIdAndAfterCommitIdAreSameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBlobIdDoesNotExistException(v **types.BlobIdDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BlobIdDoesNotExistException
	if *v == nil {
		sv = &types.BlobIdDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBlobIdRequiredException(v **types.BlobIdRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BlobIdRequiredException
	if *v == nil {
		sv = &types.BlobIdRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBlobMetadata(v **types.BlobMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BlobMetadata
	if *v == nil {
		sv = &types.BlobMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "blobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BlobId = &jtv
			}

		case "mode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Mode to be of type string, got %T instead", val)
				}
				sv.Mode = &jtv
			}

		case "path":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.Path = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBranchDoesNotExistException(v **types.BranchDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BranchDoesNotExistException
	if *v == nil {
		sv = &types.BranchDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBranchInfo(v **types.BranchInfo, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BranchInfo
	if *v == nil {
		sv = &types.BranchInfo{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "branchName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected BranchName to be of type string, got %T instead", val)
				}
				sv.BranchName = &jtv
			}

		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBranchNameExistsException(v **types.BranchNameExistsException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BranchNameExistsException
	if *v == nil {
		sv = &types.BranchNameExistsException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBranchNameIsTagNameException(v **types.BranchNameIsTagNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BranchNameIsTagNameException
	if *v == nil {
		sv = &types.BranchNameIsTagNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentBranchNameList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected BranchName to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentBranchNameRequiredException(v **types.BranchNameRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.BranchNameRequiredException
	if *v == nil {
		sv = &types.BranchNameRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCallerReactions(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected ReactionValue to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentCannotDeleteApprovalRuleFromTemplateException(v **types.CannotDeleteApprovalRuleFromTemplateException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CannotDeleteApprovalRuleFromTemplateException
	if *v == nil {
		sv = &types.CannotDeleteApprovalRuleFromTemplateException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCannotModifyApprovalRuleFromTemplateException(v **types.CannotModifyApprovalRuleFromTemplateException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CannotModifyApprovalRuleFromTemplateException
	if *v == nil {
		sv = &types.CannotModifyApprovalRuleFromTemplateException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentClientRequestTokenRequiredException(v **types.ClientRequestTokenRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ClientRequestTokenRequiredException
	if *v == nil {
		sv = &types.ClientRequestTokenRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentComment(v **types.Comment, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Comment
	if *v == nil {
		sv = &types.Comment{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "authorArn":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.AuthorArn = &jtv
			}

		case "callerReactions":
			if err := awsAwsjson11_deserializeDocumentCallerReactions(&sv.CallerReactions, decoder); err != nil {
				return err
			}

		case "clientRequestToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ClientRequestToken to be of type string, got %T instead", val)
				}
				sv.ClientRequestToken = &jtv
			}

		case "commentId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommentId to be of type string, got %T instead", val)
				}
				sv.CommentId = &jtv
			}

		case "content":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Content to be of type string, got %T instead", val)
				}
				sv.Content = &jtv
			}

		case "creationDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected CreationDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.CreationDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "deleted":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected IsCommentDeleted to be of type *bool, got %T instead", val)
				}
				sv.Deleted = &jtv
			}

		case "inReplyTo":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommentId to be of type string, got %T instead", val)
				}
				sv.InReplyTo = &jtv
			}

		case "lastModifiedDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected LastModifiedDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.LastModifiedDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "reactionCounts":
			if err := awsAwsjson11_deserializeDocumentReactionCountsMap(&sv.ReactionCounts, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentContentRequiredException(v **types.CommentContentRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommentContentRequiredException
	if *v == nil {
		sv = &types.CommentContentRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentContentSizeLimitExceededException(v **types.CommentContentSizeLimitExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommentContentSizeLimitExceededException
	if *v == nil {
		sv = &types.CommentContentSizeLimitExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentDeletedException(v **types.CommentDeletedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommentDeletedException
	if *v == nil {
		sv = &types.CommentDeletedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentDoesNotExistException(v **types.CommentDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommentDoesNotExistException
	if *v == nil {
		sv = &types.CommentDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentIdRequiredException(v **types.CommentIdRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommentIdRequiredException
	if *v == nil {
		sv = &types.CommentIdRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentNotCreatedByCallerException(v **types.CommentNotCreatedByCallerException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommentNotCreatedByCallerException
	if *v == nil {
		sv = &types.CommentNotCreatedByCallerException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentComments(v *[]*types.Comment, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.Comment
	if *v == nil {
		cv = []*types.Comment{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.Comment
		if err := awsAwsjson11_deserializeDocumentComment(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentsForComparedCommit(v **types.CommentsForComparedCommit, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommentsForComparedCommit
	if *v == nil {
		sv = &types.CommentsForComparedCommit{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "afterBlobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.AfterBlobId = &jtv
			}

		case "afterCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.AfterCommitId = &jtv
			}

		case "beforeBlobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BeforeBlobId = &jtv
			}

		case "beforeCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.BeforeCommitId = &jtv
			}

		case "comments":
			if err := awsAwsjson11_deserializeDocumentComments(&sv.Comments, decoder); err != nil {
				return err
			}

		case "location":
			if err := awsAwsjson11_deserializeDocumentLocation(&sv.Location, decoder); err != nil {
				return err
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentsForComparedCommitData(v *[]*types.CommentsForComparedCommit, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.CommentsForComparedCommit
	if *v == nil {
		cv = []*types.CommentsForComparedCommit{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.CommentsForComparedCommit
		if err := awsAwsjson11_deserializeDocumentCommentsForComparedCommit(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentsForPullRequest(v **types.CommentsForPullRequest, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommentsForPullRequest
	if *v == nil {
		sv = &types.CommentsForPullRequest{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "afterBlobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.AfterBlobId = &jtv
			}

		case "afterCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.AfterCommitId = &jtv
			}

		case "beforeBlobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BeforeBlobId = &jtv
			}

		case "beforeCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.BeforeCommitId = &jtv
			}

		case "comments":
			if err := awsAwsjson11_deserializeDocumentComments(&sv.Comments, decoder); err != nil {
				return err
			}

		case "location":
			if err := awsAwsjson11_deserializeDocumentLocation(&sv.Location, decoder); err != nil {
				return err
			}

		case "pullRequestId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected PullRequestId to be of type string, got %T instead", val)
				}
				sv.PullRequestId = &jtv
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommentsForPullRequestData(v *[]*types.CommentsForPullRequest, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.CommentsForPullRequest
	if *v == nil {
		cv = []*types.CommentsForPullRequest{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.CommentsForPullRequest
		if err := awsAwsjson11_deserializeDocumentCommentsForPullRequest(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentCommit(v **types.Commit, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Commit
	if *v == nil {
		sv = &types.Commit{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "additionalData":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected AdditionalData to be of type string, got %T instead", val)
				}
				sv.AdditionalData = &jtv
			}

		case "author":
			if err := awsAwsjson11_deserializeDocumentUserInfo(&sv.Author, decoder); err != nil {
				return err
			}

		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "committer":
			if err := awsAwsjson11_deserializeDocumentUserInfo(&sv.Committer, decoder); err != nil {
				return err
			}

		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		case "parents":
			if err := awsAwsjson11_deserializeDocumentParentList(&sv.Parents, decoder); err != nil {
				return err
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommitDoesNotExistException(v **types.CommitDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommitDoesNotExistException
	if *v == nil {
		sv = &types.CommitDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommitIdDoesNotExistException(v **types.CommitIdDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommitIdDoesNotExistException
	if *v == nil {
		sv = &types.CommitIdDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommitIdRequiredException(v **types.CommitIdRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommitIdRequiredException
	if *v == nil {
		sv = &types.CommitIdRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommitIdsLimitExceededException(v **types.CommitIdsLimitExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommitIdsLimitExceededException
	if *v == nil {
		sv = &types.CommitIdsLimitExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommitIdsListRequiredException(v **types.CommitIdsListRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommitIdsListRequiredException
	if *v == nil {
		sv = &types.CommitIdsListRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommitMessageLengthExceededException(v **types.CommitMessageLengthExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommitMessageLengthExceededException
	if *v == nil {
		sv = &types.CommitMessageLengthExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCommitObjectsList(v *[]*types.Commit, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.Commit
	if *v == nil {
		cv = []*types.Commit{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.Commit
		if err := awsAwsjson11_deserializeDocumentCommit(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentCommitRequiredException(v **types.CommitRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.CommitRequiredException
	if *v == nil {
		sv = &types.CommitRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentConcurrentReferenceUpdateException(v **types.ConcurrentReferenceUpdateException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ConcurrentReferenceUpdateException
	if *v == nil {
		sv = &types.ConcurrentReferenceUpdateException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentConflict(v **types.Conflict, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Conflict
	if *v == nil {
		sv = &types.Conflict{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "conflictMetadata":
			if err := awsAwsjson11_deserializeDocumentConflictMetadata(&sv.ConflictMetadata, decoder); err != nil {
				return err
			}

		case "mergeHunks":
			if err := awsAwsjson11_deserializeDocumentMergeHunks(&sv.MergeHunks, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentConflictMetadata(v **types.ConflictMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ConflictMetadata
	if *v == nil {
		sv = &types.ConflictMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "contentConflict":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected IsContentConflict to be of type *bool, got %T instead", val)
				}
				sv.ContentConflict = &jtv
			}

		case "fileModeConflict":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected IsFileModeConflict to be of type *bool, got %T instead", val)
				}
				sv.FileModeConflict = &jtv
			}

		case "fileModes":
			if err := awsAwsjson11_deserializeDocumentFileModes(&sv.FileModes, decoder); err != nil {
				return err
			}

		case "filePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.FilePath = &jtv
			}

		case "fileSizes":
			if err := awsAwsjson11_deserializeDocumentFileSizes(&sv.FileSizes, decoder); err != nil {
				return err
			}

		case "isBinaryFile":
			if err := awsAwsjson11_deserializeDocumentIsBinaryFile(&sv.IsBinaryFile, decoder); err != nil {
				return err
			}

		case "mergeOperations":
			if err := awsAwsjson11_deserializeDocumentMergeOperations(&sv.MergeOperations, decoder); err != nil {
				return err
			}

		case "numberOfConflicts":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected NumberOfConflicts to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.NumberOfConflicts = ptr.Int32(int32(i64))
			}

		case "objectTypeConflict":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected IsObjectTypeConflict to be of type *bool, got %T instead", val)
				}
				sv.ObjectTypeConflict = &jtv
			}

		case "objectTypes":
			if err := awsAwsjson11_deserializeDocumentObjectTypes(&sv.ObjectTypes, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentConflictMetadataList(v *[]*types.ConflictMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.ConflictMetadata
	if *v == nil {
		cv = []*types.ConflictMetadata{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.ConflictMetadata
		if err := awsAwsjson11_deserializeDocumentConflictMetadata(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentConflicts(v *[]*types.Conflict, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.Conflict
	if *v == nil {
		cv = []*types.Conflict{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.Conflict
		if err := awsAwsjson11_deserializeDocumentConflict(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentDefaultBranchCannotBeDeletedException(v **types.DefaultBranchCannotBeDeletedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.DefaultBranchCannotBeDeletedException
	if *v == nil {
		sv = &types.DefaultBranchCannotBeDeletedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentDifference(v **types.Difference, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Difference
	if *v == nil {
		sv = &types.Difference{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "afterBlob":
			if err := awsAwsjson11_deserializeDocumentBlobMetadata(&sv.AfterBlob, decoder); err != nil {
				return err
			}

		case "beforeBlob":
			if err := awsAwsjson11_deserializeDocumentBlobMetadata(&sv.BeforeBlob, decoder); err != nil {
				return err
			}

		case "changeType":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ChangeTypeEnum to be of type string, got %T instead", val)
				}
				sv.ChangeType = types.ChangeTypeEnum(jtv)
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentDifferenceList(v *[]*types.Difference, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.Difference
	if *v == nil {
		cv = []*types.Difference{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.Difference
		if err := awsAwsjson11_deserializeDocumentDifference(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentDirectoryNameConflictsWithFileNameException(v **types.DirectoryNameConflictsWithFileNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.DirectoryNameConflictsWithFileNameException
	if *v == nil {
		sv = &types.DirectoryNameConflictsWithFileNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentEncryptionIntegrityChecksFailedException(v **types.EncryptionIntegrityChecksFailedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.EncryptionIntegrityChecksFailedException
	if *v == nil {
		sv = &types.EncryptionIntegrityChecksFailedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentEncryptionKeyAccessDeniedException(v **types.EncryptionKeyAccessDeniedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.EncryptionKeyAccessDeniedException
	if *v == nil {
		sv = &types.EncryptionKeyAccessDeniedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentEncryptionKeyDisabledException(v **types.EncryptionKeyDisabledException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.EncryptionKeyDisabledException
	if *v == nil {
		sv = &types.EncryptionKeyDisabledException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentEncryptionKeyNotFoundException(v **types.EncryptionKeyNotFoundException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.EncryptionKeyNotFoundException
	if *v == nil {
		sv = &types.EncryptionKeyNotFoundException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentEncryptionKeyUnavailableException(v **types.EncryptionKeyUnavailableException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.EncryptionKeyUnavailableException
	if *v == nil {
		sv = &types.EncryptionKeyUnavailableException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentEvaluation(v **types.Evaluation, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Evaluation
	if *v == nil {
		sv = &types.Evaluation{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRulesNotSatisfied":
			if err := awsAwsjson11_deserializeDocumentApprovalRulesNotSatisfiedList(&sv.ApprovalRulesNotSatisfied, decoder); err != nil {
				return err
			}

		case "approvalRulesSatisfied":
			if err := awsAwsjson11_deserializeDocumentApprovalRulesSatisfiedList(&sv.ApprovalRulesSatisfied, decoder); err != nil {
				return err
			}

		case "approved":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected Approved to be of type *bool, got %T instead", val)
				}
				sv.Approved = &jtv
			}

		case "overridden":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected Overridden to be of type *bool, got %T instead", val)
				}
				sv.Overridden = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFile(v **types.File, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.File
	if *v == nil {
		sv = &types.File{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "absolutePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.AbsolutePath = &jtv
			}

		case "blobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BlobId = &jtv
			}

		case "fileMode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FileModeTypeEnum to be of type string, got %T instead", val)
				}
				sv.FileMode = types.FileModeTypeEnum(jtv)
			}

		case "relativePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.RelativePath = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileContentAndSourceFileSpecifiedException(v **types.FileContentAndSourceFileSpecifiedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileContentAndSourceFileSpecifiedException
	if *v == nil {
		sv = &types.FileContentAndSourceFileSpecifiedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileContentRequiredException(v **types.FileContentRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileContentRequiredException
	if *v == nil {
		sv = &types.FileContentRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileContentSizeLimitExceededException(v **types.FileContentSizeLimitExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileContentSizeLimitExceededException
	if *v == nil {
		sv = &types.FileContentSizeLimitExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileDoesNotExistException(v **types.FileDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileDoesNotExistException
	if *v == nil {
		sv = &types.FileDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileEntryRequiredException(v **types.FileEntryRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileEntryRequiredException
	if *v == nil {
		sv = &types.FileEntryRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileList(v *[]*types.File, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.File
	if *v == nil {
		cv = []*types.File{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.File
		if err := awsAwsjson11_deserializeDocumentFile(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentFileMetadata(v **types.FileMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileMetadata
	if *v == nil {
		sv = &types.FileMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "absolutePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.AbsolutePath = &jtv
			}

		case "blobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BlobId = &jtv
			}

		case "fileMode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FileModeTypeEnum to be of type string, got %T instead", val)
				}
				sv.FileMode = types.FileModeTypeEnum(jtv)
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileModeRequiredException(v **types.FileModeRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileModeRequiredException
	if *v == nil {
		sv = &types.FileModeRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileModes(v **types.FileModes, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileModes
	if *v == nil {
		sv = &types.FileModes{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "base":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FileModeTypeEnum to be of type string, got %T instead", val)
				}
				sv.Base = types.FileModeTypeEnum(jtv)
			}

		case "destination":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FileModeTypeEnum to be of type string, got %T instead", val)
				}
				sv.Destination = types.FileModeTypeEnum(jtv)
			}

		case "source":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FileModeTypeEnum to be of type string, got %T instead", val)
				}
				sv.Source = types.FileModeTypeEnum(jtv)
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileNameConflictsWithDirectoryNameException(v **types.FileNameConflictsWithDirectoryNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileNameConflictsWithDirectoryNameException
	if *v == nil {
		sv = &types.FileNameConflictsWithDirectoryNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFilePathConflictsWithSubmodulePathException(v **types.FilePathConflictsWithSubmodulePathException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FilePathConflictsWithSubmodulePathException
	if *v == nil {
		sv = &types.FilePathConflictsWithSubmodulePathException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFileSizes(v **types.FileSizes, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileSizes
	if *v == nil {
		sv = &types.FileSizes{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "base":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected FileSize to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.Base = &i64
			}

		case "destination":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected FileSize to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.Destination = &i64
			}

		case "source":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected FileSize to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.Source = &i64
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFilesMetadata(v *[]*types.FileMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.FileMetadata
	if *v == nil {
		cv = []*types.FileMetadata{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.FileMetadata
		if err := awsAwsjson11_deserializeDocumentFileMetadata(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentFileTooLargeException(v **types.FileTooLargeException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FileTooLargeException
	if *v == nil {
		sv = &types.FileTooLargeException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFolder(v **types.Folder, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Folder
	if *v == nil {
		sv = &types.Folder{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "absolutePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.AbsolutePath = &jtv
			}

		case "relativePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.RelativePath = &jtv
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFolderContentSizeLimitExceededException(v **types.FolderContentSizeLimitExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FolderContentSizeLimitExceededException
	if *v == nil {
		sv = &types.FolderContentSizeLimitExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFolderDoesNotExistException(v **types.FolderDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.FolderDoesNotExistException
	if *v == nil {
		sv = &types.FolderDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentFolderList(v *[]*types.Folder, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.Folder
	if *v == nil {
		cv = []*types.Folder{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.Folder
		if err := awsAwsjson11_deserializeDocumentFolder(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentIdempotencyParameterMismatchException(v **types.IdempotencyParameterMismatchException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.IdempotencyParameterMismatchException
	if *v == nil {
		sv = &types.IdempotencyParameterMismatchException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidActorArnException(v **types.InvalidActorArnException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidActorArnException
	if *v == nil {
		sv = &types.InvalidActorArnException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidApprovalRuleContentException(v **types.InvalidApprovalRuleContentException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidApprovalRuleContentException
	if *v == nil {
		sv = &types.InvalidApprovalRuleContentException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidApprovalRuleNameException(v **types.InvalidApprovalRuleNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidApprovalRuleNameException
	if *v == nil {
		sv = &types.InvalidApprovalRuleNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidApprovalRuleTemplateContentException(v **types.InvalidApprovalRuleTemplateContentException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidApprovalRuleTemplateContentException
	if *v == nil {
		sv = &types.InvalidApprovalRuleTemplateContentException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidApprovalRuleTemplateDescriptionException(v **types.InvalidApprovalRuleTemplateDescriptionException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidApprovalRuleTemplateDescriptionException
	if *v == nil {
		sv = &types.InvalidApprovalRuleTemplateDescriptionException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidApprovalRuleTemplateNameException(v **types.InvalidApprovalRuleTemplateNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidApprovalRuleTemplateNameException
	if *v == nil {
		sv = &types.InvalidApprovalRuleTemplateNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidApprovalStateException(v **types.InvalidApprovalStateException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidApprovalStateException
	if *v == nil {
		sv = &types.InvalidApprovalStateException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidAuthorArnException(v **types.InvalidAuthorArnException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidAuthorArnException
	if *v == nil {
		sv = &types.InvalidAuthorArnException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidBlobIdException(v **types.InvalidBlobIdException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidBlobIdException
	if *v == nil {
		sv = &types.InvalidBlobIdException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidBranchNameException(v **types.InvalidBranchNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidBranchNameException
	if *v == nil {
		sv = &types.InvalidBranchNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidClientRequestTokenException(v **types.InvalidClientRequestTokenException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidClientRequestTokenException
	if *v == nil {
		sv = &types.InvalidClientRequestTokenException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidCommentIdException(v **types.InvalidCommentIdException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidCommentIdException
	if *v == nil {
		sv = &types.InvalidCommentIdException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidCommitException(v **types.InvalidCommitException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidCommitException
	if *v == nil {
		sv = &types.InvalidCommitException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidCommitIdException(v **types.InvalidCommitIdException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidCommitIdException
	if *v == nil {
		sv = &types.InvalidCommitIdException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidConflictDetailLevelException(v **types.InvalidConflictDetailLevelException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidConflictDetailLevelException
	if *v == nil {
		sv = &types.InvalidConflictDetailLevelException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidConflictResolutionException(v **types.InvalidConflictResolutionException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidConflictResolutionException
	if *v == nil {
		sv = &types.InvalidConflictResolutionException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidConflictResolutionStrategyException(v **types.InvalidConflictResolutionStrategyException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidConflictResolutionStrategyException
	if *v == nil {
		sv = &types.InvalidConflictResolutionStrategyException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidContinuationTokenException(v **types.InvalidContinuationTokenException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidContinuationTokenException
	if *v == nil {
		sv = &types.InvalidContinuationTokenException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidDeletionParameterException(v **types.InvalidDeletionParameterException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidDeletionParameterException
	if *v == nil {
		sv = &types.InvalidDeletionParameterException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidDescriptionException(v **types.InvalidDescriptionException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidDescriptionException
	if *v == nil {
		sv = &types.InvalidDescriptionException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidDestinationCommitSpecifierException(v **types.InvalidDestinationCommitSpecifierException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidDestinationCommitSpecifierException
	if *v == nil {
		sv = &types.InvalidDestinationCommitSpecifierException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidEmailException(v **types.InvalidEmailException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidEmailException
	if *v == nil {
		sv = &types.InvalidEmailException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidFileLocationException(v **types.InvalidFileLocationException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidFileLocationException
	if *v == nil {
		sv = &types.InvalidFileLocationException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidFileModeException(v **types.InvalidFileModeException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidFileModeException
	if *v == nil {
		sv = &types.InvalidFileModeException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidFilePositionException(v **types.InvalidFilePositionException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidFilePositionException
	if *v == nil {
		sv = &types.InvalidFilePositionException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidMaxConflictFilesException(v **types.InvalidMaxConflictFilesException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidMaxConflictFilesException
	if *v == nil {
		sv = &types.InvalidMaxConflictFilesException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidMaxMergeHunksException(v **types.InvalidMaxMergeHunksException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidMaxMergeHunksException
	if *v == nil {
		sv = &types.InvalidMaxMergeHunksException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidMaxResultsException(v **types.InvalidMaxResultsException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidMaxResultsException
	if *v == nil {
		sv = &types.InvalidMaxResultsException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidMergeOptionException(v **types.InvalidMergeOptionException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidMergeOptionException
	if *v == nil {
		sv = &types.InvalidMergeOptionException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidOrderException(v **types.InvalidOrderException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidOrderException
	if *v == nil {
		sv = &types.InvalidOrderException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidOverrideStatusException(v **types.InvalidOverrideStatusException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidOverrideStatusException
	if *v == nil {
		sv = &types.InvalidOverrideStatusException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidParentCommitIdException(v **types.InvalidParentCommitIdException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidParentCommitIdException
	if *v == nil {
		sv = &types.InvalidParentCommitIdException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidPathException(v **types.InvalidPathException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidPathException
	if *v == nil {
		sv = &types.InvalidPathException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidPullRequestEventTypeException(v **types.InvalidPullRequestEventTypeException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidPullRequestEventTypeException
	if *v == nil {
		sv = &types.InvalidPullRequestEventTypeException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidPullRequestIdException(v **types.InvalidPullRequestIdException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidPullRequestIdException
	if *v == nil {
		sv = &types.InvalidPullRequestIdException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidPullRequestStatusException(v **types.InvalidPullRequestStatusException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidPullRequestStatusException
	if *v == nil {
		sv = &types.InvalidPullRequestStatusException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidPullRequestStatusUpdateException(v **types.InvalidPullRequestStatusUpdateException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidPullRequestStatusUpdateException
	if *v == nil {
		sv = &types.InvalidPullRequestStatusUpdateException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidReactionUserArnException(v **types.InvalidReactionUserArnException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidReactionUserArnException
	if *v == nil {
		sv = &types.InvalidReactionUserArnException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidReactionValueException(v **types.InvalidReactionValueException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidReactionValueException
	if *v == nil {
		sv = &types.InvalidReactionValueException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidReferenceNameException(v **types.InvalidReferenceNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidReferenceNameException
	if *v == nil {
		sv = &types.InvalidReferenceNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRelativeFileVersionEnumException(v **types.InvalidRelativeFileVersionEnumException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRelativeFileVersionEnumException
	if *v == nil {
		sv = &types.InvalidRelativeFileVersionEnumException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidReplacementContentException(v **types.InvalidReplacementContentException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidReplacementContentException
	if *v == nil {
		sv = &types.InvalidReplacementContentException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidReplacementTypeException(v **types.InvalidReplacementTypeException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidReplacementTypeException
	if *v == nil {
		sv = &types.InvalidReplacementTypeException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRepositoryDescriptionException(v **types.InvalidRepositoryDescriptionException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRepositoryDescriptionException
	if *v == nil {
		sv = &types.InvalidRepositoryDescriptionException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRepositoryNameException(v **types.InvalidRepositoryNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRepositoryNameException
	if *v == nil {
		sv = &types.InvalidRepositoryNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerBranchNameException(v **types.InvalidRepositoryTriggerBranchNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRepositoryTriggerBranchNameException
	if *v == nil {
		sv = &types.InvalidRepositoryTriggerBranchNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerCustomDataException(v **types.InvalidRepositoryTriggerCustomDataException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRepositoryTriggerCustomDataException
	if *v == nil {
		sv = &types.InvalidRepositoryTriggerCustomDataException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerDestinationArnException(v **types.InvalidRepositoryTriggerDestinationArnException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRepositoryTriggerDestinationArnException
	if *v == nil {
		sv = &types.InvalidRepositoryTriggerDestinationArnException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerEventsException(v **types.InvalidRepositoryTriggerEventsException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRepositoryTriggerEventsException
	if *v == nil {
		sv = &types.InvalidRepositoryTriggerEventsException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerNameException(v **types.InvalidRepositoryTriggerNameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRepositoryTriggerNameException
	if *v == nil {
		sv = &types.InvalidRepositoryTriggerNameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRepositoryTriggerRegionException(v **types.InvalidRepositoryTriggerRegionException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRepositoryTriggerRegionException
	if *v == nil {
		sv = &types.InvalidRepositoryTriggerRegionException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidResourceArnException(v **types.InvalidResourceArnException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidResourceArnException
	if *v == nil {
		sv = &types.InvalidResourceArnException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRevisionIdException(v **types.InvalidRevisionIdException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRevisionIdException
	if *v == nil {
		sv = &types.InvalidRevisionIdException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidRuleContentSha256Exception(v **types.InvalidRuleContentSha256Exception, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidRuleContentSha256Exception
	if *v == nil {
		sv = &types.InvalidRuleContentSha256Exception{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidSortByException(v **types.InvalidSortByException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidSortByException
	if *v == nil {
		sv = &types.InvalidSortByException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidSourceCommitSpecifierException(v **types.InvalidSourceCommitSpecifierException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidSourceCommitSpecifierException
	if *v == nil {
		sv = &types.InvalidSourceCommitSpecifierException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidSystemTagUsageException(v **types.InvalidSystemTagUsageException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidSystemTagUsageException
	if *v == nil {
		sv = &types.InvalidSystemTagUsageException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidTagKeysListException(v **types.InvalidTagKeysListException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidTagKeysListException
	if *v == nil {
		sv = &types.InvalidTagKeysListException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidTagsMapException(v **types.InvalidTagsMapException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidTagsMapException
	if *v == nil {
		sv = &types.InvalidTagsMapException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidTargetBranchException(v **types.InvalidTargetBranchException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidTargetBranchException
	if *v == nil {
		sv = &types.InvalidTargetBranchException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidTargetException(v **types.InvalidTargetException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidTargetException
	if *v == nil {
		sv = &types.InvalidTargetException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidTargetsException(v **types.InvalidTargetsException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidTargetsException
	if *v == nil {
		sv = &types.InvalidTargetsException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentInvalidTitleException(v **types.InvalidTitleException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.InvalidTitleException
	if *v == nil {
		sv = &types.InvalidTitleException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentIsBinaryFile(v **types.IsBinaryFile, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.IsBinaryFile
	if *v == nil {
		sv = &types.IsBinaryFile{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "base":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected CapitalBoolean to be of type *bool, got %T instead", val)
				}
				sv.Base = &jtv
			}

		case "destination":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected CapitalBoolean to be of type *bool, got %T instead", val)
				}
				sv.Destination = &jtv
			}

		case "source":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected CapitalBoolean to be of type *bool, got %T instead", val)
				}
				sv.Source = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentLocation(v **types.Location, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.Location
	if *v == nil {
		sv = &types.Location{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "filePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.FilePath = &jtv
			}

		case "filePosition":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Position to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.FilePosition = &i64
			}

		case "relativeFileVersion":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RelativeFileVersionEnum to be of type string, got %T instead", val)
				}
				sv.RelativeFileVersion = types.RelativeFileVersionEnum(jtv)
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentManualMergeRequiredException(v **types.ManualMergeRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ManualMergeRequiredException
	if *v == nil {
		sv = &types.ManualMergeRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumBranchesExceededException(v **types.MaximumBranchesExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumBranchesExceededException
	if *v == nil {
		sv = &types.MaximumBranchesExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumConflictResolutionEntriesExceededException(v **types.MaximumConflictResolutionEntriesExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumConflictResolutionEntriesExceededException
	if *v == nil {
		sv = &types.MaximumConflictResolutionEntriesExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumFileContentToLoadExceededException(v **types.MaximumFileContentToLoadExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumFileContentToLoadExceededException
	if *v == nil {
		sv = &types.MaximumFileContentToLoadExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumFileEntriesExceededException(v **types.MaximumFileEntriesExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumFileEntriesExceededException
	if *v == nil {
		sv = &types.MaximumFileEntriesExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumItemsToCompareExceededException(v **types.MaximumItemsToCompareExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumItemsToCompareExceededException
	if *v == nil {
		sv = &types.MaximumItemsToCompareExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumNumberOfApprovalsExceededException(v **types.MaximumNumberOfApprovalsExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumNumberOfApprovalsExceededException
	if *v == nil {
		sv = &types.MaximumNumberOfApprovalsExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumOpenPullRequestsExceededException(v **types.MaximumOpenPullRequestsExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumOpenPullRequestsExceededException
	if *v == nil {
		sv = &types.MaximumOpenPullRequestsExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumRepositoryNamesExceededException(v **types.MaximumRepositoryNamesExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumRepositoryNamesExceededException
	if *v == nil {
		sv = &types.MaximumRepositoryNamesExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumRepositoryTriggersExceededException(v **types.MaximumRepositoryTriggersExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumRepositoryTriggersExceededException
	if *v == nil {
		sv = &types.MaximumRepositoryTriggersExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMaximumRuleTemplatesAssociatedWithRepositoryException(v **types.MaximumRuleTemplatesAssociatedWithRepositoryException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MaximumRuleTemplatesAssociatedWithRepositoryException
	if *v == nil {
		sv = &types.MaximumRuleTemplatesAssociatedWithRepositoryException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMergeHunk(v **types.MergeHunk, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MergeHunk
	if *v == nil {
		sv = &types.MergeHunk{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "base":
			if err := awsAwsjson11_deserializeDocumentMergeHunkDetail(&sv.Base, decoder); err != nil {
				return err
			}

		case "destination":
			if err := awsAwsjson11_deserializeDocumentMergeHunkDetail(&sv.Destination, decoder); err != nil {
				return err
			}

		case "isConflict":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected IsHunkConflict to be of type *bool, got %T instead", val)
				}
				sv.IsConflict = &jtv
			}

		case "source":
			if err := awsAwsjson11_deserializeDocumentMergeHunkDetail(&sv.Source, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMergeHunkDetail(v **types.MergeHunkDetail, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MergeHunkDetail
	if *v == nil {
		sv = &types.MergeHunkDetail{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "endLine":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected LineNumber to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.EndLine = ptr.Int32(int32(i64))
			}

		case "hunkContent":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected HunkContent to be of type string, got %T instead", val)
				}
				sv.HunkContent = &jtv
			}

		case "startLine":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected LineNumber to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.StartLine = ptr.Int32(int32(i64))
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMergeHunks(v *[]*types.MergeHunk, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.MergeHunk
	if *v == nil {
		cv = []*types.MergeHunk{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.MergeHunk
		if err := awsAwsjson11_deserializeDocumentMergeHunk(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentMergeMetadata(v **types.MergeMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MergeMetadata
	if *v == nil {
		sv = &types.MergeMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "isMerged":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected IsMerged to be of type *bool, got %T instead", val)
				}
				sv.IsMerged = &jtv
			}

		case "mergeCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.MergeCommitId = &jtv
			}

		case "mergedBy":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.MergedBy = &jtv
			}

		case "mergeOption":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected MergeOptionTypeEnum to be of type string, got %T instead", val)
				}
				sv.MergeOption = types.MergeOptionTypeEnum(jtv)
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMergeOperations(v **types.MergeOperations, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MergeOperations
	if *v == nil {
		sv = &types.MergeOperations{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "destination":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ChangeTypeEnum to be of type string, got %T instead", val)
				}
				sv.Destination = types.ChangeTypeEnum(jtv)
			}

		case "source":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ChangeTypeEnum to be of type string, got %T instead", val)
				}
				sv.Source = types.ChangeTypeEnum(jtv)
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMergeOptionRequiredException(v **types.MergeOptionRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MergeOptionRequiredException
	if *v == nil {
		sv = &types.MergeOptionRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMergeOptions(v *[]types.MergeOptionTypeEnum, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []types.MergeOptionTypeEnum
	if *v == nil {
		cv = []types.MergeOptionTypeEnum{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col types.MergeOptionTypeEnum
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected MergeOptionTypeEnum to be of type string, got %T instead", val)
			}
			col = types.MergeOptionTypeEnum(jtv)
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentMultipleConflictResolutionEntriesException(v **types.MultipleConflictResolutionEntriesException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MultipleConflictResolutionEntriesException
	if *v == nil {
		sv = &types.MultipleConflictResolutionEntriesException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentMultipleRepositoriesInPullRequestException(v **types.MultipleRepositoriesInPullRequestException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.MultipleRepositoriesInPullRequestException
	if *v == nil {
		sv = &types.MultipleRepositoriesInPullRequestException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentNameLengthExceededException(v **types.NameLengthExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.NameLengthExceededException
	if *v == nil {
		sv = &types.NameLengthExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentNoChangeException(v **types.NoChangeException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.NoChangeException
	if *v == nil {
		sv = &types.NoChangeException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentNumberOfRulesExceededException(v **types.NumberOfRulesExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.NumberOfRulesExceededException
	if *v == nil {
		sv = &types.NumberOfRulesExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentNumberOfRuleTemplatesExceededException(v **types.NumberOfRuleTemplatesExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.NumberOfRuleTemplatesExceededException
	if *v == nil {
		sv = &types.NumberOfRuleTemplatesExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentObjectTypes(v **types.ObjectTypes, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ObjectTypes
	if *v == nil {
		sv = &types.ObjectTypes{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "base":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectTypeEnum to be of type string, got %T instead", val)
				}
				sv.Base = types.ObjectTypeEnum(jtv)
			}

		case "destination":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectTypeEnum to be of type string, got %T instead", val)
				}
				sv.Destination = types.ObjectTypeEnum(jtv)
			}

		case "source":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectTypeEnum to be of type string, got %T instead", val)
				}
				sv.Source = types.ObjectTypeEnum(jtv)
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentOriginApprovalRuleTemplate(v **types.OriginApprovalRuleTemplate, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.OriginApprovalRuleTemplate
	if *v == nil {
		sv = &types.OriginApprovalRuleTemplate{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplateId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleTemplateId to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleTemplateId = &jtv
			}

		case "approvalRuleTemplateName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleTemplateName to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleTemplateName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentOverrideAlreadySetException(v **types.OverrideAlreadySetException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.OverrideAlreadySetException
	if *v == nil {
		sv = &types.OverrideAlreadySetException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentOverrideStatusRequiredException(v **types.OverrideStatusRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.OverrideStatusRequiredException
	if *v == nil {
		sv = &types.OverrideStatusRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentParentCommitDoesNotExistException(v **types.ParentCommitDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ParentCommitDoesNotExistException
	if *v == nil {
		sv = &types.ParentCommitDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentParentCommitIdOutdatedException(v **types.ParentCommitIdOutdatedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ParentCommitIdOutdatedException
	if *v == nil {
		sv = &types.ParentCommitIdOutdatedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentParentCommitIdRequiredException(v **types.ParentCommitIdRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ParentCommitIdRequiredException
	if *v == nil {
		sv = &types.ParentCommitIdRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentParentList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentPathDoesNotExistException(v **types.PathDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PathDoesNotExistException
	if *v == nil {
		sv = &types.PathDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPathRequiredException(v **types.PathRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PathRequiredException
	if *v == nil {
		sv = &types.PathRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequest(v **types.PullRequest, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequest
	if *v == nil {
		sv = &types.PullRequest{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRules":
			if err := awsAwsjson11_deserializeDocumentApprovalRulesList(&sv.ApprovalRules, decoder); err != nil {
				return err
			}

		case "authorArn":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.AuthorArn = &jtv
			}

		case "clientRequestToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ClientRequestToken to be of type string, got %T instead", val)
				}
				sv.ClientRequestToken = &jtv
			}

		case "creationDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected CreationDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.CreationDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "description":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Description to be of type string, got %T instead", val)
				}
				sv.Description = &jtv
			}

		case "lastActivityDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected LastModifiedDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.LastActivityDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "pullRequestId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected PullRequestId to be of type string, got %T instead", val)
				}
				sv.PullRequestId = &jtv
			}

		case "pullRequestStatus":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected PullRequestStatusEnum to be of type string, got %T instead", val)
				}
				sv.PullRequestStatus = types.PullRequestStatusEnum(jtv)
			}

		case "pullRequestTargets":
			if err := awsAwsjson11_deserializeDocumentPullRequestTargetList(&sv.PullRequestTargets, decoder); err != nil {
				return err
			}

		case "revisionId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RevisionId to be of type string, got %T instead", val)
				}
				sv.RevisionId = &jtv
			}

		case "title":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Title to be of type string, got %T instead", val)
				}
				sv.Title = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestAlreadyClosedException(v **types.PullRequestAlreadyClosedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestAlreadyClosedException
	if *v == nil {
		sv = &types.PullRequestAlreadyClosedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestApprovalRulesNotSatisfiedException(v **types.PullRequestApprovalRulesNotSatisfiedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestApprovalRulesNotSatisfiedException
	if *v == nil {
		sv = &types.PullRequestApprovalRulesNotSatisfiedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestCannotBeApprovedByAuthorException(v **types.PullRequestCannotBeApprovedByAuthorException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestCannotBeApprovedByAuthorException
	if *v == nil {
		sv = &types.PullRequestCannotBeApprovedByAuthorException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestCreatedEventMetadata(v **types.PullRequestCreatedEventMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestCreatedEventMetadata
	if *v == nil {
		sv = &types.PullRequestCreatedEventMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "destinationCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.DestinationCommitId = &jtv
			}

		case "mergeBase":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.MergeBase = &jtv
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		case "sourceCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.SourceCommitId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestDoesNotExistException(v **types.PullRequestDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestDoesNotExistException
	if *v == nil {
		sv = &types.PullRequestDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestEvent(v **types.PullRequestEvent, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestEvent
	if *v == nil {
		sv = &types.PullRequestEvent{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "actorArn":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.ActorArn = &jtv
			}

		case "approvalRuleEventMetadata":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleEventMetadata(&sv.ApprovalRuleEventMetadata, decoder); err != nil {
				return err
			}

		case "approvalRuleOverriddenEventMetadata":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleOverriddenEventMetadata(&sv.ApprovalRuleOverriddenEventMetadata, decoder); err != nil {
				return err
			}

		case "approvalStateChangedEventMetadata":
			if err := awsAwsjson11_deserializeDocumentApprovalStateChangedEventMetadata(&sv.ApprovalStateChangedEventMetadata, decoder); err != nil {
				return err
			}

		case "eventDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected EventDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.EventDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "pullRequestCreatedEventMetadata":
			if err := awsAwsjson11_deserializeDocumentPullRequestCreatedEventMetadata(&sv.PullRequestCreatedEventMetadata, decoder); err != nil {
				return err
			}

		case "pullRequestEventType":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected PullRequestEventType to be of type string, got %T instead", val)
				}
				sv.PullRequestEventType = types.PullRequestEventType(jtv)
			}

		case "pullRequestId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected PullRequestId to be of type string, got %T instead", val)
				}
				sv.PullRequestId = &jtv
			}

		case "pullRequestMergedStateChangedEventMetadata":
			if err := awsAwsjson11_deserializeDocumentPullRequestMergedStateChangedEventMetadata(&sv.PullRequestMergedStateChangedEventMetadata, decoder); err != nil {
				return err
			}

		case "pullRequestSourceReferenceUpdatedEventMetadata":
			if err := awsAwsjson11_deserializeDocumentPullRequestSourceReferenceUpdatedEventMetadata(&sv.PullRequestSourceReferenceUpdatedEventMetadata, decoder); err != nil {
				return err
			}

		case "pullRequestStatusChangedEventMetadata":
			if err := awsAwsjson11_deserializeDocumentPullRequestStatusChangedEventMetadata(&sv.PullRequestStatusChangedEventMetadata, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestEventList(v *[]*types.PullRequestEvent, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.PullRequestEvent
	if *v == nil {
		cv = []*types.PullRequestEvent{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.PullRequestEvent
		if err := awsAwsjson11_deserializeDocumentPullRequestEvent(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestIdList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected PullRequestId to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestIdRequiredException(v **types.PullRequestIdRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestIdRequiredException
	if *v == nil {
		sv = &types.PullRequestIdRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestMergedStateChangedEventMetadata(v **types.PullRequestMergedStateChangedEventMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestMergedStateChangedEventMetadata
	if *v == nil {
		sv = &types.PullRequestMergedStateChangedEventMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "destinationReference":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ReferenceName to be of type string, got %T instead", val)
				}
				sv.DestinationReference = &jtv
			}

		case "mergeMetadata":
			if err := awsAwsjson11_deserializeDocumentMergeMetadata(&sv.MergeMetadata, decoder); err != nil {
				return err
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestSourceReferenceUpdatedEventMetadata(v **types.PullRequestSourceReferenceUpdatedEventMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestSourceReferenceUpdatedEventMetadata
	if *v == nil {
		sv = &types.PullRequestSourceReferenceUpdatedEventMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "afterCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.AfterCommitId = &jtv
			}

		case "beforeCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.BeforeCommitId = &jtv
			}

		case "mergeBase":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.MergeBase = &jtv
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestStatusChangedEventMetadata(v **types.PullRequestStatusChangedEventMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestStatusChangedEventMetadata
	if *v == nil {
		sv = &types.PullRequestStatusChangedEventMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequestStatus":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected PullRequestStatusEnum to be of type string, got %T instead", val)
				}
				sv.PullRequestStatus = types.PullRequestStatusEnum(jtv)
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestStatusRequiredException(v **types.PullRequestStatusRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestStatusRequiredException
	if *v == nil {
		sv = &types.PullRequestStatusRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestTarget(v **types.PullRequestTarget, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PullRequestTarget
	if *v == nil {
		sv = &types.PullRequestTarget{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "destinationCommit":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.DestinationCommit = &jtv
			}

		case "destinationReference":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ReferenceName to be of type string, got %T instead", val)
				}
				sv.DestinationReference = &jtv
			}

		case "mergeBase":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.MergeBase = &jtv
			}

		case "mergeMetadata":
			if err := awsAwsjson11_deserializeDocumentMergeMetadata(&sv.MergeMetadata, decoder); err != nil {
				return err
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		case "sourceCommit":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.SourceCommit = &jtv
			}

		case "sourceReference":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ReferenceName to be of type string, got %T instead", val)
				}
				sv.SourceReference = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPullRequestTargetList(v *[]*types.PullRequestTarget, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.PullRequestTarget
	if *v == nil {
		cv = []*types.PullRequestTarget{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.PullRequestTarget
		if err := awsAwsjson11_deserializeDocumentPullRequestTarget(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentPutFileEntryConflictException(v **types.PutFileEntryConflictException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.PutFileEntryConflictException
	if *v == nil {
		sv = &types.PutFileEntryConflictException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReactionCountsMap(v *map[string]*int32, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var mv map[string]*int32
	if *v == nil {
		mv = map[string]*int32{}
	} else {
		mv = *v
	}

	for decoder.More() {
		token, err := decoder.Token()
		if err != nil {
			return err
		}

		key, ok := token.(string)
		if !ok {
			return fmt.Errorf("expected map-key of type string, found type %T", token)
		}

		var parsedVal *int32
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(json.Number)
			if !ok {
				return fmt.Errorf("expected Count to be json.Number, got %T instead", val)
			}
			i64, err := jtv.Int64()
			if err != nil {
				return err
			}
			parsedVal = ptr.Int32(int32(i64))
		}
		mv[key] = parsedVal

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = mv
	return nil
}

func awsAwsjson11_deserializeDocumentReactionForComment(v **types.ReactionForComment, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReactionForComment
	if *v == nil {
		sv = &types.ReactionForComment{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "reaction":
			if err := awsAwsjson11_deserializeDocumentReactionValueFormats(&sv.Reaction, decoder); err != nil {
				return err
			}

		case "reactionsFromDeletedUsersCount":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected Count to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.ReactionsFromDeletedUsersCount = ptr.Int32(int32(i64))
			}

		case "reactionUsers":
			if err := awsAwsjson11_deserializeDocumentReactionUsersList(&sv.ReactionUsers, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReactionLimitExceededException(v **types.ReactionLimitExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReactionLimitExceededException
	if *v == nil {
		sv = &types.ReactionLimitExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReactionsForCommentList(v *[]*types.ReactionForComment, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.ReactionForComment
	if *v == nil {
		cv = []*types.ReactionForComment{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.ReactionForComment
		if err := awsAwsjson11_deserializeDocumentReactionForComment(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentReactionUsersList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentReactionValueFormats(v **types.ReactionValueFormats, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReactionValueFormats
	if *v == nil {
		sv = &types.ReactionValueFormats{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "emoji":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ReactionEmoji to be of type string, got %T instead", val)
				}
				sv.Emoji = &jtv
			}

		case "shortCode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ReactionShortCode to be of type string, got %T instead", val)
				}
				sv.ShortCode = &jtv
			}

		case "unicode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ReactionUnicode to be of type string, got %T instead", val)
				}
				sv.Unicode = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReactionValueRequiredException(v **types.ReactionValueRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReactionValueRequiredException
	if *v == nil {
		sv = &types.ReactionValueRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReferenceDoesNotExistException(v **types.ReferenceDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReferenceDoesNotExistException
	if *v == nil {
		sv = &types.ReferenceDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReferenceNameRequiredException(v **types.ReferenceNameRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReferenceNameRequiredException
	if *v == nil {
		sv = &types.ReferenceNameRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReferenceTypeNotSupportedException(v **types.ReferenceTypeNotSupportedException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReferenceTypeNotSupportedException
	if *v == nil {
		sv = &types.ReferenceTypeNotSupportedException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReplacementContentRequiredException(v **types.ReplacementContentRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReplacementContentRequiredException
	if *v == nil {
		sv = &types.ReplacementContentRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentReplacementTypeRequiredException(v **types.ReplacementTypeRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ReplacementTypeRequiredException
	if *v == nil {
		sv = &types.ReplacementTypeRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryDoesNotExistException(v **types.RepositoryDoesNotExistException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryDoesNotExistException
	if *v == nil {
		sv = &types.RepositoryDoesNotExistException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryLimitExceededException(v **types.RepositoryLimitExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryLimitExceededException
	if *v == nil {
		sv = &types.RepositoryLimitExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryMetadata(v **types.RepositoryMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryMetadata
	if *v == nil {
		sv = &types.RepositoryMetadata{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "accountId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected AccountId to be of type string, got %T instead", val)
				}
				sv.AccountId = &jtv
			}

		case "Arn":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.Arn = &jtv
			}

		case "cloneUrlHttp":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CloneUrlHttp to be of type string, got %T instead", val)
				}
				sv.CloneUrlHttp = &jtv
			}

		case "cloneUrlSsh":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CloneUrlSsh to be of type string, got %T instead", val)
				}
				sv.CloneUrlSsh = &jtv
			}

		case "creationDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected CreationDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.CreationDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "defaultBranch":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected BranchName to be of type string, got %T instead", val)
				}
				sv.DefaultBranch = &jtv
			}

		case "lastModifiedDate":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected LastModifiedDate to be json.Number, got %T instead", val)
				}
				f64, err := jtv.Float64()
				if err != nil {
					return err
				}
				sv.LastModifiedDate = ptr.Time(smithytime.ParseEpochSeconds(f64))
			}

		case "repositoryDescription":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryDescription to be of type string, got %T instead", val)
				}
				sv.RepositoryDescription = &jtv
			}

		case "repositoryId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryId to be of type string, got %T instead", val)
				}
				sv.RepositoryId = &jtv
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryMetadataList(v *[]*types.RepositoryMetadata, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.RepositoryMetadata
	if *v == nil {
		cv = []*types.RepositoryMetadata{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.RepositoryMetadata
		if err := awsAwsjson11_deserializeDocumentRepositoryMetadata(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryNameExistsException(v **types.RepositoryNameExistsException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryNameExistsException
	if *v == nil {
		sv = &types.RepositoryNameExistsException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryNameIdPair(v **types.RepositoryNameIdPair, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryNameIdPair
	if *v == nil {
		sv = &types.RepositoryNameIdPair{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "repositoryId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryId to be of type string, got %T instead", val)
				}
				sv.RepositoryId = &jtv
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryNameIdPairList(v *[]*types.RepositoryNameIdPair, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.RepositoryNameIdPair
	if *v == nil {
		cv = []*types.RepositoryNameIdPair{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.RepositoryNameIdPair
		if err := awsAwsjson11_deserializeDocumentRepositoryNameIdPair(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryNameList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryNameRequiredException(v **types.RepositoryNameRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryNameRequiredException
	if *v == nil {
		sv = &types.RepositoryNameRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryNamesRequiredException(v **types.RepositoryNamesRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryNamesRequiredException
	if *v == nil {
		sv = &types.RepositoryNamesRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryNotAssociatedWithPullRequestException(v **types.RepositoryNotAssociatedWithPullRequestException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryNotAssociatedWithPullRequestException
	if *v == nil {
		sv = &types.RepositoryNotAssociatedWithPullRequestException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryNotFoundList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTrigger(v **types.RepositoryTrigger, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryTrigger
	if *v == nil {
		sv = &types.RepositoryTrigger{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "branches":
			if err := awsAwsjson11_deserializeDocumentBranchNameList(&sv.Branches, decoder); err != nil {
				return err
			}

		case "customData":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryTriggerCustomData to be of type string, got %T instead", val)
				}
				sv.CustomData = &jtv
			}

		case "destinationArn":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.DestinationArn = &jtv
			}

		case "events":
			if err := awsAwsjson11_deserializeDocumentRepositoryTriggerEventList(&sv.Events, decoder); err != nil {
				return err
			}

		case "name":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryTriggerName to be of type string, got %T instead", val)
				}
				sv.Name = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggerBranchNameListRequiredException(v **types.RepositoryTriggerBranchNameListRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryTriggerBranchNameListRequiredException
	if *v == nil {
		sv = &types.RepositoryTriggerBranchNameListRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggerDestinationArnRequiredException(v **types.RepositoryTriggerDestinationArnRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryTriggerDestinationArnRequiredException
	if *v == nil {
		sv = &types.RepositoryTriggerDestinationArnRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggerEventList(v *[]types.RepositoryTriggerEventEnum, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []types.RepositoryTriggerEventEnum
	if *v == nil {
		cv = []types.RepositoryTriggerEventEnum{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col types.RepositoryTriggerEventEnum
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected RepositoryTriggerEventEnum to be of type string, got %T instead", val)
			}
			col = types.RepositoryTriggerEventEnum(jtv)
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggerEventsListRequiredException(v **types.RepositoryTriggerEventsListRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryTriggerEventsListRequiredException
	if *v == nil {
		sv = &types.RepositoryTriggerEventsListRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggerExecutionFailure(v **types.RepositoryTriggerExecutionFailure, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryTriggerExecutionFailure
	if *v == nil {
		sv = &types.RepositoryTriggerExecutionFailure{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "failureMessage":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryTriggerExecutionFailureMessage to be of type string, got %T instead", val)
				}
				sv.FailureMessage = &jtv
			}

		case "trigger":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryTriggerName to be of type string, got %T instead", val)
				}
				sv.Trigger = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggerExecutionFailureList(v *[]*types.RepositoryTriggerExecutionFailure, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.RepositoryTriggerExecutionFailure
	if *v == nil {
		cv = []*types.RepositoryTriggerExecutionFailure{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.RepositoryTriggerExecutionFailure
		if err := awsAwsjson11_deserializeDocumentRepositoryTriggerExecutionFailure(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggerNameList(v *[]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*string
	if *v == nil {
		cv = []*string{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected RepositoryTriggerName to be of type string, got %T instead", val)
			}
			col = &jtv
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggerNameRequiredException(v **types.RepositoryTriggerNameRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryTriggerNameRequiredException
	if *v == nil {
		sv = &types.RepositoryTriggerNameRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggersList(v *[]*types.RepositoryTrigger, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.RepositoryTrigger
	if *v == nil {
		cv = []*types.RepositoryTrigger{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.RepositoryTrigger
		if err := awsAwsjson11_deserializeDocumentRepositoryTrigger(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentRepositoryTriggersListRequiredException(v **types.RepositoryTriggersListRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RepositoryTriggersListRequiredException
	if *v == nil {
		sv = &types.RepositoryTriggersListRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentResourceArnRequiredException(v **types.ResourceArnRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.ResourceArnRequiredException
	if *v == nil {
		sv = &types.ResourceArnRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRestrictedSourceFileException(v **types.RestrictedSourceFileException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RestrictedSourceFileException
	if *v == nil {
		sv = &types.RestrictedSourceFileException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRevisionIdRequiredException(v **types.RevisionIdRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RevisionIdRequiredException
	if *v == nil {
		sv = &types.RevisionIdRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentRevisionNotCurrentException(v **types.RevisionNotCurrentException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.RevisionNotCurrentException
	if *v == nil {
		sv = &types.RevisionNotCurrentException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentSameFileContentException(v **types.SameFileContentException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.SameFileContentException
	if *v == nil {
		sv = &types.SameFileContentException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentSamePathRequestException(v **types.SamePathRequestException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.SamePathRequestException
	if *v == nil {
		sv = &types.SamePathRequestException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentSourceAndDestinationAreSameException(v **types.SourceAndDestinationAreSameException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.SourceAndDestinationAreSameException
	if *v == nil {
		sv = &types.SourceAndDestinationAreSameException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentSourceFileOrContentRequiredException(v **types.SourceFileOrContentRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.SourceFileOrContentRequiredException
	if *v == nil {
		sv = &types.SourceFileOrContentRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentSubModule(v **types.SubModule, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.SubModule
	if *v == nil {
		sv = &types.SubModule{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "absolutePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.AbsolutePath = &jtv
			}

		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "relativePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.RelativePath = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentSubModuleList(v *[]*types.SubModule, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.SubModule
	if *v == nil {
		cv = []*types.SubModule{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.SubModule
		if err := awsAwsjson11_deserializeDocumentSubModule(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentSymbolicLink(v **types.SymbolicLink, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.SymbolicLink
	if *v == nil {
		sv = &types.SymbolicLink{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "absolutePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.AbsolutePath = &jtv
			}

		case "blobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BlobId = &jtv
			}

		case "fileMode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FileModeTypeEnum to be of type string, got %T instead", val)
				}
				sv.FileMode = types.FileModeTypeEnum(jtv)
			}

		case "relativePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.RelativePath = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentSymbolicLinkList(v *[]*types.SymbolicLink, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '[' {
		return fmt.Errorf("expect `[` as start token")
	}

	var cv []*types.SymbolicLink
	if *v == nil {
		cv = []*types.SymbolicLink{}
	} else {
		cv = *v
	}

	for decoder.More() {
		var col *types.SymbolicLink
		if err := awsAwsjson11_deserializeDocumentSymbolicLink(&col, decoder); err != nil {
			return err
		}
		cv = append(cv, col)

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != ']' {
		return fmt.Errorf("expect `]` as end token")
	}

	*v = cv
	return nil
}

func awsAwsjson11_deserializeDocumentTagKeysListRequiredException(v **types.TagKeysListRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TagKeysListRequiredException
	if *v == nil {
		sv = &types.TagKeysListRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTagPolicyException(v **types.TagPolicyException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TagPolicyException
	if *v == nil {
		sv = &types.TagPolicyException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTagsMap(v *map[string]*string, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var mv map[string]*string
	if *v == nil {
		mv = map[string]*string{}
	} else {
		mv = *v
	}

	for decoder.More() {
		token, err := decoder.Token()
		if err != nil {
			return err
		}

		key, ok := token.(string)
		if !ok {
			return fmt.Errorf("expected map-key of type string, found type %T", token)
		}

		var parsedVal *string
		val, err := decoder.Token()
		if err != nil {
			return err
		}
		if val != nil {
			jtv, ok := val.(string)
			if !ok {
				return fmt.Errorf("expected TagValue to be of type string, got %T instead", val)
			}
			parsedVal = &jtv
		}
		mv[key] = parsedVal

	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = mv
	return nil
}

func awsAwsjson11_deserializeDocumentTagsMapRequiredException(v **types.TagsMapRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TagsMapRequiredException
	if *v == nil {
		sv = &types.TagsMapRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTargetRequiredException(v **types.TargetRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TargetRequiredException
	if *v == nil {
		sv = &types.TargetRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTargetsRequiredException(v **types.TargetsRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TargetsRequiredException
	if *v == nil {
		sv = &types.TargetsRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTipOfSourceReferenceIsDifferentException(v **types.TipOfSourceReferenceIsDifferentException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TipOfSourceReferenceIsDifferentException
	if *v == nil {
		sv = &types.TipOfSourceReferenceIsDifferentException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTipsDivergenceExceededException(v **types.TipsDivergenceExceededException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TipsDivergenceExceededException
	if *v == nil {
		sv = &types.TipsDivergenceExceededException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTitleRequiredException(v **types.TitleRequiredException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TitleRequiredException
	if *v == nil {
		sv = &types.TitleRequiredException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTooManyTagsException(v **types.TooManyTagsException, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.TooManyTagsException
	if *v == nil {
		sv = &types.TooManyTagsException{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "message":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Message to be of type string, got %T instead", val)
				}
				sv.Message = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentUserInfo(v **types.UserInfo, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *types.UserInfo
	if *v == nil {
		sv = &types.UserInfo{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "date":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Date to be of type string, got %T instead", val)
				}
				sv.Date = &jtv
			}

		case "email":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Email to be of type string, got %T instead", val)
				}
				sv.Email = &jtv
			}

		case "name":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Name to be of type string, got %T instead", val)
				}
				sv.Name = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentAssociateApprovalRuleTemplateWithRepositoryOutput(v **AssociateApprovalRuleTemplateWithRepositoryOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *AssociateApprovalRuleTemplateWithRepositoryOutput
	if *v == nil {
		sv = &AssociateApprovalRuleTemplateWithRepositoryOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentBatchAssociateApprovalRuleTemplateWithRepositoriesOutput(v **BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *BatchAssociateApprovalRuleTemplateWithRepositoriesOutput
	if *v == nil {
		sv = &BatchAssociateApprovalRuleTemplateWithRepositoriesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "associatedRepositoryNames":
			if err := awsAwsjson11_deserializeDocumentRepositoryNameList(&sv.AssociatedRepositoryNames, decoder); err != nil {
				return err
			}

		case "errors":
			if err := awsAwsjson11_deserializeDocumentBatchAssociateApprovalRuleTemplateWithRepositoriesErrorsList(&sv.Errors, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentBatchDescribeMergeConflictsOutput(v **BatchDescribeMergeConflictsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *BatchDescribeMergeConflictsOutput
	if *v == nil {
		sv = &BatchDescribeMergeConflictsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "baseCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BaseCommitId = &jtv
			}

		case "conflicts":
			if err := awsAwsjson11_deserializeDocumentConflicts(&sv.Conflicts, decoder); err != nil {
				return err
			}

		case "destinationCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.DestinationCommitId = &jtv
			}

		case "errors":
			if err := awsAwsjson11_deserializeDocumentBatchDescribeMergeConflictsErrors(&sv.Errors, decoder); err != nil {
				return err
			}

		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "sourceCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.SourceCommitId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentBatchDisassociateApprovalRuleTemplateFromRepositoriesOutput(v **BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput
	if *v == nil {
		sv = &BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "disassociatedRepositoryNames":
			if err := awsAwsjson11_deserializeDocumentRepositoryNameList(&sv.DisassociatedRepositoryNames, decoder); err != nil {
				return err
			}

		case "errors":
			if err := awsAwsjson11_deserializeDocumentBatchDisassociateApprovalRuleTemplateFromRepositoriesErrorsList(&sv.Errors, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentBatchGetCommitsOutput(v **BatchGetCommitsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *BatchGetCommitsOutput
	if *v == nil {
		sv = &BatchGetCommitsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commits":
			if err := awsAwsjson11_deserializeDocumentCommitObjectsList(&sv.Commits, decoder); err != nil {
				return err
			}

		case "errors":
			if err := awsAwsjson11_deserializeDocumentBatchGetCommitsErrorsList(&sv.Errors, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentBatchGetRepositoriesOutput(v **BatchGetRepositoriesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *BatchGetRepositoriesOutput
	if *v == nil {
		sv = &BatchGetRepositoriesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "repositories":
			if err := awsAwsjson11_deserializeDocumentRepositoryMetadataList(&sv.Repositories, decoder); err != nil {
				return err
			}

		case "repositoriesNotFound":
			if err := awsAwsjson11_deserializeDocumentRepositoryNotFoundList(&sv.RepositoriesNotFound, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentCreateApprovalRuleTemplateOutput(v **CreateApprovalRuleTemplateOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *CreateApprovalRuleTemplateOutput
	if *v == nil {
		sv = &CreateApprovalRuleTemplateOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplate":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleTemplate(&sv.ApprovalRuleTemplate, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentCreateBranchOutput(v **CreateBranchOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *CreateBranchOutput
	if *v == nil {
		sv = &CreateBranchOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentCreateCommitOutput(v **CreateCommitOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *CreateCommitOutput
	if *v == nil {
		sv = &CreateCommitOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "filesAdded":
			if err := awsAwsjson11_deserializeDocumentFilesMetadata(&sv.FilesAdded, decoder); err != nil {
				return err
			}

		case "filesDeleted":
			if err := awsAwsjson11_deserializeDocumentFilesMetadata(&sv.FilesDeleted, decoder); err != nil {
				return err
			}

		case "filesUpdated":
			if err := awsAwsjson11_deserializeDocumentFilesMetadata(&sv.FilesUpdated, decoder); err != nil {
				return err
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentCreatePullRequestApprovalRuleOutput(v **CreatePullRequestApprovalRuleOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *CreatePullRequestApprovalRuleOutput
	if *v == nil {
		sv = &CreatePullRequestApprovalRuleOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRule":
			if err := awsAwsjson11_deserializeDocumentApprovalRule(&sv.ApprovalRule, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentCreatePullRequestOutput(v **CreatePullRequestOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *CreatePullRequestOutput
	if *v == nil {
		sv = &CreatePullRequestOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequest":
			if err := awsAwsjson11_deserializeDocumentPullRequest(&sv.PullRequest, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentCreateRepositoryOutput(v **CreateRepositoryOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *CreateRepositoryOutput
	if *v == nil {
		sv = &CreateRepositoryOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "repositoryMetadata":
			if err := awsAwsjson11_deserializeDocumentRepositoryMetadata(&sv.RepositoryMetadata, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentCreateUnreferencedMergeCommitOutput(v **CreateUnreferencedMergeCommitOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *CreateUnreferencedMergeCommitOutput
	if *v == nil {
		sv = &CreateUnreferencedMergeCommitOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentDeleteApprovalRuleTemplateOutput(v **DeleteApprovalRuleTemplateOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DeleteApprovalRuleTemplateOutput
	if *v == nil {
		sv = &DeleteApprovalRuleTemplateOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplateId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleTemplateId to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleTemplateId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentDeleteBranchOutput(v **DeleteBranchOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DeleteBranchOutput
	if *v == nil {
		sv = &DeleteBranchOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "deletedBranch":
			if err := awsAwsjson11_deserializeDocumentBranchInfo(&sv.DeletedBranch, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentDeleteCommentContentOutput(v **DeleteCommentContentOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DeleteCommentContentOutput
	if *v == nil {
		sv = &DeleteCommentContentOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "comment":
			if err := awsAwsjson11_deserializeDocumentComment(&sv.Comment, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentDeleteFileOutput(v **DeleteFileOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DeleteFileOutput
	if *v == nil {
		sv = &DeleteFileOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "blobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BlobId = &jtv
			}

		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "filePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.FilePath = &jtv
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentDeletePullRequestApprovalRuleOutput(v **DeletePullRequestApprovalRuleOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DeletePullRequestApprovalRuleOutput
	if *v == nil {
		sv = &DeletePullRequestApprovalRuleOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ApprovalRuleId to be of type string, got %T instead", val)
				}
				sv.ApprovalRuleId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentDeleteRepositoryOutput(v **DeleteRepositoryOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DeleteRepositoryOutput
	if *v == nil {
		sv = &DeleteRepositoryOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "repositoryId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryId to be of type string, got %T instead", val)
				}
				sv.RepositoryId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentDescribeMergeConflictsOutput(v **DescribeMergeConflictsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DescribeMergeConflictsOutput
	if *v == nil {
		sv = &DescribeMergeConflictsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "baseCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BaseCommitId = &jtv
			}

		case "conflictMetadata":
			if err := awsAwsjson11_deserializeDocumentConflictMetadata(&sv.ConflictMetadata, decoder); err != nil {
				return err
			}

		case "destinationCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.DestinationCommitId = &jtv
			}

		case "mergeHunks":
			if err := awsAwsjson11_deserializeDocumentMergeHunks(&sv.MergeHunks, decoder); err != nil {
				return err
			}

		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "sourceCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.SourceCommitId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentDescribePullRequestEventsOutput(v **DescribePullRequestEventsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DescribePullRequestEventsOutput
	if *v == nil {
		sv = &DescribePullRequestEventsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "pullRequestEvents":
			if err := awsAwsjson11_deserializeDocumentPullRequestEventList(&sv.PullRequestEvents, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentDisassociateApprovalRuleTemplateFromRepositoryOutput(v **DisassociateApprovalRuleTemplateFromRepositoryOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *DisassociateApprovalRuleTemplateFromRepositoryOutput
	if *v == nil {
		sv = &DisassociateApprovalRuleTemplateFromRepositoryOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentEvaluatePullRequestApprovalRulesOutput(v **EvaluatePullRequestApprovalRulesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *EvaluatePullRequestApprovalRulesOutput
	if *v == nil {
		sv = &EvaluatePullRequestApprovalRulesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "evaluation":
			if err := awsAwsjson11_deserializeDocumentEvaluation(&sv.Evaluation, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetApprovalRuleTemplateOutput(v **GetApprovalRuleTemplateOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetApprovalRuleTemplateOutput
	if *v == nil {
		sv = &GetApprovalRuleTemplateOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplate":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleTemplate(&sv.ApprovalRuleTemplate, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetBlobOutput(v **GetBlobOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetBlobOutput
	if *v == nil {
		sv = &GetBlobOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "content":
			err := decoder.Decode(&sv.Content)
			if err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetBranchOutput(v **GetBranchOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetBranchOutput
	if *v == nil {
		sv = &GetBranchOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "branch":
			if err := awsAwsjson11_deserializeDocumentBranchInfo(&sv.Branch, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetCommentOutput(v **GetCommentOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetCommentOutput
	if *v == nil {
		sv = &GetCommentOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "comment":
			if err := awsAwsjson11_deserializeDocumentComment(&sv.Comment, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetCommentReactionsOutput(v **GetCommentReactionsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetCommentReactionsOutput
	if *v == nil {
		sv = &GetCommentReactionsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "reactionsForComment":
			if err := awsAwsjson11_deserializeDocumentReactionsForCommentList(&sv.ReactionsForComment, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetCommentsForComparedCommitOutput(v **GetCommentsForComparedCommitOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetCommentsForComparedCommitOutput
	if *v == nil {
		sv = &GetCommentsForComparedCommitOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commentsForComparedCommitData":
			if err := awsAwsjson11_deserializeDocumentCommentsForComparedCommitData(&sv.CommentsForComparedCommitData, decoder); err != nil {
				return err
			}

		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetCommentsForPullRequestOutput(v **GetCommentsForPullRequestOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetCommentsForPullRequestOutput
	if *v == nil {
		sv = &GetCommentsForPullRequestOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commentsForPullRequestData":
			if err := awsAwsjson11_deserializeDocumentCommentsForPullRequestData(&sv.CommentsForPullRequestData, decoder); err != nil {
				return err
			}

		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetCommitOutput(v **GetCommitOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetCommitOutput
	if *v == nil {
		sv = &GetCommitOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commit":
			if err := awsAwsjson11_deserializeDocumentCommit(&sv.Commit, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetDifferencesOutput(v **GetDifferencesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetDifferencesOutput
	if *v == nil {
		sv = &GetDifferencesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "differences":
			if err := awsAwsjson11_deserializeDocumentDifferenceList(&sv.Differences, decoder); err != nil {
				return err
			}

		case "NextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetFileOutput(v **GetFileOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetFileOutput
	if *v == nil {
		sv = &GetFileOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "blobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BlobId = &jtv
			}

		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "fileContent":
			err := decoder.Decode(&sv.FileContent)
			if err != nil {
				return err
			}

		case "fileMode":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected FileModeTypeEnum to be of type string, got %T instead", val)
				}
				sv.FileMode = types.FileModeTypeEnum(jtv)
			}

		case "filePath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.FilePath = &jtv
			}

		case "fileSize":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(json.Number)
				if !ok {
					return fmt.Errorf("expected ObjectSize to be json.Number, got %T instead", val)
				}
				i64, err := jtv.Int64()
				if err != nil {
					return err
				}
				sv.FileSize = &i64
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetFolderOutput(v **GetFolderOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetFolderOutput
	if *v == nil {
		sv = &GetFolderOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "files":
			if err := awsAwsjson11_deserializeDocumentFileList(&sv.Files, decoder); err != nil {
				return err
			}

		case "folderPath":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Path to be of type string, got %T instead", val)
				}
				sv.FolderPath = &jtv
			}

		case "subFolders":
			if err := awsAwsjson11_deserializeDocumentFolderList(&sv.SubFolders, decoder); err != nil {
				return err
			}

		case "subModules":
			if err := awsAwsjson11_deserializeDocumentSubModuleList(&sv.SubModules, decoder); err != nil {
				return err
			}

		case "symbolicLinks":
			if err := awsAwsjson11_deserializeDocumentSymbolicLinkList(&sv.SymbolicLinks, decoder); err != nil {
				return err
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetMergeCommitOutput(v **GetMergeCommitOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetMergeCommitOutput
	if *v == nil {
		sv = &GetMergeCommitOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "baseCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BaseCommitId = &jtv
			}

		case "destinationCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.DestinationCommitId = &jtv
			}

		case "mergedCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.MergedCommitId = &jtv
			}

		case "sourceCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.SourceCommitId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetMergeConflictsOutput(v **GetMergeConflictsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetMergeConflictsOutput
	if *v == nil {
		sv = &GetMergeConflictsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "baseCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BaseCommitId = &jtv
			}

		case "conflictMetadataList":
			if err := awsAwsjson11_deserializeDocumentConflictMetadataList(&sv.ConflictMetadataList, decoder); err != nil {
				return err
			}

		case "destinationCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.DestinationCommitId = &jtv
			}

		case "mergeable":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected IsMergeable to be of type *bool, got %T instead", val)
				}
				sv.Mergeable = &jtv
			}

		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "sourceCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.SourceCommitId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetMergeOptionsOutput(v **GetMergeOptionsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetMergeOptionsOutput
	if *v == nil {
		sv = &GetMergeOptionsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "baseCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BaseCommitId = &jtv
			}

		case "destinationCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.DestinationCommitId = &jtv
			}

		case "mergeOptions":
			if err := awsAwsjson11_deserializeDocumentMergeOptions(&sv.MergeOptions, decoder); err != nil {
				return err
			}

		case "sourceCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.SourceCommitId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetPullRequestApprovalStatesOutput(v **GetPullRequestApprovalStatesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetPullRequestApprovalStatesOutput
	if *v == nil {
		sv = &GetPullRequestApprovalStatesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvals":
			if err := awsAwsjson11_deserializeDocumentApprovalList(&sv.Approvals, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetPullRequestOutput(v **GetPullRequestOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetPullRequestOutput
	if *v == nil {
		sv = &GetPullRequestOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequest":
			if err := awsAwsjson11_deserializeDocumentPullRequest(&sv.PullRequest, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetPullRequestOverrideStateOutput(v **GetPullRequestOverrideStateOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetPullRequestOverrideStateOutput
	if *v == nil {
		sv = &GetPullRequestOverrideStateOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "overridden":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(bool)
				if !ok {
					return fmt.Errorf("expected Overridden to be of type *bool, got %T instead", val)
				}
				sv.Overridden = &jtv
			}

		case "overrider":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected Arn to be of type string, got %T instead", val)
				}
				sv.Overrider = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetRepositoryOutput(v **GetRepositoryOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetRepositoryOutput
	if *v == nil {
		sv = &GetRepositoryOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "repositoryMetadata":
			if err := awsAwsjson11_deserializeDocumentRepositoryMetadata(&sv.RepositoryMetadata, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentGetRepositoryTriggersOutput(v **GetRepositoryTriggersOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *GetRepositoryTriggersOutput
	if *v == nil {
		sv = &GetRepositoryTriggersOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "configurationId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryTriggersConfigurationId to be of type string, got %T instead", val)
				}
				sv.ConfigurationId = &jtv
			}

		case "triggers":
			if err := awsAwsjson11_deserializeDocumentRepositoryTriggersList(&sv.Triggers, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentListApprovalRuleTemplatesOutput(v **ListApprovalRuleTemplatesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *ListApprovalRuleTemplatesOutput
	if *v == nil {
		sv = &ListApprovalRuleTemplatesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplateNames":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleTemplateNameList(&sv.ApprovalRuleTemplateNames, decoder); err != nil {
				return err
			}

		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentListAssociatedApprovalRuleTemplatesForRepositoryOutput(v **ListAssociatedApprovalRuleTemplatesForRepositoryOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *ListAssociatedApprovalRuleTemplatesForRepositoryOutput
	if *v == nil {
		sv = &ListAssociatedApprovalRuleTemplatesForRepositoryOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplateNames":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleTemplateNameList(&sv.ApprovalRuleTemplateNames, decoder); err != nil {
				return err
			}

		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentListBranchesOutput(v **ListBranchesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *ListBranchesOutput
	if *v == nil {
		sv = &ListBranchesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "branches":
			if err := awsAwsjson11_deserializeDocumentBranchNameList(&sv.Branches, decoder); err != nil {
				return err
			}

		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentListPullRequestsOutput(v **ListPullRequestsOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *ListPullRequestsOutput
	if *v == nil {
		sv = &ListPullRequestsOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "pullRequestIds":
			if err := awsAwsjson11_deserializeDocumentPullRequestIdList(&sv.PullRequestIds, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentListRepositoriesForApprovalRuleTemplateOutput(v **ListRepositoriesForApprovalRuleTemplateOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *ListRepositoriesForApprovalRuleTemplateOutput
	if *v == nil {
		sv = &ListRepositoriesForApprovalRuleTemplateOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "repositoryNames":
			if err := awsAwsjson11_deserializeDocumentRepositoryNameList(&sv.RepositoryNames, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentListRepositoriesOutput(v **ListRepositoriesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *ListRepositoriesOutput
	if *v == nil {
		sv = &ListRepositoriesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "repositories":
			if err := awsAwsjson11_deserializeDocumentRepositoryNameIdPairList(&sv.Repositories, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentListTagsForResourceOutput(v **ListTagsForResourceOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *ListTagsForResourceOutput
	if *v == nil {
		sv = &ListTagsForResourceOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "nextToken":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected NextToken to be of type string, got %T instead", val)
				}
				sv.NextToken = &jtv
			}

		case "tags":
			if err := awsAwsjson11_deserializeDocumentTagsMap(&sv.Tags, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentMergeBranchesByFastForwardOutput(v **MergeBranchesByFastForwardOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *MergeBranchesByFastForwardOutput
	if *v == nil {
		sv = &MergeBranchesByFastForwardOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentMergeBranchesBySquashOutput(v **MergeBranchesBySquashOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *MergeBranchesBySquashOutput
	if *v == nil {
		sv = &MergeBranchesBySquashOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentMergeBranchesByThreeWayOutput(v **MergeBranchesByThreeWayOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *MergeBranchesByThreeWayOutput
	if *v == nil {
		sv = &MergeBranchesByThreeWayOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentMergePullRequestByFastForwardOutput(v **MergePullRequestByFastForwardOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *MergePullRequestByFastForwardOutput
	if *v == nil {
		sv = &MergePullRequestByFastForwardOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequest":
			if err := awsAwsjson11_deserializeDocumentPullRequest(&sv.PullRequest, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentMergePullRequestBySquashOutput(v **MergePullRequestBySquashOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *MergePullRequestBySquashOutput
	if *v == nil {
		sv = &MergePullRequestBySquashOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequest":
			if err := awsAwsjson11_deserializeDocumentPullRequest(&sv.PullRequest, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentMergePullRequestByThreeWayOutput(v **MergePullRequestByThreeWayOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *MergePullRequestByThreeWayOutput
	if *v == nil {
		sv = &MergePullRequestByThreeWayOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequest":
			if err := awsAwsjson11_deserializeDocumentPullRequest(&sv.PullRequest, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentOverridePullRequestApprovalRulesOutput(v **OverridePullRequestApprovalRulesOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *OverridePullRequestApprovalRulesOutput
	if *v == nil {
		sv = &OverridePullRequestApprovalRulesOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentPostCommentForComparedCommitOutput(v **PostCommentForComparedCommitOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *PostCommentForComparedCommitOutput
	if *v == nil {
		sv = &PostCommentForComparedCommitOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "afterBlobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.AfterBlobId = &jtv
			}

		case "afterCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.AfterCommitId = &jtv
			}

		case "beforeBlobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BeforeBlobId = &jtv
			}

		case "beforeCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.BeforeCommitId = &jtv
			}

		case "comment":
			if err := awsAwsjson11_deserializeDocumentComment(&sv.Comment, decoder); err != nil {
				return err
			}

		case "location":
			if err := awsAwsjson11_deserializeDocumentLocation(&sv.Location, decoder); err != nil {
				return err
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentPostCommentForPullRequestOutput(v **PostCommentForPullRequestOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *PostCommentForPullRequestOutput
	if *v == nil {
		sv = &PostCommentForPullRequestOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "afterBlobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.AfterBlobId = &jtv
			}

		case "afterCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.AfterCommitId = &jtv
			}

		case "beforeBlobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BeforeBlobId = &jtv
			}

		case "beforeCommitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected CommitId to be of type string, got %T instead", val)
				}
				sv.BeforeCommitId = &jtv
			}

		case "comment":
			if err := awsAwsjson11_deserializeDocumentComment(&sv.Comment, decoder); err != nil {
				return err
			}

		case "location":
			if err := awsAwsjson11_deserializeDocumentLocation(&sv.Location, decoder); err != nil {
				return err
			}

		case "pullRequestId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected PullRequestId to be of type string, got %T instead", val)
				}
				sv.PullRequestId = &jtv
			}

		case "repositoryName":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryName to be of type string, got %T instead", val)
				}
				sv.RepositoryName = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentPostCommentReplyOutput(v **PostCommentReplyOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *PostCommentReplyOutput
	if *v == nil {
		sv = &PostCommentReplyOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "comment":
			if err := awsAwsjson11_deserializeDocumentComment(&sv.Comment, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentPutCommentReactionOutput(v **PutCommentReactionOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *PutCommentReactionOutput
	if *v == nil {
		sv = &PutCommentReactionOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentPutFileOutput(v **PutFileOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *PutFileOutput
	if *v == nil {
		sv = &PutFileOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "blobId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.BlobId = &jtv
			}

		case "commitId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.CommitId = &jtv
			}

		case "treeId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected ObjectId to be of type string, got %T instead", val)
				}
				sv.TreeId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentPutRepositoryTriggersOutput(v **PutRepositoryTriggersOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *PutRepositoryTriggersOutput
	if *v == nil {
		sv = &PutRepositoryTriggersOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "configurationId":
			val, err := decoder.Token()
			if err != nil {
				return err
			}
			if val != nil {
				jtv, ok := val.(string)
				if !ok {
					return fmt.Errorf("expected RepositoryTriggersConfigurationId to be of type string, got %T instead", val)
				}
				sv.ConfigurationId = &jtv
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentTagResourceOutput(v **TagResourceOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *TagResourceOutput
	if *v == nil {
		sv = &TagResourceOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentTestRepositoryTriggersOutput(v **TestRepositoryTriggersOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *TestRepositoryTriggersOutput
	if *v == nil {
		sv = &TestRepositoryTriggersOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "failedExecutions":
			if err := awsAwsjson11_deserializeDocumentRepositoryTriggerExecutionFailureList(&sv.FailedExecutions, decoder); err != nil {
				return err
			}

		case "successfulExecutions":
			if err := awsAwsjson11_deserializeDocumentRepositoryTriggerNameList(&sv.SuccessfulExecutions, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentUntagResourceOutput(v **UntagResourceOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UntagResourceOutput
	if *v == nil {
		sv = &UntagResourceOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentUpdateApprovalRuleTemplateContentOutput(v **UpdateApprovalRuleTemplateContentOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdateApprovalRuleTemplateContentOutput
	if *v == nil {
		sv = &UpdateApprovalRuleTemplateContentOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplate":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleTemplate(&sv.ApprovalRuleTemplate, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentUpdateApprovalRuleTemplateDescriptionOutput(v **UpdateApprovalRuleTemplateDescriptionOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdateApprovalRuleTemplateDescriptionOutput
	if *v == nil {
		sv = &UpdateApprovalRuleTemplateDescriptionOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplate":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleTemplate(&sv.ApprovalRuleTemplate, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentUpdateApprovalRuleTemplateNameOutput(v **UpdateApprovalRuleTemplateNameOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdateApprovalRuleTemplateNameOutput
	if *v == nil {
		sv = &UpdateApprovalRuleTemplateNameOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRuleTemplate":
			if err := awsAwsjson11_deserializeDocumentApprovalRuleTemplate(&sv.ApprovalRuleTemplate, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentUpdateCommentOutput(v **UpdateCommentOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdateCommentOutput
	if *v == nil {
		sv = &UpdateCommentOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "comment":
			if err := awsAwsjson11_deserializeDocumentComment(&sv.Comment, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentUpdateDefaultBranchOutput(v **UpdateDefaultBranchOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdateDefaultBranchOutput
	if *v == nil {
		sv = &UpdateDefaultBranchOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentUpdatePullRequestApprovalRuleContentOutput(v **UpdatePullRequestApprovalRuleContentOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdatePullRequestApprovalRuleContentOutput
	if *v == nil {
		sv = &UpdatePullRequestApprovalRuleContentOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "approvalRule":
			if err := awsAwsjson11_deserializeDocumentApprovalRule(&sv.ApprovalRule, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentUpdatePullRequestApprovalStateOutput(v **UpdatePullRequestApprovalStateOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdatePullRequestApprovalStateOutput
	if *v == nil {
		sv = &UpdatePullRequestApprovalStateOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentUpdatePullRequestDescriptionOutput(v **UpdatePullRequestDescriptionOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdatePullRequestDescriptionOutput
	if *v == nil {
		sv = &UpdatePullRequestDescriptionOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequest":
			if err := awsAwsjson11_deserializeDocumentPullRequest(&sv.PullRequest, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentUpdatePullRequestStatusOutput(v **UpdatePullRequestStatusOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdatePullRequestStatusOutput
	if *v == nil {
		sv = &UpdatePullRequestStatusOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequest":
			if err := awsAwsjson11_deserializeDocumentPullRequest(&sv.PullRequest, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeOpDocumentUpdatePullRequestTitleOutput(v **UpdatePullRequestTitleOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdatePullRequestTitleOutput
	if *v == nil {
		sv = &UpdatePullRequestTitleOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		case "pullRequest":
			if err := awsAwsjson11_deserializeDocumentPullRequest(&sv.PullRequest, decoder); err != nil {
				return err
			}

		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentUpdateRepositoryDescriptionOutput(v **UpdateRepositoryDescriptionOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdateRepositoryDescriptionOutput
	if *v == nil {
		sv = &UpdateRepositoryDescriptionOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}

func awsAwsjson11_deserializeDocumentUpdateRepositoryNameOutput(v **UpdateRepositoryNameOutput, decoder *json.Decoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	startToken, err := decoder.Token()
	if err == io.EOF {
		return nil
	}
	if err != nil {
		return err
	}
	if startToken == nil {
		return nil
	}
	if t, ok := startToken.(json.Delim); !ok || t != '{' {
		return fmt.Errorf("expect `{` as start token")
	}

	var sv *UpdateRepositoryNameOutput
	if *v == nil {
		sv = &UpdateRepositoryNameOutput{}
	} else {
		sv = *v
	}

	for decoder.More() {
		t, err := decoder.Token()
		if err != nil {
			return err
		}
		switch t {
		default:
			err := smithyjson.DiscardUnknownField(decoder)
			if err != nil {
				return err
			}

		}
	}
	endToken, err := decoder.Token()
	if err != nil {
		return err
	}
	if t, ok := endToken.(json.Delim); !ok || t != '}' {
		return fmt.Errorf("expect `}` as end token")
	}

	*v = sv
	return nil
}
