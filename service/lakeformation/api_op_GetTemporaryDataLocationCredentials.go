// Code generated by smithy-go-codegen DO NOT EDIT.

package lakeformation

import (
	"context"
	"fmt"
	awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
	"github.com/aws/aws-sdk-go-v2/service/lakeformation/types"
	"github.com/aws/smithy-go/middleware"
	smithyhttp "github.com/aws/smithy-go/transport/http"
)

// Allows a user or application in a secure environment to access data in a
// specific Amazon S3 location registered with Lake Formation by providing
// temporary scoped credentials that are limited to the requested data location and
// the caller's authorized access level.
//
// The API operation returns an error in the following scenarios:
//
//   - The data location is not registered with Lake Formation.
//
//   - No Glue table is associated with the data location.
//
//   - The caller doesn't have required permissions on the associated table. The
//     caller must have SELECT or SUPER permissions on the associated table, and
//     credential vending for full table access must be enabled in the data lake
//     settings.
//
// For more information, see [Application integration for full table access].
//
//   - The data location is in a different Amazon Web Services Region. Lake
//     Formation doesn't support cross-Region access when vending credentials for a
//     data location. Lake Formation only supports Amazon S3 paths registered within
//     the same Region as the API call.
//
// [Application integration for full table access]: https://docs.aws.amazon.com/lake-formation/latest/dg/full-table-credential-vending.html
func (c *Client) GetTemporaryDataLocationCredentials(ctx context.Context, params *GetTemporaryDataLocationCredentialsInput, optFns ...func(*Options)) (*GetTemporaryDataLocationCredentialsOutput, error) {
	if params == nil {
		params = &GetTemporaryDataLocationCredentialsInput{}
	}

	result, metadata, err := c.invokeOperation(ctx, "GetTemporaryDataLocationCredentials", params, optFns, c.addOperationGetTemporaryDataLocationCredentialsMiddlewares)
	if err != nil {
		return nil, err
	}

	out := result.(*GetTemporaryDataLocationCredentialsOutput)
	out.ResultMetadata = metadata
	return out, nil
}

type GetTemporaryDataLocationCredentialsInput struct {

	// A structure used to include auditing information on the privileged API.
	AuditContext *types.AuditContext

	// The credential scope is determined by the caller's Lake Formation permission on
	// the associated table. Credential scope can be either:
	//
	//   - READ - Provides read-only access to the data location.
	//
	//   - READ_WRITE - Provides both read and write access to the data location.
	CredentialsScope types.CredentialsScope

	// The Amazon S3 data location that you want to access.
	DataLocations []string

	// The time period, between 900 and 43,200 seconds, for the timeout of the
	// temporary credentials.
	DurationSeconds *int32

	noSmithyDocumentSerde
}

type GetTemporaryDataLocationCredentialsOutput struct {

	// Refers to the Amazon S3 locations that can be accessed through the
	// GetTemporaryCredentialsForLocation API operation.
	AccessibleDataLocations []string

	// A temporary set of credentials for an Lake Formation user. These credentials
	// are scoped down to only access the raw data sources that the user has access to.
	//
	// The temporary security credentials consist of an access key and a session
	// token. The access key consists of an access key ID and a secret key. When the
	// credentials are created, they are associated with an IAM access control policy
	// that limits what the user can do when using the credentials.
	Credentials *types.TemporaryCredentials

	// The credential scope is determined by the caller's Lake Formation permission on
	// the associated table. Credential scope can be either:
	//
	//   - READ - Provides read-only access to the data location.
	//
	//   - READ_WRITE - Provides both read and write access to the data location.
	CredentialsScope types.CredentialsScope

	// Metadata pertaining to the operation's result.
	ResultMetadata middleware.Metadata

	noSmithyDocumentSerde
}

func (c *Client) addOperationGetTemporaryDataLocationCredentialsMiddlewares(stack *middleware.Stack, options Options) (err error) {
	if err := stack.Serialize.Add(&setOperationInputMiddleware{}, middleware.After); err != nil {
		return err
	}
	err = stack.Serialize.Add(&awsRestjson1_serializeOpGetTemporaryDataLocationCredentials{}, middleware.After)
	if err != nil {
		return err
	}
	err = stack.Deserialize.Add(&awsRestjson1_deserializeOpGetTemporaryDataLocationCredentials{}, middleware.After)
	if err != nil {
		return err
	}
	if err := addProtocolFinalizerMiddlewares(stack, options, "GetTemporaryDataLocationCredentials"); err != nil {
		return fmt.Errorf("add protocol finalizers: %v", err)
	}

	if err = addlegacyEndpointContextSetter(stack, options); err != nil {
		return err
	}
	if err = addSetLoggerMiddleware(stack, options); err != nil {
		return err
	}
	if err = addClientRequestID(stack); err != nil {
		return err
	}
	if err = addComputeContentLength(stack); err != nil {
		return err
	}
	if err = addResolveEndpointMiddleware(stack, options); err != nil {
		return err
	}
	if err = addComputePayloadSHA256(stack); err != nil {
		return err
	}
	if err = addRetry(stack, options); err != nil {
		return err
	}
	if err = addRawResponseToMetadata(stack); err != nil {
		return err
	}
	if err = addRecordResponseTiming(stack); err != nil {
		return err
	}
	if err = addSpanRetryLoop(stack, options); err != nil {
		return err
	}
	if err = addClientUserAgent(stack, options); err != nil {
		return err
	}
	if err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {
		return err
	}
	if err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {
		return err
	}
	if err = addSetLegacyContextSigningOptionsMiddleware(stack); err != nil {
		return err
	}
	if err = addTimeOffsetBuild(stack, c); err != nil {
		return err
	}
	if err = addUserAgentRetryMode(stack, options); err != nil {
		return err
	}
	if err = addCredentialSource(stack, options); err != nil {
		return err
	}
	if err = stack.Initialize.Add(newServiceMetadataMiddleware_opGetTemporaryDataLocationCredentials(options.Region), middleware.Before); err != nil {
		return err
	}
	if err = addRecursionDetection(stack); err != nil {
		return err
	}
	if err = addRequestIDRetrieverMiddleware(stack); err != nil {
		return err
	}
	if err = addResponseErrorMiddleware(stack); err != nil {
		return err
	}
	if err = addRequestResponseLogging(stack, options); err != nil {
		return err
	}
	if err = addDisableHTTPSMiddleware(stack, options); err != nil {
		return err
	}
	if err = addInterceptBeforeRetryLoop(stack, options); err != nil {
		return err
	}
	if err = addInterceptAttempt(stack, options); err != nil {
		return err
	}
	if err = addInterceptors(stack, options); err != nil {
		return err
	}
	return nil
}

func newServiceMetadataMiddleware_opGetTemporaryDataLocationCredentials(region string) *awsmiddleware.RegisterServiceMetadata {
	return &awsmiddleware.RegisterServiceMetadata{
		Region:        region,
		ServiceID:     ServiceID,
		OperationName: "GetTemporaryDataLocationCredentials",
	}
}
