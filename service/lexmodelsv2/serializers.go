// Code generated by smithy-go-codegen DO NOT EDIT.

package lexmodelsv2

import (
	"bytes"
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/lexmodelsv2/types"
	smithy "github.com/aws/smithy-go"
	"github.com/aws/smithy-go/encoding/httpbinding"
	smithyjson "github.com/aws/smithy-go/encoding/json"
	"github.com/aws/smithy-go/middleware"
	smithyhttp "github.com/aws/smithy-go/transport/http"
	"math"
)

type awsRestjson1_serializeOpBuildBotLocale struct {
}

func (*awsRestjson1_serializeOpBuildBotLocale) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpBuildBotLocale) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*BuildBotLocaleInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsBuildBotLocaleInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsBuildBotLocaleInput(v *BuildBotLocaleInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateBot struct {
}

func (*awsRestjson1_serializeOpCreateBot) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateBot) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateBotInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateBotInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateBotInput(v *CreateBotInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateBotInput(v *CreateBotInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotName != nil {
		ok := object.Key("botName")
		ok.String(*v.BotName)
	}

	if v.BotTags != nil {
		ok := object.Key("botTags")
		if err := awsRestjson1_serializeDocumentTagMap(v.BotTags, ok); err != nil {
			return err
		}
	}

	if v.DataPrivacy != nil {
		ok := object.Key("dataPrivacy")
		if err := awsRestjson1_serializeDocumentDataPrivacy(v.DataPrivacy, ok); err != nil {
			return err
		}
	}

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.IdleSessionTTLInSeconds != nil {
		ok := object.Key("idleSessionTTLInSeconds")
		ok.Integer(*v.IdleSessionTTLInSeconds)
	}

	if v.RoleArn != nil {
		ok := object.Key("roleArn")
		ok.String(*v.RoleArn)
	}

	if v.TestBotAliasTags != nil {
		ok := object.Key("testBotAliasTags")
		if err := awsRestjson1_serializeDocumentTagMap(v.TestBotAliasTags, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateBotAlias struct {
}

func (*awsRestjson1_serializeOpCreateBotAlias) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateBotAlias) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateBotAliasInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botaliases")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsCreateBotAliasInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateBotAliasInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateBotAliasInput(v *CreateBotAliasInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateBotAliasInput(v *CreateBotAliasInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotAliasLocaleSettings != nil {
		ok := object.Key("botAliasLocaleSettings")
		if err := awsRestjson1_serializeDocumentBotAliasLocaleSettingsMap(v.BotAliasLocaleSettings, ok); err != nil {
			return err
		}
	}

	if v.BotAliasName != nil {
		ok := object.Key("botAliasName")
		ok.String(*v.BotAliasName)
	}

	if v.BotVersion != nil {
		ok := object.Key("botVersion")
		ok.String(*v.BotVersion)
	}

	if v.ConversationLogSettings != nil {
		ok := object.Key("conversationLogSettings")
		if err := awsRestjson1_serializeDocumentConversationLogSettings(v.ConversationLogSettings, ok); err != nil {
			return err
		}
	}

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.SentimentAnalysisSettings != nil {
		ok := object.Key("sentimentAnalysisSettings")
		if err := awsRestjson1_serializeDocumentSentimentAnalysisSettings(v.SentimentAnalysisSettings, ok); err != nil {
			return err
		}
	}

	if v.Tags != nil {
		ok := object.Key("tags")
		if err := awsRestjson1_serializeDocumentTagMap(v.Tags, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateBotLocale struct {
}

func (*awsRestjson1_serializeOpCreateBotLocale) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateBotLocale) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateBotLocaleInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsCreateBotLocaleInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateBotLocaleInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateBotLocaleInput(v *CreateBotLocaleInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateBotLocaleInput(v *CreateBotLocaleInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.LocaleId != nil {
		ok := object.Key("localeId")
		ok.String(*v.LocaleId)
	}

	if v.NluIntentConfidenceThreshold != nil {
		ok := object.Key("nluIntentConfidenceThreshold")
		switch {
		case math.IsNaN(*v.NluIntentConfidenceThreshold):
			ok.String("NaN")

		case math.IsInf(*v.NluIntentConfidenceThreshold, 1):
			ok.String("Infinity")

		case math.IsInf(*v.NluIntentConfidenceThreshold, -1):
			ok.String("-Infinity")

		default:
			ok.Double(*v.NluIntentConfidenceThreshold)

		}
	}

	if v.VoiceSettings != nil {
		ok := object.Key("voiceSettings")
		if err := awsRestjson1_serializeDocumentVoiceSettings(v.VoiceSettings, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateBotVersion struct {
}

func (*awsRestjson1_serializeOpCreateBotVersion) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateBotVersion) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateBotVersionInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsCreateBotVersionInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateBotVersionInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateBotVersionInput(v *CreateBotVersionInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateBotVersionInput(v *CreateBotVersionInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotVersionLocaleSpecification != nil {
		ok := object.Key("botVersionLocaleSpecification")
		if err := awsRestjson1_serializeDocumentBotVersionLocaleSpecification(v.BotVersionLocaleSpecification, ok); err != nil {
			return err
		}
	}

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	return nil
}

type awsRestjson1_serializeOpCreateExport struct {
}

func (*awsRestjson1_serializeOpCreateExport) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateExport) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateExportInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/exports")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateExportInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateExportInput(v *CreateExportInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateExportInput(v *CreateExportInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.FileFormat) > 0 {
		ok := object.Key("fileFormat")
		ok.String(string(v.FileFormat))
	}

	if v.FilePassword != nil {
		ok := object.Key("filePassword")
		ok.String(*v.FilePassword)
	}

	if v.ResourceSpecification != nil {
		ok := object.Key("resourceSpecification")
		if err := awsRestjson1_serializeDocumentExportResourceSpecification(v.ResourceSpecification, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateIntent struct {
}

func (*awsRestjson1_serializeOpCreateIntent) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateIntent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateIntentInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsCreateIntentInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateIntentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateIntentInput(v *CreateIntentInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateIntentInput(v *CreateIntentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.DialogCodeHook != nil {
		ok := object.Key("dialogCodeHook")
		if err := awsRestjson1_serializeDocumentDialogCodeHookSettings(v.DialogCodeHook, ok); err != nil {
			return err
		}
	}

	if v.FulfillmentCodeHook != nil {
		ok := object.Key("fulfillmentCodeHook")
		if err := awsRestjson1_serializeDocumentFulfillmentCodeHookSettings(v.FulfillmentCodeHook, ok); err != nil {
			return err
		}
	}

	if v.InputContexts != nil {
		ok := object.Key("inputContexts")
		if err := awsRestjson1_serializeDocumentInputContextsList(v.InputContexts, ok); err != nil {
			return err
		}
	}

	if v.IntentClosingSetting != nil {
		ok := object.Key("intentClosingSetting")
		if err := awsRestjson1_serializeDocumentIntentClosingSetting(v.IntentClosingSetting, ok); err != nil {
			return err
		}
	}

	if v.IntentConfirmationSetting != nil {
		ok := object.Key("intentConfirmationSetting")
		if err := awsRestjson1_serializeDocumentIntentConfirmationSetting(v.IntentConfirmationSetting, ok); err != nil {
			return err
		}
	}

	if v.IntentName != nil {
		ok := object.Key("intentName")
		ok.String(*v.IntentName)
	}

	if v.KendraConfiguration != nil {
		ok := object.Key("kendraConfiguration")
		if err := awsRestjson1_serializeDocumentKendraConfiguration(v.KendraConfiguration, ok); err != nil {
			return err
		}
	}

	if v.OutputContexts != nil {
		ok := object.Key("outputContexts")
		if err := awsRestjson1_serializeDocumentOutputContextsList(v.OutputContexts, ok); err != nil {
			return err
		}
	}

	if v.ParentIntentSignature != nil {
		ok := object.Key("parentIntentSignature")
		ok.String(*v.ParentIntentSignature)
	}

	if v.SampleUtterances != nil {
		ok := object.Key("sampleUtterances")
		if err := awsRestjson1_serializeDocumentSampleUtterancesList(v.SampleUtterances, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateResourcePolicy struct {
}

func (*awsRestjson1_serializeOpCreateResourcePolicy) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateResourcePolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateResourcePolicyInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/policy/{resourceArn}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsCreateResourcePolicyInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateResourcePolicyInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateResourcePolicyInput(v *CreateResourcePolicyInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ResourceArn == nil || len(*v.ResourceArn) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceArn must not be empty")}
	}
	if v.ResourceArn != nil {
		if err := encoder.SetURI("resourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateResourcePolicyInput(v *CreateResourcePolicyInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Policy != nil {
		ok := object.Key("policy")
		ok.String(*v.Policy)
	}

	return nil
}

type awsRestjson1_serializeOpCreateResourcePolicyStatement struct {
}

func (*awsRestjson1_serializeOpCreateResourcePolicyStatement) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateResourcePolicyStatement) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateResourcePolicyStatementInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/policy/{resourceArn}/statements")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsCreateResourcePolicyStatementInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateResourcePolicyStatementInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateResourcePolicyStatementInput(v *CreateResourcePolicyStatementInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ExpectedRevisionId != nil {
		encoder.SetQuery("expectedRevisionId").String(*v.ExpectedRevisionId)
	}

	if v.ResourceArn == nil || len(*v.ResourceArn) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceArn must not be empty")}
	}
	if v.ResourceArn != nil {
		if err := encoder.SetURI("resourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateResourcePolicyStatementInput(v *CreateResourcePolicyStatementInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Action != nil {
		ok := object.Key("action")
		if err := awsRestjson1_serializeDocumentOperationList(v.Action, ok); err != nil {
			return err
		}
	}

	if v.Condition != nil {
		ok := object.Key("condition")
		if err := awsRestjson1_serializeDocumentConditionMap(v.Condition, ok); err != nil {
			return err
		}
	}

	if len(v.Effect) > 0 {
		ok := object.Key("effect")
		ok.String(string(v.Effect))
	}

	if v.Principal != nil {
		ok := object.Key("principal")
		if err := awsRestjson1_serializeDocumentPrincipalList(v.Principal, ok); err != nil {
			return err
		}
	}

	if v.StatementId != nil {
		ok := object.Key("statementId")
		ok.String(*v.StatementId)
	}

	return nil
}

type awsRestjson1_serializeOpCreateSlot struct {
}

func (*awsRestjson1_serializeOpCreateSlot) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateSlot) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateSlotInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsCreateSlotInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateSlotInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateSlotInput(v *CreateSlotInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.IntentId == nil || len(*v.IntentId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member intentId must not be empty")}
	}
	if v.IntentId != nil {
		if err := encoder.SetURI("intentId").String(*v.IntentId); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateSlotInput(v *CreateSlotInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.MultipleValuesSetting != nil {
		ok := object.Key("multipleValuesSetting")
		if err := awsRestjson1_serializeDocumentMultipleValuesSetting(v.MultipleValuesSetting, ok); err != nil {
			return err
		}
	}

	if v.ObfuscationSetting != nil {
		ok := object.Key("obfuscationSetting")
		if err := awsRestjson1_serializeDocumentObfuscationSetting(v.ObfuscationSetting, ok); err != nil {
			return err
		}
	}

	if v.SlotName != nil {
		ok := object.Key("slotName")
		ok.String(*v.SlotName)
	}

	if v.SlotTypeId != nil {
		ok := object.Key("slotTypeId")
		ok.String(*v.SlotTypeId)
	}

	if v.ValueElicitationSetting != nil {
		ok := object.Key("valueElicitationSetting")
		if err := awsRestjson1_serializeDocumentSlotValueElicitationSetting(v.ValueElicitationSetting, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateSlotType struct {
}

func (*awsRestjson1_serializeOpCreateSlotType) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateSlotType) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateSlotTypeInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsCreateSlotTypeInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentCreateSlotTypeInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateSlotTypeInput(v *CreateSlotTypeInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentCreateSlotTypeInput(v *CreateSlotTypeInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.ParentSlotTypeSignature != nil {
		ok := object.Key("parentSlotTypeSignature")
		ok.String(*v.ParentSlotTypeSignature)
	}

	if v.SlotTypeName != nil {
		ok := object.Key("slotTypeName")
		ok.String(*v.SlotTypeName)
	}

	if v.SlotTypeValues != nil {
		ok := object.Key("slotTypeValues")
		if err := awsRestjson1_serializeDocumentSlotTypeValues(v.SlotTypeValues, ok); err != nil {
			return err
		}
	}

	if v.ValueSelectionSetting != nil {
		ok := object.Key("valueSelectionSetting")
		if err := awsRestjson1_serializeDocumentSlotValueSelectionSetting(v.ValueSelectionSetting, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpCreateUploadUrl struct {
}

func (*awsRestjson1_serializeOpCreateUploadUrl) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateUploadUrl) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateUploadUrlInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/createuploadurl")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsCreateUploadUrlInput(v *CreateUploadUrlInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

type awsRestjson1_serializeOpDeleteBot struct {
}

func (*awsRestjson1_serializeOpDeleteBot) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteBot) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteBotInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteBotInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteBotInput(v *DeleteBotInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.SkipResourceInUseCheck {
		encoder.SetQuery("skipResourceInUseCheck").Boolean(v.SkipResourceInUseCheck)
	}

	return nil
}

type awsRestjson1_serializeOpDeleteBotAlias struct {
}

func (*awsRestjson1_serializeOpDeleteBotAlias) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteBotAlias) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteBotAliasInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botaliases/{botAliasId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteBotAliasInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteBotAliasInput(v *DeleteBotAliasInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotAliasId == nil || len(*v.BotAliasId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botAliasId must not be empty")}
	}
	if v.BotAliasId != nil {
		if err := encoder.SetURI("botAliasId").String(*v.BotAliasId); err != nil {
			return err
		}
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.SkipResourceInUseCheck {
		encoder.SetQuery("skipResourceInUseCheck").Boolean(v.SkipResourceInUseCheck)
	}

	return nil
}

type awsRestjson1_serializeOpDeleteBotLocale struct {
}

func (*awsRestjson1_serializeOpDeleteBotLocale) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteBotLocale) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteBotLocaleInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteBotLocaleInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteBotLocaleInput(v *DeleteBotLocaleInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteBotVersion struct {
}

func (*awsRestjson1_serializeOpDeleteBotVersion) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteBotVersion) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteBotVersionInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteBotVersionInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteBotVersionInput(v *DeleteBotVersionInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.SkipResourceInUseCheck {
		encoder.SetQuery("skipResourceInUseCheck").Boolean(v.SkipResourceInUseCheck)
	}

	return nil
}

type awsRestjson1_serializeOpDeleteExport struct {
}

func (*awsRestjson1_serializeOpDeleteExport) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteExport) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteExportInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/exports/{exportId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteExportInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteExportInput(v *DeleteExportInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ExportId == nil || len(*v.ExportId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member exportId must not be empty")}
	}
	if v.ExportId != nil {
		if err := encoder.SetURI("exportId").String(*v.ExportId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteImport struct {
}

func (*awsRestjson1_serializeOpDeleteImport) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteImport) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteImportInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/imports/{importId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteImportInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteImportInput(v *DeleteImportInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ImportId == nil || len(*v.ImportId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member importId must not be empty")}
	}
	if v.ImportId != nil {
		if err := encoder.SetURI("importId").String(*v.ImportId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteIntent struct {
}

func (*awsRestjson1_serializeOpDeleteIntent) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteIntent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteIntentInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteIntentInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteIntentInput(v *DeleteIntentInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.IntentId == nil || len(*v.IntentId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member intentId must not be empty")}
	}
	if v.IntentId != nil {
		if err := encoder.SetURI("intentId").String(*v.IntentId); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteResourcePolicy struct {
}

func (*awsRestjson1_serializeOpDeleteResourcePolicy) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteResourcePolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteResourcePolicyInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/policy/{resourceArn}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteResourcePolicyInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteResourcePolicyInput(v *DeleteResourcePolicyInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ExpectedRevisionId != nil {
		encoder.SetQuery("expectedRevisionId").String(*v.ExpectedRevisionId)
	}

	if v.ResourceArn == nil || len(*v.ResourceArn) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceArn must not be empty")}
	}
	if v.ResourceArn != nil {
		if err := encoder.SetURI("resourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteResourcePolicyStatement struct {
}

func (*awsRestjson1_serializeOpDeleteResourcePolicyStatement) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteResourcePolicyStatement) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteResourcePolicyStatementInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/policy/{resourceArn}/statements/{statementId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteResourcePolicyStatementInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteResourcePolicyStatementInput(v *DeleteResourcePolicyStatementInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ExpectedRevisionId != nil {
		encoder.SetQuery("expectedRevisionId").String(*v.ExpectedRevisionId)
	}

	if v.ResourceArn == nil || len(*v.ResourceArn) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceArn must not be empty")}
	}
	if v.ResourceArn != nil {
		if err := encoder.SetURI("resourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	if v.StatementId == nil || len(*v.StatementId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member statementId must not be empty")}
	}
	if v.StatementId != nil {
		if err := encoder.SetURI("statementId").String(*v.StatementId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteSlot struct {
}

func (*awsRestjson1_serializeOpDeleteSlot) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteSlot) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteSlotInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteSlotInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteSlotInput(v *DeleteSlotInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.IntentId == nil || len(*v.IntentId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member intentId must not be empty")}
	}
	if v.IntentId != nil {
		if err := encoder.SetURI("intentId").String(*v.IntentId); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	if v.SlotId == nil || len(*v.SlotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member slotId must not be empty")}
	}
	if v.SlotId != nil {
		if err := encoder.SetURI("slotId").String(*v.SlotId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDeleteSlotType struct {
}

func (*awsRestjson1_serializeOpDeleteSlotType) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteSlotType) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteSlotTypeInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDeleteSlotTypeInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDeleteSlotTypeInput(v *DeleteSlotTypeInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	if v.SkipResourceInUseCheck {
		encoder.SetQuery("skipResourceInUseCheck").Boolean(v.SkipResourceInUseCheck)
	}

	if v.SlotTypeId == nil || len(*v.SlotTypeId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member slotTypeId must not be empty")}
	}
	if v.SlotTypeId != nil {
		if err := encoder.SetURI("slotTypeId").String(*v.SlotTypeId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeBot struct {
}

func (*awsRestjson1_serializeOpDescribeBot) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeBot) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeBotInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeBotInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeBotInput(v *DescribeBotInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeBotAlias struct {
}

func (*awsRestjson1_serializeOpDescribeBotAlias) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeBotAlias) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeBotAliasInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botaliases/{botAliasId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeBotAliasInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeBotAliasInput(v *DescribeBotAliasInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotAliasId == nil || len(*v.BotAliasId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botAliasId must not be empty")}
	}
	if v.BotAliasId != nil {
		if err := encoder.SetURI("botAliasId").String(*v.BotAliasId); err != nil {
			return err
		}
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeBotLocale struct {
}

func (*awsRestjson1_serializeOpDescribeBotLocale) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeBotLocale) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeBotLocaleInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeBotLocaleInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeBotLocaleInput(v *DescribeBotLocaleInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeBotVersion struct {
}

func (*awsRestjson1_serializeOpDescribeBotVersion) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeBotVersion) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeBotVersionInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeBotVersionInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeBotVersionInput(v *DescribeBotVersionInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeExport struct {
}

func (*awsRestjson1_serializeOpDescribeExport) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeExport) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeExportInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/exports/{exportId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeExportInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeExportInput(v *DescribeExportInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ExportId == nil || len(*v.ExportId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member exportId must not be empty")}
	}
	if v.ExportId != nil {
		if err := encoder.SetURI("exportId").String(*v.ExportId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeImport struct {
}

func (*awsRestjson1_serializeOpDescribeImport) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeImport) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeImportInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/imports/{importId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeImportInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeImportInput(v *DescribeImportInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ImportId == nil || len(*v.ImportId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member importId must not be empty")}
	}
	if v.ImportId != nil {
		if err := encoder.SetURI("importId").String(*v.ImportId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeIntent struct {
}

func (*awsRestjson1_serializeOpDescribeIntent) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeIntent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeIntentInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeIntentInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeIntentInput(v *DescribeIntentInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.IntentId == nil || len(*v.IntentId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member intentId must not be empty")}
	}
	if v.IntentId != nil {
		if err := encoder.SetURI("intentId").String(*v.IntentId); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeResourcePolicy struct {
}

func (*awsRestjson1_serializeOpDescribeResourcePolicy) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeResourcePolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeResourcePolicyInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/policy/{resourceArn}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeResourcePolicyInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeResourcePolicyInput(v *DescribeResourcePolicyInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ResourceArn == nil || len(*v.ResourceArn) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceArn must not be empty")}
	}
	if v.ResourceArn != nil {
		if err := encoder.SetURI("resourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeSlot struct {
}

func (*awsRestjson1_serializeOpDescribeSlot) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeSlot) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeSlotInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeSlotInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeSlotInput(v *DescribeSlotInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.IntentId == nil || len(*v.IntentId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member intentId must not be empty")}
	}
	if v.IntentId != nil {
		if err := encoder.SetURI("intentId").String(*v.IntentId); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	if v.SlotId == nil || len(*v.SlotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member slotId must not be empty")}
	}
	if v.SlotId != nil {
		if err := encoder.SetURI("slotId").String(*v.SlotId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpDescribeSlotType struct {
}

func (*awsRestjson1_serializeOpDescribeSlotType) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeSlotType) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeSlotTypeInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsDescribeSlotTypeInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsDescribeSlotTypeInput(v *DescribeSlotTypeInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	if v.SlotTypeId == nil || len(*v.SlotTypeId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member slotTypeId must not be empty")}
	}
	if v.SlotTypeId != nil {
		if err := encoder.SetURI("slotTypeId").String(*v.SlotTypeId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListBotAliases struct {
}

func (*awsRestjson1_serializeOpListBotAliases) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListBotAliases) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListBotAliasesInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botaliases")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListBotAliasesInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListBotAliasesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListBotAliasesInput(v *ListBotAliasesInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListBotAliasesInput(v *ListBotAliasesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpListBotLocales struct {
}

func (*awsRestjson1_serializeOpListBotLocales) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListBotLocales) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListBotLocalesInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListBotLocalesInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListBotLocalesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListBotLocalesInput(v *ListBotLocalesInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListBotLocalesInput(v *ListBotLocalesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("filters")
		if err := awsRestjson1_serializeDocumentBotLocaleFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentBotLocaleSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListBots struct {
}

func (*awsRestjson1_serializeOpListBots) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListBots) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListBotsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListBotsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListBotsInput(v *ListBotsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListBotsInput(v *ListBotsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("filters")
		if err := awsRestjson1_serializeDocumentBotFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentBotSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListBotVersions struct {
}

func (*awsRestjson1_serializeOpListBotVersions) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListBotVersions) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListBotVersionsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListBotVersionsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListBotVersionsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListBotVersionsInput(v *ListBotVersionsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListBotVersionsInput(v *ListBotVersionsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentBotVersionSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListBuiltInIntents struct {
}

func (*awsRestjson1_serializeOpListBuiltInIntents) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListBuiltInIntents) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListBuiltInIntentsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/builtins/locales/{localeId}/intents")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListBuiltInIntentsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListBuiltInIntentsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListBuiltInIntentsInput(v *ListBuiltInIntentsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListBuiltInIntentsInput(v *ListBuiltInIntentsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentBuiltInIntentSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListBuiltInSlotTypes struct {
}

func (*awsRestjson1_serializeOpListBuiltInSlotTypes) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListBuiltInSlotTypes) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListBuiltInSlotTypesInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/builtins/locales/{localeId}/slottypes")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListBuiltInSlotTypesInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListBuiltInSlotTypesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListBuiltInSlotTypesInput(v *ListBuiltInSlotTypesInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListBuiltInSlotTypesInput(v *ListBuiltInSlotTypesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentBuiltInSlotTypeSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListExports struct {
}

func (*awsRestjson1_serializeOpListExports) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListExports) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListExportsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/exports")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListExportsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListExportsInput(v *ListExportsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListExportsInput(v *ListExportsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotId != nil {
		ok := object.Key("botId")
		ok.String(*v.BotId)
	}

	if v.BotVersion != nil {
		ok := object.Key("botVersion")
		ok.String(*v.BotVersion)
	}

	if v.Filters != nil {
		ok := object.Key("filters")
		if err := awsRestjson1_serializeDocumentExportFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentExportSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListImports struct {
}

func (*awsRestjson1_serializeOpListImports) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListImports) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListImportsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/imports")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListImportsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListImportsInput(v *ListImportsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListImportsInput(v *ListImportsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotId != nil {
		ok := object.Key("botId")
		ok.String(*v.BotId)
	}

	if v.BotVersion != nil {
		ok := object.Key("botVersion")
		ok.String(*v.BotVersion)
	}

	if v.Filters != nil {
		ok := object.Key("filters")
		if err := awsRestjson1_serializeDocumentImportFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentImportSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListIntents struct {
}

func (*awsRestjson1_serializeOpListIntents) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListIntents) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListIntentsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListIntentsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListIntentsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListIntentsInput(v *ListIntentsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListIntentsInput(v *ListIntentsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("filters")
		if err := awsRestjson1_serializeDocumentIntentFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentIntentSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListSlots struct {
}

func (*awsRestjson1_serializeOpListSlots) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListSlots) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListSlotsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListSlotsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListSlotsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListSlotsInput(v *ListSlotsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.IntentId == nil || len(*v.IntentId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member intentId must not be empty")}
	}
	if v.IntentId != nil {
		if err := encoder.SetURI("intentId").String(*v.IntentId); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListSlotsInput(v *ListSlotsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("filters")
		if err := awsRestjson1_serializeDocumentSlotFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentSlotSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListSlotTypes struct {
}

func (*awsRestjson1_serializeOpListSlotTypes) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListSlotTypes) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListSlotTypesInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListSlotTypesInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentListSlotTypesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListSlotTypesInput(v *ListSlotTypesInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentListSlotTypesInput(v *ListSlotTypesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Filters != nil {
		ok := object.Key("filters")
		if err := awsRestjson1_serializeDocumentSlotTypeFilters(v.Filters, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.SortBy != nil {
		ok := object.Key("sortBy")
		if err := awsRestjson1_serializeDocumentSlotTypeSortBy(v.SortBy, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListTagsForResource struct {
}

func (*awsRestjson1_serializeOpListTagsForResource) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListTagsForResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListTagsForResourceInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/tags/{resourceARN}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsListTagsForResourceInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsListTagsForResourceInput(v *ListTagsForResourceInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ResourceARN == nil || len(*v.ResourceARN) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceARN must not be empty")}
	}
	if v.ResourceARN != nil {
		if err := encoder.SetURI("resourceARN").String(*v.ResourceARN); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpStartImport struct {
}

func (*awsRestjson1_serializeOpStartImport) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpStartImport) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*StartImportInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/imports")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentStartImportInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsStartImportInput(v *StartImportInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeOpDocumentStartImportInput(v *StartImportInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.FilePassword != nil {
		ok := object.Key("filePassword")
		ok.String(*v.FilePassword)
	}

	if v.ImportId != nil {
		ok := object.Key("importId")
		ok.String(*v.ImportId)
	}

	if len(v.MergeStrategy) > 0 {
		ok := object.Key("mergeStrategy")
		ok.String(string(v.MergeStrategy))
	}

	if v.ResourceSpecification != nil {
		ok := object.Key("resourceSpecification")
		if err := awsRestjson1_serializeDocumentImportResourceSpecification(v.ResourceSpecification, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpTagResource struct {
}

func (*awsRestjson1_serializeOpTagResource) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpTagResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*TagResourceInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/tags/{resourceARN}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsTagResourceInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentTagResourceInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsTagResourceInput(v *TagResourceInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ResourceARN == nil || len(*v.ResourceARN) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceARN must not be empty")}
	}
	if v.ResourceARN != nil {
		if err := encoder.SetURI("resourceARN").String(*v.ResourceARN); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentTagResourceInput(v *TagResourceInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Tags != nil {
		ok := object.Key("tags")
		if err := awsRestjson1_serializeDocumentTagMap(v.Tags, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpUntagResource struct {
}

func (*awsRestjson1_serializeOpUntagResource) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUntagResource) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UntagResourceInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/tags/{resourceARN}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUntagResourceInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUntagResourceInput(v *UntagResourceInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ResourceARN == nil || len(*v.ResourceARN) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceARN must not be empty")}
	}
	if v.ResourceARN != nil {
		if err := encoder.SetURI("resourceARN").String(*v.ResourceARN); err != nil {
			return err
		}
	}

	if v.TagKeys != nil {
		for i := range v.TagKeys {
			encoder.AddQuery("tagKeys").String(v.TagKeys[i])
		}
	}

	return nil
}

type awsRestjson1_serializeOpUpdateBot struct {
}

func (*awsRestjson1_serializeOpUpdateBot) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateBot) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateBotInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUpdateBotInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentUpdateBotInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUpdateBotInput(v *UpdateBotInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentUpdateBotInput(v *UpdateBotInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotName != nil {
		ok := object.Key("botName")
		ok.String(*v.BotName)
	}

	if v.DataPrivacy != nil {
		ok := object.Key("dataPrivacy")
		if err := awsRestjson1_serializeDocumentDataPrivacy(v.DataPrivacy, ok); err != nil {
			return err
		}
	}

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.IdleSessionTTLInSeconds != nil {
		ok := object.Key("idleSessionTTLInSeconds")
		ok.Integer(*v.IdleSessionTTLInSeconds)
	}

	if v.RoleArn != nil {
		ok := object.Key("roleArn")
		ok.String(*v.RoleArn)
	}

	return nil
}

type awsRestjson1_serializeOpUpdateBotAlias struct {
}

func (*awsRestjson1_serializeOpUpdateBotAlias) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateBotAlias) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateBotAliasInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botaliases/{botAliasId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUpdateBotAliasInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentUpdateBotAliasInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUpdateBotAliasInput(v *UpdateBotAliasInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotAliasId == nil || len(*v.BotAliasId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botAliasId must not be empty")}
	}
	if v.BotAliasId != nil {
		if err := encoder.SetURI("botAliasId").String(*v.BotAliasId); err != nil {
			return err
		}
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentUpdateBotAliasInput(v *UpdateBotAliasInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotAliasLocaleSettings != nil {
		ok := object.Key("botAliasLocaleSettings")
		if err := awsRestjson1_serializeDocumentBotAliasLocaleSettingsMap(v.BotAliasLocaleSettings, ok); err != nil {
			return err
		}
	}

	if v.BotAliasName != nil {
		ok := object.Key("botAliasName")
		ok.String(*v.BotAliasName)
	}

	if v.BotVersion != nil {
		ok := object.Key("botVersion")
		ok.String(*v.BotVersion)
	}

	if v.ConversationLogSettings != nil {
		ok := object.Key("conversationLogSettings")
		if err := awsRestjson1_serializeDocumentConversationLogSettings(v.ConversationLogSettings, ok); err != nil {
			return err
		}
	}

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.SentimentAnalysisSettings != nil {
		ok := object.Key("sentimentAnalysisSettings")
		if err := awsRestjson1_serializeDocumentSentimentAnalysisSettings(v.SentimentAnalysisSettings, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpUpdateBotLocale struct {
}

func (*awsRestjson1_serializeOpUpdateBotLocale) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateBotLocale) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateBotLocaleInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUpdateBotLocaleInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentUpdateBotLocaleInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUpdateBotLocaleInput(v *UpdateBotLocaleInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentUpdateBotLocaleInput(v *UpdateBotLocaleInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.NluIntentConfidenceThreshold != nil {
		ok := object.Key("nluIntentConfidenceThreshold")
		switch {
		case math.IsNaN(*v.NluIntentConfidenceThreshold):
			ok.String("NaN")

		case math.IsInf(*v.NluIntentConfidenceThreshold, 1):
			ok.String("Infinity")

		case math.IsInf(*v.NluIntentConfidenceThreshold, -1):
			ok.String("-Infinity")

		default:
			ok.Double(*v.NluIntentConfidenceThreshold)

		}
	}

	if v.VoiceSettings != nil {
		ok := object.Key("voiceSettings")
		if err := awsRestjson1_serializeDocumentVoiceSettings(v.VoiceSettings, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpUpdateExport struct {
}

func (*awsRestjson1_serializeOpUpdateExport) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateExport) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateExportInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/exports/{exportId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUpdateExportInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentUpdateExportInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUpdateExportInput(v *UpdateExportInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ExportId == nil || len(*v.ExportId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member exportId must not be empty")}
	}
	if v.ExportId != nil {
		if err := encoder.SetURI("exportId").String(*v.ExportId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentUpdateExportInput(v *UpdateExportInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.FilePassword != nil {
		ok := object.Key("filePassword")
		ok.String(*v.FilePassword)
	}

	return nil
}

type awsRestjson1_serializeOpUpdateIntent struct {
}

func (*awsRestjson1_serializeOpUpdateIntent) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateIntent) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateIntentInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUpdateIntentInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentUpdateIntentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUpdateIntentInput(v *UpdateIntentInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.IntentId == nil || len(*v.IntentId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member intentId must not be empty")}
	}
	if v.IntentId != nil {
		if err := encoder.SetURI("intentId").String(*v.IntentId); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentUpdateIntentInput(v *UpdateIntentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.DialogCodeHook != nil {
		ok := object.Key("dialogCodeHook")
		if err := awsRestjson1_serializeDocumentDialogCodeHookSettings(v.DialogCodeHook, ok); err != nil {
			return err
		}
	}

	if v.FulfillmentCodeHook != nil {
		ok := object.Key("fulfillmentCodeHook")
		if err := awsRestjson1_serializeDocumentFulfillmentCodeHookSettings(v.FulfillmentCodeHook, ok); err != nil {
			return err
		}
	}

	if v.InputContexts != nil {
		ok := object.Key("inputContexts")
		if err := awsRestjson1_serializeDocumentInputContextsList(v.InputContexts, ok); err != nil {
			return err
		}
	}

	if v.IntentClosingSetting != nil {
		ok := object.Key("intentClosingSetting")
		if err := awsRestjson1_serializeDocumentIntentClosingSetting(v.IntentClosingSetting, ok); err != nil {
			return err
		}
	}

	if v.IntentConfirmationSetting != nil {
		ok := object.Key("intentConfirmationSetting")
		if err := awsRestjson1_serializeDocumentIntentConfirmationSetting(v.IntentConfirmationSetting, ok); err != nil {
			return err
		}
	}

	if v.IntentName != nil {
		ok := object.Key("intentName")
		ok.String(*v.IntentName)
	}

	if v.KendraConfiguration != nil {
		ok := object.Key("kendraConfiguration")
		if err := awsRestjson1_serializeDocumentKendraConfiguration(v.KendraConfiguration, ok); err != nil {
			return err
		}
	}

	if v.OutputContexts != nil {
		ok := object.Key("outputContexts")
		if err := awsRestjson1_serializeDocumentOutputContextsList(v.OutputContexts, ok); err != nil {
			return err
		}
	}

	if v.ParentIntentSignature != nil {
		ok := object.Key("parentIntentSignature")
		ok.String(*v.ParentIntentSignature)
	}

	if v.SampleUtterances != nil {
		ok := object.Key("sampleUtterances")
		if err := awsRestjson1_serializeDocumentSampleUtterancesList(v.SampleUtterances, ok); err != nil {
			return err
		}
	}

	if v.SlotPriorities != nil {
		ok := object.Key("slotPriorities")
		if err := awsRestjson1_serializeDocumentSlotPrioritiesList(v.SlotPriorities, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpUpdateResourcePolicy struct {
}

func (*awsRestjson1_serializeOpUpdateResourcePolicy) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateResourcePolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateResourcePolicyInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/policy/{resourceArn}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUpdateResourcePolicyInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentUpdateResourcePolicyInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUpdateResourcePolicyInput(v *UpdateResourcePolicyInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.ExpectedRevisionId != nil {
		encoder.SetQuery("expectedRevisionId").String(*v.ExpectedRevisionId)
	}

	if v.ResourceArn == nil || len(*v.ResourceArn) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member resourceArn must not be empty")}
	}
	if v.ResourceArn != nil {
		if err := encoder.SetURI("resourceArn").String(*v.ResourceArn); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentUpdateResourcePolicyInput(v *UpdateResourcePolicyInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Policy != nil {
		ok := object.Key("policy")
		ok.String(*v.Policy)
	}

	return nil
}

type awsRestjson1_serializeOpUpdateSlot struct {
}

func (*awsRestjson1_serializeOpUpdateSlot) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateSlot) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateSlotInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/intents/{intentId}/slots/{slotId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUpdateSlotInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentUpdateSlotInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUpdateSlotInput(v *UpdateSlotInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.IntentId == nil || len(*v.IntentId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member intentId must not be empty")}
	}
	if v.IntentId != nil {
		if err := encoder.SetURI("intentId").String(*v.IntentId); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	if v.SlotId == nil || len(*v.SlotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member slotId must not be empty")}
	}
	if v.SlotId != nil {
		if err := encoder.SetURI("slotId").String(*v.SlotId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentUpdateSlotInput(v *UpdateSlotInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.MultipleValuesSetting != nil {
		ok := object.Key("multipleValuesSetting")
		if err := awsRestjson1_serializeDocumentMultipleValuesSetting(v.MultipleValuesSetting, ok); err != nil {
			return err
		}
	}

	if v.ObfuscationSetting != nil {
		ok := object.Key("obfuscationSetting")
		if err := awsRestjson1_serializeDocumentObfuscationSetting(v.ObfuscationSetting, ok); err != nil {
			return err
		}
	}

	if v.SlotName != nil {
		ok := object.Key("slotName")
		ok.String(*v.SlotName)
	}

	if v.SlotTypeId != nil {
		ok := object.Key("slotTypeId")
		ok.String(*v.SlotTypeId)
	}

	if v.ValueElicitationSetting != nil {
		ok := object.Key("valueElicitationSetting")
		if err := awsRestjson1_serializeDocumentSlotValueElicitationSetting(v.ValueElicitationSetting, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpUpdateSlotType struct {
}

func (*awsRestjson1_serializeOpUpdateSlotType) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateSlotType) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateSlotTypeInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/bots/{botId}/botversions/{botVersion}/botlocales/{localeId}/slottypes/{slotTypeId}")
	request.URL.Path = smithyhttp.JoinPath(request.URL.Path, opPath)
	request.URL.RawQuery = smithyhttp.JoinRawQuery(request.URL.RawQuery, opQuery)
	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestjson1_serializeOpHttpBindingsUpdateSlotTypeInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeOpDocumentUpdateSlotTypeInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeOpHttpBindingsUpdateSlotTypeInput(v *UpdateSlotTypeInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.BotId == nil || len(*v.BotId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botId must not be empty")}
	}
	if v.BotId != nil {
		if err := encoder.SetURI("botId").String(*v.BotId); err != nil {
			return err
		}
	}

	if v.BotVersion == nil || len(*v.BotVersion) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member botVersion must not be empty")}
	}
	if v.BotVersion != nil {
		if err := encoder.SetURI("botVersion").String(*v.BotVersion); err != nil {
			return err
		}
	}

	if v.LocaleId == nil || len(*v.LocaleId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member localeId must not be empty")}
	}
	if v.LocaleId != nil {
		if err := encoder.SetURI("localeId").String(*v.LocaleId); err != nil {
			return err
		}
	}

	if v.SlotTypeId == nil || len(*v.SlotTypeId) == 0 {
		return &smithy.SerializationError{Err: fmt.Errorf("input member slotTypeId must not be empty")}
	}
	if v.SlotTypeId != nil {
		if err := encoder.SetURI("slotTypeId").String(*v.SlotTypeId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeOpDocumentUpdateSlotTypeInput(v *UpdateSlotTypeInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Description != nil {
		ok := object.Key("description")
		ok.String(*v.Description)
	}

	if v.ParentSlotTypeSignature != nil {
		ok := object.Key("parentSlotTypeSignature")
		ok.String(*v.ParentSlotTypeSignature)
	}

	if v.SlotTypeName != nil {
		ok := object.Key("slotTypeName")
		ok.String(*v.SlotTypeName)
	}

	if v.SlotTypeValues != nil {
		ok := object.Key("slotTypeValues")
		if err := awsRestjson1_serializeDocumentSlotTypeValues(v.SlotTypeValues, ok); err != nil {
			return err
		}
	}

	if v.ValueSelectionSetting != nil {
		ok := object.Key("valueSelectionSetting")
		if err := awsRestjson1_serializeDocumentSlotValueSelectionSetting(v.ValueSelectionSetting, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAudioLogDestination(v *types.AudioLogDestination, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.S3Bucket != nil {
		ok := object.Key("s3Bucket")
		if err := awsRestjson1_serializeDocumentS3BucketLogDestination(v.S3Bucket, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentAudioLogSetting(v *types.AudioLogSetting, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Destination != nil {
		ok := object.Key("destination")
		if err := awsRestjson1_serializeDocumentAudioLogDestination(v.Destination, ok); err != nil {
			return err
		}
	}

	{
		ok := object.Key("enabled")
		ok.Boolean(v.Enabled)
	}

	return nil
}

func awsRestjson1_serializeDocumentAudioLogSettingsList(v []types.AudioLogSetting, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentAudioLogSetting(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentBotAliasLocaleSettings(v *types.BotAliasLocaleSettings, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CodeHookSpecification != nil {
		ok := object.Key("codeHookSpecification")
		if err := awsRestjson1_serializeDocumentCodeHookSpecification(v.CodeHookSpecification, ok); err != nil {
			return err
		}
	}

	{
		ok := object.Key("enabled")
		ok.Boolean(v.Enabled)
	}

	return nil
}

func awsRestjson1_serializeDocumentBotAliasLocaleSettingsMap(v map[string]types.BotAliasLocaleSettings, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		mapVar := v[key]
		if err := awsRestjson1_serializeDocumentBotAliasLocaleSettings(&mapVar, om); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentBotExportSpecification(v *types.BotExportSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotId != nil {
		ok := object.Key("botId")
		ok.String(*v.BotId)
	}

	if v.BotVersion != nil {
		ok := object.Key("botVersion")
		ok.String(*v.BotVersion)
	}

	return nil
}

func awsRestjson1_serializeDocumentBotFilter(v *types.BotFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Name) > 0 {
		ok := object.Key("name")
		ok.String(string(v.Name))
	}

	if len(v.Operator) > 0 {
		ok := object.Key("operator")
		ok.String(string(v.Operator))
	}

	if v.Values != nil {
		ok := object.Key("values")
		if err := awsRestjson1_serializeDocumentFilterValues(v.Values, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentBotFilters(v []types.BotFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentBotFilter(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentBotImportSpecification(v *types.BotImportSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotName != nil {
		ok := object.Key("botName")
		ok.String(*v.BotName)
	}

	if v.BotTags != nil {
		ok := object.Key("botTags")
		if err := awsRestjson1_serializeDocumentTagMap(v.BotTags, ok); err != nil {
			return err
		}
	}

	if v.DataPrivacy != nil {
		ok := object.Key("dataPrivacy")
		if err := awsRestjson1_serializeDocumentDataPrivacy(v.DataPrivacy, ok); err != nil {
			return err
		}
	}

	if v.IdleSessionTTLInSeconds != nil {
		ok := object.Key("idleSessionTTLInSeconds")
		ok.Integer(*v.IdleSessionTTLInSeconds)
	}

	if v.RoleArn != nil {
		ok := object.Key("roleArn")
		ok.String(*v.RoleArn)
	}

	if v.TestBotAliasTags != nil {
		ok := object.Key("testBotAliasTags")
		if err := awsRestjson1_serializeDocumentTagMap(v.TestBotAliasTags, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentBotLocaleExportSpecification(v *types.BotLocaleExportSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotId != nil {
		ok := object.Key("botId")
		ok.String(*v.BotId)
	}

	if v.BotVersion != nil {
		ok := object.Key("botVersion")
		ok.String(*v.BotVersion)
	}

	if v.LocaleId != nil {
		ok := object.Key("localeId")
		ok.String(*v.LocaleId)
	}

	return nil
}

func awsRestjson1_serializeDocumentBotLocaleFilter(v *types.BotLocaleFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Name) > 0 {
		ok := object.Key("name")
		ok.String(string(v.Name))
	}

	if len(v.Operator) > 0 {
		ok := object.Key("operator")
		ok.String(string(v.Operator))
	}

	if v.Values != nil {
		ok := object.Key("values")
		if err := awsRestjson1_serializeDocumentFilterValues(v.Values, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentBotLocaleFilters(v []types.BotLocaleFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentBotLocaleFilter(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentBotLocaleImportSpecification(v *types.BotLocaleImportSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotId != nil {
		ok := object.Key("botId")
		ok.String(*v.BotId)
	}

	if v.BotVersion != nil {
		ok := object.Key("botVersion")
		ok.String(*v.BotVersion)
	}

	if v.LocaleId != nil {
		ok := object.Key("localeId")
		ok.String(*v.LocaleId)
	}

	if v.NluIntentConfidenceThreshold != nil {
		ok := object.Key("nluIntentConfidenceThreshold")
		switch {
		case math.IsNaN(*v.NluIntentConfidenceThreshold):
			ok.String("NaN")

		case math.IsInf(*v.NluIntentConfidenceThreshold, 1):
			ok.String("Infinity")

		case math.IsInf(*v.NluIntentConfidenceThreshold, -1):
			ok.String("-Infinity")

		default:
			ok.Double(*v.NluIntentConfidenceThreshold)

		}
	}

	if v.VoiceSettings != nil {
		ok := object.Key("voiceSettings")
		if err := awsRestjson1_serializeDocumentVoiceSettings(v.VoiceSettings, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentBotLocaleSortBy(v *types.BotLocaleSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentBotSortBy(v *types.BotSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentBotVersionLocaleDetails(v *types.BotVersionLocaleDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.SourceBotVersion != nil {
		ok := object.Key("sourceBotVersion")
		ok.String(*v.SourceBotVersion)
	}

	return nil
}

func awsRestjson1_serializeDocumentBotVersionLocaleSpecification(v map[string]types.BotVersionLocaleDetails, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		mapVar := v[key]
		if err := awsRestjson1_serializeDocumentBotVersionLocaleDetails(&mapVar, om); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentBotVersionSortBy(v *types.BotVersionSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentBuiltInIntentSortBy(v *types.BuiltInIntentSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentBuiltInSlotTypeSortBy(v *types.BuiltInSlotTypeSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentButton(v *types.Button, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Text != nil {
		ok := object.Key("text")
		ok.String(*v.Text)
	}

	if v.Value != nil {
		ok := object.Key("value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentButtonsList(v []types.Button, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentButton(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentCloudWatchLogGroupLogDestination(v *types.CloudWatchLogGroupLogDestination, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CloudWatchLogGroupArn != nil {
		ok := object.Key("cloudWatchLogGroupArn")
		ok.String(*v.CloudWatchLogGroupArn)
	}

	if v.LogPrefix != nil {
		ok := object.Key("logPrefix")
		ok.String(*v.LogPrefix)
	}

	return nil
}

func awsRestjson1_serializeDocumentCodeHookSpecification(v *types.CodeHookSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.LambdaCodeHook != nil {
		ok := object.Key("lambdaCodeHook")
		if err := awsRestjson1_serializeDocumentLambdaCodeHook(v.LambdaCodeHook, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentConditionKeyValueMap(v map[string]string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		om.String(v[key])
	}
	return nil
}

func awsRestjson1_serializeDocumentConditionMap(v map[string]map[string]string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		if vv := v[key]; vv == nil {
			continue
		}
		if err := awsRestjson1_serializeDocumentConditionKeyValueMap(v[key], om); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentConversationLogSettings(v *types.ConversationLogSettings, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AudioLogSettings != nil {
		ok := object.Key("audioLogSettings")
		if err := awsRestjson1_serializeDocumentAudioLogSettingsList(v.AudioLogSettings, ok); err != nil {
			return err
		}
	}

	if v.TextLogSettings != nil {
		ok := object.Key("textLogSettings")
		if err := awsRestjson1_serializeDocumentTextLogSettingsList(v.TextLogSettings, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentCustomPayload(v *types.CustomPayload, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Value != nil {
		ok := object.Key("value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentDataPrivacy(v *types.DataPrivacy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	{
		ok := object.Key("childDirected")
		ok.Boolean(v.ChildDirected)
	}

	return nil
}

func awsRestjson1_serializeDocumentDialogCodeHookSettings(v *types.DialogCodeHookSettings, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	{
		ok := object.Key("enabled")
		ok.Boolean(v.Enabled)
	}

	return nil
}

func awsRestjson1_serializeDocumentExportFilter(v *types.ExportFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Name) > 0 {
		ok := object.Key("name")
		ok.String(string(v.Name))
	}

	if len(v.Operator) > 0 {
		ok := object.Key("operator")
		ok.String(string(v.Operator))
	}

	if v.Values != nil {
		ok := object.Key("values")
		if err := awsRestjson1_serializeDocumentFilterValues(v.Values, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentExportFilters(v []types.ExportFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentExportFilter(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentExportResourceSpecification(v *types.ExportResourceSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotExportSpecification != nil {
		ok := object.Key("botExportSpecification")
		if err := awsRestjson1_serializeDocumentBotExportSpecification(v.BotExportSpecification, ok); err != nil {
			return err
		}
	}

	if v.BotLocaleExportSpecification != nil {
		ok := object.Key("botLocaleExportSpecification")
		if err := awsRestjson1_serializeDocumentBotLocaleExportSpecification(v.BotLocaleExportSpecification, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentExportSortBy(v *types.ExportSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentFilterValues(v []string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		av.String(v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentFulfillmentCodeHookSettings(v *types.FulfillmentCodeHookSettings, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	{
		ok := object.Key("enabled")
		ok.Boolean(v.Enabled)
	}

	return nil
}

func awsRestjson1_serializeDocumentImageResponseCard(v *types.ImageResponseCard, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Buttons != nil {
		ok := object.Key("buttons")
		if err := awsRestjson1_serializeDocumentButtonsList(v.Buttons, ok); err != nil {
			return err
		}
	}

	if v.ImageUrl != nil {
		ok := object.Key("imageUrl")
		ok.String(*v.ImageUrl)
	}

	if v.Subtitle != nil {
		ok := object.Key("subtitle")
		ok.String(*v.Subtitle)
	}

	if v.Title != nil {
		ok := object.Key("title")
		ok.String(*v.Title)
	}

	return nil
}

func awsRestjson1_serializeDocumentImportFilter(v *types.ImportFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Name) > 0 {
		ok := object.Key("name")
		ok.String(string(v.Name))
	}

	if len(v.Operator) > 0 {
		ok := object.Key("operator")
		ok.String(string(v.Operator))
	}

	if v.Values != nil {
		ok := object.Key("values")
		if err := awsRestjson1_serializeDocumentFilterValues(v.Values, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentImportFilters(v []types.ImportFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentImportFilter(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentImportResourceSpecification(v *types.ImportResourceSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.BotImportSpecification != nil {
		ok := object.Key("botImportSpecification")
		if err := awsRestjson1_serializeDocumentBotImportSpecification(v.BotImportSpecification, ok); err != nil {
			return err
		}
	}

	if v.BotLocaleImportSpecification != nil {
		ok := object.Key("botLocaleImportSpecification")
		if err := awsRestjson1_serializeDocumentBotLocaleImportSpecification(v.BotLocaleImportSpecification, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentImportSortBy(v *types.ImportSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentInputContext(v *types.InputContext, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Name != nil {
		ok := object.Key("name")
		ok.String(*v.Name)
	}

	return nil
}

func awsRestjson1_serializeDocumentInputContextsList(v []types.InputContext, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentInputContext(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentIntentClosingSetting(v *types.IntentClosingSetting, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ClosingResponse != nil {
		ok := object.Key("closingResponse")
		if err := awsRestjson1_serializeDocumentResponseSpecification(v.ClosingResponse, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentIntentConfirmationSetting(v *types.IntentConfirmationSetting, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DeclinationResponse != nil {
		ok := object.Key("declinationResponse")
		if err := awsRestjson1_serializeDocumentResponseSpecification(v.DeclinationResponse, ok); err != nil {
			return err
		}
	}

	if v.PromptSpecification != nil {
		ok := object.Key("promptSpecification")
		if err := awsRestjson1_serializeDocumentPromptSpecification(v.PromptSpecification, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentIntentFilter(v *types.IntentFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Name) > 0 {
		ok := object.Key("name")
		ok.String(string(v.Name))
	}

	if len(v.Operator) > 0 {
		ok := object.Key("operator")
		ok.String(string(v.Operator))
	}

	if v.Values != nil {
		ok := object.Key("values")
		if err := awsRestjson1_serializeDocumentFilterValues(v.Values, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentIntentFilters(v []types.IntentFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentIntentFilter(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentIntentSortBy(v *types.IntentSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentKendraConfiguration(v *types.KendraConfiguration, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.KendraIndex != nil {
		ok := object.Key("kendraIndex")
		ok.String(*v.KendraIndex)
	}

	if v.QueryFilterString != nil {
		ok := object.Key("queryFilterString")
		ok.String(*v.QueryFilterString)
	}

	if v.QueryFilterStringEnabled {
		ok := object.Key("queryFilterStringEnabled")
		ok.Boolean(v.QueryFilterStringEnabled)
	}

	return nil
}

func awsRestjson1_serializeDocumentLambdaCodeHook(v *types.LambdaCodeHook, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CodeHookInterfaceVersion != nil {
		ok := object.Key("codeHookInterfaceVersion")
		ok.String(*v.CodeHookInterfaceVersion)
	}

	if v.LambdaARN != nil {
		ok := object.Key("lambdaARN")
		ok.String(*v.LambdaARN)
	}

	return nil
}

func awsRestjson1_serializeDocumentMessage(v *types.Message, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CustomPayload != nil {
		ok := object.Key("customPayload")
		if err := awsRestjson1_serializeDocumentCustomPayload(v.CustomPayload, ok); err != nil {
			return err
		}
	}

	if v.ImageResponseCard != nil {
		ok := object.Key("imageResponseCard")
		if err := awsRestjson1_serializeDocumentImageResponseCard(v.ImageResponseCard, ok); err != nil {
			return err
		}
	}

	if v.PlainTextMessage != nil {
		ok := object.Key("plainTextMessage")
		if err := awsRestjson1_serializeDocumentPlainTextMessage(v.PlainTextMessage, ok); err != nil {
			return err
		}
	}

	if v.SsmlMessage != nil {
		ok := object.Key("ssmlMessage")
		if err := awsRestjson1_serializeDocumentSSMLMessage(v.SsmlMessage, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentMessageGroup(v *types.MessageGroup, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Message != nil {
		ok := object.Key("message")
		if err := awsRestjson1_serializeDocumentMessage(v.Message, ok); err != nil {
			return err
		}
	}

	if v.Variations != nil {
		ok := object.Key("variations")
		if err := awsRestjson1_serializeDocumentMessageVariationsList(v.Variations, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentMessageGroupsList(v []types.MessageGroup, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentMessageGroup(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentMessageVariationsList(v []types.Message, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentMessage(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentMultipleValuesSetting(v *types.MultipleValuesSetting, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AllowMultipleValues {
		ok := object.Key("allowMultipleValues")
		ok.Boolean(v.AllowMultipleValues)
	}

	return nil
}

func awsRestjson1_serializeDocumentObfuscationSetting(v *types.ObfuscationSetting, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.ObfuscationSettingType) > 0 {
		ok := object.Key("obfuscationSettingType")
		ok.String(string(v.ObfuscationSettingType))
	}

	return nil
}

func awsRestjson1_serializeDocumentOperationList(v []string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		av.String(v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentOutputContext(v *types.OutputContext, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Name != nil {
		ok := object.Key("name")
		ok.String(*v.Name)
	}

	if v.TimeToLiveInSeconds != nil {
		ok := object.Key("timeToLiveInSeconds")
		ok.Integer(*v.TimeToLiveInSeconds)
	}

	if v.TurnsToLive != nil {
		ok := object.Key("turnsToLive")
		ok.Integer(*v.TurnsToLive)
	}

	return nil
}

func awsRestjson1_serializeDocumentOutputContextsList(v []types.OutputContext, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentOutputContext(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentPlainTextMessage(v *types.PlainTextMessage, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Value != nil {
		ok := object.Key("value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentPrincipal(v *types.Principal, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Arn != nil {
		ok := object.Key("arn")
		ok.String(*v.Arn)
	}

	if v.Service != nil {
		ok := object.Key("service")
		ok.String(*v.Service)
	}

	return nil
}

func awsRestjson1_serializeDocumentPrincipalList(v []types.Principal, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentPrincipal(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentPromptSpecification(v *types.PromptSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AllowInterrupt != nil {
		ok := object.Key("allowInterrupt")
		ok.Boolean(*v.AllowInterrupt)
	}

	if v.MaxRetries != nil {
		ok := object.Key("maxRetries")
		ok.Integer(*v.MaxRetries)
	}

	if v.MessageGroups != nil {
		ok := object.Key("messageGroups")
		if err := awsRestjson1_serializeDocumentMessageGroupsList(v.MessageGroups, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentResponseSpecification(v *types.ResponseSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AllowInterrupt != nil {
		ok := object.Key("allowInterrupt")
		ok.Boolean(*v.AllowInterrupt)
	}

	if v.MessageGroups != nil {
		ok := object.Key("messageGroups")
		if err := awsRestjson1_serializeDocumentMessageGroupsList(v.MessageGroups, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentS3BucketLogDestination(v *types.S3BucketLogDestination, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.KmsKeyArn != nil {
		ok := object.Key("kmsKeyArn")
		ok.String(*v.KmsKeyArn)
	}

	if v.LogPrefix != nil {
		ok := object.Key("logPrefix")
		ok.String(*v.LogPrefix)
	}

	if v.S3BucketArn != nil {
		ok := object.Key("s3BucketArn")
		ok.String(*v.S3BucketArn)
	}

	return nil
}

func awsRestjson1_serializeDocumentSampleUtterance(v *types.SampleUtterance, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Utterance != nil {
		ok := object.Key("utterance")
		ok.String(*v.Utterance)
	}

	return nil
}

func awsRestjson1_serializeDocumentSampleUtterancesList(v []types.SampleUtterance, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentSampleUtterance(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSampleValue(v *types.SampleValue, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Value != nil {
		ok := object.Key("value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentSentimentAnalysisSettings(v *types.SentimentAnalysisSettings, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	{
		ok := object.Key("detectSentiment")
		ok.Boolean(v.DetectSentiment)
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotDefaultValue(v *types.SlotDefaultValue, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DefaultValue != nil {
		ok := object.Key("defaultValue")
		ok.String(*v.DefaultValue)
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotDefaultValueList(v []types.SlotDefaultValue, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentSlotDefaultValue(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSlotDefaultValueSpecification(v *types.SlotDefaultValueSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DefaultValueList != nil {
		ok := object.Key("defaultValueList")
		if err := awsRestjson1_serializeDocumentSlotDefaultValueList(v.DefaultValueList, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotFilter(v *types.SlotFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Name) > 0 {
		ok := object.Key("name")
		ok.String(string(v.Name))
	}

	if len(v.Operator) > 0 {
		ok := object.Key("operator")
		ok.String(string(v.Operator))
	}

	if v.Values != nil {
		ok := object.Key("values")
		if err := awsRestjson1_serializeDocumentFilterValues(v.Values, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotFilters(v []types.SlotFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentSlotFilter(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSlotPrioritiesList(v []types.SlotPriority, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentSlotPriority(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSlotPriority(v *types.SlotPriority, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Priority != nil {
		ok := object.Key("priority")
		ok.Integer(*v.Priority)
	}

	if v.SlotId != nil {
		ok := object.Key("slotId")
		ok.String(*v.SlotId)
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotSortBy(v *types.SlotSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotTypeFilter(v *types.SlotTypeFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Name) > 0 {
		ok := object.Key("name")
		ok.String(string(v.Name))
	}

	if len(v.Operator) > 0 {
		ok := object.Key("operator")
		ok.String(string(v.Operator))
	}

	if v.Values != nil {
		ok := object.Key("values")
		if err := awsRestjson1_serializeDocumentFilterValues(v.Values, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotTypeFilters(v []types.SlotTypeFilter, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentSlotTypeFilter(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSlotTypeSortBy(v *types.SlotTypeSortBy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Attribute) > 0 {
		ok := object.Key("attribute")
		ok.String(string(v.Attribute))
	}

	if len(v.Order) > 0 {
		ok := object.Key("order")
		ok.String(string(v.Order))
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotTypeValue(v *types.SlotTypeValue, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.SampleValue != nil {
		ok := object.Key("sampleValue")
		if err := awsRestjson1_serializeDocumentSampleValue(v.SampleValue, ok); err != nil {
			return err
		}
	}

	if v.Synonyms != nil {
		ok := object.Key("synonyms")
		if err := awsRestjson1_serializeDocumentSynonymList(v.Synonyms, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotTypeValues(v []types.SlotTypeValue, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentSlotTypeValue(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentSlotValueElicitationSetting(v *types.SlotValueElicitationSetting, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DefaultValueSpecification != nil {
		ok := object.Key("defaultValueSpecification")
		if err := awsRestjson1_serializeDocumentSlotDefaultValueSpecification(v.DefaultValueSpecification, ok); err != nil {
			return err
		}
	}

	if v.PromptSpecification != nil {
		ok := object.Key("promptSpecification")
		if err := awsRestjson1_serializeDocumentPromptSpecification(v.PromptSpecification, ok); err != nil {
			return err
		}
	}

	if v.SampleUtterances != nil {
		ok := object.Key("sampleUtterances")
		if err := awsRestjson1_serializeDocumentSampleUtterancesList(v.SampleUtterances, ok); err != nil {
			return err
		}
	}

	if len(v.SlotConstraint) > 0 {
		ok := object.Key("slotConstraint")
		ok.String(string(v.SlotConstraint))
	}

	if v.WaitAndContinueSpecification != nil {
		ok := object.Key("waitAndContinueSpecification")
		if err := awsRestjson1_serializeDocumentWaitAndContinueSpecification(v.WaitAndContinueSpecification, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotValueRegexFilter(v *types.SlotValueRegexFilter, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Pattern != nil {
		ok := object.Key("pattern")
		ok.String(*v.Pattern)
	}

	return nil
}

func awsRestjson1_serializeDocumentSlotValueSelectionSetting(v *types.SlotValueSelectionSetting, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.RegexFilter != nil {
		ok := object.Key("regexFilter")
		if err := awsRestjson1_serializeDocumentSlotValueRegexFilter(v.RegexFilter, ok); err != nil {
			return err
		}
	}

	if len(v.ResolutionStrategy) > 0 {
		ok := object.Key("resolutionStrategy")
		ok.String(string(v.ResolutionStrategy))
	}

	return nil
}

func awsRestjson1_serializeDocumentSSMLMessage(v *types.SSMLMessage, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Value != nil {
		ok := object.Key("value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentStillWaitingResponseSpecification(v *types.StillWaitingResponseSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AllowInterrupt != nil {
		ok := object.Key("allowInterrupt")
		ok.Boolean(*v.AllowInterrupt)
	}

	if v.FrequencyInSeconds != nil {
		ok := object.Key("frequencyInSeconds")
		ok.Integer(*v.FrequencyInSeconds)
	}

	if v.MessageGroups != nil {
		ok := object.Key("messageGroups")
		if err := awsRestjson1_serializeDocumentMessageGroupsList(v.MessageGroups, ok); err != nil {
			return err
		}
	}

	if v.TimeoutInSeconds != nil {
		ok := object.Key("timeoutInSeconds")
		ok.Integer(*v.TimeoutInSeconds)
	}

	return nil
}

func awsRestjson1_serializeDocumentSynonymList(v []types.SampleValue, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentSampleValue(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentTagMap(v map[string]string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		om.String(v[key])
	}
	return nil
}

func awsRestjson1_serializeDocumentTextLogDestination(v *types.TextLogDestination, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.CloudWatch != nil {
		ok := object.Key("cloudWatch")
		if err := awsRestjson1_serializeDocumentCloudWatchLogGroupLogDestination(v.CloudWatch, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentTextLogSetting(v *types.TextLogSetting, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Destination != nil {
		ok := object.Key("destination")
		if err := awsRestjson1_serializeDocumentTextLogDestination(v.Destination, ok); err != nil {
			return err
		}
	}

	{
		ok := object.Key("enabled")
		ok.Boolean(v.Enabled)
	}

	return nil
}

func awsRestjson1_serializeDocumentTextLogSettingsList(v []types.TextLogSetting, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if err := awsRestjson1_serializeDocumentTextLogSetting(&v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentVoiceSettings(v *types.VoiceSettings, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.VoiceId != nil {
		ok := object.Key("voiceId")
		ok.String(*v.VoiceId)
	}

	return nil
}

func awsRestjson1_serializeDocumentWaitAndContinueSpecification(v *types.WaitAndContinueSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ContinueResponse != nil {
		ok := object.Key("continueResponse")
		if err := awsRestjson1_serializeDocumentResponseSpecification(v.ContinueResponse, ok); err != nil {
			return err
		}
	}

	if v.StillWaitingResponse != nil {
		ok := object.Key("stillWaitingResponse")
		if err := awsRestjson1_serializeDocumentStillWaitingResponseSpecification(v.StillWaitingResponse, ok); err != nil {
			return err
		}
	}

	if v.WaitingResponse != nil {
		ok := object.Key("waitingResponse")
		if err := awsRestjson1_serializeDocumentResponseSpecification(v.WaitingResponse, ok); err != nil {
			return err
		}
	}

	return nil
}
