// Code generated by smithy-go-codegen DO NOT EDIT.

package kinesis

import (
	"bytes"
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream"
	"github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream/eventstreamapi"
	"github.com/aws/aws-sdk-go-v2/service/kinesis/types"
	smithy "github.com/aws/smithy-go"
	smithycbor "github.com/aws/smithy-go/encoding/cbor"
	"github.com/aws/smithy-go/middleware"
	smithyhttp "github.com/aws/smithy-go/transport/http"
	"net/http"
	"time"
)

type smithyRpcv2cbor_serializeOpAddTagsToStream struct {
}

func (*smithyRpcv2cbor_serializeOpAddTagsToStream) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpAddTagsToStream) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*AddTagsToStreamInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/AddTagsToStream"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_AddTagsToStreamInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpCreateStream struct {
}

func (*smithyRpcv2cbor_serializeOpCreateStream) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpCreateStream) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*CreateStreamInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/CreateStream"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_CreateStreamInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDecreaseStreamRetentionPeriod struct {
}

func (*smithyRpcv2cbor_serializeOpDecreaseStreamRetentionPeriod) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDecreaseStreamRetentionPeriod) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DecreaseStreamRetentionPeriodInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DecreaseStreamRetentionPeriod"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DecreaseStreamRetentionPeriodInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDeleteResourcePolicy struct {
}

func (*smithyRpcv2cbor_serializeOpDeleteResourcePolicy) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDeleteResourcePolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DeleteResourcePolicyInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DeleteResourcePolicy"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DeleteResourcePolicyInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDeleteStream struct {
}

func (*smithyRpcv2cbor_serializeOpDeleteStream) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDeleteStream) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DeleteStreamInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DeleteStream"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DeleteStreamInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDeregisterStreamConsumer struct {
}

func (*smithyRpcv2cbor_serializeOpDeregisterStreamConsumer) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDeregisterStreamConsumer) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DeregisterStreamConsumerInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DeregisterStreamConsumer"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DeregisterStreamConsumerInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDescribeLimits struct {
}

func (*smithyRpcv2cbor_serializeOpDescribeLimits) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDescribeLimits) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DescribeLimitsInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DescribeLimits"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DescribeLimitsInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDescribeStream struct {
}

func (*smithyRpcv2cbor_serializeOpDescribeStream) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDescribeStream) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DescribeStreamInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DescribeStream"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DescribeStreamInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDescribeStreamConsumer struct {
}

func (*smithyRpcv2cbor_serializeOpDescribeStreamConsumer) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDescribeStreamConsumer) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DescribeStreamConsumerInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DescribeStreamConsumer"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DescribeStreamConsumerInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDescribeStreamSummary struct {
}

func (*smithyRpcv2cbor_serializeOpDescribeStreamSummary) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDescribeStreamSummary) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DescribeStreamSummaryInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DescribeStreamSummary"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DescribeStreamSummaryInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpDisableEnhancedMonitoring struct {
}

func (*smithyRpcv2cbor_serializeOpDisableEnhancedMonitoring) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpDisableEnhancedMonitoring) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*DisableEnhancedMonitoringInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/DisableEnhancedMonitoring"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_DisableEnhancedMonitoringInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpEnableEnhancedMonitoring struct {
}

func (*smithyRpcv2cbor_serializeOpEnableEnhancedMonitoring) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpEnableEnhancedMonitoring) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*EnableEnhancedMonitoringInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/EnableEnhancedMonitoring"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_EnableEnhancedMonitoringInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpGetRecords struct {
}

func (*smithyRpcv2cbor_serializeOpGetRecords) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpGetRecords) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*GetRecordsInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/GetRecords"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_GetRecordsInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpGetResourcePolicy struct {
}

func (*smithyRpcv2cbor_serializeOpGetResourcePolicy) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpGetResourcePolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*GetResourcePolicyInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/GetResourcePolicy"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_GetResourcePolicyInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpGetShardIterator struct {
}

func (*smithyRpcv2cbor_serializeOpGetShardIterator) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpGetShardIterator) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*GetShardIteratorInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/GetShardIterator"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_GetShardIteratorInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpIncreaseStreamRetentionPeriod struct {
}

func (*smithyRpcv2cbor_serializeOpIncreaseStreamRetentionPeriod) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpIncreaseStreamRetentionPeriod) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*IncreaseStreamRetentionPeriodInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/IncreaseStreamRetentionPeriod"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_IncreaseStreamRetentionPeriodInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpListShards struct {
}

func (*smithyRpcv2cbor_serializeOpListShards) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpListShards) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*ListShardsInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/ListShards"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_ListShardsInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpListStreamConsumers struct {
}

func (*smithyRpcv2cbor_serializeOpListStreamConsumers) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpListStreamConsumers) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*ListStreamConsumersInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/ListStreamConsumers"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_ListStreamConsumersInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpListStreams struct {
}

func (*smithyRpcv2cbor_serializeOpListStreams) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpListStreams) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*ListStreamsInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/ListStreams"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_ListStreamsInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpListTagsForStream struct {
}

func (*smithyRpcv2cbor_serializeOpListTagsForStream) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpListTagsForStream) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*ListTagsForStreamInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/ListTagsForStream"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_ListTagsForStreamInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpMergeShards struct {
}

func (*smithyRpcv2cbor_serializeOpMergeShards) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpMergeShards) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*MergeShardsInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/MergeShards"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_MergeShardsInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpPutRecord struct {
}

func (*smithyRpcv2cbor_serializeOpPutRecord) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpPutRecord) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*PutRecordInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/PutRecord"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_PutRecordInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpPutRecords struct {
}

func (*smithyRpcv2cbor_serializeOpPutRecords) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpPutRecords) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*PutRecordsInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/PutRecords"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_PutRecordsInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpPutResourcePolicy struct {
}

func (*smithyRpcv2cbor_serializeOpPutResourcePolicy) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpPutResourcePolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*PutResourcePolicyInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/PutResourcePolicy"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_PutResourcePolicyInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpRegisterStreamConsumer struct {
}

func (*smithyRpcv2cbor_serializeOpRegisterStreamConsumer) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpRegisterStreamConsumer) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*RegisterStreamConsumerInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/RegisterStreamConsumer"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_RegisterStreamConsumerInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpRemoveTagsFromStream struct {
}

func (*smithyRpcv2cbor_serializeOpRemoveTagsFromStream) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpRemoveTagsFromStream) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*RemoveTagsFromStreamInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/RemoveTagsFromStream"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_RemoveTagsFromStreamInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpSplitShard struct {
}

func (*smithyRpcv2cbor_serializeOpSplitShard) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpSplitShard) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*SplitShardInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/SplitShard"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_SplitShardInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpStartStreamEncryption struct {
}

func (*smithyRpcv2cbor_serializeOpStartStreamEncryption) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpStartStreamEncryption) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*StartStreamEncryptionInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/StartStreamEncryption"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_StartStreamEncryptionInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpStopStreamEncryption struct {
}

func (*smithyRpcv2cbor_serializeOpStopStreamEncryption) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpStopStreamEncryption) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*StopStreamEncryptionInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/StopStreamEncryption"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_StopStreamEncryptionInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpSubscribeToShard struct {
}

func (*smithyRpcv2cbor_serializeOpSubscribeToShard) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpSubscribeToShard) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*SubscribeToShardInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/SubscribeToShard"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/vnd.amazon.eventstream")
	req.Header.Set("Accept", "application/vnd.amazon.eventstream")

	cv, err := serializeCBOR_SubscribeToShardInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpUpdateShardCount struct {
}

func (*smithyRpcv2cbor_serializeOpUpdateShardCount) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpUpdateShardCount) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*UpdateShardCountInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/UpdateShardCount"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_UpdateShardCountInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}

type smithyRpcv2cbor_serializeOpUpdateStreamMode struct {
}

func (*smithyRpcv2cbor_serializeOpUpdateStreamMode) ID() string {
	return "OperationSerializer"
}

func (m *smithyRpcv2cbor_serializeOpUpdateStreamMode) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	input, ok := in.Parameters.(*UpdateStreamModeInput)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected input type %T", in.Parameters)
	}

	req, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, fmt.Errorf("unexpected transport type %T", in.Request)
	}

	req.Method = http.MethodPost
	req.URL.Path = "/service/Kinesis_20131202/operation/UpdateStreamMode"
	req.Header.Set("smithy-protocol", "rpc-v2-cbor")

	req.Header.Set("Content-Type", "application/cbor")
	req.Header.Set("Accept", "application/cbor")

	cv, err := serializeCBOR_UpdateStreamModeInput(input)
	if err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	payload := bytes.NewReader(smithycbor.Encode(cv))
	if req, err = req.SetStream(payload); err != nil {
		return out, metadata, &smithy.SerializationError{err}
	}

	in.Request = req

	return next.HandleSerialize(ctx, in)
}
func serializeCBOR_RegisterStreamConsumerInput(v *RegisterStreamConsumerInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	if v.ConsumerName != nil {
		ser, err := serializeCBOR_String(*v.ConsumerName)
		if err != nil {
			return nil, err
		}
		vm["ConsumerName"] = ser
	}
	return vm, nil
}

func serializeCBOR_StopStreamEncryptionInput(v *StopStreamEncryptionInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	serEncryptionType, err := serializeCBOR_EncryptionType(v.EncryptionType)
	if err != nil {
		return nil, err
	}
	vm["EncryptionType"] = serEncryptionType
	if v.KeyId != nil {
		ser, err := serializeCBOR_String(*v.KeyId)
		if err != nil {
			return nil, err
		}
		vm["KeyId"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_DescribeStreamInput(v *DescribeStreamInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.Limit != nil {
		ser, err := serializeCBOR_Int32(*v.Limit)
		if err != nil {
			return nil, err
		}
		vm["Limit"] = ser
	}
	if v.ExclusiveStartShardId != nil {
		ser, err := serializeCBOR_String(*v.ExclusiveStartShardId)
		if err != nil {
			return nil, err
		}
		vm["ExclusiveStartShardId"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_DescribeStreamConsumerInput(v *DescribeStreamConsumerInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	if v.ConsumerName != nil {
		ser, err := serializeCBOR_String(*v.ConsumerName)
		if err != nil {
			return nil, err
		}
		vm["ConsumerName"] = ser
	}
	if v.ConsumerARN != nil {
		ser, err := serializeCBOR_String(*v.ConsumerARN)
		if err != nil {
			return nil, err
		}
		vm["ConsumerARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_GetRecordsInput(v *GetRecordsInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.ShardIterator != nil {
		ser, err := serializeCBOR_String(*v.ShardIterator)
		if err != nil {
			return nil, err
		}
		vm["ShardIterator"] = ser
	}
	if v.Limit != nil {
		ser, err := serializeCBOR_Int32(*v.Limit)
		if err != nil {
			return nil, err
		}
		vm["Limit"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_DeleteStreamInput(v *DeleteStreamInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.EnforceConsumerDeletion != nil {
		ser, err := serializeCBOR_Bool(*v.EnforceConsumerDeletion)
		if err != nil {
			return nil, err
		}
		vm["EnforceConsumerDeletion"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_PutRecordsInput(v *PutRecordsInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.Records != nil {
		ser, err := serializeCBOR_PutRecordsRequestEntryList(v.Records)
		if err != nil {
			return nil, err
		}
		vm["Records"] = ser
	}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_ShardIteratorType(v types.ShardIteratorType) (smithycbor.Value, error) {
	return smithycbor.String(string(v)), nil
}

func serializeCBOR_ListStreamsInput(v *ListStreamsInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.Limit != nil {
		ser, err := serializeCBOR_Int32(*v.Limit)
		if err != nil {
			return nil, err
		}
		vm["Limit"] = ser
	}
	if v.ExclusiveStartStreamName != nil {
		ser, err := serializeCBOR_String(*v.ExclusiveStartStreamName)
		if err != nil {
			return nil, err
		}
		vm["ExclusiveStartStreamName"] = ser
	}
	if v.NextToken != nil {
		ser, err := serializeCBOR_String(*v.NextToken)
		if err != nil {
			return nil, err
		}
		vm["NextToken"] = ser
	}
	return vm, nil
}

func serializeCBOR_PutResourcePolicyInput(v *PutResourcePolicyInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.ResourceARN != nil {
		ser, err := serializeCBOR_String(*v.ResourceARN)
		if err != nil {
			return nil, err
		}
		vm["ResourceARN"] = ser
	}
	if v.Policy != nil {
		ser, err := serializeCBOR_String(*v.Policy)
		if err != nil {
			return nil, err
		}
		vm["Policy"] = ser
	}
	return vm, nil
}

func serializeCBOR_UpdateStreamModeInput(v *UpdateStreamModeInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	if v.StreamModeDetails != nil {
		ser, err := serializeCBOR_StreamModeDetails(v.StreamModeDetails)
		if err != nil {
			return nil, err
		}
		vm["StreamModeDetails"] = ser
	}
	return vm, nil
}

func serializeCBOR_StartingPosition(v *types.StartingPosition) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	serType, err := serializeCBOR_ShardIteratorType(v.Type)
	if err != nil {
		return nil, err
	}
	vm["Type"] = serType
	if v.SequenceNumber != nil {
		ser, err := serializeCBOR_String(*v.SequenceNumber)
		if err != nil {
			return nil, err
		}
		vm["SequenceNumber"] = ser
	}
	if v.Timestamp != nil {
		ser, err := serializeCBOR_Time(*v.Timestamp)
		if err != nil {
			return nil, err
		}
		vm["Timestamp"] = ser
	}
	return vm, nil
}

func serializeCBOR_SplitShardInput(v *SplitShardInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.ShardToSplit != nil {
		ser, err := serializeCBOR_String(*v.ShardToSplit)
		if err != nil {
			return nil, err
		}
		vm["ShardToSplit"] = ser
	}
	if v.NewStartingHashKey != nil {
		ser, err := serializeCBOR_String(*v.NewStartingHashKey)
		if err != nil {
			return nil, err
		}
		vm["NewStartingHashKey"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_StreamMode(v types.StreamMode) (smithycbor.Value, error) {
	return smithycbor.String(string(v)), nil
}

func serializeCBOR_Bool(v bool) (smithycbor.Value, error) {
	return smithycbor.Bool(v), nil
}

func serializeCBOR_ShardIdList(v []string) (smithycbor.Value, error) {
	vl := smithycbor.List{}
	for i := range v {

		ser, err := serializeCBOR_String(v[i])
		if err != nil {
			return nil, err
		}
		vl = append(vl, ser)
	}
	return vl, nil
}

func serializeCBOR_DeleteResourcePolicyInput(v *DeleteResourcePolicyInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.ResourceARN != nil {
		ser, err := serializeCBOR_String(*v.ResourceARN)
		if err != nil {
			return nil, err
		}
		vm["ResourceARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_TagKeyList(v []string) (smithycbor.Value, error) {
	vl := smithycbor.List{}
	for i := range v {

		ser, err := serializeCBOR_String(v[i])
		if err != nil {
			return nil, err
		}
		vl = append(vl, ser)
	}
	return vl, nil
}

func serializeCBOR_ChildShard(v *types.ChildShard) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.ShardId != nil {
		ser, err := serializeCBOR_String(*v.ShardId)
		if err != nil {
			return nil, err
		}
		vm["ShardId"] = ser
	}
	if v.ParentShards != nil {
		ser, err := serializeCBOR_ShardIdList(v.ParentShards)
		if err != nil {
			return nil, err
		}
		vm["ParentShards"] = ser
	}
	if v.HashKeyRange != nil {
		ser, err := serializeCBOR_HashKeyRange(v.HashKeyRange)
		if err != nil {
			return nil, err
		}
		vm["HashKeyRange"] = ser
	}
	return vm, nil
}

func serializeCBOR_RemoveTagsFromStreamInput(v *RemoveTagsFromStreamInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.TagKeys != nil {
		ser, err := serializeCBOR_TagKeyList(v.TagKeys)
		if err != nil {
			return nil, err
		}
		vm["TagKeys"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_DescribeLimitsInput(v *DescribeLimitsInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}

	return vm, nil
}

func serializeCBOR_SubscribeToShardInput(v *SubscribeToShardInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.ConsumerARN != nil {
		ser, err := serializeCBOR_String(*v.ConsumerARN)
		if err != nil {
			return nil, err
		}
		vm["ConsumerARN"] = ser
	}
	if v.ShardId != nil {
		ser, err := serializeCBOR_String(*v.ShardId)
		if err != nil {
			return nil, err
		}
		vm["ShardId"] = ser
	}
	if v.StartingPosition != nil {
		ser, err := serializeCBOR_StartingPosition(v.StartingPosition)
		if err != nil {
			return nil, err
		}
		vm["StartingPosition"] = ser
	}
	return vm, nil
}

func serializeCBOR_MetricsName(v types.MetricsName) (smithycbor.Value, error) {
	return smithycbor.String(string(v)), nil
}

func serializeCBOR_Record(v *types.Record) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.SequenceNumber != nil {
		ser, err := serializeCBOR_String(*v.SequenceNumber)
		if err != nil {
			return nil, err
		}
		vm["SequenceNumber"] = ser
	}
	if v.ApproximateArrivalTimestamp != nil {
		ser, err := serializeCBOR_Time(*v.ApproximateArrivalTimestamp)
		if err != nil {
			return nil, err
		}
		vm["ApproximateArrivalTimestamp"] = ser
	}
	if v.Data != nil {
		ser, err := serializeCBOR_Blob(v.Data)
		if err != nil {
			return nil, err
		}
		vm["Data"] = ser
	}
	if v.PartitionKey != nil {
		ser, err := serializeCBOR_String(*v.PartitionKey)
		if err != nil {
			return nil, err
		}
		vm["PartitionKey"] = ser
	}
	serEncryptionType, err := serializeCBOR_EncryptionType(v.EncryptionType)
	if err != nil {
		return nil, err
	}
	vm["EncryptionType"] = serEncryptionType
	return vm, nil
}

func serializeCBOR_Int32(v int32) (smithycbor.Value, error) {
	if v < 0 {
		return smithycbor.NegInt(uint64(-v)), nil
	}
	return smithycbor.Uint(uint64(v)), nil
}

func serializeCBOR_StartStreamEncryptionInput(v *StartStreamEncryptionInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	serEncryptionType, err := serializeCBOR_EncryptionType(v.EncryptionType)
	if err != nil {
		return nil, err
	}
	vm["EncryptionType"] = serEncryptionType
	if v.KeyId != nil {
		ser, err := serializeCBOR_String(*v.KeyId)
		if err != nil {
			return nil, err
		}
		vm["KeyId"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_Int64(v int64) (smithycbor.Value, error) {
	if v < 0 {
		return smithycbor.NegInt(uint64(-v)), nil
	}
	return smithycbor.Uint(uint64(v)), nil
}

func serializeCBOR_String(v string) (smithycbor.Value, error) {
	return smithycbor.String(v), nil
}

func serializeCBOR_UpdateShardCountInput(v *UpdateShardCountInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.TargetShardCount != nil {
		ser, err := serializeCBOR_Int32(*v.TargetShardCount)
		if err != nil {
			return nil, err
		}
		vm["TargetShardCount"] = ser
	}
	serScalingType, err := serializeCBOR_ScalingType(v.ScalingType)
	if err != nil {
		return nil, err
	}
	vm["ScalingType"] = serScalingType
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_ShardFilterType(v types.ShardFilterType) (smithycbor.Value, error) {
	return smithycbor.String(string(v)), nil
}

func serializeCBOR_ScalingType(v types.ScalingType) (smithycbor.Value, error) {
	return smithycbor.String(string(v)), nil
}

func serializeCBOR_EnableEnhancedMonitoringInput(v *EnableEnhancedMonitoringInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.ShardLevelMetrics != nil {
		ser, err := serializeCBOR_MetricsNameList(v.ShardLevelMetrics)
		if err != nil {
			return nil, err
		}
		vm["ShardLevelMetrics"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_GetShardIteratorInput(v *GetShardIteratorInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.ShardId != nil {
		ser, err := serializeCBOR_String(*v.ShardId)
		if err != nil {
			return nil, err
		}
		vm["ShardId"] = ser
	}
	serShardIteratorType, err := serializeCBOR_ShardIteratorType(v.ShardIteratorType)
	if err != nil {
		return nil, err
	}
	vm["ShardIteratorType"] = serShardIteratorType
	if v.StartingSequenceNumber != nil {
		ser, err := serializeCBOR_String(*v.StartingSequenceNumber)
		if err != nil {
			return nil, err
		}
		vm["StartingSequenceNumber"] = ser
	}
	if v.Timestamp != nil {
		ser, err := serializeCBOR_Time(*v.Timestamp)
		if err != nil {
			return nil, err
		}
		vm["Timestamp"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_IncreaseStreamRetentionPeriodInput(v *IncreaseStreamRetentionPeriodInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.RetentionPeriodHours != nil {
		ser, err := serializeCBOR_Int32(*v.RetentionPeriodHours)
		if err != nil {
			return nil, err
		}
		vm["RetentionPeriodHours"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_ListTagsForStreamInput(v *ListTagsForStreamInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.ExclusiveStartTagKey != nil {
		ser, err := serializeCBOR_String(*v.ExclusiveStartTagKey)
		if err != nil {
			return nil, err
		}
		vm["ExclusiveStartTagKey"] = ser
	}
	if v.Limit != nil {
		ser, err := serializeCBOR_Int32(*v.Limit)
		if err != nil {
			return nil, err
		}
		vm["Limit"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_DeregisterStreamConsumerInput(v *DeregisterStreamConsumerInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	if v.ConsumerName != nil {
		ser, err := serializeCBOR_String(*v.ConsumerName)
		if err != nil {
			return nil, err
		}
		vm["ConsumerName"] = ser
	}
	if v.ConsumerARN != nil {
		ser, err := serializeCBOR_String(*v.ConsumerARN)
		if err != nil {
			return nil, err
		}
		vm["ConsumerARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_TagMap(v map[string]string) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	for k, vv := range v {

		ser, err := serializeCBOR_String(vv)
		if err != nil {
			return nil, err
		}
		vm[k] = ser
	}
	return vm, nil
}

func serializeCBOR_CreateStreamInput(v *CreateStreamInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.ShardCount != nil {
		ser, err := serializeCBOR_Int32(*v.ShardCount)
		if err != nil {
			return nil, err
		}
		vm["ShardCount"] = ser
	}
	if v.StreamModeDetails != nil {
		ser, err := serializeCBOR_StreamModeDetails(v.StreamModeDetails)
		if err != nil {
			return nil, err
		}
		vm["StreamModeDetails"] = ser
	}
	return vm, nil
}

func serializeCBOR_Blob(v []byte) (smithycbor.Value, error) {
	return smithycbor.Slice(v), nil
}

func serializeCBOR_MetricsNameList(v []types.MetricsName) (smithycbor.Value, error) {
	vl := smithycbor.List{}
	for i := range v {

		ser, err := serializeCBOR_MetricsName(v[i])
		if err != nil {
			return nil, err
		}
		vl = append(vl, ser)
	}
	return vl, nil
}

func serializeCBOR_RecordList(v []types.Record) (smithycbor.Value, error) {
	vl := smithycbor.List{}
	for i := range v {

		ser, err := serializeCBOR_Record(&v[i])
		if err != nil {
			return nil, err
		}
		vl = append(vl, ser)
	}
	return vl, nil
}

func serializeCBOR_GetResourcePolicyInput(v *GetResourcePolicyInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.ResourceARN != nil {
		ser, err := serializeCBOR_String(*v.ResourceARN)
		if err != nil {
			return nil, err
		}
		vm["ResourceARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_AddTagsToStreamInput(v *AddTagsToStreamInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.Tags != nil {
		ser, err := serializeCBOR_TagMap(v.Tags)
		if err != nil {
			return nil, err
		}
		vm["Tags"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_PutRecordsRequestEntryList(v []types.PutRecordsRequestEntry) (smithycbor.Value, error) {
	vl := smithycbor.List{}
	for i := range v {

		ser, err := serializeCBOR_PutRecordsRequestEntry(&v[i])
		if err != nil {
			return nil, err
		}
		vl = append(vl, ser)
	}
	return vl, nil
}

func serializeCBOR_DescribeStreamSummaryInput(v *DescribeStreamSummaryInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_ListShardsInput(v *ListShardsInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.NextToken != nil {
		ser, err := serializeCBOR_String(*v.NextToken)
		if err != nil {
			return nil, err
		}
		vm["NextToken"] = ser
	}
	if v.ExclusiveStartShardId != nil {
		ser, err := serializeCBOR_String(*v.ExclusiveStartShardId)
		if err != nil {
			return nil, err
		}
		vm["ExclusiveStartShardId"] = ser
	}
	if v.MaxResults != nil {
		ser, err := serializeCBOR_Int32(*v.MaxResults)
		if err != nil {
			return nil, err
		}
		vm["MaxResults"] = ser
	}
	if v.StreamCreationTimestamp != nil {
		ser, err := serializeCBOR_Time(*v.StreamCreationTimestamp)
		if err != nil {
			return nil, err
		}
		vm["StreamCreationTimestamp"] = ser
	}
	if v.ShardFilter != nil {
		ser, err := serializeCBOR_ShardFilter(v.ShardFilter)
		if err != nil {
			return nil, err
		}
		vm["ShardFilter"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_ShardFilter(v *types.ShardFilter) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	serType, err := serializeCBOR_ShardFilterType(v.Type)
	if err != nil {
		return nil, err
	}
	vm["Type"] = serType
	if v.ShardId != nil {
		ser, err := serializeCBOR_String(*v.ShardId)
		if err != nil {
			return nil, err
		}
		vm["ShardId"] = ser
	}
	if v.Timestamp != nil {
		ser, err := serializeCBOR_Time(*v.Timestamp)
		if err != nil {
			return nil, err
		}
		vm["Timestamp"] = ser
	}
	return vm, nil
}

func serializeCBOR_StreamModeDetails(v *types.StreamModeDetails) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	serStreamMode, err := serializeCBOR_StreamMode(v.StreamMode)
	if err != nil {
		return nil, err
	}
	vm["StreamMode"] = serStreamMode
	return vm, nil
}

func serializeCBOR_DisableEnhancedMonitoringInput(v *DisableEnhancedMonitoringInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.ShardLevelMetrics != nil {
		ser, err := serializeCBOR_MetricsNameList(v.ShardLevelMetrics)
		if err != nil {
			return nil, err
		}
		vm["ShardLevelMetrics"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_EncryptionType(v types.EncryptionType) (smithycbor.Value, error) {
	return smithycbor.String(string(v)), nil
}

func serializeCBOR_DecreaseStreamRetentionPeriodInput(v *DecreaseStreamRetentionPeriodInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.RetentionPeriodHours != nil {
		ser, err := serializeCBOR_Int32(*v.RetentionPeriodHours)
		if err != nil {
			return nil, err
		}
		vm["RetentionPeriodHours"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_HashKeyRange(v *types.HashKeyRange) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StartingHashKey != nil {
		ser, err := serializeCBOR_String(*v.StartingHashKey)
		if err != nil {
			return nil, err
		}
		vm["StartingHashKey"] = ser
	}
	if v.EndingHashKey != nil {
		ser, err := serializeCBOR_String(*v.EndingHashKey)
		if err != nil {
			return nil, err
		}
		vm["EndingHashKey"] = ser
	}
	return vm, nil
}

func serializeCBOR_SubscribeToShardEvent(v *types.SubscribeToShardEvent) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.Records != nil {
		ser, err := serializeCBOR_RecordList(v.Records)
		if err != nil {
			return nil, err
		}
		vm["Records"] = ser
	}
	if v.ContinuationSequenceNumber != nil {
		ser, err := serializeCBOR_String(*v.ContinuationSequenceNumber)
		if err != nil {
			return nil, err
		}
		vm["ContinuationSequenceNumber"] = ser
	}
	if v.MillisBehindLatest != nil {
		ser, err := serializeCBOR_Int64(*v.MillisBehindLatest)
		if err != nil {
			return nil, err
		}
		vm["MillisBehindLatest"] = ser
	}
	if v.ChildShards != nil {
		ser, err := serializeCBOR_ChildShardList(v.ChildShards)
		if err != nil {
			return nil, err
		}
		vm["ChildShards"] = ser
	}
	return vm, nil
}

func serializeCBOR_Time(v time.Time) (smithycbor.Value, error) {
	return &smithycbor.Tag{
		ID:    1,
		Value: smithycbor.Float64(float64(v.UnixMilli()) / 1000),
	}, nil
}

func serializeCBOR_MergeShardsInput(v *MergeShardsInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.ShardToMerge != nil {
		ser, err := serializeCBOR_String(*v.ShardToMerge)
		if err != nil {
			return nil, err
		}
		vm["ShardToMerge"] = ser
	}
	if v.AdjacentShardToMerge != nil {
		ser, err := serializeCBOR_String(*v.AdjacentShardToMerge)
		if err != nil {
			return nil, err
		}
		vm["AdjacentShardToMerge"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}

func serializeCBOR_ListStreamConsumersInput(v *ListStreamConsumersInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	if v.NextToken != nil {
		ser, err := serializeCBOR_String(*v.NextToken)
		if err != nil {
			return nil, err
		}
		vm["NextToken"] = ser
	}
	if v.MaxResults != nil {
		ser, err := serializeCBOR_Int32(*v.MaxResults)
		if err != nil {
			return nil, err
		}
		vm["MaxResults"] = ser
	}
	if v.StreamCreationTimestamp != nil {
		ser, err := serializeCBOR_Time(*v.StreamCreationTimestamp)
		if err != nil {
			return nil, err
		}
		vm["StreamCreationTimestamp"] = ser
	}
	return vm, nil
}

func serializeCBOR_PutRecordsRequestEntry(v *types.PutRecordsRequestEntry) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.Data != nil {
		ser, err := serializeCBOR_Blob(v.Data)
		if err != nil {
			return nil, err
		}
		vm["Data"] = ser
	}
	if v.ExplicitHashKey != nil {
		ser, err := serializeCBOR_String(*v.ExplicitHashKey)
		if err != nil {
			return nil, err
		}
		vm["ExplicitHashKey"] = ser
	}
	if v.PartitionKey != nil {
		ser, err := serializeCBOR_String(*v.PartitionKey)
		if err != nil {
			return nil, err
		}
		vm["PartitionKey"] = ser
	}
	return vm, nil
}

func serializeCBOR_ChildShardList(v []types.ChildShard) (smithycbor.Value, error) {
	vl := smithycbor.List{}
	for i := range v {

		ser, err := serializeCBOR_ChildShard(&v[i])
		if err != nil {
			return nil, err
		}
		vl = append(vl, ser)
	}
	return vl, nil
}

func serializeCBOR_PutRecordInput(v *PutRecordInput) (smithycbor.Value, error) {
	vm := smithycbor.Map{}
	if v.StreamName != nil {
		ser, err := serializeCBOR_String(*v.StreamName)
		if err != nil {
			return nil, err
		}
		vm["StreamName"] = ser
	}
	if v.Data != nil {
		ser, err := serializeCBOR_Blob(v.Data)
		if err != nil {
			return nil, err
		}
		vm["Data"] = ser
	}
	if v.PartitionKey != nil {
		ser, err := serializeCBOR_String(*v.PartitionKey)
		if err != nil {
			return nil, err
		}
		vm["PartitionKey"] = ser
	}
	if v.ExplicitHashKey != nil {
		ser, err := serializeCBOR_String(*v.ExplicitHashKey)
		if err != nil {
			return nil, err
		}
		vm["ExplicitHashKey"] = ser
	}
	if v.SequenceNumberForOrdering != nil {
		ser, err := serializeCBOR_String(*v.SequenceNumberForOrdering)
		if err != nil {
			return nil, err
		}
		vm["SequenceNumberForOrdering"] = ser
	}
	if v.StreamARN != nil {
		ser, err := serializeCBOR_String(*v.StreamARN)
		if err != nil {
			return nil, err
		}
		vm["StreamARN"] = ser
	}
	return vm, nil
}
func smithyRpcv2cbor_serializeEventMessageRequestSubscribeToShardInput(input interface{}, msg *eventstream.Message) error {
	in, ok := input.(*SubscribeToShardInput)
	if !ok {
		return fmt.Errorf("unexpected input type %T", input)
	}
	cv, err := serializeCBOR_SubscribeToShardInput(in)
	if err != nil {
		return err
	}
	msg.Payload = smithycbor.Encode(cv)
	return nil
}
func smithyRpcv2cbor_serializeEventStreamSubscribeToShardInputEventStream(v types.SubscribeToShardInputEventStream, msg *eventstream.Message) error {
	switch vv := v.(type) {
	case *types.SubscribeToShardInputEventStreamMemberSubscribeToShardEvent:
		msg.Headers.Set(eventstreamapi.EventTypeHeader, eventstream.StringValue("SubscribeToShardEvent"))
		cv, err := serializeCBOR_SubscribeToShardEvent(&vv.Value)
		if err != nil {
			return err
		}
		msg.Payload = smithycbor.Encode(cv)
		return nil
	default:
		return fmt.Errorf("unexpected event message type: %T", v)
	}
}
