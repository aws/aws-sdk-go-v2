// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package appsync

import (
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

const opCreateApiKey = "CreateApiKey"

// CreateApiKeyRequest is a API request type for the CreateApiKey API operation.
type CreateApiKeyRequest struct {
	*aws.Request
	Input *CreateApiKeyInput
	Copy  func(*CreateApiKeyInput) CreateApiKeyRequest
}

// Send marshals and sends the CreateApiKey API request.
func (r CreateApiKeyRequest) Send() (*CreateApiKeyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateApiKeyOutput), nil
}

// CreateApiKeyRequest returns a request value for making API operation for
// AWS AppSync.
//
// Creates a unique key that you can distribute to clients who are executing
// your API.
//
//    // Example sending a request using the CreateApiKeyRequest method.
//    req := client.CreateApiKeyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateApiKey
func (c *AppSync) CreateApiKeyRequest(input *CreateApiKeyInput) CreateApiKeyRequest {
	op := &aws.Operation{
		Name:       opCreateApiKey,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/apikeys",
	}

	if input == nil {
		input = &CreateApiKeyInput{}
	}

	output := &CreateApiKeyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateApiKeyRequest{Request: req, Input: input, Copy: c.CreateApiKeyRequest}
}

const opCreateDataSource = "CreateDataSource"

// CreateDataSourceRequest is a API request type for the CreateDataSource API operation.
type CreateDataSourceRequest struct {
	*aws.Request
	Input *CreateDataSourceInput
	Copy  func(*CreateDataSourceInput) CreateDataSourceRequest
}

// Send marshals and sends the CreateDataSource API request.
func (r CreateDataSourceRequest) Send() (*CreateDataSourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateDataSourceOutput), nil
}

// CreateDataSourceRequest returns a request value for making API operation for
// AWS AppSync.
//
// Creates a DataSource object.
//
//    // Example sending a request using the CreateDataSourceRequest method.
//    req := client.CreateDataSourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateDataSource
func (c *AppSync) CreateDataSourceRequest(input *CreateDataSourceInput) CreateDataSourceRequest {
	op := &aws.Operation{
		Name:       opCreateDataSource,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/datasources",
	}

	if input == nil {
		input = &CreateDataSourceInput{}
	}

	output := &CreateDataSourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDataSourceRequest{Request: req, Input: input, Copy: c.CreateDataSourceRequest}
}

const opCreateGraphqlApi = "CreateGraphqlApi"

// CreateGraphqlApiRequest is a API request type for the CreateGraphqlApi API operation.
type CreateGraphqlApiRequest struct {
	*aws.Request
	Input *CreateGraphqlApiInput
	Copy  func(*CreateGraphqlApiInput) CreateGraphqlApiRequest
}

// Send marshals and sends the CreateGraphqlApi API request.
func (r CreateGraphqlApiRequest) Send() (*CreateGraphqlApiOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateGraphqlApiOutput), nil
}

// CreateGraphqlApiRequest returns a request value for making API operation for
// AWS AppSync.
//
// Creates a GraphqlApi object.
//
//    // Example sending a request using the CreateGraphqlApiRequest method.
//    req := client.CreateGraphqlApiRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateGraphqlApi
func (c *AppSync) CreateGraphqlApiRequest(input *CreateGraphqlApiInput) CreateGraphqlApiRequest {
	op := &aws.Operation{
		Name:       opCreateGraphqlApi,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis",
	}

	if input == nil {
		input = &CreateGraphqlApiInput{}
	}

	output := &CreateGraphqlApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateGraphqlApiRequest{Request: req, Input: input, Copy: c.CreateGraphqlApiRequest}
}

const opCreateResolver = "CreateResolver"

// CreateResolverRequest is a API request type for the CreateResolver API operation.
type CreateResolverRequest struct {
	*aws.Request
	Input *CreateResolverInput
	Copy  func(*CreateResolverInput) CreateResolverRequest
}

// Send marshals and sends the CreateResolver API request.
func (r CreateResolverRequest) Send() (*CreateResolverOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateResolverOutput), nil
}

// CreateResolverRequest returns a request value for making API operation for
// AWS AppSync.
//
// Creates a Resolver object.
//
// A resolver converts incoming requests into a format that a data source can
// understand and converts the data source's responses into GraphQL.
//
//    // Example sending a request using the CreateResolverRequest method.
//    req := client.CreateResolverRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateResolver
func (c *AppSync) CreateResolverRequest(input *CreateResolverInput) CreateResolverRequest {
	op := &aws.Operation{
		Name:       opCreateResolver,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/types/{typeName}/resolvers",
	}

	if input == nil {
		input = &CreateResolverInput{}
	}

	output := &CreateResolverOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateResolverRequest{Request: req, Input: input, Copy: c.CreateResolverRequest}
}

const opCreateType = "CreateType"

// CreateTypeRequest is a API request type for the CreateType API operation.
type CreateTypeRequest struct {
	*aws.Request
	Input *CreateTypeInput
	Copy  func(*CreateTypeInput) CreateTypeRequest
}

// Send marshals and sends the CreateType API request.
func (r CreateTypeRequest) Send() (*CreateTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTypeOutput), nil
}

// CreateTypeRequest returns a request value for making API operation for
// AWS AppSync.
//
// Creates a Type object.
//
//    // Example sending a request using the CreateTypeRequest method.
//    req := client.CreateTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateType
func (c *AppSync) CreateTypeRequest(input *CreateTypeInput) CreateTypeRequest {
	op := &aws.Operation{
		Name:       opCreateType,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/types",
	}

	if input == nil {
		input = &CreateTypeInput{}
	}

	output := &CreateTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTypeRequest{Request: req, Input: input, Copy: c.CreateTypeRequest}
}

const opDeleteApiKey = "DeleteApiKey"

// DeleteApiKeyRequest is a API request type for the DeleteApiKey API operation.
type DeleteApiKeyRequest struct {
	*aws.Request
	Input *DeleteApiKeyInput
	Copy  func(*DeleteApiKeyInput) DeleteApiKeyRequest
}

// Send marshals and sends the DeleteApiKey API request.
func (r DeleteApiKeyRequest) Send() (*DeleteApiKeyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteApiKeyOutput), nil
}

// DeleteApiKeyRequest returns a request value for making API operation for
// AWS AppSync.
//
// Deletes an API key.
//
//    // Example sending a request using the DeleteApiKeyRequest method.
//    req := client.DeleteApiKeyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteApiKey
func (c *AppSync) DeleteApiKeyRequest(input *DeleteApiKeyInput) DeleteApiKeyRequest {
	op := &aws.Operation{
		Name:       opDeleteApiKey,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/apis/{apiId}/apikeys/{id}",
	}

	if input == nil {
		input = &DeleteApiKeyInput{}
	}

	output := &DeleteApiKeyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteApiKeyRequest{Request: req, Input: input, Copy: c.DeleteApiKeyRequest}
}

const opDeleteDataSource = "DeleteDataSource"

// DeleteDataSourceRequest is a API request type for the DeleteDataSource API operation.
type DeleteDataSourceRequest struct {
	*aws.Request
	Input *DeleteDataSourceInput
	Copy  func(*DeleteDataSourceInput) DeleteDataSourceRequest
}

// Send marshals and sends the DeleteDataSource API request.
func (r DeleteDataSourceRequest) Send() (*DeleteDataSourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteDataSourceOutput), nil
}

// DeleteDataSourceRequest returns a request value for making API operation for
// AWS AppSync.
//
// Deletes a DataSource object.
//
//    // Example sending a request using the DeleteDataSourceRequest method.
//    req := client.DeleteDataSourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteDataSource
func (c *AppSync) DeleteDataSourceRequest(input *DeleteDataSourceInput) DeleteDataSourceRequest {
	op := &aws.Operation{
		Name:       opDeleteDataSource,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/apis/{apiId}/datasources/{name}",
	}

	if input == nil {
		input = &DeleteDataSourceInput{}
	}

	output := &DeleteDataSourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteDataSourceRequest{Request: req, Input: input, Copy: c.DeleteDataSourceRequest}
}

const opDeleteGraphqlApi = "DeleteGraphqlApi"

// DeleteGraphqlApiRequest is a API request type for the DeleteGraphqlApi API operation.
type DeleteGraphqlApiRequest struct {
	*aws.Request
	Input *DeleteGraphqlApiInput
	Copy  func(*DeleteGraphqlApiInput) DeleteGraphqlApiRequest
}

// Send marshals and sends the DeleteGraphqlApi API request.
func (r DeleteGraphqlApiRequest) Send() (*DeleteGraphqlApiOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteGraphqlApiOutput), nil
}

// DeleteGraphqlApiRequest returns a request value for making API operation for
// AWS AppSync.
//
// Deletes a GraphqlApi object.
//
//    // Example sending a request using the DeleteGraphqlApiRequest method.
//    req := client.DeleteGraphqlApiRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteGraphqlApi
func (c *AppSync) DeleteGraphqlApiRequest(input *DeleteGraphqlApiInput) DeleteGraphqlApiRequest {
	op := &aws.Operation{
		Name:       opDeleteGraphqlApi,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/apis/{apiId}",
	}

	if input == nil {
		input = &DeleteGraphqlApiInput{}
	}

	output := &DeleteGraphqlApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteGraphqlApiRequest{Request: req, Input: input, Copy: c.DeleteGraphqlApiRequest}
}

const opDeleteResolver = "DeleteResolver"

// DeleteResolverRequest is a API request type for the DeleteResolver API operation.
type DeleteResolverRequest struct {
	*aws.Request
	Input *DeleteResolverInput
	Copy  func(*DeleteResolverInput) DeleteResolverRequest
}

// Send marshals and sends the DeleteResolver API request.
func (r DeleteResolverRequest) Send() (*DeleteResolverOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteResolverOutput), nil
}

// DeleteResolverRequest returns a request value for making API operation for
// AWS AppSync.
//
// Deletes a Resolver object.
//
//    // Example sending a request using the DeleteResolverRequest method.
//    req := client.DeleteResolverRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteResolver
func (c *AppSync) DeleteResolverRequest(input *DeleteResolverInput) DeleteResolverRequest {
	op := &aws.Operation{
		Name:       opDeleteResolver,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}",
	}

	if input == nil {
		input = &DeleteResolverInput{}
	}

	output := &DeleteResolverOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteResolverRequest{Request: req, Input: input, Copy: c.DeleteResolverRequest}
}

const opDeleteType = "DeleteType"

// DeleteTypeRequest is a API request type for the DeleteType API operation.
type DeleteTypeRequest struct {
	*aws.Request
	Input *DeleteTypeInput
	Copy  func(*DeleteTypeInput) DeleteTypeRequest
}

// Send marshals and sends the DeleteType API request.
func (r DeleteTypeRequest) Send() (*DeleteTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTypeOutput), nil
}

// DeleteTypeRequest returns a request value for making API operation for
// AWS AppSync.
//
// Deletes a Type object.
//
//    // Example sending a request using the DeleteTypeRequest method.
//    req := client.DeleteTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteType
func (c *AppSync) DeleteTypeRequest(input *DeleteTypeInput) DeleteTypeRequest {
	op := &aws.Operation{
		Name:       opDeleteType,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/apis/{apiId}/types/{typeName}",
	}

	if input == nil {
		input = &DeleteTypeInput{}
	}

	output := &DeleteTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTypeRequest{Request: req, Input: input, Copy: c.DeleteTypeRequest}
}

const opGetDataSource = "GetDataSource"

// GetDataSourceRequest is a API request type for the GetDataSource API operation.
type GetDataSourceRequest struct {
	*aws.Request
	Input *GetDataSourceInput
	Copy  func(*GetDataSourceInput) GetDataSourceRequest
}

// Send marshals and sends the GetDataSource API request.
func (r GetDataSourceRequest) Send() (*GetDataSourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDataSourceOutput), nil
}

// GetDataSourceRequest returns a request value for making API operation for
// AWS AppSync.
//
// Retrieves a DataSource object.
//
//    // Example sending a request using the GetDataSourceRequest method.
//    req := client.GetDataSourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetDataSource
func (c *AppSync) GetDataSourceRequest(input *GetDataSourceInput) GetDataSourceRequest {
	op := &aws.Operation{
		Name:       opGetDataSource,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/datasources/{name}",
	}

	if input == nil {
		input = &GetDataSourceInput{}
	}

	output := &GetDataSourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDataSourceRequest{Request: req, Input: input, Copy: c.GetDataSourceRequest}
}

const opGetGraphqlApi = "GetGraphqlApi"

// GetGraphqlApiRequest is a API request type for the GetGraphqlApi API operation.
type GetGraphqlApiRequest struct {
	*aws.Request
	Input *GetGraphqlApiInput
	Copy  func(*GetGraphqlApiInput) GetGraphqlApiRequest
}

// Send marshals and sends the GetGraphqlApi API request.
func (r GetGraphqlApiRequest) Send() (*GetGraphqlApiOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetGraphqlApiOutput), nil
}

// GetGraphqlApiRequest returns a request value for making API operation for
// AWS AppSync.
//
// Retrieves a GraphqlApi object.
//
//    // Example sending a request using the GetGraphqlApiRequest method.
//    req := client.GetGraphqlApiRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetGraphqlApi
func (c *AppSync) GetGraphqlApiRequest(input *GetGraphqlApiInput) GetGraphqlApiRequest {
	op := &aws.Operation{
		Name:       opGetGraphqlApi,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}",
	}

	if input == nil {
		input = &GetGraphqlApiInput{}
	}

	output := &GetGraphqlApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetGraphqlApiRequest{Request: req, Input: input, Copy: c.GetGraphqlApiRequest}
}

const opGetIntrospectionSchema = "GetIntrospectionSchema"

// GetIntrospectionSchemaRequest is a API request type for the GetIntrospectionSchema API operation.
type GetIntrospectionSchemaRequest struct {
	*aws.Request
	Input *GetIntrospectionSchemaInput
	Copy  func(*GetIntrospectionSchemaInput) GetIntrospectionSchemaRequest
}

// Send marshals and sends the GetIntrospectionSchema API request.
func (r GetIntrospectionSchemaRequest) Send() (*GetIntrospectionSchemaOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetIntrospectionSchemaOutput), nil
}

// GetIntrospectionSchemaRequest returns a request value for making API operation for
// AWS AppSync.
//
// Retrieves the introspection schema for a GraphQL API.
//
//    // Example sending a request using the GetIntrospectionSchemaRequest method.
//    req := client.GetIntrospectionSchemaRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetIntrospectionSchema
func (c *AppSync) GetIntrospectionSchemaRequest(input *GetIntrospectionSchemaInput) GetIntrospectionSchemaRequest {
	op := &aws.Operation{
		Name:       opGetIntrospectionSchema,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/schema",
	}

	if input == nil {
		input = &GetIntrospectionSchemaInput{}
	}

	output := &GetIntrospectionSchemaOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetIntrospectionSchemaRequest{Request: req, Input: input, Copy: c.GetIntrospectionSchemaRequest}
}

const opGetResolver = "GetResolver"

// GetResolverRequest is a API request type for the GetResolver API operation.
type GetResolverRequest struct {
	*aws.Request
	Input *GetResolverInput
	Copy  func(*GetResolverInput) GetResolverRequest
}

// Send marshals and sends the GetResolver API request.
func (r GetResolverRequest) Send() (*GetResolverOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetResolverOutput), nil
}

// GetResolverRequest returns a request value for making API operation for
// AWS AppSync.
//
// Retrieves a Resolver object.
//
//    // Example sending a request using the GetResolverRequest method.
//    req := client.GetResolverRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetResolver
func (c *AppSync) GetResolverRequest(input *GetResolverInput) GetResolverRequest {
	op := &aws.Operation{
		Name:       opGetResolver,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}",
	}

	if input == nil {
		input = &GetResolverInput{}
	}

	output := &GetResolverOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetResolverRequest{Request: req, Input: input, Copy: c.GetResolverRequest}
}

const opGetSchemaCreationStatus = "GetSchemaCreationStatus"

// GetSchemaCreationStatusRequest is a API request type for the GetSchemaCreationStatus API operation.
type GetSchemaCreationStatusRequest struct {
	*aws.Request
	Input *GetSchemaCreationStatusInput
	Copy  func(*GetSchemaCreationStatusInput) GetSchemaCreationStatusRequest
}

// Send marshals and sends the GetSchemaCreationStatus API request.
func (r GetSchemaCreationStatusRequest) Send() (*GetSchemaCreationStatusOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSchemaCreationStatusOutput), nil
}

// GetSchemaCreationStatusRequest returns a request value for making API operation for
// AWS AppSync.
//
// Retrieves the current status of a schema creation operation.
//
//    // Example sending a request using the GetSchemaCreationStatusRequest method.
//    req := client.GetSchemaCreationStatusRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetSchemaCreationStatus
func (c *AppSync) GetSchemaCreationStatusRequest(input *GetSchemaCreationStatusInput) GetSchemaCreationStatusRequest {
	op := &aws.Operation{
		Name:       opGetSchemaCreationStatus,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/schemacreation",
	}

	if input == nil {
		input = &GetSchemaCreationStatusInput{}
	}

	output := &GetSchemaCreationStatusOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSchemaCreationStatusRequest{Request: req, Input: input, Copy: c.GetSchemaCreationStatusRequest}
}

const opGetType = "GetType"

// GetTypeRequest is a API request type for the GetType API operation.
type GetTypeRequest struct {
	*aws.Request
	Input *GetTypeInput
	Copy  func(*GetTypeInput) GetTypeRequest
}

// Send marshals and sends the GetType API request.
func (r GetTypeRequest) Send() (*GetTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTypeOutput), nil
}

// GetTypeRequest returns a request value for making API operation for
// AWS AppSync.
//
// Retrieves a Type object.
//
//    // Example sending a request using the GetTypeRequest method.
//    req := client.GetTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetType
func (c *AppSync) GetTypeRequest(input *GetTypeInput) GetTypeRequest {
	op := &aws.Operation{
		Name:       opGetType,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/types/{typeName}",
	}

	if input == nil {
		input = &GetTypeInput{}
	}

	output := &GetTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTypeRequest{Request: req, Input: input, Copy: c.GetTypeRequest}
}

const opListApiKeys = "ListApiKeys"

// ListApiKeysRequest is a API request type for the ListApiKeys API operation.
type ListApiKeysRequest struct {
	*aws.Request
	Input *ListApiKeysInput
	Copy  func(*ListApiKeysInput) ListApiKeysRequest
}

// Send marshals and sends the ListApiKeys API request.
func (r ListApiKeysRequest) Send() (*ListApiKeysOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListApiKeysOutput), nil
}

// ListApiKeysRequest returns a request value for making API operation for
// AWS AppSync.
//
// Lists the API keys for a given API.
//
// API keys are deleted automatically sometime after they expire. However, they
// may still be included in the response until they have actually been deleted.
// You can safely call DeleteApiKey to manually delete a key before it's automatically
// deleted.
//
//    // Example sending a request using the ListApiKeysRequest method.
//    req := client.ListApiKeysRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListApiKeys
func (c *AppSync) ListApiKeysRequest(input *ListApiKeysInput) ListApiKeysRequest {
	op := &aws.Operation{
		Name:       opListApiKeys,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/apikeys",
	}

	if input == nil {
		input = &ListApiKeysInput{}
	}

	output := &ListApiKeysOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListApiKeysRequest{Request: req, Input: input, Copy: c.ListApiKeysRequest}
}

const opListDataSources = "ListDataSources"

// ListDataSourcesRequest is a API request type for the ListDataSources API operation.
type ListDataSourcesRequest struct {
	*aws.Request
	Input *ListDataSourcesInput
	Copy  func(*ListDataSourcesInput) ListDataSourcesRequest
}

// Send marshals and sends the ListDataSources API request.
func (r ListDataSourcesRequest) Send() (*ListDataSourcesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListDataSourcesOutput), nil
}

// ListDataSourcesRequest returns a request value for making API operation for
// AWS AppSync.
//
// Lists the data sources for a given API.
//
//    // Example sending a request using the ListDataSourcesRequest method.
//    req := client.ListDataSourcesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListDataSources
func (c *AppSync) ListDataSourcesRequest(input *ListDataSourcesInput) ListDataSourcesRequest {
	op := &aws.Operation{
		Name:       opListDataSources,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/datasources",
	}

	if input == nil {
		input = &ListDataSourcesInput{}
	}

	output := &ListDataSourcesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListDataSourcesRequest{Request: req, Input: input, Copy: c.ListDataSourcesRequest}
}

const opListGraphqlApis = "ListGraphqlApis"

// ListGraphqlApisRequest is a API request type for the ListGraphqlApis API operation.
type ListGraphqlApisRequest struct {
	*aws.Request
	Input *ListGraphqlApisInput
	Copy  func(*ListGraphqlApisInput) ListGraphqlApisRequest
}

// Send marshals and sends the ListGraphqlApis API request.
func (r ListGraphqlApisRequest) Send() (*ListGraphqlApisOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListGraphqlApisOutput), nil
}

// ListGraphqlApisRequest returns a request value for making API operation for
// AWS AppSync.
//
// Lists your GraphQL APIs.
//
//    // Example sending a request using the ListGraphqlApisRequest method.
//    req := client.ListGraphqlApisRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListGraphqlApis
func (c *AppSync) ListGraphqlApisRequest(input *ListGraphqlApisInput) ListGraphqlApisRequest {
	op := &aws.Operation{
		Name:       opListGraphqlApis,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis",
	}

	if input == nil {
		input = &ListGraphqlApisInput{}
	}

	output := &ListGraphqlApisOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListGraphqlApisRequest{Request: req, Input: input, Copy: c.ListGraphqlApisRequest}
}

const opListResolvers = "ListResolvers"

// ListResolversRequest is a API request type for the ListResolvers API operation.
type ListResolversRequest struct {
	*aws.Request
	Input *ListResolversInput
	Copy  func(*ListResolversInput) ListResolversRequest
}

// Send marshals and sends the ListResolvers API request.
func (r ListResolversRequest) Send() (*ListResolversOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListResolversOutput), nil
}

// ListResolversRequest returns a request value for making API operation for
// AWS AppSync.
//
// Lists the resolvers for a given API and type.
//
//    // Example sending a request using the ListResolversRequest method.
//    req := client.ListResolversRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListResolvers
func (c *AppSync) ListResolversRequest(input *ListResolversInput) ListResolversRequest {
	op := &aws.Operation{
		Name:       opListResolvers,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/types/{typeName}/resolvers",
	}

	if input == nil {
		input = &ListResolversInput{}
	}

	output := &ListResolversOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListResolversRequest{Request: req, Input: input, Copy: c.ListResolversRequest}
}

const opListTypes = "ListTypes"

// ListTypesRequest is a API request type for the ListTypes API operation.
type ListTypesRequest struct {
	*aws.Request
	Input *ListTypesInput
	Copy  func(*ListTypesInput) ListTypesRequest
}

// Send marshals and sends the ListTypes API request.
func (r ListTypesRequest) Send() (*ListTypesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTypesOutput), nil
}

// ListTypesRequest returns a request value for making API operation for
// AWS AppSync.
//
// Lists the types for a given API.
//
//    // Example sending a request using the ListTypesRequest method.
//    req := client.ListTypesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListTypes
func (c *AppSync) ListTypesRequest(input *ListTypesInput) ListTypesRequest {
	op := &aws.Operation{
		Name:       opListTypes,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/apis/{apiId}/types",
	}

	if input == nil {
		input = &ListTypesInput{}
	}

	output := &ListTypesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTypesRequest{Request: req, Input: input, Copy: c.ListTypesRequest}
}

const opStartSchemaCreation = "StartSchemaCreation"

// StartSchemaCreationRequest is a API request type for the StartSchemaCreation API operation.
type StartSchemaCreationRequest struct {
	*aws.Request
	Input *StartSchemaCreationInput
	Copy  func(*StartSchemaCreationInput) StartSchemaCreationRequest
}

// Send marshals and sends the StartSchemaCreation API request.
func (r StartSchemaCreationRequest) Send() (*StartSchemaCreationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartSchemaCreationOutput), nil
}

// StartSchemaCreationRequest returns a request value for making API operation for
// AWS AppSync.
//
// Adds a new schema to your GraphQL API.
//
// This operation is asynchronous. Use to determine when it has completed.
//
//    // Example sending a request using the StartSchemaCreationRequest method.
//    req := client.StartSchemaCreationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/StartSchemaCreation
func (c *AppSync) StartSchemaCreationRequest(input *StartSchemaCreationInput) StartSchemaCreationRequest {
	op := &aws.Operation{
		Name:       opStartSchemaCreation,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/schemacreation",
	}

	if input == nil {
		input = &StartSchemaCreationInput{}
	}

	output := &StartSchemaCreationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartSchemaCreationRequest{Request: req, Input: input, Copy: c.StartSchemaCreationRequest}
}

const opUpdateApiKey = "UpdateApiKey"

// UpdateApiKeyRequest is a API request type for the UpdateApiKey API operation.
type UpdateApiKeyRequest struct {
	*aws.Request
	Input *UpdateApiKeyInput
	Copy  func(*UpdateApiKeyInput) UpdateApiKeyRequest
}

// Send marshals and sends the UpdateApiKey API request.
func (r UpdateApiKeyRequest) Send() (*UpdateApiKeyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateApiKeyOutput), nil
}

// UpdateApiKeyRequest returns a request value for making API operation for
// AWS AppSync.
//
// Updates an API key.
//
//    // Example sending a request using the UpdateApiKeyRequest method.
//    req := client.UpdateApiKeyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateApiKey
func (c *AppSync) UpdateApiKeyRequest(input *UpdateApiKeyInput) UpdateApiKeyRequest {
	op := &aws.Operation{
		Name:       opUpdateApiKey,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/apikeys/{id}",
	}

	if input == nil {
		input = &UpdateApiKeyInput{}
	}

	output := &UpdateApiKeyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateApiKeyRequest{Request: req, Input: input, Copy: c.UpdateApiKeyRequest}
}

const opUpdateDataSource = "UpdateDataSource"

// UpdateDataSourceRequest is a API request type for the UpdateDataSource API operation.
type UpdateDataSourceRequest struct {
	*aws.Request
	Input *UpdateDataSourceInput
	Copy  func(*UpdateDataSourceInput) UpdateDataSourceRequest
}

// Send marshals and sends the UpdateDataSource API request.
func (r UpdateDataSourceRequest) Send() (*UpdateDataSourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDataSourceOutput), nil
}

// UpdateDataSourceRequest returns a request value for making API operation for
// AWS AppSync.
//
// Updates a DataSource object.
//
//    // Example sending a request using the UpdateDataSourceRequest method.
//    req := client.UpdateDataSourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateDataSource
func (c *AppSync) UpdateDataSourceRequest(input *UpdateDataSourceInput) UpdateDataSourceRequest {
	op := &aws.Operation{
		Name:       opUpdateDataSource,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/datasources/{name}",
	}

	if input == nil {
		input = &UpdateDataSourceInput{}
	}

	output := &UpdateDataSourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateDataSourceRequest{Request: req, Input: input, Copy: c.UpdateDataSourceRequest}
}

const opUpdateGraphqlApi = "UpdateGraphqlApi"

// UpdateGraphqlApiRequest is a API request type for the UpdateGraphqlApi API operation.
type UpdateGraphqlApiRequest struct {
	*aws.Request
	Input *UpdateGraphqlApiInput
	Copy  func(*UpdateGraphqlApiInput) UpdateGraphqlApiRequest
}

// Send marshals and sends the UpdateGraphqlApi API request.
func (r UpdateGraphqlApiRequest) Send() (*UpdateGraphqlApiOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGraphqlApiOutput), nil
}

// UpdateGraphqlApiRequest returns a request value for making API operation for
// AWS AppSync.
//
// Updates a GraphqlApi object.
//
//    // Example sending a request using the UpdateGraphqlApiRequest method.
//    req := client.UpdateGraphqlApiRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateGraphqlApi
func (c *AppSync) UpdateGraphqlApiRequest(input *UpdateGraphqlApiInput) UpdateGraphqlApiRequest {
	op := &aws.Operation{
		Name:       opUpdateGraphqlApi,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}",
	}

	if input == nil {
		input = &UpdateGraphqlApiInput{}
	}

	output := &UpdateGraphqlApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateGraphqlApiRequest{Request: req, Input: input, Copy: c.UpdateGraphqlApiRequest}
}

const opUpdateResolver = "UpdateResolver"

// UpdateResolverRequest is a API request type for the UpdateResolver API operation.
type UpdateResolverRequest struct {
	*aws.Request
	Input *UpdateResolverInput
	Copy  func(*UpdateResolverInput) UpdateResolverRequest
}

// Send marshals and sends the UpdateResolver API request.
func (r UpdateResolverRequest) Send() (*UpdateResolverOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateResolverOutput), nil
}

// UpdateResolverRequest returns a request value for making API operation for
// AWS AppSync.
//
// Updates a Resolver object.
//
//    // Example sending a request using the UpdateResolverRequest method.
//    req := client.UpdateResolverRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateResolver
func (c *AppSync) UpdateResolverRequest(input *UpdateResolverInput) UpdateResolverRequest {
	op := &aws.Operation{
		Name:       opUpdateResolver,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}",
	}

	if input == nil {
		input = &UpdateResolverInput{}
	}

	output := &UpdateResolverOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateResolverRequest{Request: req, Input: input, Copy: c.UpdateResolverRequest}
}

const opUpdateType = "UpdateType"

// UpdateTypeRequest is a API request type for the UpdateType API operation.
type UpdateTypeRequest struct {
	*aws.Request
	Input *UpdateTypeInput
	Copy  func(*UpdateTypeInput) UpdateTypeRequest
}

// Send marshals and sends the UpdateType API request.
func (r UpdateTypeRequest) Send() (*UpdateTypeOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateTypeOutput), nil
}

// UpdateTypeRequest returns a request value for making API operation for
// AWS AppSync.
//
// Updates a Type object.
//
//    // Example sending a request using the UpdateTypeRequest method.
//    req := client.UpdateTypeRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateType
func (c *AppSync) UpdateTypeRequest(input *UpdateTypeInput) UpdateTypeRequest {
	op := &aws.Operation{
		Name:       opUpdateType,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/apis/{apiId}/types/{typeName}",
	}

	if input == nil {
		input = &UpdateTypeInput{}
	}

	output := &UpdateTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateTypeRequest{Request: req, Input: input, Copy: c.UpdateTypeRequest}
}

// Describes an API key.
//
// Customers invoke AWS AppSync GraphQL APIs with API keys as an identity mechanism.
// There are two key versions:
//
// da1: This version was introduced at launch in November 2017. These keys always
// expire after 7 days. Key expiration is managed by DynamoDB TTL. The keys
// will cease to be valid after Feb 21, 2018 and should not be used after that
// date.
//
//    * ListApiKeys returns the expiration time in milliseconds.
//
//    * CreateApiKey returns the expiration time in milliseconds.
//
//    * UpdateApiKey is not available for this key version.
//
//    * DeleteApiKey deletes the item from the table.
//
//    * Expiration is stored in DynamoDB as milliseconds. This results in a
//    bug where keys are not automatically deleted because DynamoDB expects
//    the TTL to be stored in seconds. As a one-time action, we will delete
//    these keys from the table after Feb 21, 2018.
//
// da2: This version was introduced in February 2018 when AppSync added support
// to extend key expiration.
//
//    * ListApiKeys returns the expiration time in seconds.
//
//    * CreateApiKey returns the expiration time in seconds and accepts a user-provided
//    expiration time in seconds.
//
//    * UpdateApiKey returns the expiration time in seconds and accepts a user-provided
//    expiration time in seconds. Key expiration can only be updated while the
//    key has not expired.
//
//    * DeleteApiKey deletes the item from the table.
//
//    * Expiration is stored in DynamoDB as seconds.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ApiKey
type ApiKey struct {
	_ struct{} `type:"structure"`

	// A description of the purpose of the API key.
	Description *string `locationName:"description" type:"string"`

	// The time after which the API key expires. The date is represented as seconds
	// since the epoch, rounded down to the nearest hour.
	Expires *int64 `locationName:"expires" type:"long"`

	// The API key ID.
	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s ApiKey) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApiKey) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ApiKey) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Expires != nil {
		v := *s.Expires

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "expires", protocol.Int64Value(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateApiKeyRequest
type CreateApiKeyInput struct {
	_ struct{} `type:"structure"`

	// The ID for your GraphQL API.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// A description of the purpose of the API key.
	Description *string `locationName:"description" type:"string"`

	// The time from creation time after which the API key expires. The date is
	// represented as seconds since the epoch, rounded down to the nearest hour.
	// The default value for this parameter is 7 days from creation time. For more
	// information, see .
	Expires *int64 `locationName:"expires" type:"long"`
}

// String returns the string representation
func (s CreateApiKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateApiKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateApiKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateApiKeyInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateApiKeyInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Expires != nil {
		v := *s.Expires

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "expires", protocol.Int64Value(v), metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateApiKeyResponse
type CreateApiKeyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The API key.
	ApiKey *ApiKey `locationName:"apiKey" type:"structure"`
}

// String returns the string representation
func (s CreateApiKeyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateApiKeyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateApiKeyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateApiKeyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApiKey != nil {
		v := s.ApiKey

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "apiKey", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateDataSourceRequest
type CreateDataSourceInput struct {
	_ struct{} `type:"structure"`

	// The API ID for the GraphQL API for the DataSource.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// A description of the DataSource.
	Description *string `locationName:"description" type:"string"`

	// DynamoDB settings.
	DynamodbConfig *DynamodbDataSourceConfig `locationName:"dynamodbConfig" type:"structure"`

	// Amazon Elasticsearch settings.
	ElasticsearchConfig *ElasticsearchDataSourceConfig `locationName:"elasticsearchConfig" type:"structure"`

	// Http endpoint settings.
	HttpConfig *HttpDataSourceConfig `locationName:"httpConfig" type:"structure"`

	// AWS Lambda settings.
	LambdaConfig *LambdaDataSourceConfig `locationName:"lambdaConfig" type:"structure"`

	// A user-supplied name for the DataSource.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// The IAM service role ARN for the data source. The system assumes this role
	// when accessing the data source.
	ServiceRoleArn *string `locationName:"serviceRoleArn" type:"string"`

	// The type of the DataSource.
	//
	// Type is a required field
	Type DataSourceType `locationName:"type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s CreateDataSourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDataSourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDataSourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDataSourceInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}
	if s.DynamodbConfig != nil {
		if err := s.DynamodbConfig.Validate(); err != nil {
			invalidParams.AddNested("DynamodbConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.ElasticsearchConfig != nil {
		if err := s.ElasticsearchConfig.Validate(); err != nil {
			invalidParams.AddNested("ElasticsearchConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.LambdaConfig != nil {
		if err := s.LambdaConfig.Validate(); err != nil {
			invalidParams.AddNested("LambdaConfig", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateDataSourceInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DynamodbConfig != nil {
		v := s.DynamodbConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dynamodbConfig", v, metadata)
	}
	if s.ElasticsearchConfig != nil {
		v := s.ElasticsearchConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "elasticsearchConfig", v, metadata)
	}
	if s.HttpConfig != nil {
		v := s.HttpConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "httpConfig", v, metadata)
	}
	if s.LambdaConfig != nil {
		v := s.LambdaConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "lambdaConfig", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ServiceRoleArn != nil {
		v := *s.ServiceRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "serviceRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateDataSourceResponse
type CreateDataSourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The DataSource object.
	DataSource *DataSource `locationName:"dataSource" type:"structure"`
}

// String returns the string representation
func (s CreateDataSourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDataSourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateDataSourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateDataSourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DataSource != nil {
		v := s.DataSource

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dataSource", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateGraphqlApiRequest
type CreateGraphqlApiInput struct {
	_ struct{} `type:"structure"`

	// The authentication type: API key, IAM, or Amazon Cognito User Pools.
	//
	// AuthenticationType is a required field
	AuthenticationType AuthenticationType `locationName:"authenticationType" type:"string" required:"true" enum:"true"`

	// The Amazon CloudWatch logs configuration.
	LogConfig *LogConfig `locationName:"logConfig" type:"structure"`

	// A user-supplied name for the GraphqlApi.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// The Open Id Connect configuration configuration.
	OpenIDConnectConfig *OpenIDConnectConfig `locationName:"openIDConnectConfig" type:"structure"`

	// The Amazon Cognito User Pool configuration.
	UserPoolConfig *UserPoolConfig `locationName:"userPoolConfig" type:"structure"`
}

// String returns the string representation
func (s CreateGraphqlApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGraphqlApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateGraphqlApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateGraphqlApiInput"}
	if len(s.AuthenticationType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("AuthenticationType"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.LogConfig != nil {
		if err := s.LogConfig.Validate(); err != nil {
			invalidParams.AddNested("LogConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.OpenIDConnectConfig != nil {
		if err := s.OpenIDConnectConfig.Validate(); err != nil {
			invalidParams.AddNested("OpenIDConnectConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.UserPoolConfig != nil {
		if err := s.UserPoolConfig.Validate(); err != nil {
			invalidParams.AddNested("UserPoolConfig", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateGraphqlApiInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.AuthenticationType) > 0 {
		v := s.AuthenticationType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authenticationType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.LogConfig != nil {
		v := s.LogConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logConfig", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OpenIDConnectConfig != nil {
		v := s.OpenIDConnectConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "openIDConnectConfig", v, metadata)
	}
	if s.UserPoolConfig != nil {
		v := s.UserPoolConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "userPoolConfig", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateGraphqlApiResponse
type CreateGraphqlApiOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The GraphqlApi.
	GraphqlApi *GraphqlApi `locationName:"graphqlApi" type:"structure"`
}

// String returns the string representation
func (s CreateGraphqlApiOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGraphqlApiOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateGraphqlApiOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateGraphqlApiOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.GraphqlApi != nil {
		v := s.GraphqlApi

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "graphqlApi", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateResolverRequest
type CreateResolverInput struct {
	_ struct{} `type:"structure"`

	// The ID for the GraphQL API for which the resolver is being created.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The name of the data source for which the resolver is being created.
	//
	// DataSourceName is a required field
	DataSourceName *string `locationName:"dataSourceName" type:"string" required:"true"`

	// The name of the field to attach the resolver to.
	//
	// FieldName is a required field
	FieldName *string `locationName:"fieldName" type:"string" required:"true"`

	// The mapping template to be used for requests.
	//
	// A resolver uses a request mapping template to convert a GraphQL expression
	// into a format that a data source can understand. Mapping templates are written
	// in Apache Velocity Template Language (VTL).
	//
	// RequestMappingTemplate is a required field
	RequestMappingTemplate *string `locationName:"requestMappingTemplate" min:"1" type:"string" required:"true"`

	// The mapping template to be used for responses from the data source.
	ResponseMappingTemplate *string `locationName:"responseMappingTemplate" min:"1" type:"string"`

	// The name of the Type.
	//
	// TypeName is a required field
	TypeName *string `location:"uri" locationName:"typeName" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateResolverInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateResolverInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateResolverInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateResolverInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.DataSourceName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceName"))
	}

	if s.FieldName == nil {
		invalidParams.Add(aws.NewErrParamRequired("FieldName"))
	}

	if s.RequestMappingTemplate == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestMappingTemplate"))
	}
	if s.RequestMappingTemplate != nil && len(*s.RequestMappingTemplate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RequestMappingTemplate", 1))
	}
	if s.ResponseMappingTemplate != nil && len(*s.ResponseMappingTemplate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResponseMappingTemplate", 1))
	}

	if s.TypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypeName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateResolverInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.DataSourceName != nil {
		v := *s.DataSourceName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "dataSourceName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FieldName != nil {
		v := *s.FieldName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "fieldName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RequestMappingTemplate != nil {
		v := *s.RequestMappingTemplate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "requestMappingTemplate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResponseMappingTemplate != nil {
		v := *s.ResponseMappingTemplate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "responseMappingTemplate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateResolverResponse
type CreateResolverOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Resolver object.
	Resolver *Resolver `locationName:"resolver" type:"structure"`
}

// String returns the string representation
func (s CreateResolverOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateResolverOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateResolverOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateResolverOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Resolver != nil {
		v := s.Resolver

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "resolver", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateTypeRequest
type CreateTypeInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The type definition, in GraphQL Schema Definition Language (SDL) format.
	//
	// For more information, see the GraphQL SDL documentation (http://graphql.org/learn/schema/).
	//
	// Definition is a required field
	Definition *string `locationName:"definition" type:"string" required:"true"`

	// The type format: SDL or JSON.
	//
	// Format is a required field
	Format TypeDefinitionFormat `locationName:"format" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s CreateTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTypeInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Definition == nil {
		invalidParams.Add(aws.NewErrParamRequired("Definition"))
	}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTypeInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Definition != nil {
		v := *s.Definition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "definition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "format", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/CreateTypeResponse
type CreateTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Type object.
	Type *Type `locationName:"type" type:"structure"`
}

// String returns the string representation
func (s CreateTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Type != nil {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "type", v, metadata)
	}
	return nil
}

// Describes a data source.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DataSource
type DataSource struct {
	_ struct{} `type:"structure"`

	// The data source ARN.
	DataSourceArn *string `locationName:"dataSourceArn" type:"string"`

	// The description of the data source.
	Description *string `locationName:"description" type:"string"`

	// DynamoDB settings.
	DynamodbConfig *DynamodbDataSourceConfig `locationName:"dynamodbConfig" type:"structure"`

	// Amazon Elasticsearch settings.
	ElasticsearchConfig *ElasticsearchDataSourceConfig `locationName:"elasticsearchConfig" type:"structure"`

	// Http endpoint settings.
	HttpConfig *HttpDataSourceConfig `locationName:"httpConfig" type:"structure"`

	// Lambda settings.
	LambdaConfig *LambdaDataSourceConfig `locationName:"lambdaConfig" type:"structure"`

	// The name of the data source.
	Name *string `locationName:"name" type:"string"`

	// The IAM service role ARN for the data source. The system assumes this role
	// when accessing the data source.
	ServiceRoleArn *string `locationName:"serviceRoleArn" type:"string"`

	// The type of the data source.
	//
	//    * AMAZON_DYNAMODB: The data source is an Amazon DynamoDB table.
	//
	//    * AMAZON_ELASTICSEARCH: The data source is an Amazon Elasticsearch Service
	//    domain.
	//
	//    * AWS_LAMBDA: The data source is an AWS Lambda function.
	//
	//    * NONE: There is no data source. This type is used when when you wish
	//    to invoke a GraphQL operation without connecting to a data source, such
	//    as performing data transformation with resolvers or triggering a subscription
	//    to be invoked from a mutation.
	//
	//    * HTTP: The data source is an HTTP endpoint.
	Type DataSourceType `locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s DataSource) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DataSource) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DataSource) MarshalFields(e protocol.FieldEncoder) error {
	if s.DataSourceArn != nil {
		v := *s.DataSourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "dataSourceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DynamodbConfig != nil {
		v := s.DynamodbConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dynamodbConfig", v, metadata)
	}
	if s.ElasticsearchConfig != nil {
		v := s.ElasticsearchConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "elasticsearchConfig", v, metadata)
	}
	if s.HttpConfig != nil {
		v := s.HttpConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "httpConfig", v, metadata)
	}
	if s.LambdaConfig != nil {
		v := s.LambdaConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "lambdaConfig", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ServiceRoleArn != nil {
		v := *s.ServiceRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "serviceRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteApiKeyRequest
type DeleteApiKeyInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The ID for the API key.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteApiKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteApiKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteApiKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteApiKeyInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteApiKeyInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteApiKeyResponse
type DeleteApiKeyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteApiKeyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteApiKeyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteApiKeyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteApiKeyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteDataSourceRequest
type DeleteDataSourceInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The name of the data source.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDataSourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDataSourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteDataSourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteDataSourceInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDataSourceInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteDataSourceResponse
type DeleteDataSourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteDataSourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDataSourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteDataSourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDataSourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteGraphqlApiRequest
type DeleteGraphqlApiInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteGraphqlApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGraphqlApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteGraphqlApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteGraphqlApiInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteGraphqlApiInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteGraphqlApiResponse
type DeleteGraphqlApiOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteGraphqlApiOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGraphqlApiOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteGraphqlApiOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteGraphqlApiOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteResolverRequest
type DeleteResolverInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The resolver field name.
	//
	// FieldName is a required field
	FieldName *string `location:"uri" locationName:"fieldName" type:"string" required:"true"`

	// The name of the resolver type.
	//
	// TypeName is a required field
	TypeName *string `location:"uri" locationName:"typeName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteResolverInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteResolverInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteResolverInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteResolverInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.FieldName == nil {
		invalidParams.Add(aws.NewErrParamRequired("FieldName"))
	}

	if s.TypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypeName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteResolverInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FieldName != nil {
		v := *s.FieldName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "fieldName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteResolverResponse
type DeleteResolverOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteResolverOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteResolverOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteResolverOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteResolverOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteTypeRequest
type DeleteTypeInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The type name.
	//
	// TypeName is a required field
	TypeName *string `location:"uri" locationName:"typeName" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTypeInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.TypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypeName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTypeInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DeleteTypeResponse
type DeleteTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Describes a DynamoDB data source configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/DynamodbDataSourceConfig
type DynamodbDataSourceConfig struct {
	_ struct{} `type:"structure"`

	// The AWS region.
	//
	// AwsRegion is a required field
	AwsRegion *string `locationName:"awsRegion" type:"string" required:"true"`

	// The table name.
	//
	// TableName is a required field
	TableName *string `locationName:"tableName" type:"string" required:"true"`

	// Set to TRUE to use Amazon Cognito credentials with this data source.
	UseCallerCredentials *bool `locationName:"useCallerCredentials" type:"boolean"`
}

// String returns the string representation
func (s DynamodbDataSourceConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DynamodbDataSourceConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DynamodbDataSourceConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DynamodbDataSourceConfig"}

	if s.AwsRegion == nil {
		invalidParams.Add(aws.NewErrParamRequired("AwsRegion"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DynamodbDataSourceConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.AwsRegion != nil {
		v := *s.AwsRegion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsRegion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TableName != nil {
		v := *s.TableName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tableName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UseCallerCredentials != nil {
		v := *s.UseCallerCredentials

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "useCallerCredentials", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Describes an Elasticsearch data source configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ElasticsearchDataSourceConfig
type ElasticsearchDataSourceConfig struct {
	_ struct{} `type:"structure"`

	// The AWS region.
	//
	// AwsRegion is a required field
	AwsRegion *string `locationName:"awsRegion" type:"string" required:"true"`

	// The endpoint.
	//
	// Endpoint is a required field
	Endpoint *string `locationName:"endpoint" type:"string" required:"true"`
}

// String returns the string representation
func (s ElasticsearchDataSourceConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ElasticsearchDataSourceConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ElasticsearchDataSourceConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ElasticsearchDataSourceConfig"}

	if s.AwsRegion == nil {
		invalidParams.Add(aws.NewErrParamRequired("AwsRegion"))
	}

	if s.Endpoint == nil {
		invalidParams.Add(aws.NewErrParamRequired("Endpoint"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ElasticsearchDataSourceConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.AwsRegion != nil {
		v := *s.AwsRegion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsRegion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Endpoint != nil {
		v := *s.Endpoint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "endpoint", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetDataSourceRequest
type GetDataSourceInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The name of the data source.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDataSourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDataSourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDataSourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDataSourceInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDataSourceInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetDataSourceResponse
type GetDataSourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The DataSource object.
	DataSource *DataSource `locationName:"dataSource" type:"structure"`
}

// String returns the string representation
func (s GetDataSourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDataSourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDataSourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDataSourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DataSource != nil {
		v := s.DataSource

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dataSource", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetGraphqlApiRequest
type GetGraphqlApiInput struct {
	_ struct{} `type:"structure"`

	// The API ID for the GraphQL API.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetGraphqlApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGraphqlApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetGraphqlApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetGraphqlApiInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGraphqlApiInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetGraphqlApiResponse
type GetGraphqlApiOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The GraphqlApi object.
	GraphqlApi *GraphqlApi `locationName:"graphqlApi" type:"structure"`
}

// String returns the string representation
func (s GetGraphqlApiOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGraphqlApiOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetGraphqlApiOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGraphqlApiOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.GraphqlApi != nil {
		v := s.GraphqlApi

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "graphqlApi", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetIntrospectionSchemaRequest
type GetIntrospectionSchemaInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The schema format: SDL or JSON.
	//
	// Format is a required field
	Format OutputType `location:"querystring" locationName:"format" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s GetIntrospectionSchemaInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntrospectionSchemaInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetIntrospectionSchemaInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetIntrospectionSchemaInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntrospectionSchemaInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "format", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetIntrospectionSchemaResponse
type GetIntrospectionSchemaOutput struct {
	_ struct{} `type:"structure" payload:"Schema"`

	responseMetadata aws.Response

	// The schema, in GraphQL Schema Definition Language (SDL) format.
	//
	// For more information, see the GraphQL SDL documentation (http://graphql.org/learn/schema/).
	Schema []byte `locationName:"schema" type:"blob"`
}

// String returns the string representation
func (s GetIntrospectionSchemaOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntrospectionSchemaOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetIntrospectionSchemaOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntrospectionSchemaOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Schema != nil {
		v := s.Schema

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "schema", protocol.BytesStream(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetResolverRequest
type GetResolverInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The resolver field name.
	//
	// FieldName is a required field
	FieldName *string `location:"uri" locationName:"fieldName" type:"string" required:"true"`

	// The resolver type name.
	//
	// TypeName is a required field
	TypeName *string `location:"uri" locationName:"typeName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetResolverInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetResolverInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetResolverInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetResolverInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.FieldName == nil {
		invalidParams.Add(aws.NewErrParamRequired("FieldName"))
	}

	if s.TypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypeName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetResolverInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FieldName != nil {
		v := *s.FieldName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "fieldName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetResolverResponse
type GetResolverOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Resolver object.
	Resolver *Resolver `locationName:"resolver" type:"structure"`
}

// String returns the string representation
func (s GetResolverOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetResolverOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetResolverOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetResolverOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Resolver != nil {
		v := s.Resolver

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "resolver", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetSchemaCreationStatusRequest
type GetSchemaCreationStatusInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetSchemaCreationStatusInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSchemaCreationStatusInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSchemaCreationStatusInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSchemaCreationStatusInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSchemaCreationStatusInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetSchemaCreationStatusResponse
type GetSchemaCreationStatusOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Detailed information about the status of the schema creation operation.
	Details *string `locationName:"details" type:"string"`

	// The current state of the schema (PROCESSING, ACTIVE, or DELETING). Once the
	// schema is in the ACTIVE state, you can add data.
	Status SchemaStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s GetSchemaCreationStatusOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSchemaCreationStatusOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSchemaCreationStatusOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSchemaCreationStatusOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Details != nil {
		v := *s.Details

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "details", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetTypeRequest
type GetTypeInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The type format: SDL or JSON.
	//
	// Format is a required field
	Format TypeDefinitionFormat `location:"querystring" locationName:"format" type:"string" required:"true" enum:"true"`

	// The type name.
	//
	// TypeName is a required field
	TypeName *string `location:"uri" locationName:"typeName" type:"string" required:"true"`
}

// String returns the string representation
func (s GetTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTypeInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}

	if s.TypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypeName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTypeInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "format", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GetTypeResponse
type GetTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Type object.
	Type *Type `locationName:"type" type:"structure"`
}

// String returns the string representation
func (s GetTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Type != nil {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "type", v, metadata)
	}
	return nil
}

// Describes a GraphQL API.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/GraphqlApi
type GraphqlApi struct {
	_ struct{} `type:"structure"`

	// The API ID.
	ApiId *string `locationName:"apiId" type:"string"`

	// The ARN.
	Arn *string `locationName:"arn" type:"string"`

	// The authentication type.
	AuthenticationType AuthenticationType `locationName:"authenticationType" type:"string" enum:"true"`

	// The Amazon CloudWatch Logs configuration.
	LogConfig *LogConfig `locationName:"logConfig" type:"structure"`

	// The API name.
	Name *string `locationName:"name" type:"string"`

	// The Open Id Connect configuration.
	OpenIDConnectConfig *OpenIDConnectConfig `locationName:"openIDConnectConfig" type:"structure"`

	// The URIs.
	Uris map[string]string `locationName:"uris" type:"map"`

	// The Amazon Cognito User Pool configuration.
	UserPoolConfig *UserPoolConfig `locationName:"userPoolConfig" type:"structure"`
}

// String returns the string representation
func (s GraphqlApi) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GraphqlApi) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GraphqlApi) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.AuthenticationType) > 0 {
		v := s.AuthenticationType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authenticationType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.LogConfig != nil {
		v := s.LogConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logConfig", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OpenIDConnectConfig != nil {
		v := s.OpenIDConnectConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "openIDConnectConfig", v, metadata)
	}
	if len(s.Uris) > 0 {
		v := s.Uris

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "uris", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.UserPoolConfig != nil {
		v := s.UserPoolConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "userPoolConfig", v, metadata)
	}
	return nil
}

// Describes a Http data source configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/HttpDataSourceConfig
type HttpDataSourceConfig struct {
	_ struct{} `type:"structure"`

	// The Http url endpoint. You can either specify the domain name or ip and port
	// combination and the url scheme must be http(s). If the port is not specified,
	// AWS AppSync will use the default port 80 for http endpoint and port 443 for
	// https endpoints.
	Endpoint *string `locationName:"endpoint" type:"string"`
}

// String returns the string representation
func (s HttpDataSourceConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HttpDataSourceConfig) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HttpDataSourceConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.Endpoint != nil {
		v := *s.Endpoint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "endpoint", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a Lambda data source configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/LambdaDataSourceConfig
type LambdaDataSourceConfig struct {
	_ struct{} `type:"structure"`

	// The ARN for the Lambda function.
	//
	// LambdaFunctionArn is a required field
	LambdaFunctionArn *string `locationName:"lambdaFunctionArn" type:"string" required:"true"`
}

// String returns the string representation
func (s LambdaDataSourceConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LambdaDataSourceConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LambdaDataSourceConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LambdaDataSourceConfig"}

	if s.LambdaFunctionArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("LambdaFunctionArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LambdaDataSourceConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.LambdaFunctionArn != nil {
		v := *s.LambdaFunctionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lambdaFunctionArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListApiKeysRequest
type ListApiKeysInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The maximum number of results you want the request to return.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// An identifier that was returned from the previous call to this operation,
	// which can be used to return the next set of items in the list.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListApiKeysInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListApiKeysInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListApiKeysInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListApiKeysInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListApiKeysInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListApiKeysResponse
type ListApiKeysOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ApiKey objects.
	ApiKeys []ApiKey `locationName:"apiKeys" type:"list"`

	// An identifier to be passed in the next request to this operation to return
	// the next set of items in the list.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListApiKeysOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListApiKeysOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListApiKeysOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListApiKeysOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ApiKeys) > 0 {
		v := s.ApiKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "apiKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListDataSourcesRequest
type ListDataSourcesInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The maximum number of results you want the request to return.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// An identifier that was returned from the previous call to this operation,
	// which can be used to return the next set of items in the list.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListDataSourcesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListDataSourcesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListDataSourcesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListDataSourcesInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListDataSourcesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListDataSourcesResponse
type ListDataSourcesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The DataSource objects.
	DataSources []DataSource `locationName:"dataSources" type:"list"`

	// An identifier to be passed in the next request to this operation to return
	// the next set of items in the list.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListDataSourcesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListDataSourcesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListDataSourcesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListDataSourcesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DataSources) > 0 {
		v := s.DataSources

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "dataSources", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListGraphqlApisRequest
type ListGraphqlApisInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of results you want the request to return.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// An identifier that was returned from the previous call to this operation,
	// which can be used to return the next set of items in the list.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListGraphqlApisInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListGraphqlApisInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListGraphqlApisInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListGraphqlApisResponse
type ListGraphqlApisOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The GraphqlApi objects.
	GraphqlApis []GraphqlApi `locationName:"graphqlApis" type:"list"`

	// An identifier to be passed in the next request to this operation to return
	// the next set of items in the list.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListGraphqlApisOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListGraphqlApisOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListGraphqlApisOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListGraphqlApisOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.GraphqlApis) > 0 {
		v := s.GraphqlApis

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "graphqlApis", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListResolversRequest
type ListResolversInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The maximum number of results you want the request to return.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// An identifier that was returned from the previous call to this operation,
	// which can be used to return the next set of items in the list.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The type name.
	//
	// TypeName is a required field
	TypeName *string `location:"uri" locationName:"typeName" type:"string" required:"true"`
}

// String returns the string representation
func (s ListResolversInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListResolversInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListResolversInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListResolversInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.TypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypeName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListResolversInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListResolversResponse
type ListResolversOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An identifier to be passed in the next request to this operation to return
	// the next set of items in the list.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The Resolver objects.
	Resolvers []Resolver `locationName:"resolvers" type:"list"`
}

// String returns the string representation
func (s ListResolversOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListResolversOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListResolversOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListResolversOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Resolvers) > 0 {
		v := s.Resolvers

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "resolvers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListTypesRequest
type ListTypesInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The type format: SDL or JSON.
	//
	// Format is a required field
	Format TypeDefinitionFormat `location:"querystring" locationName:"format" type:"string" required:"true" enum:"true"`

	// The maximum number of results you want the request to return.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// An identifier that was returned from the previous call to this operation,
	// which can be used to return the next set of items in the list.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListTypesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTypesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTypesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTypesInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTypesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "format", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/ListTypesResponse
type ListTypesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An identifier to be passed in the next request to this operation to return
	// the next set of items in the list.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The Type objects.
	Types []Type `locationName:"types" type:"list"`
}

// String returns the string representation
func (s ListTypesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTypesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTypesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTypesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Types) > 0 {
		v := s.Types

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "types", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The CloudWatch Logs configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/LogConfig
type LogConfig struct {
	_ struct{} `type:"structure"`

	// The service role that AWS AppSync will assume to publish to Amazon CloudWatch
	// logs in your account.
	//
	// CloudWatchLogsRoleArn is a required field
	CloudWatchLogsRoleArn *string `locationName:"cloudWatchLogsRoleArn" type:"string" required:"true"`

	// The field logging level. Values can be NONE, ERROR, ALL.
	//
	//    * NONE: No field-level logs are captured.
	//
	//    * ERROR: Logs the following information only for the fields that are in
	//    error:
	//
	// The error section in the server response.
	//
	// Field-level errors.
	//
	// The generated request/response functions that got resolved for error fields.
	//
	//    * ALL: The following information is logged for all fields in the query:
	//
	// Field-level tracing information.
	//
	// The generated request/response functions that got resolved for each field.
	//
	// FieldLogLevel is a required field
	FieldLogLevel FieldLogLevel `locationName:"fieldLogLevel" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s LogConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LogConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LogConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LogConfig"}

	if s.CloudWatchLogsRoleArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("CloudWatchLogsRoleArn"))
	}
	if len(s.FieldLogLevel) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("FieldLogLevel"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LogConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.CloudWatchLogsRoleArn != nil {
		v := *s.CloudWatchLogsRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cloudWatchLogsRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.FieldLogLevel) > 0 {
		v := s.FieldLogLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "fieldLogLevel", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes an Open Id Connect configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/OpenIDConnectConfig
type OpenIDConnectConfig struct {
	_ struct{} `type:"structure"`

	// The number of milliseconds a token is valid after being authenticated.
	AuthTTL *int64 `locationName:"authTTL" type:"long"`

	// The client identifier of the Relying party at the OpenID Provider. This identifier
	// is typically obtained when the Relying party is registered with the OpenID
	// Provider. You can specify a regular expression so the AWS AppSync can validate
	// against multiple client identifiers at a time
	ClientId *string `locationName:"clientId" type:"string"`

	// The number of milliseconds a token is valid after being issued to a user.
	IatTTL *int64 `locationName:"iatTTL" type:"long"`

	// The issuer for the open id connect configuration. The issuer returned by
	// discovery MUST exactly match the value of iss in the ID Token.
	//
	// Issuer is a required field
	Issuer *string `locationName:"issuer" type:"string" required:"true"`
}

// String returns the string representation
func (s OpenIDConnectConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OpenIDConnectConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *OpenIDConnectConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "OpenIDConnectConfig"}

	if s.Issuer == nil {
		invalidParams.Add(aws.NewErrParamRequired("Issuer"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OpenIDConnectConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthTTL != nil {
		v := *s.AuthTTL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authTTL", protocol.Int64Value(v), metadata)
	}
	if s.ClientId != nil {
		v := *s.ClientId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "clientId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IatTTL != nil {
		v := *s.IatTTL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "iatTTL", protocol.Int64Value(v), metadata)
	}
	if s.Issuer != nil {
		v := *s.Issuer

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "issuer", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Describes a resolver.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/Resolver
type Resolver struct {
	_ struct{} `type:"structure"`

	// The resolver data source name.
	DataSourceName *string `locationName:"dataSourceName" type:"string"`

	// The resolver field name.
	FieldName *string `locationName:"fieldName" type:"string"`

	// The request mapping template.
	RequestMappingTemplate *string `locationName:"requestMappingTemplate" min:"1" type:"string"`

	// The resolver ARN.
	ResolverArn *string `locationName:"resolverArn" type:"string"`

	// The response mapping template.
	ResponseMappingTemplate *string `locationName:"responseMappingTemplate" min:"1" type:"string"`

	// The resolver type name.
	TypeName *string `locationName:"typeName" type:"string"`
}

// String returns the string representation
func (s Resolver) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Resolver) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Resolver) MarshalFields(e protocol.FieldEncoder) error {
	if s.DataSourceName != nil {
		v := *s.DataSourceName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "dataSourceName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FieldName != nil {
		v := *s.FieldName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "fieldName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RequestMappingTemplate != nil {
		v := *s.RequestMappingTemplate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "requestMappingTemplate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResolverArn != nil {
		v := *s.ResolverArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "resolverArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResponseMappingTemplate != nil {
		v := *s.ResponseMappingTemplate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "responseMappingTemplate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/StartSchemaCreationRequest
type StartSchemaCreationInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The schema definition, in GraphQL schema language format.
	//
	// Definition is automatically base64 encoded/decoded by the SDK.
	//
	// Definition is a required field
	Definition []byte `locationName:"definition" type:"blob" required:"true"`
}

// String returns the string representation
func (s StartSchemaCreationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartSchemaCreationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartSchemaCreationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartSchemaCreationInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Definition == nil {
		invalidParams.Add(aws.NewErrParamRequired("Definition"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartSchemaCreationInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Definition != nil {
		v := s.Definition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "definition", protocol.QuotedValue{ValueMarshaler: protocol.BytesValue(v)}, metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/StartSchemaCreationResponse
type StartSchemaCreationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current state of the schema (PROCESSING, ACTIVE, or DELETING). Once the
	// schema is in the ACTIVE state, you can add data.
	Status SchemaStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s StartSchemaCreationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartSchemaCreationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartSchemaCreationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartSchemaCreationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Describes a type.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/Type
type Type struct {
	_ struct{} `type:"structure"`

	// The type ARN.
	Arn *string `locationName:"arn" type:"string"`

	// The type definition.
	Definition *string `locationName:"definition" type:"string"`

	// The type description.
	Description *string `locationName:"description" type:"string"`

	// The type format: SDL or JSON.
	Format TypeDefinitionFormat `locationName:"format" type:"string" enum:"true"`

	// The type name.
	Name *string `locationName:"name" type:"string"`
}

// String returns the string representation
func (s Type) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Type) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Type) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Definition != nil {
		v := *s.Definition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "definition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "format", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateApiKeyRequest
type UpdateApiKeyInput struct {
	_ struct{} `type:"structure"`

	// The ID for the GraphQL API
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// A description of the purpose of the API key.
	Description *string `locationName:"description" type:"string"`

	// The time from update time after which the API key expires. The date is represented
	// as seconds since the epoch. For more information, see .
	Expires *int64 `locationName:"expires" type:"long"`

	// The API key ID.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateApiKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApiKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateApiKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateApiKeyInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateApiKeyInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Expires != nil {
		v := *s.Expires

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "expires", protocol.Int64Value(v), metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateApiKeyResponse
type UpdateApiKeyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The API key.
	ApiKey *ApiKey `locationName:"apiKey" type:"structure"`
}

// String returns the string representation
func (s UpdateApiKeyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApiKeyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateApiKeyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateApiKeyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApiKey != nil {
		v := s.ApiKey

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "apiKey", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateDataSourceRequest
type UpdateDataSourceInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The new description for the data source.
	Description *string `locationName:"description" type:"string"`

	// The new DynamoDB configuration.
	DynamodbConfig *DynamodbDataSourceConfig `locationName:"dynamodbConfig" type:"structure"`

	// The new Elasticsearch configuration.
	ElasticsearchConfig *ElasticsearchDataSourceConfig `locationName:"elasticsearchConfig" type:"structure"`

	// The new http endpoint configuration
	HttpConfig *HttpDataSourceConfig `locationName:"httpConfig" type:"structure"`

	// The new Lambda configuration.
	LambdaConfig *LambdaDataSourceConfig `locationName:"lambdaConfig" type:"structure"`

	// The new name for the data source.
	//
	// Name is a required field
	Name *string `location:"uri" locationName:"name" type:"string" required:"true"`

	// The new service role ARN for the data source.
	ServiceRoleArn *string `locationName:"serviceRoleArn" type:"string"`

	// The new data source type.
	//
	// Type is a required field
	Type DataSourceType `locationName:"type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s UpdateDataSourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDataSourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDataSourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateDataSourceInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}
	if s.DynamodbConfig != nil {
		if err := s.DynamodbConfig.Validate(); err != nil {
			invalidParams.AddNested("DynamodbConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.ElasticsearchConfig != nil {
		if err := s.ElasticsearchConfig.Validate(); err != nil {
			invalidParams.AddNested("ElasticsearchConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.LambdaConfig != nil {
		if err := s.LambdaConfig.Validate(); err != nil {
			invalidParams.AddNested("LambdaConfig", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDataSourceInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DynamodbConfig != nil {
		v := s.DynamodbConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dynamodbConfig", v, metadata)
	}
	if s.ElasticsearchConfig != nil {
		v := s.ElasticsearchConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "elasticsearchConfig", v, metadata)
	}
	if s.HttpConfig != nil {
		v := s.HttpConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "httpConfig", v, metadata)
	}
	if s.LambdaConfig != nil {
		v := s.LambdaConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "lambdaConfig", v, metadata)
	}
	if s.ServiceRoleArn != nil {
		v := *s.ServiceRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "serviceRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateDataSourceResponse
type UpdateDataSourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The updated DataSource object.
	DataSource *DataSource `locationName:"dataSource" type:"structure"`
}

// String returns the string representation
func (s UpdateDataSourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDataSourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateDataSourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDataSourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DataSource != nil {
		v := s.DataSource

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "dataSource", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateGraphqlApiRequest
type UpdateGraphqlApiInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The new authentication type for the GraphqlApi object.
	AuthenticationType AuthenticationType `locationName:"authenticationType" type:"string" enum:"true"`

	// The Amazon CloudWatch logs configuration for the GraphqlApi object.
	LogConfig *LogConfig `locationName:"logConfig" type:"structure"`

	// The new name for the GraphqlApi object.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// The Open Id Connect configuration configuration for the GraphqlApi object.
	OpenIDConnectConfig *OpenIDConnectConfig `locationName:"openIDConnectConfig" type:"structure"`

	// The new Amazon Cognito User Pool configuration for the GraphqlApi object.
	UserPoolConfig *UserPoolConfig `locationName:"userPoolConfig" type:"structure"`
}

// String returns the string representation
func (s UpdateGraphqlApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGraphqlApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateGraphqlApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateGraphqlApiInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.LogConfig != nil {
		if err := s.LogConfig.Validate(); err != nil {
			invalidParams.AddNested("LogConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.OpenIDConnectConfig != nil {
		if err := s.OpenIDConnectConfig.Validate(); err != nil {
			invalidParams.AddNested("OpenIDConnectConfig", err.(aws.ErrInvalidParams))
		}
	}
	if s.UserPoolConfig != nil {
		if err := s.UserPoolConfig.Validate(); err != nil {
			invalidParams.AddNested("UserPoolConfig", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateGraphqlApiInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.AuthenticationType) > 0 {
		v := s.AuthenticationType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authenticationType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.LogConfig != nil {
		v := s.LogConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logConfig", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OpenIDConnectConfig != nil {
		v := s.OpenIDConnectConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "openIDConnectConfig", v, metadata)
	}
	if s.UserPoolConfig != nil {
		v := s.UserPoolConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "userPoolConfig", v, metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateGraphqlApiResponse
type UpdateGraphqlApiOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The updated GraphqlApi object.
	GraphqlApi *GraphqlApi `locationName:"graphqlApi" type:"structure"`
}

// String returns the string representation
func (s UpdateGraphqlApiOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGraphqlApiOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateGraphqlApiOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateGraphqlApiOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.GraphqlApi != nil {
		v := s.GraphqlApi

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "graphqlApi", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateResolverRequest
type UpdateResolverInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The new data source name.
	//
	// DataSourceName is a required field
	DataSourceName *string `locationName:"dataSourceName" type:"string" required:"true"`

	// The new field name.
	//
	// FieldName is a required field
	FieldName *string `location:"uri" locationName:"fieldName" type:"string" required:"true"`

	// The new request mapping template.
	//
	// RequestMappingTemplate is a required field
	RequestMappingTemplate *string `locationName:"requestMappingTemplate" min:"1" type:"string" required:"true"`

	// The new response mapping template.
	ResponseMappingTemplate *string `locationName:"responseMappingTemplate" min:"1" type:"string"`

	// The new type name.
	//
	// TypeName is a required field
	TypeName *string `location:"uri" locationName:"typeName" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateResolverInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateResolverInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateResolverInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateResolverInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}

	if s.DataSourceName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceName"))
	}

	if s.FieldName == nil {
		invalidParams.Add(aws.NewErrParamRequired("FieldName"))
	}

	if s.RequestMappingTemplate == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestMappingTemplate"))
	}
	if s.RequestMappingTemplate != nil && len(*s.RequestMappingTemplate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RequestMappingTemplate", 1))
	}
	if s.ResponseMappingTemplate != nil && len(*s.ResponseMappingTemplate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResponseMappingTemplate", 1))
	}

	if s.TypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypeName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateResolverInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.DataSourceName != nil {
		v := *s.DataSourceName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "dataSourceName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RequestMappingTemplate != nil {
		v := *s.RequestMappingTemplate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "requestMappingTemplate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResponseMappingTemplate != nil {
		v := *s.ResponseMappingTemplate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "responseMappingTemplate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FieldName != nil {
		v := *s.FieldName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "fieldName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateResolverResponse
type UpdateResolverOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The updated Resolver object.
	Resolver *Resolver `locationName:"resolver" type:"structure"`
}

// String returns the string representation
func (s UpdateResolverOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateResolverOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateResolverOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateResolverOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Resolver != nil {
		v := s.Resolver

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "resolver", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateTypeRequest
type UpdateTypeInput struct {
	_ struct{} `type:"structure"`

	// The API ID.
	//
	// ApiId is a required field
	ApiId *string `location:"uri" locationName:"apiId" type:"string" required:"true"`

	// The new definition.
	Definition *string `locationName:"definition" type:"string"`

	// The new type format: SDL or JSON.
	//
	// Format is a required field
	Format TypeDefinitionFormat `locationName:"format" type:"string" required:"true" enum:"true"`

	// The new type name.
	//
	// TypeName is a required field
	TypeName *string `location:"uri" locationName:"typeName" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateTypeInput"}

	if s.ApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiId"))
	}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}

	if s.TypeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TypeName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateTypeInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Definition != nil {
		v := *s.Definition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "definition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "format", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TypeName != nil {
		v := *s.TypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "typeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UpdateTypeResponse
type UpdateTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The updated Type object.
	Type *Type `locationName:"type" type:"structure"`
}

// String returns the string representation
func (s UpdateTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Type != nil {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "type", v, metadata)
	}
	return nil
}

// Describes an Amazon Cognito User Pool configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/appsync-2017-07-25/UserPoolConfig
type UserPoolConfig struct {
	_ struct{} `type:"structure"`

	// A regular expression for validating the incoming Amazon Cognito User Pool
	// app client ID.
	AppIdClientRegex *string `locationName:"appIdClientRegex" type:"string"`

	// The AWS region in which the user pool was created.
	//
	// AwsRegion is a required field
	AwsRegion *string `locationName:"awsRegion" type:"string" required:"true"`

	// The action that you want your GraphQL API to take when a request that uses
	// Amazon Cognito User Pool authentication doesn't match the Amazon Cognito
	// User Pool configuration.
	//
	// DefaultAction is a required field
	DefaultAction DefaultAction `locationName:"defaultAction" type:"string" required:"true" enum:"true"`

	// The user pool ID.
	//
	// UserPoolId is a required field
	UserPoolId *string `locationName:"userPoolId" type:"string" required:"true"`
}

// String returns the string representation
func (s UserPoolConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UserPoolConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UserPoolConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UserPoolConfig"}

	if s.AwsRegion == nil {
		invalidParams.Add(aws.NewErrParamRequired("AwsRegion"))
	}
	if len(s.DefaultAction) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("DefaultAction"))
	}

	if s.UserPoolId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UserPoolId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UserPoolConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.AppIdClientRegex != nil {
		v := *s.AppIdClientRegex

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "appIdClientRegex", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AwsRegion != nil {
		v := *s.AwsRegion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "awsRegion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.DefaultAction) > 0 {
		v := s.DefaultAction

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultAction", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.UserPoolId != nil {
		v := *s.UserPoolId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "userPoolId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type AuthenticationType string

// Enum values for AuthenticationType
const (
	AuthenticationTypeApiKey                 AuthenticationType = "API_KEY"
	AuthenticationTypeAwsIam                 AuthenticationType = "AWS_IAM"
	AuthenticationTypeAmazonCognitoUserPools AuthenticationType = "AMAZON_COGNITO_USER_POOLS"
	AuthenticationTypeOpenidConnect          AuthenticationType = "OPENID_CONNECT"
)

func (enum AuthenticationType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AuthenticationType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DataSourceType string

// Enum values for DataSourceType
const (
	DataSourceTypeAwsLambda           DataSourceType = "AWS_LAMBDA"
	DataSourceTypeAmazonDynamodb      DataSourceType = "AMAZON_DYNAMODB"
	DataSourceTypeAmazonElasticsearch DataSourceType = "AMAZON_ELASTICSEARCH"
	DataSourceTypeNone                DataSourceType = "NONE"
	DataSourceTypeHttp                DataSourceType = "HTTP"
)

func (enum DataSourceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DataSourceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DefaultAction string

// Enum values for DefaultAction
const (
	DefaultActionAllow DefaultAction = "ALLOW"
	DefaultActionDeny  DefaultAction = "DENY"
)

func (enum DefaultAction) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DefaultAction) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type FieldLogLevel string

// Enum values for FieldLogLevel
const (
	FieldLogLevelNone  FieldLogLevel = "NONE"
	FieldLogLevelError FieldLogLevel = "ERROR"
	FieldLogLevelAll   FieldLogLevel = "ALL"
)

func (enum FieldLogLevel) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum FieldLogLevel) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type OutputType string

// Enum values for OutputType
const (
	OutputTypeSdl  OutputType = "SDL"
	OutputTypeJson OutputType = "JSON"
)

func (enum OutputType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum OutputType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SchemaStatus string

// Enum values for SchemaStatus
const (
	SchemaStatusProcessing SchemaStatus = "PROCESSING"
	SchemaStatusActive     SchemaStatus = "ACTIVE"
	SchemaStatusDeleting   SchemaStatus = "DELETING"
)

func (enum SchemaStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SchemaStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type TypeDefinitionFormat string

// Enum values for TypeDefinitionFormat
const (
	TypeDefinitionFormatSdl  TypeDefinitionFormat = "SDL"
	TypeDefinitionFormatJson TypeDefinitionFormat = "JSON"
)

func (enum TypeDefinitionFormat) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum TypeDefinitionFormat) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
