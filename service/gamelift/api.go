// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package gamelift

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/jsonrpc"
)

const opAcceptMatch = "AcceptMatch"

// AcceptMatchRequest is a API request type for the AcceptMatch API operation.
type AcceptMatchRequest struct {
	*aws.Request
	Input *AcceptMatchInput
	Copy  func(*AcceptMatchInput) AcceptMatchRequest
}

// Send marshals and sends the AcceptMatch API request.
func (r AcceptMatchRequest) Send() (*AcceptMatchOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AcceptMatchOutput), nil
}

// AcceptMatchRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Registers a player's acceptance or rejection of a proposed FlexMatch match.
// A matchmaking configuration may require player acceptance; if so, then matches
// built with that configuration cannot be completed unless all players accept
// the proposed match within a specified time limit.
//
// When FlexMatch builds a match, all the matchmaking tickets involved in the
// proposed match are placed into status REQUIRES_ACCEPTANCE. This is a trigger
// for your game to get acceptance from all players in the ticket. Acceptances
// are only valid for tickets when they are in this status; all other acceptances
// result in an error.
//
// To register acceptance, specify the ticket ID, a response, and one or more
// players. Once all players have registered acceptance, the matchmaking tickets
// advance to status PLACING, where a new game session is created for the match.
//
// If any player rejects the match, or if acceptances are not received before
// a specified timeout, the proposed match is dropped. The matchmaking tickets
// are then handled in one of two ways: For tickets where all players accepted
// the match, the ticket status is returned to SEARCHING to find a new match.
// For tickets where one or more players failed to accept the match, the ticket
// status is set to FAILED, and processing is terminated. A new matchmaking
// request for these players can be submitted as needed.
//
// Matchmaking-related operations include:
//
//    * StartMatchmaking
//
//    * DescribeMatchmaking
//
//    * StopMatchmaking
//
//    * AcceptMatch
//
//    * StartMatchBackfill
//
//    // Example sending a request using the AcceptMatchRequest method.
//    req := client.AcceptMatchRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/AcceptMatch
func (c *GameLift) AcceptMatchRequest(input *AcceptMatchInput) AcceptMatchRequest {
	op := &aws.Operation{
		Name:       opAcceptMatch,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &AcceptMatchInput{}
	}

	output := &AcceptMatchOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AcceptMatchRequest{Request: req, Input: input, Copy: c.AcceptMatchRequest}
}

const opCreateAlias = "CreateAlias"

// CreateAliasRequest is a API request type for the CreateAlias API operation.
type CreateAliasRequest struct {
	*aws.Request
	Input *CreateAliasInput
	Copy  func(*CreateAliasInput) CreateAliasRequest
}

// Send marshals and sends the CreateAlias API request.
func (r CreateAliasRequest) Send() (*CreateAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateAliasOutput), nil
}

// CreateAliasRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Creates an alias for a fleet. In most situations, you can use an alias ID
// in place of a fleet ID. By using a fleet alias instead of a specific fleet
// ID, you can switch gameplay and players to a new fleet without changing your
// game client or other game components. For example, for games in production,
// using an alias allows you to seamlessly redirect your player base to a new
// game server update.
//
// Amazon GameLift supports two types of routing strategies for aliases: simple
// and terminal. A simple alias points to an active fleet. A terminal alias
// is used to display messaging or link to a URL instead of routing players
// to an active fleet. For example, you might use a terminal alias when a game
// version is no longer supported and you want to direct players to an upgrade
// site.
//
// To create a fleet alias, specify an alias name, routing strategy, and optional
// description. Each simple alias can point to only one fleet, but a fleet can
// have multiple aliases. If successful, a new alias record is returned, including
// an alias ID, which you can reference when creating a game session. You can
// reassign an alias to another fleet by calling UpdateAlias.
//
// Alias-related operations include:
//
//    * CreateAlias
//
//    * ListAliases
//
//    * DescribeAlias
//
//    * UpdateAlias
//
//    * DeleteAlias
//
//    * ResolveAlias
//
//    // Example sending a request using the CreateAliasRequest method.
//    req := client.CreateAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateAlias
func (c *GameLift) CreateAliasRequest(input *CreateAliasInput) CreateAliasRequest {
	op := &aws.Operation{
		Name:       opCreateAlias,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateAliasInput{}
	}

	output := &CreateAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateAliasRequest{Request: req, Input: input, Copy: c.CreateAliasRequest}
}

const opCreateBuild = "CreateBuild"

// CreateBuildRequest is a API request type for the CreateBuild API operation.
type CreateBuildRequest struct {
	*aws.Request
	Input *CreateBuildInput
	Copy  func(*CreateBuildInput) CreateBuildRequest
}

// Send marshals and sends the CreateBuild API request.
func (r CreateBuildRequest) Send() (*CreateBuildOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateBuildOutput), nil
}

// CreateBuildRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Creates a new Amazon GameLift build record for your game server binary files
// and points to the location of your game server build files in an Amazon Simple
// Storage Service (Amazon S3) location.
//
// Game server binaries must be combined into a .zip file for use with Amazon
// GameLift. See Uploading Your Game (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-build-intro.html)
// for more information.
//
// To create new builds quickly and easily, use the AWS CLI command upload-build
// (http://docs.aws.amazon.com/cli/latest/reference/gamelift/upload-build.html).
// This helper command uploads your build and creates a new build record in
// one step, and automatically handles the necessary permissions. See  Upload
// Build Files to Amazon GameLift (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-build-cli-uploading.html)
// for more help.
//
// The CreateBuild operation should be used only when you need to manually upload
// your build files, as in the following scenarios:
//
//    * Store a build file in an Amazon S3 bucket under your own AWS account.
//    To use this option, you must first give Amazon GameLift access to that
//    Amazon S3 bucket. See  Create a Build with Files in Amazon S3 (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-build-cli-uploading.html#gamelift-build-cli-uploading-create-build)
//    for detailed help. To create a new build record using files in your Amazon
//    S3 bucket, call CreateBuild and specify a build name, operating system,
//    and the storage location of your game build.
//
//    * Upload a build file directly to Amazon GameLift's Amazon S3 account.
//    To use this option, you first call CreateBuild with a build name and operating
//    system. This action creates a new build record and returns an Amazon S3
//    storage location (bucket and key only) and temporary access credentials.
//    Use the credentials to manually upload your build file to the storage
//    location (see the Amazon S3 topic Uploading Objects (http://docs.aws.amazon.com/AmazonS3/latest/dev/UploadingObjects.html)).
//    You can upload files to a location only once.
//
// If successful, this operation creates a new build record with a unique build
// ID and places it in INITIALIZED status. You can use DescribeBuild to check
// the status of your build. A build must be in READY status before it can be
// used to create fleets.
//
// Build-related operations include:
//
//    * CreateBuild
//
//    * ListBuilds
//
//    * DescribeBuild
//
//    * UpdateBuild
//
//    * DeleteBuild
//
//    // Example sending a request using the CreateBuildRequest method.
//    req := client.CreateBuildRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateBuild
func (c *GameLift) CreateBuildRequest(input *CreateBuildInput) CreateBuildRequest {
	op := &aws.Operation{
		Name:       opCreateBuild,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateBuildInput{}
	}

	output := &CreateBuildOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBuildRequest{Request: req, Input: input, Copy: c.CreateBuildRequest}
}

const opCreateFleet = "CreateFleet"

// CreateFleetRequest is a API request type for the CreateFleet API operation.
type CreateFleetRequest struct {
	*aws.Request
	Input *CreateFleetInput
	Copy  func(*CreateFleetInput) CreateFleetRequest
}

// Send marshals and sends the CreateFleet API request.
func (r CreateFleetRequest) Send() (*CreateFleetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateFleetOutput), nil
}

// CreateFleetRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Creates a new fleet to run your game servers. A fleet is a set of Amazon
// Elastic Compute Cloud (Amazon EC2) instances, each of which can run multiple
// server processes to host game sessions. You set up a fleet to use instances
// with certain hardware specifications (see Amazon EC2 Instance Types (http://aws.amazon.com/ec2/instance-types/)
// for more information), and deploy your game build to run on each instance.
//
// To create a new fleet, you must specify the following: (1) a fleet name,
// (2) the build ID of a successfully uploaded game build, (3) an EC2 instance
// type, and (4) a run-time configuration, which describes the server processes
// to run on each instance in the fleet. If you don't specify a fleet type (on-demand
// or spot), the new fleet uses on-demand instances by default.
//
// You can also configure the new fleet with the following settings:
//
//    * Fleet description
//
//    * Access permissions for inbound traffic
//
//    * Fleet-wide game session protection
//
//    * Resource usage limits
//
//    * VPC peering connection (see VPC Peering with Amazon GameLift Fleets
//    (http://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html))
//
// If you use Amazon CloudWatch for metrics, you can add the new fleet to a
// metric group. By adding multiple fleets to a metric group, you can view aggregated
// metrics for all the fleets in the group.
//
// If the CreateFleet call is successful, Amazon GameLift performs the following
// tasks. You can track the process of a fleet by checking the fleet status
// or by monitoring fleet creation events:
//
//    * Creates a fleet record. Status: NEW.
//
//    * Begins writing events to the fleet event log, which can be accessed
//    in the Amazon GameLift console.
//
// Sets the fleet's target capacity to 1 (desired instances), which triggers
//    Amazon GameLift to start one new EC2 instance.
//
//    * Downloads the game build to the new instance and installs it. Statuses:
//    DOWNLOADING, VALIDATING, BUILDING.
//
//    * Starts launching server processes on the instance. If the fleet is configured
//    to run multiple server processes per instance, Amazon GameLift staggers
//    each launch by a few seconds. Status: ACTIVATING.
//
//    * Sets the fleet's status to ACTIVE as soon as one server process is ready
//    to host a game session.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the CreateFleetRequest method.
//    req := client.CreateFleetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateFleet
func (c *GameLift) CreateFleetRequest(input *CreateFleetInput) CreateFleetRequest {
	op := &aws.Operation{
		Name:       opCreateFleet,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateFleetInput{}
	}

	output := &CreateFleetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateFleetRequest{Request: req, Input: input, Copy: c.CreateFleetRequest}
}

const opCreateGameSession = "CreateGameSession"

// CreateGameSessionRequest is a API request type for the CreateGameSession API operation.
type CreateGameSessionRequest struct {
	*aws.Request
	Input *CreateGameSessionInput
	Copy  func(*CreateGameSessionInput) CreateGameSessionRequest
}

// Send marshals and sends the CreateGameSession API request.
func (r CreateGameSessionRequest) Send() (*CreateGameSessionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateGameSessionOutput), nil
}

// CreateGameSessionRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Creates a multiplayer game session for players. This action creates a game
// session record and assigns an available server process in the specified fleet
// to host the game session. A fleet must have an ACTIVE status before a game
// session can be created in it.
//
// To create a game session, specify either fleet ID or alias ID and indicate
// a maximum number of players to allow in the game session. You can also provide
// a name and game-specific properties for this game session. If successful,
// a GameSession object is returned containing the game session properties and
// other settings you specified.
//
// Idempotency tokens. You can add a token that uniquely identifies game session
// requests. This is useful for ensuring that game session requests are idempotent.
// Multiple requests with the same idempotency token are processed only once;
// subsequent requests return the original result. All response values are the
// same with the exception of game session status, which may change.
//
// Resource creation limits. If you are creating a game session on a fleet with
// a resource creation limit policy in force, then you must specify a creator
// ID. Without this ID, Amazon GameLift has no way to evaluate the policy for
// this new game session request.
//
// Player acceptance policy. By default, newly created game sessions are open
// to new players. You can restrict new player access by using UpdateGameSession
// to change the game session's player session creation policy.
//
// Game session logs. Logs are retained for all active game sessions for 14
// days. To access the logs, call GetGameSessionLogUrl to download the log files.
//
// Available in Amazon GameLift Local.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the CreateGameSessionRequest method.
//    req := client.CreateGameSessionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateGameSession
func (c *GameLift) CreateGameSessionRequest(input *CreateGameSessionInput) CreateGameSessionRequest {
	op := &aws.Operation{
		Name:       opCreateGameSession,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateGameSessionInput{}
	}

	output := &CreateGameSessionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateGameSessionRequest{Request: req, Input: input, Copy: c.CreateGameSessionRequest}
}

const opCreateGameSessionQueue = "CreateGameSessionQueue"

// CreateGameSessionQueueRequest is a API request type for the CreateGameSessionQueue API operation.
type CreateGameSessionQueueRequest struct {
	*aws.Request
	Input *CreateGameSessionQueueInput
	Copy  func(*CreateGameSessionQueueInput) CreateGameSessionQueueRequest
}

// Send marshals and sends the CreateGameSessionQueue API request.
func (r CreateGameSessionQueueRequest) Send() (*CreateGameSessionQueueOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateGameSessionQueueOutput), nil
}

// CreateGameSessionQueueRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Establishes a new queue for processing requests to place new game sessions.
// A queue identifies where new game sessions can be hosted -- by specifying
// a list of destinations (fleets or aliases) -- and how long requests can wait
// in the queue before timing out. You can set up a queue to try to place game
// sessions on fleets in multiple regions. To add placement requests to a queue,
// call StartGameSessionPlacement and reference the queue name.
//
// Destination order. When processing a request for a game session, Amazon GameLift
// tries each destination in order until it finds one with available resources
// to host the new game session. A queue's default order is determined by how
// destinations are listed. The default order is overridden when a game session
// placement request provides player latency information. Player latency information
// enables Amazon GameLift to prioritize destinations where players report the
// lowest average latency, as a result placing the new game session where the
// majority of players will have the best possible gameplay experience.
//
// Player latency policies. For placement requests containing player latency
// information, use player latency policies to protect individual players from
// very high latencies. With a latency cap, even when a destination can deliver
// a low latency for most players, the game is not placed where any individual
// player is reporting latency higher than a policy's maximum. A queue can have
// multiple latency policies, which are enforced consecutively starting with
// the policy with the lowest latency cap. Use multiple policies to gradually
// relax latency controls; for example, you might set a policy with a low latency
// cap for the first 60 seconds, a second policy with a higher cap for the next
// 60 seconds, etc.
//
// To create a new queue, provide a name, timeout value, a list of destinations
// and, if desired, a set of latency policies. If successful, a new queue object
// is returned.
//
// Queue-related operations include:
//
//    * CreateGameSessionQueue
//
//    * DescribeGameSessionQueues
//
//    * UpdateGameSessionQueue
//
//    * DeleteGameSessionQueue
//
//    // Example sending a request using the CreateGameSessionQueueRequest method.
//    req := client.CreateGameSessionQueueRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateGameSessionQueue
func (c *GameLift) CreateGameSessionQueueRequest(input *CreateGameSessionQueueInput) CreateGameSessionQueueRequest {
	op := &aws.Operation{
		Name:       opCreateGameSessionQueue,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateGameSessionQueueInput{}
	}

	output := &CreateGameSessionQueueOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateGameSessionQueueRequest{Request: req, Input: input, Copy: c.CreateGameSessionQueueRequest}
}

const opCreateMatchmakingConfiguration = "CreateMatchmakingConfiguration"

// CreateMatchmakingConfigurationRequest is a API request type for the CreateMatchmakingConfiguration API operation.
type CreateMatchmakingConfigurationRequest struct {
	*aws.Request
	Input *CreateMatchmakingConfigurationInput
	Copy  func(*CreateMatchmakingConfigurationInput) CreateMatchmakingConfigurationRequest
}

// Send marshals and sends the CreateMatchmakingConfiguration API request.
func (r CreateMatchmakingConfigurationRequest) Send() (*CreateMatchmakingConfigurationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateMatchmakingConfigurationOutput), nil
}

// CreateMatchmakingConfigurationRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Defines a new matchmaking configuration for use with FlexMatch. A matchmaking
// configuration sets out guidelines for matching players and getting the matches
// into games. You can set up multiple matchmaking configurations to handle
// the scenarios needed for your game. Each matchmaking ticket (StartMatchmaking
// or StartMatchBackfill) specifies a configuration for the match and provides
// player attributes to support the configuration being used.
//
// To create a matchmaking configuration, at a minimum you must specify the
// following: configuration name; a rule set that governs how to evaluate players
// and find acceptable matches; a game session queue to use when placing a new
// game session for the match; and the maximum time allowed for a matchmaking
// attempt.
//
// Player acceptance -- In each configuration, you have the option to require
// that all players accept participation in a proposed match. To enable this
// feature, set AcceptanceRequired to true and specify a time limit for player
// acceptance. Players have the option to accept or reject a proposed match,
// and a match does not move ahead to game session placement unless all matched
// players accept.
//
// Matchmaking status notification -- There are two ways to track the progress
// of matchmaking tickets: (1) polling ticket status with DescribeMatchmaking;
// or (2) receiving notifications with Amazon Simple Notification Service (SNS).
// To use notifications, you first need to set up an SNS topic to receive the
// notifications, and provide the topic ARN in the matchmaking configuration
// (see  Setting up Notifications for Matchmaking (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-notification.html)).
// Since notifications promise only "best effort" delivery, we recommend calling
// DescribeMatchmaking if no notifications are received within 30 seconds.
//
// Operations related to match configurations and rule sets include:
//
//    * CreateMatchmakingConfiguration
//
//    * DescribeMatchmakingConfigurations
//
//    * UpdateMatchmakingConfiguration
//
//    * DeleteMatchmakingConfiguration
//
//    * CreateMatchmakingRuleSet
//
//    * DescribeMatchmakingRuleSets
//
//    * ValidateMatchmakingRuleSet
//
//    // Example sending a request using the CreateMatchmakingConfigurationRequest method.
//    req := client.CreateMatchmakingConfigurationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateMatchmakingConfiguration
func (c *GameLift) CreateMatchmakingConfigurationRequest(input *CreateMatchmakingConfigurationInput) CreateMatchmakingConfigurationRequest {
	op := &aws.Operation{
		Name:       opCreateMatchmakingConfiguration,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateMatchmakingConfigurationInput{}
	}

	output := &CreateMatchmakingConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateMatchmakingConfigurationRequest{Request: req, Input: input, Copy: c.CreateMatchmakingConfigurationRequest}
}

const opCreateMatchmakingRuleSet = "CreateMatchmakingRuleSet"

// CreateMatchmakingRuleSetRequest is a API request type for the CreateMatchmakingRuleSet API operation.
type CreateMatchmakingRuleSetRequest struct {
	*aws.Request
	Input *CreateMatchmakingRuleSetInput
	Copy  func(*CreateMatchmakingRuleSetInput) CreateMatchmakingRuleSetRequest
}

// Send marshals and sends the CreateMatchmakingRuleSet API request.
func (r CreateMatchmakingRuleSetRequest) Send() (*CreateMatchmakingRuleSetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateMatchmakingRuleSetOutput), nil
}

// CreateMatchmakingRuleSetRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Creates a new rule set for FlexMatch matchmaking. A rule set describes the
// type of match to create, such as the number and size of teams, and sets the
// parameters for acceptable player matches, such as minimum skill level or
// character type. Rule sets are used in matchmaking configurations, which define
// how matchmaking requests are handled. Each MatchmakingConfiguration uses
// one rule set; you can set up multiple rule sets to handle the scenarios that
// suit your game (such as for different game modes), and create a separate
// matchmaking configuration for each rule set. See additional information on
// rule set content in the MatchmakingRuleSet structure. For help creating rule
// sets, including useful examples, see the topic  Adding FlexMatch to Your
// Game (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-intro.html).
//
// Once created, matchmaking rule sets cannot be changed or deleted, so we recommend
// checking the rule set syntax using ValidateMatchmakingRuleSet before creating
// the rule set.
//
// To create a matchmaking rule set, provide the set of rules and a unique name.
// Rule sets must be defined in the same region as the matchmaking configuration
// they will be used with. Rule sets cannot be edited or deleted. If you need
// to change a rule set, create a new one with the necessary edits and then
// update matchmaking configurations to use the new rule set.
//
// Operations related to match configurations and rule sets include:
//
//    * CreateMatchmakingConfiguration
//
//    * DescribeMatchmakingConfigurations
//
//    * UpdateMatchmakingConfiguration
//
//    * DeleteMatchmakingConfiguration
//
//    * CreateMatchmakingRuleSet
//
//    * DescribeMatchmakingRuleSets
//
//    * ValidateMatchmakingRuleSet
//
//    // Example sending a request using the CreateMatchmakingRuleSetRequest method.
//    req := client.CreateMatchmakingRuleSetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateMatchmakingRuleSet
func (c *GameLift) CreateMatchmakingRuleSetRequest(input *CreateMatchmakingRuleSetInput) CreateMatchmakingRuleSetRequest {
	op := &aws.Operation{
		Name:       opCreateMatchmakingRuleSet,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateMatchmakingRuleSetInput{}
	}

	output := &CreateMatchmakingRuleSetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateMatchmakingRuleSetRequest{Request: req, Input: input, Copy: c.CreateMatchmakingRuleSetRequest}
}

const opCreatePlayerSession = "CreatePlayerSession"

// CreatePlayerSessionRequest is a API request type for the CreatePlayerSession API operation.
type CreatePlayerSessionRequest struct {
	*aws.Request
	Input *CreatePlayerSessionInput
	Copy  func(*CreatePlayerSessionInput) CreatePlayerSessionRequest
}

// Send marshals and sends the CreatePlayerSession API request.
func (r CreatePlayerSessionRequest) Send() (*CreatePlayerSessionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreatePlayerSessionOutput), nil
}

// CreatePlayerSessionRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Adds a player to a game session and creates a player session record. Before
// a player can be added, a game session must have an ACTIVE status, have a
// creation policy of ALLOW_ALL, and have an open player slot. To add a group
// of players to a game session, use CreatePlayerSessions.
//
// To create a player session, specify a game session ID, player ID, and optionally
// a string of player data. If successful, the player is added to the game session
// and a new PlayerSession object is returned. Player sessions cannot be updated.
//
// Available in Amazon GameLift Local.
//
// Player-session-related operations include:
//
//    * CreatePlayerSession
//
//    * CreatePlayerSessions
//
//    * DescribePlayerSessions
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the CreatePlayerSessionRequest method.
//    req := client.CreatePlayerSessionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreatePlayerSession
func (c *GameLift) CreatePlayerSessionRequest(input *CreatePlayerSessionInput) CreatePlayerSessionRequest {
	op := &aws.Operation{
		Name:       opCreatePlayerSession,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreatePlayerSessionInput{}
	}

	output := &CreatePlayerSessionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreatePlayerSessionRequest{Request: req, Input: input, Copy: c.CreatePlayerSessionRequest}
}

const opCreatePlayerSessions = "CreatePlayerSessions"

// CreatePlayerSessionsRequest is a API request type for the CreatePlayerSessions API operation.
type CreatePlayerSessionsRequest struct {
	*aws.Request
	Input *CreatePlayerSessionsInput
	Copy  func(*CreatePlayerSessionsInput) CreatePlayerSessionsRequest
}

// Send marshals and sends the CreatePlayerSessions API request.
func (r CreatePlayerSessionsRequest) Send() (*CreatePlayerSessionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreatePlayerSessionsOutput), nil
}

// CreatePlayerSessionsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Adds a group of players to a game session. This action is useful with a team
// matching feature. Before players can be added, a game session must have an
// ACTIVE status, have a creation policy of ALLOW_ALL, and have an open player
// slot. To add a single player to a game session, use CreatePlayerSession.
//
// To create player sessions, specify a game session ID, a list of player IDs,
// and optionally a set of player data strings. If successful, the players are
// added to the game session and a set of new PlayerSession objects is returned.
// Player sessions cannot be updated.
//
// Available in Amazon GameLift Local.
//
// Player-session-related operations include:
//
//    * CreatePlayerSession
//
//    * CreatePlayerSessions
//
//    * DescribePlayerSessions
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the CreatePlayerSessionsRequest method.
//    req := client.CreatePlayerSessionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreatePlayerSessions
func (c *GameLift) CreatePlayerSessionsRequest(input *CreatePlayerSessionsInput) CreatePlayerSessionsRequest {
	op := &aws.Operation{
		Name:       opCreatePlayerSessions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreatePlayerSessionsInput{}
	}

	output := &CreatePlayerSessionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreatePlayerSessionsRequest{Request: req, Input: input, Copy: c.CreatePlayerSessionsRequest}
}

const opCreateVpcPeeringAuthorization = "CreateVpcPeeringAuthorization"

// CreateVpcPeeringAuthorizationRequest is a API request type for the CreateVpcPeeringAuthorization API operation.
type CreateVpcPeeringAuthorizationRequest struct {
	*aws.Request
	Input *CreateVpcPeeringAuthorizationInput
	Copy  func(*CreateVpcPeeringAuthorizationInput) CreateVpcPeeringAuthorizationRequest
}

// Send marshals and sends the CreateVpcPeeringAuthorization API request.
func (r CreateVpcPeeringAuthorizationRequest) Send() (*CreateVpcPeeringAuthorizationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateVpcPeeringAuthorizationOutput), nil
}

// CreateVpcPeeringAuthorizationRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Requests authorization to create or delete a peer connection between the
// VPC for your Amazon GameLift fleet and a virtual private cloud (VPC) in your
// AWS account. VPC peering enables the game servers on your fleet to communicate
// directly with other AWS resources. Once you've received authorization, call
// CreateVpcPeeringConnection to establish the peering connection. For more
// information, see VPC Peering with Amazon GameLift Fleets (http://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html).
//
// You can peer with VPCs that are owned by any AWS account you have access
// to, including the account that you use to manage your Amazon GameLift fleets.
// You cannot peer with VPCs that are in different regions.
//
// To request authorization to create a connection, call this operation from
// the AWS account with the VPC that you want to peer to your Amazon GameLift
// fleet. For example, to enable your game servers to retrieve data from a DynamoDB
// table, use the account that manages that DynamoDB resource. Identify the
// following values: (1) The ID of the VPC that you want to peer with, and (2)
// the ID of the AWS account that you use to manage Amazon GameLift. If successful,
// VPC peering is authorized for the specified VPC.
//
// To request authorization to delete a connection, call this operation from
// the AWS account with the VPC that is peered with your Amazon GameLift fleet.
// Identify the following values: (1) VPC ID that you want to delete the peering
// connection for, and (2) ID of the AWS account that you use to manage Amazon
// GameLift.
//
// The authorization remains valid for 24 hours unless it is canceled by a call
// to DeleteVpcPeeringAuthorization. You must create or delete the peering connection
// while the authorization is valid.
//
// VPC peering connection operations include:
//
//    * CreateVpcPeeringAuthorization
//
//    * DescribeVpcPeeringAuthorizations
//
//    * DeleteVpcPeeringAuthorization
//
//    * CreateVpcPeeringConnection
//
//    * DescribeVpcPeeringConnections
//
//    * DeleteVpcPeeringConnection
//
//    // Example sending a request using the CreateVpcPeeringAuthorizationRequest method.
//    req := client.CreateVpcPeeringAuthorizationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateVpcPeeringAuthorization
func (c *GameLift) CreateVpcPeeringAuthorizationRequest(input *CreateVpcPeeringAuthorizationInput) CreateVpcPeeringAuthorizationRequest {
	op := &aws.Operation{
		Name:       opCreateVpcPeeringAuthorization,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateVpcPeeringAuthorizationInput{}
	}

	output := &CreateVpcPeeringAuthorizationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateVpcPeeringAuthorizationRequest{Request: req, Input: input, Copy: c.CreateVpcPeeringAuthorizationRequest}
}

const opCreateVpcPeeringConnection = "CreateVpcPeeringConnection"

// CreateVpcPeeringConnectionRequest is a API request type for the CreateVpcPeeringConnection API operation.
type CreateVpcPeeringConnectionRequest struct {
	*aws.Request
	Input *CreateVpcPeeringConnectionInput
	Copy  func(*CreateVpcPeeringConnectionInput) CreateVpcPeeringConnectionRequest
}

// Send marshals and sends the CreateVpcPeeringConnection API request.
func (r CreateVpcPeeringConnectionRequest) Send() (*CreateVpcPeeringConnectionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateVpcPeeringConnectionOutput), nil
}

// CreateVpcPeeringConnectionRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Establishes a VPC peering connection between a virtual private cloud (VPC)
// in an AWS account with the VPC for your Amazon GameLift fleet. VPC peering
// enables the game servers on your fleet to communicate directly with other
// AWS resources. You can peer with VPCs in any AWS account that you have access
// to, including the account that you use to manage your Amazon GameLift fleets.
// You cannot peer with VPCs that are in different regions. For more information,
// see VPC Peering with Amazon GameLift Fleets (http://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html).
//
// Before calling this operation to establish the peering connection, you first
// need to call CreateVpcPeeringAuthorization and identify the VPC you want
// to peer with. Once the authorization for the specified VPC is issued, you
// have 24 hours to establish the connection. These two operations handle all
// tasks necessary to peer the two VPCs, including acceptance, updating routing
// tables, etc.
//
// To establish the connection, call this operation from the AWS account that
// is used to manage the Amazon GameLift fleets. Identify the following values:
// (1) The ID of the fleet you want to be enable a VPC peering connection for;
// (2) The AWS account with the VPC that you want to peer with; and (3) The
// ID of the VPC you want to peer with. This operation is asynchronous. If successful,
// a VpcPeeringConnection request is created. You can use continuous polling
// to track the request's status using DescribeVpcPeeringConnections, or by
// monitoring fleet events for success or failure using DescribeFleetEvents.
//
// VPC peering connection operations include:
//
//    * CreateVpcPeeringAuthorization
//
//    * DescribeVpcPeeringAuthorizations
//
//    * DeleteVpcPeeringAuthorization
//
//    * CreateVpcPeeringConnection
//
//    * DescribeVpcPeeringConnections
//
//    * DeleteVpcPeeringConnection
//
//    // Example sending a request using the CreateVpcPeeringConnectionRequest method.
//    req := client.CreateVpcPeeringConnectionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateVpcPeeringConnection
func (c *GameLift) CreateVpcPeeringConnectionRequest(input *CreateVpcPeeringConnectionInput) CreateVpcPeeringConnectionRequest {
	op := &aws.Operation{
		Name:       opCreateVpcPeeringConnection,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateVpcPeeringConnectionInput{}
	}

	output := &CreateVpcPeeringConnectionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateVpcPeeringConnectionRequest{Request: req, Input: input, Copy: c.CreateVpcPeeringConnectionRequest}
}

const opDeleteAlias = "DeleteAlias"

// DeleteAliasRequest is a API request type for the DeleteAlias API operation.
type DeleteAliasRequest struct {
	*aws.Request
	Input *DeleteAliasInput
	Copy  func(*DeleteAliasInput) DeleteAliasRequest
}

// Send marshals and sends the DeleteAlias API request.
func (r DeleteAliasRequest) Send() (*DeleteAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteAliasOutput), nil
}

// DeleteAliasRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Deletes an alias. This action removes all record of the alias. Game clients
// attempting to access a server process using the deleted alias receive an
// error. To delete an alias, specify the alias ID to be deleted.
//
// Alias-related operations include:
//
//    * CreateAlias
//
//    * ListAliases
//
//    * DescribeAlias
//
//    * UpdateAlias
//
//    * DeleteAlias
//
//    * ResolveAlias
//
//    // Example sending a request using the DeleteAliasRequest method.
//    req := client.DeleteAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteAlias
func (c *GameLift) DeleteAliasRequest(input *DeleteAliasInput) DeleteAliasRequest {
	op := &aws.Operation{
		Name:       opDeleteAlias,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteAliasInput{}
	}

	output := &DeleteAliasOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(jsonrpc.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteAliasRequest{Request: req, Input: input, Copy: c.DeleteAliasRequest}
}

const opDeleteBuild = "DeleteBuild"

// DeleteBuildRequest is a API request type for the DeleteBuild API operation.
type DeleteBuildRequest struct {
	*aws.Request
	Input *DeleteBuildInput
	Copy  func(*DeleteBuildInput) DeleteBuildRequest
}

// Send marshals and sends the DeleteBuild API request.
func (r DeleteBuildRequest) Send() (*DeleteBuildOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBuildOutput), nil
}

// DeleteBuildRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Deletes a build. This action permanently deletes the build record and any
// uploaded build files.
//
// To delete a build, specify its ID. Deleting a build does not affect the status
// of any active fleets using the build, but you can no longer create new fleets
// with the deleted build.
//
// Build-related operations include:
//
//    * CreateBuild
//
//    * ListBuilds
//
//    * DescribeBuild
//
//    * UpdateBuild
//
//    * DeleteBuild
//
//    // Example sending a request using the DeleteBuildRequest method.
//    req := client.DeleteBuildRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteBuild
func (c *GameLift) DeleteBuildRequest(input *DeleteBuildInput) DeleteBuildRequest {
	op := &aws.Operation{
		Name:       opDeleteBuild,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteBuildInput{}
	}

	output := &DeleteBuildOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(jsonrpc.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBuildRequest{Request: req, Input: input, Copy: c.DeleteBuildRequest}
}

const opDeleteFleet = "DeleteFleet"

// DeleteFleetRequest is a API request type for the DeleteFleet API operation.
type DeleteFleetRequest struct {
	*aws.Request
	Input *DeleteFleetInput
	Copy  func(*DeleteFleetInput) DeleteFleetRequest
}

// Send marshals and sends the DeleteFleet API request.
func (r DeleteFleetRequest) Send() (*DeleteFleetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteFleetOutput), nil
}

// DeleteFleetRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Deletes everything related to a fleet. Before deleting a fleet, you must
// set the fleet's desired capacity to zero. See UpdateFleetCapacity.
//
// This action removes the fleet's resources and the fleet record. Once a fleet
// is deleted, you can no longer use that fleet.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DeleteFleetRequest method.
//    req := client.DeleteFleetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteFleet
func (c *GameLift) DeleteFleetRequest(input *DeleteFleetInput) DeleteFleetRequest {
	op := &aws.Operation{
		Name:       opDeleteFleet,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteFleetInput{}
	}

	output := &DeleteFleetOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(jsonrpc.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteFleetRequest{Request: req, Input: input, Copy: c.DeleteFleetRequest}
}

const opDeleteGameSessionQueue = "DeleteGameSessionQueue"

// DeleteGameSessionQueueRequest is a API request type for the DeleteGameSessionQueue API operation.
type DeleteGameSessionQueueRequest struct {
	*aws.Request
	Input *DeleteGameSessionQueueInput
	Copy  func(*DeleteGameSessionQueueInput) DeleteGameSessionQueueRequest
}

// Send marshals and sends the DeleteGameSessionQueue API request.
func (r DeleteGameSessionQueueRequest) Send() (*DeleteGameSessionQueueOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteGameSessionQueueOutput), nil
}

// DeleteGameSessionQueueRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Deletes a game session queue. This action means that any StartGameSessionPlacement
// requests that reference this queue will fail. To delete a queue, specify
// the queue name.
//
// Queue-related operations include:
//
//    * CreateGameSessionQueue
//
//    * DescribeGameSessionQueues
//
//    * UpdateGameSessionQueue
//
//    * DeleteGameSessionQueue
//
//    // Example sending a request using the DeleteGameSessionQueueRequest method.
//    req := client.DeleteGameSessionQueueRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteGameSessionQueue
func (c *GameLift) DeleteGameSessionQueueRequest(input *DeleteGameSessionQueueInput) DeleteGameSessionQueueRequest {
	op := &aws.Operation{
		Name:       opDeleteGameSessionQueue,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteGameSessionQueueInput{}
	}

	output := &DeleteGameSessionQueueOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteGameSessionQueueRequest{Request: req, Input: input, Copy: c.DeleteGameSessionQueueRequest}
}

const opDeleteMatchmakingConfiguration = "DeleteMatchmakingConfiguration"

// DeleteMatchmakingConfigurationRequest is a API request type for the DeleteMatchmakingConfiguration API operation.
type DeleteMatchmakingConfigurationRequest struct {
	*aws.Request
	Input *DeleteMatchmakingConfigurationInput
	Copy  func(*DeleteMatchmakingConfigurationInput) DeleteMatchmakingConfigurationRequest
}

// Send marshals and sends the DeleteMatchmakingConfiguration API request.
func (r DeleteMatchmakingConfigurationRequest) Send() (*DeleteMatchmakingConfigurationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteMatchmakingConfigurationOutput), nil
}

// DeleteMatchmakingConfigurationRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Permanently removes a FlexMatch matchmaking configuration. To delete, specify
// the configuration name. A matchmaking configuration cannot be deleted if
// it is being used in any active matchmaking tickets.
//
// Operations related to match configurations and rule sets include:
//
//    * CreateMatchmakingConfiguration
//
//    * DescribeMatchmakingConfigurations
//
//    * UpdateMatchmakingConfiguration
//
//    * DeleteMatchmakingConfiguration
//
//    * CreateMatchmakingRuleSet
//
//    * DescribeMatchmakingRuleSets
//
//    * ValidateMatchmakingRuleSet
//
//    // Example sending a request using the DeleteMatchmakingConfigurationRequest method.
//    req := client.DeleteMatchmakingConfigurationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteMatchmakingConfiguration
func (c *GameLift) DeleteMatchmakingConfigurationRequest(input *DeleteMatchmakingConfigurationInput) DeleteMatchmakingConfigurationRequest {
	op := &aws.Operation{
		Name:       opDeleteMatchmakingConfiguration,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteMatchmakingConfigurationInput{}
	}

	output := &DeleteMatchmakingConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteMatchmakingConfigurationRequest{Request: req, Input: input, Copy: c.DeleteMatchmakingConfigurationRequest}
}

const opDeleteScalingPolicy = "DeleteScalingPolicy"

// DeleteScalingPolicyRequest is a API request type for the DeleteScalingPolicy API operation.
type DeleteScalingPolicyRequest struct {
	*aws.Request
	Input *DeleteScalingPolicyInput
	Copy  func(*DeleteScalingPolicyInput) DeleteScalingPolicyRequest
}

// Send marshals and sends the DeleteScalingPolicy API request.
func (r DeleteScalingPolicyRequest) Send() (*DeleteScalingPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteScalingPolicyOutput), nil
}

// DeleteScalingPolicyRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Deletes a fleet scaling policy. This action means that the policy is no longer
// in force and removes all record of it. To delete a scaling policy, specify
// both the scaling policy name and the fleet ID it is associated with.
//
// To temporarily suspend scaling policies, call StopFleetActions. This operation
// suspends all policies for the fleet.
//
// Operations related to fleet capacity scaling include:
//
//    * DescribeFleetCapacity
//
//    * UpdateFleetCapacity
//
//    * DescribeEC2InstanceLimits
//
//    * Manage scaling policies:
//
// PutScalingPolicy (auto-scaling)
//
// DescribeScalingPolicies (auto-scaling)
//
// DeleteScalingPolicy (auto-scaling)
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DeleteScalingPolicyRequest method.
//    req := client.DeleteScalingPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteScalingPolicy
func (c *GameLift) DeleteScalingPolicyRequest(input *DeleteScalingPolicyInput) DeleteScalingPolicyRequest {
	op := &aws.Operation{
		Name:       opDeleteScalingPolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteScalingPolicyInput{}
	}

	output := &DeleteScalingPolicyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(jsonrpc.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteScalingPolicyRequest{Request: req, Input: input, Copy: c.DeleteScalingPolicyRequest}
}

const opDeleteVpcPeeringAuthorization = "DeleteVpcPeeringAuthorization"

// DeleteVpcPeeringAuthorizationRequest is a API request type for the DeleteVpcPeeringAuthorization API operation.
type DeleteVpcPeeringAuthorizationRequest struct {
	*aws.Request
	Input *DeleteVpcPeeringAuthorizationInput
	Copy  func(*DeleteVpcPeeringAuthorizationInput) DeleteVpcPeeringAuthorizationRequest
}

// Send marshals and sends the DeleteVpcPeeringAuthorization API request.
func (r DeleteVpcPeeringAuthorizationRequest) Send() (*DeleteVpcPeeringAuthorizationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteVpcPeeringAuthorizationOutput), nil
}

// DeleteVpcPeeringAuthorizationRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Cancels a pending VPC peering authorization for the specified VPC. If the
// authorization has already been used to create a peering connection, call
// DeleteVpcPeeringConnection to remove the connection.
//
// VPC peering connection operations include:
//
//    * CreateVpcPeeringAuthorization
//
//    * DescribeVpcPeeringAuthorizations
//
//    * DeleteVpcPeeringAuthorization
//
//    * CreateVpcPeeringConnection
//
//    * DescribeVpcPeeringConnections
//
//    * DeleteVpcPeeringConnection
//
//    // Example sending a request using the DeleteVpcPeeringAuthorizationRequest method.
//    req := client.DeleteVpcPeeringAuthorizationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteVpcPeeringAuthorization
func (c *GameLift) DeleteVpcPeeringAuthorizationRequest(input *DeleteVpcPeeringAuthorizationInput) DeleteVpcPeeringAuthorizationRequest {
	op := &aws.Operation{
		Name:       opDeleteVpcPeeringAuthorization,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteVpcPeeringAuthorizationInput{}
	}

	output := &DeleteVpcPeeringAuthorizationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteVpcPeeringAuthorizationRequest{Request: req, Input: input, Copy: c.DeleteVpcPeeringAuthorizationRequest}
}

const opDeleteVpcPeeringConnection = "DeleteVpcPeeringConnection"

// DeleteVpcPeeringConnectionRequest is a API request type for the DeleteVpcPeeringConnection API operation.
type DeleteVpcPeeringConnectionRequest struct {
	*aws.Request
	Input *DeleteVpcPeeringConnectionInput
	Copy  func(*DeleteVpcPeeringConnectionInput) DeleteVpcPeeringConnectionRequest
}

// Send marshals and sends the DeleteVpcPeeringConnection API request.
func (r DeleteVpcPeeringConnectionRequest) Send() (*DeleteVpcPeeringConnectionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteVpcPeeringConnectionOutput), nil
}

// DeleteVpcPeeringConnectionRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Removes a VPC peering connection. To delete the connection, you must have
// a valid authorization for the VPC peering connection that you want to delete.
// You can check for an authorization by calling DescribeVpcPeeringAuthorizations
// or request a new one using CreateVpcPeeringAuthorization.
//
// Once a valid authorization exists, call this operation from the AWS account
// that is used to manage the Amazon GameLift fleets. Identify the connection
// to delete by the connection ID and fleet ID. If successful, the connection
// is removed.
//
// VPC peering connection operations include:
//
//    * CreateVpcPeeringAuthorization
//
//    * DescribeVpcPeeringAuthorizations
//
//    * DeleteVpcPeeringAuthorization
//
//    * CreateVpcPeeringConnection
//
//    * DescribeVpcPeeringConnections
//
//    * DeleteVpcPeeringConnection
//
//    // Example sending a request using the DeleteVpcPeeringConnectionRequest method.
//    req := client.DeleteVpcPeeringConnectionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteVpcPeeringConnection
func (c *GameLift) DeleteVpcPeeringConnectionRequest(input *DeleteVpcPeeringConnectionInput) DeleteVpcPeeringConnectionRequest {
	op := &aws.Operation{
		Name:       opDeleteVpcPeeringConnection,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteVpcPeeringConnectionInput{}
	}

	output := &DeleteVpcPeeringConnectionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteVpcPeeringConnectionRequest{Request: req, Input: input, Copy: c.DeleteVpcPeeringConnectionRequest}
}

const opDescribeAlias = "DescribeAlias"

// DescribeAliasRequest is a API request type for the DescribeAlias API operation.
type DescribeAliasRequest struct {
	*aws.Request
	Input *DescribeAliasInput
	Copy  func(*DescribeAliasInput) DescribeAliasRequest
}

// Send marshals and sends the DescribeAlias API request.
func (r DescribeAliasRequest) Send() (*DescribeAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeAliasOutput), nil
}

// DescribeAliasRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves properties for an alias. This operation returns all alias metadata
// and settings. To get an alias's target fleet ID only, use ResolveAlias.
//
// To get alias properties, specify the alias ID. If successful, the requested
// alias record is returned.
//
// Alias-related operations include:
//
//    * CreateAlias
//
//    * ListAliases
//
//    * DescribeAlias
//
//    * UpdateAlias
//
//    * DeleteAlias
//
//    * ResolveAlias
//
//    // Example sending a request using the DescribeAliasRequest method.
//    req := client.DescribeAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeAlias
func (c *GameLift) DescribeAliasRequest(input *DescribeAliasInput) DescribeAliasRequest {
	op := &aws.Operation{
		Name:       opDescribeAlias,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeAliasInput{}
	}

	output := &DescribeAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeAliasRequest{Request: req, Input: input, Copy: c.DescribeAliasRequest}
}

const opDescribeBuild = "DescribeBuild"

// DescribeBuildRequest is a API request type for the DescribeBuild API operation.
type DescribeBuildRequest struct {
	*aws.Request
	Input *DescribeBuildInput
	Copy  func(*DescribeBuildInput) DescribeBuildRequest
}

// Send marshals and sends the DescribeBuild API request.
func (r DescribeBuildRequest) Send() (*DescribeBuildOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeBuildOutput), nil
}

// DescribeBuildRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves properties for a build. To request a build record, specify a build
// ID. If successful, an object containing the build properties is returned.
//
// Build-related operations include:
//
//    * CreateBuild
//
//    * ListBuilds
//
//    * DescribeBuild
//
//    * UpdateBuild
//
//    * DeleteBuild
//
//    // Example sending a request using the DescribeBuildRequest method.
//    req := client.DescribeBuildRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeBuild
func (c *GameLift) DescribeBuildRequest(input *DescribeBuildInput) DescribeBuildRequest {
	op := &aws.Operation{
		Name:       opDescribeBuild,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeBuildInput{}
	}

	output := &DescribeBuildOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeBuildRequest{Request: req, Input: input, Copy: c.DescribeBuildRequest}
}

const opDescribeEC2InstanceLimits = "DescribeEC2InstanceLimits"

// DescribeEC2InstanceLimitsRequest is a API request type for the DescribeEC2InstanceLimits API operation.
type DescribeEC2InstanceLimitsRequest struct {
	*aws.Request
	Input *DescribeEC2InstanceLimitsInput
	Copy  func(*DescribeEC2InstanceLimitsInput) DescribeEC2InstanceLimitsRequest
}

// Send marshals and sends the DescribeEC2InstanceLimits API request.
func (r DescribeEC2InstanceLimitsRequest) Send() (*DescribeEC2InstanceLimitsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeEC2InstanceLimitsOutput), nil
}

// DescribeEC2InstanceLimitsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the following information for the specified EC2 instance type:
//
//    * maximum number of instances allowed per AWS account (service limit)
//
//    * current usage level for the AWS account
//
// Service limits vary depending on region. Available regions for Amazon GameLift
// can be found in the AWS Management Console for Amazon GameLift (see the drop-down
// list in the upper right corner).
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DescribeEC2InstanceLimitsRequest method.
//    req := client.DescribeEC2InstanceLimitsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeEC2InstanceLimits
func (c *GameLift) DescribeEC2InstanceLimitsRequest(input *DescribeEC2InstanceLimitsInput) DescribeEC2InstanceLimitsRequest {
	op := &aws.Operation{
		Name:       opDescribeEC2InstanceLimits,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeEC2InstanceLimitsInput{}
	}

	output := &DescribeEC2InstanceLimitsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeEC2InstanceLimitsRequest{Request: req, Input: input, Copy: c.DescribeEC2InstanceLimitsRequest}
}

const opDescribeFleetAttributes = "DescribeFleetAttributes"

// DescribeFleetAttributesRequest is a API request type for the DescribeFleetAttributes API operation.
type DescribeFleetAttributesRequest struct {
	*aws.Request
	Input *DescribeFleetAttributesInput
	Copy  func(*DescribeFleetAttributesInput) DescribeFleetAttributesRequest
}

// Send marshals and sends the DescribeFleetAttributes API request.
func (r DescribeFleetAttributesRequest) Send() (*DescribeFleetAttributesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeFleetAttributesOutput), nil
}

// DescribeFleetAttributesRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves fleet properties, including metadata, status, and configuration,
// for one or more fleets. You can request attributes for all fleets, or specify
// a list of one or more fleet IDs. When requesting multiple fleets, use the
// pagination parameters to retrieve results as a set of sequential pages. If
// successful, a FleetAttributes object is returned for each requested fleet
// ID. When specifying a list of fleet IDs, attribute objects are returned only
// for fleets that currently exist.
//
// Some API actions may limit the number of fleet IDs allowed in one request.
// If a request exceeds this limit, the request fails and the error message
// includes the maximum allowed.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DescribeFleetAttributesRequest method.
//    req := client.DescribeFleetAttributesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetAttributes
func (c *GameLift) DescribeFleetAttributesRequest(input *DescribeFleetAttributesInput) DescribeFleetAttributesRequest {
	op := &aws.Operation{
		Name:       opDescribeFleetAttributes,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeFleetAttributesInput{}
	}

	output := &DescribeFleetAttributesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeFleetAttributesRequest{Request: req, Input: input, Copy: c.DescribeFleetAttributesRequest}
}

const opDescribeFleetCapacity = "DescribeFleetCapacity"

// DescribeFleetCapacityRequest is a API request type for the DescribeFleetCapacity API operation.
type DescribeFleetCapacityRequest struct {
	*aws.Request
	Input *DescribeFleetCapacityInput
	Copy  func(*DescribeFleetCapacityInput) DescribeFleetCapacityRequest
}

// Send marshals and sends the DescribeFleetCapacity API request.
func (r DescribeFleetCapacityRequest) Send() (*DescribeFleetCapacityOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeFleetCapacityOutput), nil
}

// DescribeFleetCapacityRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the current status of fleet capacity for one or more fleets. This
// information includes the number of instances that have been requested for
// the fleet and the number currently active. You can request capacity for all
// fleets, or specify a list of one or more fleet IDs. When requesting multiple
// fleets, use the pagination parameters to retrieve results as a set of sequential
// pages. If successful, a FleetCapacity object is returned for each requested
// fleet ID. When specifying a list of fleet IDs, attribute objects are returned
// only for fleets that currently exist.
//
// Some API actions may limit the number of fleet IDs allowed in one request.
// If a request exceeds this limit, the request fails and the error message
// includes the maximum allowed.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DescribeFleetCapacityRequest method.
//    req := client.DescribeFleetCapacityRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetCapacity
func (c *GameLift) DescribeFleetCapacityRequest(input *DescribeFleetCapacityInput) DescribeFleetCapacityRequest {
	op := &aws.Operation{
		Name:       opDescribeFleetCapacity,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeFleetCapacityInput{}
	}

	output := &DescribeFleetCapacityOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeFleetCapacityRequest{Request: req, Input: input, Copy: c.DescribeFleetCapacityRequest}
}

const opDescribeFleetEvents = "DescribeFleetEvents"

// DescribeFleetEventsRequest is a API request type for the DescribeFleetEvents API operation.
type DescribeFleetEventsRequest struct {
	*aws.Request
	Input *DescribeFleetEventsInput
	Copy  func(*DescribeFleetEventsInput) DescribeFleetEventsRequest
}

// Send marshals and sends the DescribeFleetEvents API request.
func (r DescribeFleetEventsRequest) Send() (*DescribeFleetEventsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeFleetEventsOutput), nil
}

// DescribeFleetEventsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves entries from the specified fleet's event log. You can specify a
// time range to limit the result set. Use the pagination parameters to retrieve
// results as a set of sequential pages. If successful, a collection of event
// log entries matching the request are returned.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DescribeFleetEventsRequest method.
//    req := client.DescribeFleetEventsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetEvents
func (c *GameLift) DescribeFleetEventsRequest(input *DescribeFleetEventsInput) DescribeFleetEventsRequest {
	op := &aws.Operation{
		Name:       opDescribeFleetEvents,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeFleetEventsInput{}
	}

	output := &DescribeFleetEventsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeFleetEventsRequest{Request: req, Input: input, Copy: c.DescribeFleetEventsRequest}
}

const opDescribeFleetPortSettings = "DescribeFleetPortSettings"

// DescribeFleetPortSettingsRequest is a API request type for the DescribeFleetPortSettings API operation.
type DescribeFleetPortSettingsRequest struct {
	*aws.Request
	Input *DescribeFleetPortSettingsInput
	Copy  func(*DescribeFleetPortSettingsInput) DescribeFleetPortSettingsRequest
}

// Send marshals and sends the DescribeFleetPortSettings API request.
func (r DescribeFleetPortSettingsRequest) Send() (*DescribeFleetPortSettingsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeFleetPortSettingsOutput), nil
}

// DescribeFleetPortSettingsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the inbound connection permissions for a fleet. Connection permissions
// include a range of IP addresses and port settings that incoming traffic can
// use to access server processes in the fleet. To get a fleet's inbound connection
// permissions, specify a fleet ID. If successful, a collection of IpPermission
// objects is returned for the requested fleet ID. If the requested fleet has
// been deleted, the result set is empty.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DescribeFleetPortSettingsRequest method.
//    req := client.DescribeFleetPortSettingsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetPortSettings
func (c *GameLift) DescribeFleetPortSettingsRequest(input *DescribeFleetPortSettingsInput) DescribeFleetPortSettingsRequest {
	op := &aws.Operation{
		Name:       opDescribeFleetPortSettings,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeFleetPortSettingsInput{}
	}

	output := &DescribeFleetPortSettingsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeFleetPortSettingsRequest{Request: req, Input: input, Copy: c.DescribeFleetPortSettingsRequest}
}

const opDescribeFleetUtilization = "DescribeFleetUtilization"

// DescribeFleetUtilizationRequest is a API request type for the DescribeFleetUtilization API operation.
type DescribeFleetUtilizationRequest struct {
	*aws.Request
	Input *DescribeFleetUtilizationInput
	Copy  func(*DescribeFleetUtilizationInput) DescribeFleetUtilizationRequest
}

// Send marshals and sends the DescribeFleetUtilization API request.
func (r DescribeFleetUtilizationRequest) Send() (*DescribeFleetUtilizationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeFleetUtilizationOutput), nil
}

// DescribeFleetUtilizationRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves utilization statistics for one or more fleets. You can request
// utilization data for all fleets, or specify a list of one or more fleet IDs.
// When requesting multiple fleets, use the pagination parameters to retrieve
// results as a set of sequential pages. If successful, a FleetUtilization object
// is returned for each requested fleet ID. When specifying a list of fleet
// IDs, utilization objects are returned only for fleets that currently exist.
//
// Some API actions may limit the number of fleet IDs allowed in one request.
// If a request exceeds this limit, the request fails and the error message
// includes the maximum allowed.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DescribeFleetUtilizationRequest method.
//    req := client.DescribeFleetUtilizationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetUtilization
func (c *GameLift) DescribeFleetUtilizationRequest(input *DescribeFleetUtilizationInput) DescribeFleetUtilizationRequest {
	op := &aws.Operation{
		Name:       opDescribeFleetUtilization,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeFleetUtilizationInput{}
	}

	output := &DescribeFleetUtilizationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeFleetUtilizationRequest{Request: req, Input: input, Copy: c.DescribeFleetUtilizationRequest}
}

const opDescribeGameSessionDetails = "DescribeGameSessionDetails"

// DescribeGameSessionDetailsRequest is a API request type for the DescribeGameSessionDetails API operation.
type DescribeGameSessionDetailsRequest struct {
	*aws.Request
	Input *DescribeGameSessionDetailsInput
	Copy  func(*DescribeGameSessionDetailsInput) DescribeGameSessionDetailsRequest
}

// Send marshals and sends the DescribeGameSessionDetails API request.
func (r DescribeGameSessionDetailsRequest) Send() (*DescribeGameSessionDetailsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeGameSessionDetailsOutput), nil
}

// DescribeGameSessionDetailsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves properties, including the protection policy in force, for one or
// more game sessions. This action can be used in several ways: (1) provide
// a GameSessionId or GameSessionArn to request details for a specific game
// session; (2) provide either a FleetId or an AliasId to request properties
// for all game sessions running on a fleet.
//
// To get game session record(s), specify just one of the following: game session
// ID, fleet ID, or alias ID. You can filter this request by game session status.
// Use the pagination parameters to retrieve results as a set of sequential
// pages. If successful, a GameSessionDetail object is returned for each session
// matching the request.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the DescribeGameSessionDetailsRequest method.
//    req := client.DescribeGameSessionDetailsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionDetails
func (c *GameLift) DescribeGameSessionDetailsRequest(input *DescribeGameSessionDetailsInput) DescribeGameSessionDetailsRequest {
	op := &aws.Operation{
		Name:       opDescribeGameSessionDetails,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeGameSessionDetailsInput{}
	}

	output := &DescribeGameSessionDetailsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeGameSessionDetailsRequest{Request: req, Input: input, Copy: c.DescribeGameSessionDetailsRequest}
}

const opDescribeGameSessionPlacement = "DescribeGameSessionPlacement"

// DescribeGameSessionPlacementRequest is a API request type for the DescribeGameSessionPlacement API operation.
type DescribeGameSessionPlacementRequest struct {
	*aws.Request
	Input *DescribeGameSessionPlacementInput
	Copy  func(*DescribeGameSessionPlacementInput) DescribeGameSessionPlacementRequest
}

// Send marshals and sends the DescribeGameSessionPlacement API request.
func (r DescribeGameSessionPlacementRequest) Send() (*DescribeGameSessionPlacementOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeGameSessionPlacementOutput), nil
}

// DescribeGameSessionPlacementRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves properties and current status of a game session placement request.
// To get game session placement details, specify the placement ID. If successful,
// a GameSessionPlacement object is returned.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the DescribeGameSessionPlacementRequest method.
//    req := client.DescribeGameSessionPlacementRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionPlacement
func (c *GameLift) DescribeGameSessionPlacementRequest(input *DescribeGameSessionPlacementInput) DescribeGameSessionPlacementRequest {
	op := &aws.Operation{
		Name:       opDescribeGameSessionPlacement,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeGameSessionPlacementInput{}
	}

	output := &DescribeGameSessionPlacementOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeGameSessionPlacementRequest{Request: req, Input: input, Copy: c.DescribeGameSessionPlacementRequest}
}

const opDescribeGameSessionQueues = "DescribeGameSessionQueues"

// DescribeGameSessionQueuesRequest is a API request type for the DescribeGameSessionQueues API operation.
type DescribeGameSessionQueuesRequest struct {
	*aws.Request
	Input *DescribeGameSessionQueuesInput
	Copy  func(*DescribeGameSessionQueuesInput) DescribeGameSessionQueuesRequest
}

// Send marshals and sends the DescribeGameSessionQueues API request.
func (r DescribeGameSessionQueuesRequest) Send() (*DescribeGameSessionQueuesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeGameSessionQueuesOutput), nil
}

// DescribeGameSessionQueuesRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the properties for one or more game session queues. When requesting
// multiple queues, use the pagination parameters to retrieve results as a set
// of sequential pages. If successful, a GameSessionQueue object is returned
// for each requested queue. When specifying a list of queues, objects are returned
// only for queues that currently exist in the region.
//
// Queue-related operations include:
//
//    * CreateGameSessionQueue
//
//    * DescribeGameSessionQueues
//
//    * UpdateGameSessionQueue
//
//    * DeleteGameSessionQueue
//
//    // Example sending a request using the DescribeGameSessionQueuesRequest method.
//    req := client.DescribeGameSessionQueuesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionQueues
func (c *GameLift) DescribeGameSessionQueuesRequest(input *DescribeGameSessionQueuesInput) DescribeGameSessionQueuesRequest {
	op := &aws.Operation{
		Name:       opDescribeGameSessionQueues,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeGameSessionQueuesInput{}
	}

	output := &DescribeGameSessionQueuesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeGameSessionQueuesRequest{Request: req, Input: input, Copy: c.DescribeGameSessionQueuesRequest}
}

const opDescribeGameSessions = "DescribeGameSessions"

// DescribeGameSessionsRequest is a API request type for the DescribeGameSessions API operation.
type DescribeGameSessionsRequest struct {
	*aws.Request
	Input *DescribeGameSessionsInput
	Copy  func(*DescribeGameSessionsInput) DescribeGameSessionsRequest
}

// Send marshals and sends the DescribeGameSessions API request.
func (r DescribeGameSessionsRequest) Send() (*DescribeGameSessionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeGameSessionsOutput), nil
}

// DescribeGameSessionsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves a set of one or more game sessions. Request a specific game session
// or request all game sessions on a fleet. Alternatively, use SearchGameSessions
// to request a set of active game sessions that are filtered by certain criteria.
// To retrieve protection policy settings for game sessions, use DescribeGameSessionDetails.
//
// To get game sessions, specify one of the following: game session ID, fleet
// ID, or alias ID. You can filter this request by game session status. Use
// the pagination parameters to retrieve results as a set of sequential pages.
// If successful, a GameSession object is returned for each game session matching
// the request.
//
// Available in Amazon GameLift Local.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the DescribeGameSessionsRequest method.
//    req := client.DescribeGameSessionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessions
func (c *GameLift) DescribeGameSessionsRequest(input *DescribeGameSessionsInput) DescribeGameSessionsRequest {
	op := &aws.Operation{
		Name:       opDescribeGameSessions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeGameSessionsInput{}
	}

	output := &DescribeGameSessionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeGameSessionsRequest{Request: req, Input: input, Copy: c.DescribeGameSessionsRequest}
}

const opDescribeInstances = "DescribeInstances"

// DescribeInstancesRequest is a API request type for the DescribeInstances API operation.
type DescribeInstancesRequest struct {
	*aws.Request
	Input *DescribeInstancesInput
	Copy  func(*DescribeInstancesInput) DescribeInstancesRequest
}

// Send marshals and sends the DescribeInstances API request.
func (r DescribeInstancesRequest) Send() (*DescribeInstancesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeInstancesOutput), nil
}

// DescribeInstancesRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves information about a fleet's instances, including instance IDs.
// Use this action to get details on all instances in the fleet or get details
// on one specific instance.
//
// To get a specific instance, specify fleet ID and instance ID. To get all
// instances in a fleet, specify a fleet ID only. Use the pagination parameters
// to retrieve results as a set of sequential pages. If successful, an Instance
// object is returned for each result.
//
//    // Example sending a request using the DescribeInstancesRequest method.
//    req := client.DescribeInstancesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeInstances
func (c *GameLift) DescribeInstancesRequest(input *DescribeInstancesInput) DescribeInstancesRequest {
	op := &aws.Operation{
		Name:       opDescribeInstances,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeInstancesInput{}
	}

	output := &DescribeInstancesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeInstancesRequest{Request: req, Input: input, Copy: c.DescribeInstancesRequest}
}

const opDescribeMatchmaking = "DescribeMatchmaking"

// DescribeMatchmakingRequest is a API request type for the DescribeMatchmaking API operation.
type DescribeMatchmakingRequest struct {
	*aws.Request
	Input *DescribeMatchmakingInput
	Copy  func(*DescribeMatchmakingInput) DescribeMatchmakingRequest
}

// Send marshals and sends the DescribeMatchmaking API request.
func (r DescribeMatchmakingRequest) Send() (*DescribeMatchmakingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeMatchmakingOutput), nil
}

// DescribeMatchmakingRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves one or more matchmaking tickets. Use this operation to retrieve
// ticket information, including status and--once a successful match is made--acquire
// connection information for the resulting new game session.
//
// You can use this operation to track the progress of matchmaking requests
// (through polling) as an alternative to using event notifications. See more
// details on tracking matchmaking requests through polling or notifications
// in StartMatchmaking.
//
// To request matchmaking tickets, provide a list of up to 10 ticket IDs. If
// the request is successful, a ticket object is returned for each requested
// ID that currently exists.
//
// Matchmaking-related operations include:
//
//    * StartMatchmaking
//
//    * DescribeMatchmaking
//
//    * StopMatchmaking
//
//    * AcceptMatch
//
//    * StartMatchBackfill
//
//    // Example sending a request using the DescribeMatchmakingRequest method.
//    req := client.DescribeMatchmakingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmaking
func (c *GameLift) DescribeMatchmakingRequest(input *DescribeMatchmakingInput) DescribeMatchmakingRequest {
	op := &aws.Operation{
		Name:       opDescribeMatchmaking,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeMatchmakingInput{}
	}

	output := &DescribeMatchmakingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeMatchmakingRequest{Request: req, Input: input, Copy: c.DescribeMatchmakingRequest}
}

const opDescribeMatchmakingConfigurations = "DescribeMatchmakingConfigurations"

// DescribeMatchmakingConfigurationsRequest is a API request type for the DescribeMatchmakingConfigurations API operation.
type DescribeMatchmakingConfigurationsRequest struct {
	*aws.Request
	Input *DescribeMatchmakingConfigurationsInput
	Copy  func(*DescribeMatchmakingConfigurationsInput) DescribeMatchmakingConfigurationsRequest
}

// Send marshals and sends the DescribeMatchmakingConfigurations API request.
func (r DescribeMatchmakingConfigurationsRequest) Send() (*DescribeMatchmakingConfigurationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeMatchmakingConfigurationsOutput), nil
}

// DescribeMatchmakingConfigurationsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the details of FlexMatch matchmaking configurations. with this
// operation, you have the following options: (1) retrieve all existing configurations,
// (2) provide the names of one or more configurations to retrieve, or (3) retrieve
// all configurations that use a specified rule set name. When requesting multiple
// items, use the pagination parameters to retrieve results as a set of sequential
// pages. If successful, a configuration is returned for each requested name.
// When specifying a list of names, only configurations that currently exist
// are returned.
//
// Operations related to match configurations and rule sets include:
//
//    * CreateMatchmakingConfiguration
//
//    * DescribeMatchmakingConfigurations
//
//    * UpdateMatchmakingConfiguration
//
//    * DeleteMatchmakingConfiguration
//
//    * CreateMatchmakingRuleSet
//
//    * DescribeMatchmakingRuleSets
//
//    * ValidateMatchmakingRuleSet
//
//    // Example sending a request using the DescribeMatchmakingConfigurationsRequest method.
//    req := client.DescribeMatchmakingConfigurationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmakingConfigurations
func (c *GameLift) DescribeMatchmakingConfigurationsRequest(input *DescribeMatchmakingConfigurationsInput) DescribeMatchmakingConfigurationsRequest {
	op := &aws.Operation{
		Name:       opDescribeMatchmakingConfigurations,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeMatchmakingConfigurationsInput{}
	}

	output := &DescribeMatchmakingConfigurationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeMatchmakingConfigurationsRequest{Request: req, Input: input, Copy: c.DescribeMatchmakingConfigurationsRequest}
}

const opDescribeMatchmakingRuleSets = "DescribeMatchmakingRuleSets"

// DescribeMatchmakingRuleSetsRequest is a API request type for the DescribeMatchmakingRuleSets API operation.
type DescribeMatchmakingRuleSetsRequest struct {
	*aws.Request
	Input *DescribeMatchmakingRuleSetsInput
	Copy  func(*DescribeMatchmakingRuleSetsInput) DescribeMatchmakingRuleSetsRequest
}

// Send marshals and sends the DescribeMatchmakingRuleSets API request.
func (r DescribeMatchmakingRuleSetsRequest) Send() (*DescribeMatchmakingRuleSetsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeMatchmakingRuleSetsOutput), nil
}

// DescribeMatchmakingRuleSetsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the details for FlexMatch matchmaking rule sets. You can request
// all existing rule sets for the region, or provide a list of one or more rule
// set names. When requesting multiple items, use the pagination parameters
// to retrieve results as a set of sequential pages. If successful, a rule set
// is returned for each requested name.
//
// Operations related to match configurations and rule sets include:
//
//    * CreateMatchmakingConfiguration
//
//    * DescribeMatchmakingConfigurations
//
//    * UpdateMatchmakingConfiguration
//
//    * DeleteMatchmakingConfiguration
//
//    * CreateMatchmakingRuleSet
//
//    * DescribeMatchmakingRuleSets
//
//    * ValidateMatchmakingRuleSet
//
//    // Example sending a request using the DescribeMatchmakingRuleSetsRequest method.
//    req := client.DescribeMatchmakingRuleSetsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmakingRuleSets
func (c *GameLift) DescribeMatchmakingRuleSetsRequest(input *DescribeMatchmakingRuleSetsInput) DescribeMatchmakingRuleSetsRequest {
	op := &aws.Operation{
		Name:       opDescribeMatchmakingRuleSets,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeMatchmakingRuleSetsInput{}
	}

	output := &DescribeMatchmakingRuleSetsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeMatchmakingRuleSetsRequest{Request: req, Input: input, Copy: c.DescribeMatchmakingRuleSetsRequest}
}

const opDescribePlayerSessions = "DescribePlayerSessions"

// DescribePlayerSessionsRequest is a API request type for the DescribePlayerSessions API operation.
type DescribePlayerSessionsRequest struct {
	*aws.Request
	Input *DescribePlayerSessionsInput
	Copy  func(*DescribePlayerSessionsInput) DescribePlayerSessionsRequest
}

// Send marshals and sends the DescribePlayerSessions API request.
func (r DescribePlayerSessionsRequest) Send() (*DescribePlayerSessionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribePlayerSessionsOutput), nil
}

// DescribePlayerSessionsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves properties for one or more player sessions. This action can be
// used in several ways: (1) provide a PlayerSessionId to request properties
// for a specific player session; (2) provide a GameSessionId to request properties
// for all player sessions in the specified game session; (3) provide a PlayerId
// to request properties for all player sessions of a specified player.
//
// To get game session record(s), specify only one of the following: a player
// session ID, a game session ID, or a player ID. You can filter this request
// by player session status. Use the pagination parameters to retrieve results
// as a set of sequential pages. If successful, a PlayerSession object is returned
// for each session matching the request.
//
// Available in Amazon GameLift Local.
//
// Player-session-related operations include:
//
//    * CreatePlayerSession
//
//    * CreatePlayerSessions
//
//    * DescribePlayerSessions
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the DescribePlayerSessionsRequest method.
//    req := client.DescribePlayerSessionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribePlayerSessions
func (c *GameLift) DescribePlayerSessionsRequest(input *DescribePlayerSessionsInput) DescribePlayerSessionsRequest {
	op := &aws.Operation{
		Name:       opDescribePlayerSessions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribePlayerSessionsInput{}
	}

	output := &DescribePlayerSessionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribePlayerSessionsRequest{Request: req, Input: input, Copy: c.DescribePlayerSessionsRequest}
}

const opDescribeRuntimeConfiguration = "DescribeRuntimeConfiguration"

// DescribeRuntimeConfigurationRequest is a API request type for the DescribeRuntimeConfiguration API operation.
type DescribeRuntimeConfigurationRequest struct {
	*aws.Request
	Input *DescribeRuntimeConfigurationInput
	Copy  func(*DescribeRuntimeConfigurationInput) DescribeRuntimeConfigurationRequest
}

// Send marshals and sends the DescribeRuntimeConfiguration API request.
func (r DescribeRuntimeConfigurationRequest) Send() (*DescribeRuntimeConfigurationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeRuntimeConfigurationOutput), nil
}

// DescribeRuntimeConfigurationRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the current run-time configuration for the specified fleet. The
// run-time configuration tells Amazon GameLift how to launch server processes
// on instances in the fleet.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DescribeRuntimeConfigurationRequest method.
//    req := client.DescribeRuntimeConfigurationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeRuntimeConfiguration
func (c *GameLift) DescribeRuntimeConfigurationRequest(input *DescribeRuntimeConfigurationInput) DescribeRuntimeConfigurationRequest {
	op := &aws.Operation{
		Name:       opDescribeRuntimeConfiguration,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeRuntimeConfigurationInput{}
	}

	output := &DescribeRuntimeConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeRuntimeConfigurationRequest{Request: req, Input: input, Copy: c.DescribeRuntimeConfigurationRequest}
}

const opDescribeScalingPolicies = "DescribeScalingPolicies"

// DescribeScalingPoliciesRequest is a API request type for the DescribeScalingPolicies API operation.
type DescribeScalingPoliciesRequest struct {
	*aws.Request
	Input *DescribeScalingPoliciesInput
	Copy  func(*DescribeScalingPoliciesInput) DescribeScalingPoliciesRequest
}

// Send marshals and sends the DescribeScalingPolicies API request.
func (r DescribeScalingPoliciesRequest) Send() (*DescribeScalingPoliciesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeScalingPoliciesOutput), nil
}

// DescribeScalingPoliciesRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves all scaling policies applied to a fleet.
//
// To get a fleet's scaling policies, specify the fleet ID. You can filter this
// request by policy status, such as to retrieve only active scaling policies.
// Use the pagination parameters to retrieve results as a set of sequential
// pages. If successful, set of ScalingPolicy objects is returned for the fleet.
//
// A fleet may have all of its scaling policies suspended (StopFleetActions).
// This action does not affect the status of the scaling policies, which remains
// ACTIVE. To see whether a fleet's scaling policies are in force or suspended,
// call DescribeFleetAttributes and check the stopped actions.
//
// Operations related to fleet capacity scaling include:
//
//    * DescribeFleetCapacity
//
//    * UpdateFleetCapacity
//
//    * DescribeEC2InstanceLimits
//
//    * Manage scaling policies:
//
// PutScalingPolicy (auto-scaling)
//
// DescribeScalingPolicies (auto-scaling)
//
// DeleteScalingPolicy (auto-scaling)
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the DescribeScalingPoliciesRequest method.
//    req := client.DescribeScalingPoliciesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeScalingPolicies
func (c *GameLift) DescribeScalingPoliciesRequest(input *DescribeScalingPoliciesInput) DescribeScalingPoliciesRequest {
	op := &aws.Operation{
		Name:       opDescribeScalingPolicies,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeScalingPoliciesInput{}
	}

	output := &DescribeScalingPoliciesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeScalingPoliciesRequest{Request: req, Input: input, Copy: c.DescribeScalingPoliciesRequest}
}

const opDescribeVpcPeeringAuthorizations = "DescribeVpcPeeringAuthorizations"

// DescribeVpcPeeringAuthorizationsRequest is a API request type for the DescribeVpcPeeringAuthorizations API operation.
type DescribeVpcPeeringAuthorizationsRequest struct {
	*aws.Request
	Input *DescribeVpcPeeringAuthorizationsInput
	Copy  func(*DescribeVpcPeeringAuthorizationsInput) DescribeVpcPeeringAuthorizationsRequest
}

// Send marshals and sends the DescribeVpcPeeringAuthorizations API request.
func (r DescribeVpcPeeringAuthorizationsRequest) Send() (*DescribeVpcPeeringAuthorizationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeVpcPeeringAuthorizationsOutput), nil
}

// DescribeVpcPeeringAuthorizationsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves valid VPC peering authorizations that are pending for the AWS account.
// This operation returns all VPC peering authorizations and requests for peering.
// This includes those initiated and received by this account.
//
// VPC peering connection operations include:
//
//    * CreateVpcPeeringAuthorization
//
//    * DescribeVpcPeeringAuthorizations
//
//    * DeleteVpcPeeringAuthorization
//
//    * CreateVpcPeeringConnection
//
//    * DescribeVpcPeeringConnections
//
//    * DeleteVpcPeeringConnection
//
//    // Example sending a request using the DescribeVpcPeeringAuthorizationsRequest method.
//    req := client.DescribeVpcPeeringAuthorizationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeVpcPeeringAuthorizations
func (c *GameLift) DescribeVpcPeeringAuthorizationsRequest(input *DescribeVpcPeeringAuthorizationsInput) DescribeVpcPeeringAuthorizationsRequest {
	op := &aws.Operation{
		Name:       opDescribeVpcPeeringAuthorizations,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeVpcPeeringAuthorizationsInput{}
	}

	output := &DescribeVpcPeeringAuthorizationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeVpcPeeringAuthorizationsRequest{Request: req, Input: input, Copy: c.DescribeVpcPeeringAuthorizationsRequest}
}

const opDescribeVpcPeeringConnections = "DescribeVpcPeeringConnections"

// DescribeVpcPeeringConnectionsRequest is a API request type for the DescribeVpcPeeringConnections API operation.
type DescribeVpcPeeringConnectionsRequest struct {
	*aws.Request
	Input *DescribeVpcPeeringConnectionsInput
	Copy  func(*DescribeVpcPeeringConnectionsInput) DescribeVpcPeeringConnectionsRequest
}

// Send marshals and sends the DescribeVpcPeeringConnections API request.
func (r DescribeVpcPeeringConnectionsRequest) Send() (*DescribeVpcPeeringConnectionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeVpcPeeringConnectionsOutput), nil
}

// DescribeVpcPeeringConnectionsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves information on VPC peering connections. Use this operation to get
// peering information for all fleets or for one specific fleet ID.
//
// To retrieve connection information, call this operation from the AWS account
// that is used to manage the Amazon GameLift fleets. Specify a fleet ID or
// leave the parameter empty to retrieve all connection records. If successful,
// the retrieved information includes both active and pending connections. Active
// connections identify the IpV4 CIDR block that the VPC uses to connect.
//
// VPC peering connection operations include:
//
//    * CreateVpcPeeringAuthorization
//
//    * DescribeVpcPeeringAuthorizations
//
//    * DeleteVpcPeeringAuthorization
//
//    * CreateVpcPeeringConnection
//
//    * DescribeVpcPeeringConnections
//
//    * DeleteVpcPeeringConnection
//
//    // Example sending a request using the DescribeVpcPeeringConnectionsRequest method.
//    req := client.DescribeVpcPeeringConnectionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeVpcPeeringConnections
func (c *GameLift) DescribeVpcPeeringConnectionsRequest(input *DescribeVpcPeeringConnectionsInput) DescribeVpcPeeringConnectionsRequest {
	op := &aws.Operation{
		Name:       opDescribeVpcPeeringConnections,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeVpcPeeringConnectionsInput{}
	}

	output := &DescribeVpcPeeringConnectionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeVpcPeeringConnectionsRequest{Request: req, Input: input, Copy: c.DescribeVpcPeeringConnectionsRequest}
}

const opGetGameSessionLogUrl = "GetGameSessionLogUrl"

// GetGameSessionLogUrlRequest is a API request type for the GetGameSessionLogUrl API operation.
type GetGameSessionLogUrlRequest struct {
	*aws.Request
	Input *GetGameSessionLogUrlInput
	Copy  func(*GetGameSessionLogUrlInput) GetGameSessionLogUrlRequest
}

// Send marshals and sends the GetGameSessionLogUrl API request.
func (r GetGameSessionLogUrlRequest) Send() (*GetGameSessionLogUrlOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetGameSessionLogUrlOutput), nil
}

// GetGameSessionLogUrlRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the location of stored game session logs for a specified game session.
// When a game session is terminated, Amazon GameLift automatically stores the
// logs in Amazon S3 and retains them for 14 days. Use this URL to download
// the logs.
//
// See the AWS Service Limits (http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_gamelift)
// page for maximum log file sizes. Log files that exceed this limit are not
// saved.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the GetGameSessionLogUrlRequest method.
//    req := client.GetGameSessionLogUrlRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GetGameSessionLogUrl
func (c *GameLift) GetGameSessionLogUrlRequest(input *GetGameSessionLogUrlInput) GetGameSessionLogUrlRequest {
	op := &aws.Operation{
		Name:       opGetGameSessionLogUrl,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetGameSessionLogUrlInput{}
	}

	output := &GetGameSessionLogUrlOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetGameSessionLogUrlRequest{Request: req, Input: input, Copy: c.GetGameSessionLogUrlRequest}
}

const opGetInstanceAccess = "GetInstanceAccess"

// GetInstanceAccessRequest is a API request type for the GetInstanceAccess API operation.
type GetInstanceAccessRequest struct {
	*aws.Request
	Input *GetInstanceAccessInput
	Copy  func(*GetInstanceAccessInput) GetInstanceAccessRequest
}

// Send marshals and sends the GetInstanceAccess API request.
func (r GetInstanceAccessRequest) Send() (*GetInstanceAccessOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetInstanceAccessOutput), nil
}

// GetInstanceAccessRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Requests remote access to a fleet instance. Remote access is useful for debugging,
// gathering benchmarking data, or watching activity in real time.
//
// Access requires credentials that match the operating system of the instance.
// For a Windows instance, Amazon GameLift returns a user name and password
// as strings for use with a Windows Remote Desktop client. For a Linux instance,
// Amazon GameLift returns a user name and RSA private key, also as strings,
// for use with an SSH client. The private key must be saved in the proper format
// to a .pem file before using. If you're making this request using the AWS
// CLI, saving the secret can be handled as part of the GetInstanceAccess request.
// (See the example later in this topic). For more information on remote access,
// see Remotely Accessing an Instance (http://docs.aws.amazon.com/gamelift/latest/developerguide/fleets-remote-access.html).
//
// To request access to a specific instance, specify the IDs of the instance
// and the fleet it belongs to. If successful, an InstanceAccess object is returned
// containing the instance's IP address and a set of credentials.
//
//    // Example sending a request using the GetInstanceAccessRequest method.
//    req := client.GetInstanceAccessRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GetInstanceAccess
func (c *GameLift) GetInstanceAccessRequest(input *GetInstanceAccessInput) GetInstanceAccessRequest {
	op := &aws.Operation{
		Name:       opGetInstanceAccess,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetInstanceAccessInput{}
	}

	output := &GetInstanceAccessOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetInstanceAccessRequest{Request: req, Input: input, Copy: c.GetInstanceAccessRequest}
}

const opListAliases = "ListAliases"

// ListAliasesRequest is a API request type for the ListAliases API operation.
type ListAliasesRequest struct {
	*aws.Request
	Input *ListAliasesInput
	Copy  func(*ListAliasesInput) ListAliasesRequest
}

// Send marshals and sends the ListAliases API request.
func (r ListAliasesRequest) Send() (*ListAliasesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListAliasesOutput), nil
}

// ListAliasesRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves all aliases for this AWS account. You can filter the result set
// by alias name and/or routing strategy type. Use the pagination parameters
// to retrieve results in sequential pages.
//
// Returned aliases are not listed in any particular order.
//
// Alias-related operations include:
//
//    * CreateAlias
//
//    * ListAliases
//
//    * DescribeAlias
//
//    * UpdateAlias
//
//    * DeleteAlias
//
//    * ResolveAlias
//
//    // Example sending a request using the ListAliasesRequest method.
//    req := client.ListAliasesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListAliases
func (c *GameLift) ListAliasesRequest(input *ListAliasesInput) ListAliasesRequest {
	op := &aws.Operation{
		Name:       opListAliases,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListAliasesInput{}
	}

	output := &ListAliasesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListAliasesRequest{Request: req, Input: input, Copy: c.ListAliasesRequest}
}

const opListBuilds = "ListBuilds"

// ListBuildsRequest is a API request type for the ListBuilds API operation.
type ListBuildsRequest struct {
	*aws.Request
	Input *ListBuildsInput
	Copy  func(*ListBuildsInput) ListBuildsRequest
}

// Send marshals and sends the ListBuilds API request.
func (r ListBuildsRequest) Send() (*ListBuildsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBuildsOutput), nil
}

// ListBuildsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves build records for all builds associated with the AWS account in
// use. You can limit results to builds that are in a specific status by using
// the Status parameter. Use the pagination parameters to retrieve results in
// a set of sequential pages.
//
// Build records are not listed in any particular order.
//
// Build-related operations include:
//
//    * CreateBuild
//
//    * ListBuilds
//
//    * DescribeBuild
//
//    * UpdateBuild
//
//    * DeleteBuild
//
//    // Example sending a request using the ListBuildsRequest method.
//    req := client.ListBuildsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListBuilds
func (c *GameLift) ListBuildsRequest(input *ListBuildsInput) ListBuildsRequest {
	op := &aws.Operation{
		Name:       opListBuilds,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListBuildsInput{}
	}

	output := &ListBuildsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBuildsRequest{Request: req, Input: input, Copy: c.ListBuildsRequest}
}

const opListFleets = "ListFleets"

// ListFleetsRequest is a API request type for the ListFleets API operation.
type ListFleetsRequest struct {
	*aws.Request
	Input *ListFleetsInput
	Copy  func(*ListFleetsInput) ListFleetsRequest
}

// Send marshals and sends the ListFleets API request.
func (r ListFleetsRequest) Send() (*ListFleetsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListFleetsOutput), nil
}

// ListFleetsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves a collection of fleet records for this AWS account. You can filter
// the result set by build ID. Use the pagination parameters to retrieve results
// in sequential pages.
//
// Fleet records are not listed in any particular order.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the ListFleetsRequest method.
//    req := client.ListFleetsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListFleets
func (c *GameLift) ListFleetsRequest(input *ListFleetsInput) ListFleetsRequest {
	op := &aws.Operation{
		Name:       opListFleets,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListFleetsInput{}
	}

	output := &ListFleetsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListFleetsRequest{Request: req, Input: input, Copy: c.ListFleetsRequest}
}

const opPutScalingPolicy = "PutScalingPolicy"

// PutScalingPolicyRequest is a API request type for the PutScalingPolicy API operation.
type PutScalingPolicyRequest struct {
	*aws.Request
	Input *PutScalingPolicyInput
	Copy  func(*PutScalingPolicyInput) PutScalingPolicyRequest
}

// Send marshals and sends the PutScalingPolicy API request.
func (r PutScalingPolicyRequest) Send() (*PutScalingPolicyOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutScalingPolicyOutput), nil
}

// PutScalingPolicyRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Creates or updates a scaling policy for a fleet. Scaling policies are used
// to automatically scale a fleet's hosting capacity to meet player demand.
// An active scaling policy instructs Amazon GameLift to track a fleet metric
// and automatically change the fleet's capacity when a certain threshold is
// reached. There are two types of scaling policies: target-based and rule-based.
// Use a target-based policy to quickly and efficiently manage fleet scaling;
// this option is the most commonly used. Use rule-based policies when you need
// to exert fine-grained control over auto-scaling.
//
// Fleets can have multiple scaling policies of each type in force at the same
// time; you can have one target-based policy, one or multiple rule-based scaling
// policies, or both. We recommend caution, however, because multiple auto-scaling
// policies can have unintended consequences.
//
// You can temporarily suspend all scaling policies for a fleet by calling StopFleetActions
// with the fleet action AUTO_SCALING. To resume scaling policies, call StartFleetActions
// with the same fleet action. To stop just one scaling policy--or to permanently
// remove it, you must delete the policy with DeleteScalingPolicy.
//
// Learn more about how to work with auto-scaling in Set Up Fleet Automatic
// Scaling (http://docs.aws.amazon.com/gamelift/latest/developerguide/fleets-autoscaling.html).
//
// Target-based policy
//
// A target-based policy tracks a single metric: PercentAvailableGameSessions.
// This metric tells us how much of a fleet's hosting capacity is ready to host
// game sessions but is not currently in use. This is the fleet's buffer; it
// measures the additional player demand that the fleet could handle at current
// capacity. With a target-based policy, you set your ideal buffer size and
// leave it to Amazon GameLift to take whatever action is needed to maintain
// that target.
//
// For example, you might choose to maintain a 10% buffer for a fleet that has
// the capacity to host 100 simultaneous game sessions. This policy tells Amazon
// GameLift to take action whenever the fleet's available capacity falls below
// or rises above 10 game sessions. Amazon GameLift will start new instances
// or stop unused instances in order to return to the 10% buffer.
//
// To create or update a target-based policy, specify a fleet ID and name, and
// set the policy type to "TargetBased". Specify the metric to track (PercentAvailableGameSessions)
// and reference a TargetConfiguration object with your desired buffer value.
// Exclude all other parameters. On a successful request, the policy name is
// returned. The scaling policy is automatically in force as soon as it's successfully
// created. If the fleet's auto-scaling actions are temporarily suspended, the
// new policy will be in force once the fleet actions are restarted.
//
// Rule-based policy
//
// A rule-based policy tracks specified fleet metric, sets a threshold value,
// and specifies the type of action to initiate when triggered. With a rule-based
// policy, you can select from several available fleet metrics. Each policy
// specifies whether to scale up or scale down (and by how much), so you need
// one policy for each type of action.
//
// For example, a policy may make the following statement: "If the percentage
// of idle instances is greater than 20% for more than 15 minutes, then reduce
// the fleet capacity by 10%."
//
// A policy's rule statement has the following structure:
//
// If [MetricName] is [ComparisonOperator][Threshold] for [EvaluationPeriods]
// minutes, then [ScalingAdjustmentType] to/by [ScalingAdjustment].
//
// To implement the example, the rule statement would look like this:
//
// If [PercentIdleInstances] is [GreaterThanThreshold][20] for [15] minutes,
// then [PercentChangeInCapacity] to/by [10].
//
// To create or update a scaling policy, specify a unique combination of name
// and fleet ID, and set the policy type to "RuleBased". Specify the parameter
// values for a policy rule statement. On a successful request, the policy name
// is returned. Scaling policies are automatically in force as soon as they're
// successfully created. If the fleet's auto-scaling actions are temporarily
// suspended, the new policy will be in force once the fleet actions are restarted.
//
// Operations related to fleet capacity scaling include:
//
//    * DescribeFleetCapacity
//
//    * UpdateFleetCapacity
//
//    * DescribeEC2InstanceLimits
//
//    * Manage scaling policies:
//
// PutScalingPolicy (auto-scaling)
//
// DescribeScalingPolicies (auto-scaling)
//
// DeleteScalingPolicy (auto-scaling)
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the PutScalingPolicyRequest method.
//    req := client.PutScalingPolicyRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/PutScalingPolicy
func (c *GameLift) PutScalingPolicyRequest(input *PutScalingPolicyInput) PutScalingPolicyRequest {
	op := &aws.Operation{
		Name:       opPutScalingPolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PutScalingPolicyInput{}
	}

	output := &PutScalingPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutScalingPolicyRequest{Request: req, Input: input, Copy: c.PutScalingPolicyRequest}
}

const opRequestUploadCredentials = "RequestUploadCredentials"

// RequestUploadCredentialsRequest is a API request type for the RequestUploadCredentials API operation.
type RequestUploadCredentialsRequest struct {
	*aws.Request
	Input *RequestUploadCredentialsInput
	Copy  func(*RequestUploadCredentialsInput) RequestUploadCredentialsRequest
}

// Send marshals and sends the RequestUploadCredentials API request.
func (r RequestUploadCredentialsRequest) Send() (*RequestUploadCredentialsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RequestUploadCredentialsOutput), nil
}

// RequestUploadCredentialsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves a fresh set of credentials for use when uploading a new set of
// game build files to Amazon GameLift's Amazon S3. This is done as part of
// the build creation process; see CreateBuild.
//
// To request new credentials, specify the build ID as returned with an initial
// CreateBuild request. If successful, a new set of credentials are returned,
// along with the S3 storage location associated with the build ID.
//
//    // Example sending a request using the RequestUploadCredentialsRequest method.
//    req := client.RequestUploadCredentialsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/RequestUploadCredentials
func (c *GameLift) RequestUploadCredentialsRequest(input *RequestUploadCredentialsInput) RequestUploadCredentialsRequest {
	op := &aws.Operation{
		Name:       opRequestUploadCredentials,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RequestUploadCredentialsInput{}
	}

	output := &RequestUploadCredentialsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RequestUploadCredentialsRequest{Request: req, Input: input, Copy: c.RequestUploadCredentialsRequest}
}

const opResolveAlias = "ResolveAlias"

// ResolveAliasRequest is a API request type for the ResolveAlias API operation.
type ResolveAliasRequest struct {
	*aws.Request
	Input *ResolveAliasInput
	Copy  func(*ResolveAliasInput) ResolveAliasRequest
}

// Send marshals and sends the ResolveAlias API request.
func (r ResolveAliasRequest) Send() (*ResolveAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ResolveAliasOutput), nil
}

// ResolveAliasRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves the fleet ID that a specified alias is currently pointing to.
//
// Alias-related operations include:
//
//    * CreateAlias
//
//    * ListAliases
//
//    * DescribeAlias
//
//    * UpdateAlias
//
//    * DeleteAlias
//
//    * ResolveAlias
//
//    // Example sending a request using the ResolveAliasRequest method.
//    req := client.ResolveAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ResolveAlias
func (c *GameLift) ResolveAliasRequest(input *ResolveAliasInput) ResolveAliasRequest {
	op := &aws.Operation{
		Name:       opResolveAlias,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ResolveAliasInput{}
	}

	output := &ResolveAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ResolveAliasRequest{Request: req, Input: input, Copy: c.ResolveAliasRequest}
}

const opSearchGameSessions = "SearchGameSessions"

// SearchGameSessionsRequest is a API request type for the SearchGameSessions API operation.
type SearchGameSessionsRequest struct {
	*aws.Request
	Input *SearchGameSessionsInput
	Copy  func(*SearchGameSessionsInput) SearchGameSessionsRequest
}

// Send marshals and sends the SearchGameSessions API request.
func (r SearchGameSessionsRequest) Send() (*SearchGameSessionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SearchGameSessionsOutput), nil
}

// SearchGameSessionsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Retrieves all active game sessions that match a set of search criteria and
// sorts them in a specified order. You can search or sort by the following
// game session attributes:
//
//    * gameSessionId -- Unique identifier for the game session. You can use
//    either a GameSessionId or GameSessionArn value.
//
//    * gameSessionName -- Name assigned to a game session. This value is set
//    when requesting a new game session with CreateGameSession or updating
//    with UpdateGameSession. Game session names do not need to be unique to
//    a game session.
//
//    * gameSessionProperties -- Custom data defined in a game session's GameProperty
//    parameter. GameProperty values are stored as key:value pairs; the filter
//    expression must indicate the key and a string to search the data values
//    for. For example, to search for game sessions with custom data containing
//    the key:value pair "gameMode:brawl", specify the following: gameSessionProperties.gameMode
//    = "brawl". All custom data values are searched as strings.
//
//    * maximumSessions -- Maximum number of player sessions allowed for a game
//    session. This value is set when requesting a new game session with CreateGameSession
//    or updating with UpdateGameSession.
//
//    * creationTimeMillis -- Value indicating when a game session was created.
//    It is expressed in Unix time as milliseconds.
//
//    * playerSessionCount -- Number of players currently connected to a game
//    session. This value changes rapidly as players join the session or drop
//    out.
//
//    * hasAvailablePlayerSessions -- Boolean value indicating whether a game
//    session has reached its maximum number of players. It is highly recommended
//    that all search requests include this filter attribute to optimize search
//    performance and return only sessions that players can join.
//
// Returned values for playerSessionCount and hasAvailablePlayerSessions change
// quickly as players join sessions and others drop out. Results should be considered
// a snapshot in time. Be sure to refresh search results often, and handle sessions
// that fill up before a player can join.
//
// To search or sort, specify either a fleet ID or an alias ID, and provide
// a search filter expression, a sort expression, or both. If successful, a
// collection of GameSession objects matching the request is returned. Use the
// pagination parameters to retrieve results as a set of sequential pages.
//
// You can search for game sessions one fleet at a time only. To find game sessions
// across multiple fleets, you must search each fleet separately and combine
// the results. This search feature finds only game sessions that are in ACTIVE
// status. To locate games in statuses other than active, use DescribeGameSessionDetails.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the SearchGameSessionsRequest method.
//    req := client.SearchGameSessionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/SearchGameSessions
func (c *GameLift) SearchGameSessionsRequest(input *SearchGameSessionsInput) SearchGameSessionsRequest {
	op := &aws.Operation{
		Name:       opSearchGameSessions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &SearchGameSessionsInput{}
	}

	output := &SearchGameSessionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return SearchGameSessionsRequest{Request: req, Input: input, Copy: c.SearchGameSessionsRequest}
}

const opStartFleetActions = "StartFleetActions"

// StartFleetActionsRequest is a API request type for the StartFleetActions API operation.
type StartFleetActionsRequest struct {
	*aws.Request
	Input *StartFleetActionsInput
	Copy  func(*StartFleetActionsInput) StartFleetActionsRequest
}

// Send marshals and sends the StartFleetActions API request.
func (r StartFleetActionsRequest) Send() (*StartFleetActionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartFleetActionsOutput), nil
}

// StartFleetActionsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Resumes activity on a fleet that was suspended with StopFleetActions. Currently,
// this operation is used to restart a fleet's auto-scaling activity.
//
// To start fleet actions, specify the fleet ID and the type of actions to restart.
// When auto-scaling fleet actions are restarted, Amazon GameLift once again
// initiates scaling events as triggered by the fleet's scaling policies. If
// actions on the fleet were never stopped, this operation will have no effect.
// You can view a fleet's stopped actions using DescribeFleetAttributes.
//
// Operations related to fleet capacity scaling include:
//
//    * DescribeFleetCapacity
//
//    * UpdateFleetCapacity
//
//    * DescribeEC2InstanceLimits
//
//    * Manage scaling policies:
//
// PutScalingPolicy (auto-scaling)
//
// DescribeScalingPolicies (auto-scaling)
//
// DeleteScalingPolicy (auto-scaling)
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the StartFleetActionsRequest method.
//    req := client.StartFleetActionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartFleetActions
func (c *GameLift) StartFleetActionsRequest(input *StartFleetActionsInput) StartFleetActionsRequest {
	op := &aws.Operation{
		Name:       opStartFleetActions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &StartFleetActionsInput{}
	}

	output := &StartFleetActionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartFleetActionsRequest{Request: req, Input: input, Copy: c.StartFleetActionsRequest}
}

const opStartGameSessionPlacement = "StartGameSessionPlacement"

// StartGameSessionPlacementRequest is a API request type for the StartGameSessionPlacement API operation.
type StartGameSessionPlacementRequest struct {
	*aws.Request
	Input *StartGameSessionPlacementInput
	Copy  func(*StartGameSessionPlacementInput) StartGameSessionPlacementRequest
}

// Send marshals and sends the StartGameSessionPlacement API request.
func (r StartGameSessionPlacementRequest) Send() (*StartGameSessionPlacementOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartGameSessionPlacementOutput), nil
}

// StartGameSessionPlacementRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Places a request for a new game session in a queue (see CreateGameSessionQueue).
// When processing a placement request, Amazon GameLift searches for available
// resources on the queue's destinations, scanning each until it finds resources
// or the placement request times out.
//
// A game session placement request can also request player sessions. When a
// new game session is successfully created, Amazon GameLift creates a player
// session for each player included in the request.
//
// When placing a game session, by default Amazon GameLift tries each fleet
// in the order they are listed in the queue configuration. Ideally, a queue's
// destinations are listed in preference order.
//
// Alternatively, when requesting a game session with players, you can also
// provide latency data for each player in relevant regions. Latency data indicates
// the performance lag a player experiences when connected to a fleet in the
// region. Amazon GameLift uses latency data to reorder the list of destinations
// to place the game session in a region with minimal lag. If latency data is
// provided for multiple players, Amazon GameLift calculates each region's average
// lag for all players and reorders to get the best game play across all players.
//
// To place a new game session request, specify the following:
//
//    * The queue name and a set of game session properties and settings
//
//    * A unique ID (such as a UUID) for the placement. You use this ID to track
//    the status of the placement request
//
//    * (Optional) A set of IDs and player data for each player you want to
//    join to the new game session
//
//    * Latency data for all players (if you want to optimize game play for
//    the players)
//
// If successful, a new game session placement is created.
//
// To track the status of a placement request, call DescribeGameSessionPlacement
// and check the request's status. If the status is FULFILLED, a new game session
// has been created and a game session ARN and region are referenced. If the
// placement request times out, you can resubmit the request or retry it with
// a different queue.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the StartGameSessionPlacementRequest method.
//    req := client.StartGameSessionPlacementRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartGameSessionPlacement
func (c *GameLift) StartGameSessionPlacementRequest(input *StartGameSessionPlacementInput) StartGameSessionPlacementRequest {
	op := &aws.Operation{
		Name:       opStartGameSessionPlacement,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &StartGameSessionPlacementInput{}
	}

	output := &StartGameSessionPlacementOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartGameSessionPlacementRequest{Request: req, Input: input, Copy: c.StartGameSessionPlacementRequest}
}

const opStartMatchBackfill = "StartMatchBackfill"

// StartMatchBackfillRequest is a API request type for the StartMatchBackfill API operation.
type StartMatchBackfillRequest struct {
	*aws.Request
	Input *StartMatchBackfillInput
	Copy  func(*StartMatchBackfillInput) StartMatchBackfillRequest
}

// Send marshals and sends the StartMatchBackfill API request.
func (r StartMatchBackfillRequest) Send() (*StartMatchBackfillOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartMatchBackfillOutput), nil
}

// StartMatchBackfillRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Finds new players to fill open slots in an existing game session. This operation
// can be used to add players to matched games that start with fewer than the
// maximum number of players or to replace players when they drop out. By backfilling
// with the same matchmaker used to create the original match, you ensure that
// new players meet the match criteria and maintain a consistent experience
// throughout the game session. You can backfill a match anytime after a game
// session has been created.
//
// To request a match backfill, specify a unique ticket ID, the existing game
// session's ARN, a matchmaking configuration, and a set of data that describes
// all current players in the game session. If successful, a match backfill
// ticket is created and returned with status set to QUEUED. The ticket is placed
// in the matchmaker's ticket pool and processed. Track the status of the ticket
// to respond as needed. For more detail how to set up backfilling, see  Backfill
// Existing Games with FlexMatch (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-backfill.html).
//
// The process of finding backfill matches is essentially identical to the initial
// matchmaking process. The matchmaker searches the pool and groups tickets
// together to form potential matches, allowing only one backfill ticket per
// potential match. Once the a match is formed, the matchmaker creates player
// sessions for the new players. All tickets in the match are updated with the
// game session's connection information, and the GameSession object is updated
// to include matchmaker data on the new players. For more detail on how match
// backfill requests are processed, see  How Amazon GameLift FlexMatch Works
// (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-intro.html).
//
// Matchmaking-related operations include:
//
//    * StartMatchmaking
//
//    * DescribeMatchmaking
//
//    * StopMatchmaking
//
//    * AcceptMatch
//
//    * StartMatchBackfill
//
//    // Example sending a request using the StartMatchBackfillRequest method.
//    req := client.StartMatchBackfillRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartMatchBackfill
func (c *GameLift) StartMatchBackfillRequest(input *StartMatchBackfillInput) StartMatchBackfillRequest {
	op := &aws.Operation{
		Name:       opStartMatchBackfill,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &StartMatchBackfillInput{}
	}

	output := &StartMatchBackfillOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartMatchBackfillRequest{Request: req, Input: input, Copy: c.StartMatchBackfillRequest}
}

const opStartMatchmaking = "StartMatchmaking"

// StartMatchmakingRequest is a API request type for the StartMatchmaking API operation.
type StartMatchmakingRequest struct {
	*aws.Request
	Input *StartMatchmakingInput
	Copy  func(*StartMatchmakingInput) StartMatchmakingRequest
}

// Send marshals and sends the StartMatchmaking API request.
func (r StartMatchmakingRequest) Send() (*StartMatchmakingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartMatchmakingOutput), nil
}

// StartMatchmakingRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Uses FlexMatch to create a game match for a group of players based on custom
// matchmaking rules, and starts a new game for the matched players. Each matchmaking
// request specifies the type of match to build (team configuration, rules for
// an acceptable match, etc.). The request also specifies the players to find
// a match for and where to host the new game session for optimal performance.
// A matchmaking request might start with a single player or a group of players
// who want to play together. FlexMatch finds additional players as needed to
// fill the match. Match type, rules, and the queue used to place a new game
// session are defined in a MatchmakingConfiguration. For complete information
// on setting up and using FlexMatch, see the topic  Adding FlexMatch to Your
// Game (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-intro.html).
//
// To start matchmaking, provide a unique ticket ID, specify a matchmaking configuration,
// and include the players to be matched. You must also include a set of player
// attributes relevant for the matchmaking configuration. If successful, a matchmaking
// ticket is returned with status set to QUEUED. Track the status of the ticket
// to respond as needed and acquire game session connection information for
// successfully completed matches.
//
// Tracking ticket status -- A couple of options are available for tracking
// the status of matchmaking requests:
//
//    * Polling -- Call DescribeMatchmaking. This operation returns the full
//    ticket object, including current status and (for completed tickets) game
//    session connection info. We recommend polling no more than once every
//    10 seconds.
//
//    * Notifications -- Get event notifications for changes in ticket status
//    using Amazon Simple Notification Service (SNS). Notifications are easy
//    to set up (see CreateMatchmakingConfiguration) and typically deliver match
//    status changes faster and more efficiently than polling. We recommend
//    that you use polling to back up to notifications (since delivery is not
//    guaranteed) and call DescribeMatchmaking only when notifications are not
//    received within 30 seconds.
//
// Processing a matchmaking request -- FlexMatch handles a matchmaking request
// as follows:
//
// Your client code submits a StartMatchmaking request for one or more players
// and tracks the status of the request ticket.
//
// FlexMatch uses this ticket and others in process to build an acceptable match.
// When a potential match is identified, all tickets in the proposed match are
// advanced to the next status.
//
// If the match requires player acceptance (set in the matchmaking configuration),
// the tickets move into status REQUIRES_ACCEPTANCE. This status triggers your
// client code to solicit acceptance from all players in every ticket involved
// in the match, and then call AcceptMatch for each player. If any player rejects
// or fails to accept the match before a specified timeout, the proposed match
// is dropped (see AcceptMatch for more details).
//
// Once a match is proposed and accepted, the matchmaking tickets move into
// status PLACING. FlexMatch locates resources for a new game session using
// the game session queue (set in the matchmaking configuration) and creates
// the game session based on the match data.
//
// When the match is successfully placed, the matchmaking tickets move into
// COMPLETED status. Connection information (including game session endpoint
// and player session) is added to the matchmaking tickets. Matched players
// can use the connection information to join the game.
//
// Matchmaking-related operations include:
//
//    * StartMatchmaking
//
//    * DescribeMatchmaking
//
//    * StopMatchmaking
//
//    * AcceptMatch
//
//    * StartMatchBackfill
//
//    // Example sending a request using the StartMatchmakingRequest method.
//    req := client.StartMatchmakingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartMatchmaking
func (c *GameLift) StartMatchmakingRequest(input *StartMatchmakingInput) StartMatchmakingRequest {
	op := &aws.Operation{
		Name:       opStartMatchmaking,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &StartMatchmakingInput{}
	}

	output := &StartMatchmakingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartMatchmakingRequest{Request: req, Input: input, Copy: c.StartMatchmakingRequest}
}

const opStopFleetActions = "StopFleetActions"

// StopFleetActionsRequest is a API request type for the StopFleetActions API operation.
type StopFleetActionsRequest struct {
	*aws.Request
	Input *StopFleetActionsInput
	Copy  func(*StopFleetActionsInput) StopFleetActionsRequest
}

// Send marshals and sends the StopFleetActions API request.
func (r StopFleetActionsRequest) Send() (*StopFleetActionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StopFleetActionsOutput), nil
}

// StopFleetActionsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Suspends activity on a fleet. Currently, this operation is used to stop a
// fleet's auto-scaling activity. It is used to temporarily stop scaling events
// triggered by the fleet's scaling policies. The policies can be retained and
// auto-scaling activity can be restarted using StartFleetActions. You can view
// a fleet's stopped actions using DescribeFleetAttributes.
//
// To stop fleet actions, specify the fleet ID and the type of actions to suspend.
// When auto-scaling fleet actions are stopped, Amazon GameLift no longer initiates
// scaling events except to maintain the fleet's desired instances setting (FleetCapacity.
// Changes to the fleet's capacity must be done manually using UpdateFleetCapacity.
//
//    // Example sending a request using the StopFleetActionsRequest method.
//    req := client.StopFleetActionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopFleetActions
func (c *GameLift) StopFleetActionsRequest(input *StopFleetActionsInput) StopFleetActionsRequest {
	op := &aws.Operation{
		Name:       opStopFleetActions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &StopFleetActionsInput{}
	}

	output := &StopFleetActionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StopFleetActionsRequest{Request: req, Input: input, Copy: c.StopFleetActionsRequest}
}

const opStopGameSessionPlacement = "StopGameSessionPlacement"

// StopGameSessionPlacementRequest is a API request type for the StopGameSessionPlacement API operation.
type StopGameSessionPlacementRequest struct {
	*aws.Request
	Input *StopGameSessionPlacementInput
	Copy  func(*StopGameSessionPlacementInput) StopGameSessionPlacementRequest
}

// Send marshals and sends the StopGameSessionPlacement API request.
func (r StopGameSessionPlacementRequest) Send() (*StopGameSessionPlacementOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StopGameSessionPlacementOutput), nil
}

// StopGameSessionPlacementRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Cancels a game session placement that is in PENDING status. To stop a placement,
// provide the placement ID values. If successful, the placement is moved to
// CANCELLED status.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the StopGameSessionPlacementRequest method.
//    req := client.StopGameSessionPlacementRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopGameSessionPlacement
func (c *GameLift) StopGameSessionPlacementRequest(input *StopGameSessionPlacementInput) StopGameSessionPlacementRequest {
	op := &aws.Operation{
		Name:       opStopGameSessionPlacement,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &StopGameSessionPlacementInput{}
	}

	output := &StopGameSessionPlacementOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StopGameSessionPlacementRequest{Request: req, Input: input, Copy: c.StopGameSessionPlacementRequest}
}

const opStopMatchmaking = "StopMatchmaking"

// StopMatchmakingRequest is a API request type for the StopMatchmaking API operation.
type StopMatchmakingRequest struct {
	*aws.Request
	Input *StopMatchmakingInput
	Copy  func(*StopMatchmakingInput) StopMatchmakingRequest
}

// Send marshals and sends the StopMatchmaking API request.
func (r StopMatchmakingRequest) Send() (*StopMatchmakingOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StopMatchmakingOutput), nil
}

// StopMatchmakingRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Cancels a matchmaking ticket that is currently being processed. To stop the
// matchmaking operation, specify the ticket ID. If successful, work on the
// ticket is stopped, and the ticket status is changed to CANCELLED.
//
// Matchmaking-related operations include:
//
//    * StartMatchmaking
//
//    * DescribeMatchmaking
//
//    * StopMatchmaking
//
//    * AcceptMatch
//
//    * StartMatchBackfill
//
//    // Example sending a request using the StopMatchmakingRequest method.
//    req := client.StopMatchmakingRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopMatchmaking
func (c *GameLift) StopMatchmakingRequest(input *StopMatchmakingInput) StopMatchmakingRequest {
	op := &aws.Operation{
		Name:       opStopMatchmaking,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &StopMatchmakingInput{}
	}

	output := &StopMatchmakingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StopMatchmakingRequest{Request: req, Input: input, Copy: c.StopMatchmakingRequest}
}

const opUpdateAlias = "UpdateAlias"

// UpdateAliasRequest is a API request type for the UpdateAlias API operation.
type UpdateAliasRequest struct {
	*aws.Request
	Input *UpdateAliasInput
	Copy  func(*UpdateAliasInput) UpdateAliasRequest
}

// Send marshals and sends the UpdateAlias API request.
func (r UpdateAliasRequest) Send() (*UpdateAliasOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateAliasOutput), nil
}

// UpdateAliasRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates properties for an alias. To update properties, specify the alias
// ID to be updated and provide the information to be changed. To reassign an
// alias to another fleet, provide an updated routing strategy. If successful,
// the updated alias record is returned.
//
// Alias-related operations include:
//
//    * CreateAlias
//
//    * ListAliases
//
//    * DescribeAlias
//
//    * UpdateAlias
//
//    * DeleteAlias
//
//    * ResolveAlias
//
//    // Example sending a request using the UpdateAliasRequest method.
//    req := client.UpdateAliasRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateAlias
func (c *GameLift) UpdateAliasRequest(input *UpdateAliasInput) UpdateAliasRequest {
	op := &aws.Operation{
		Name:       opUpdateAlias,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateAliasInput{}
	}

	output := &UpdateAliasOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateAliasRequest{Request: req, Input: input, Copy: c.UpdateAliasRequest}
}

const opUpdateBuild = "UpdateBuild"

// UpdateBuildRequest is a API request type for the UpdateBuild API operation.
type UpdateBuildRequest struct {
	*aws.Request
	Input *UpdateBuildInput
	Copy  func(*UpdateBuildInput) UpdateBuildRequest
}

// Send marshals and sends the UpdateBuild API request.
func (r UpdateBuildRequest) Send() (*UpdateBuildOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateBuildOutput), nil
}

// UpdateBuildRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates metadata in a build record, including the build name and version.
// To update the metadata, specify the build ID to update and provide the new
// values. If successful, a build object containing the updated metadata is
// returned.
//
// Build-related operations include:
//
//    * CreateBuild
//
//    * ListBuilds
//
//    * DescribeBuild
//
//    * UpdateBuild
//
//    * DeleteBuild
//
//    // Example sending a request using the UpdateBuildRequest method.
//    req := client.UpdateBuildRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateBuild
func (c *GameLift) UpdateBuildRequest(input *UpdateBuildInput) UpdateBuildRequest {
	op := &aws.Operation{
		Name:       opUpdateBuild,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateBuildInput{}
	}

	output := &UpdateBuildOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateBuildRequest{Request: req, Input: input, Copy: c.UpdateBuildRequest}
}

const opUpdateFleetAttributes = "UpdateFleetAttributes"

// UpdateFleetAttributesRequest is a API request type for the UpdateFleetAttributes API operation.
type UpdateFleetAttributesRequest struct {
	*aws.Request
	Input *UpdateFleetAttributesInput
	Copy  func(*UpdateFleetAttributesInput) UpdateFleetAttributesRequest
}

// Send marshals and sends the UpdateFleetAttributes API request.
func (r UpdateFleetAttributesRequest) Send() (*UpdateFleetAttributesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateFleetAttributesOutput), nil
}

// UpdateFleetAttributesRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates fleet properties, including name and description, for a fleet. To
// update metadata, specify the fleet ID and the property values that you want
// to change. If successful, the fleet ID for the updated fleet is returned.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the UpdateFleetAttributesRequest method.
//    req := client.UpdateFleetAttributesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetAttributes
func (c *GameLift) UpdateFleetAttributesRequest(input *UpdateFleetAttributesInput) UpdateFleetAttributesRequest {
	op := &aws.Operation{
		Name:       opUpdateFleetAttributes,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateFleetAttributesInput{}
	}

	output := &UpdateFleetAttributesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateFleetAttributesRequest{Request: req, Input: input, Copy: c.UpdateFleetAttributesRequest}
}

const opUpdateFleetCapacity = "UpdateFleetCapacity"

// UpdateFleetCapacityRequest is a API request type for the UpdateFleetCapacity API operation.
type UpdateFleetCapacityRequest struct {
	*aws.Request
	Input *UpdateFleetCapacityInput
	Copy  func(*UpdateFleetCapacityInput) UpdateFleetCapacityRequest
}

// Send marshals and sends the UpdateFleetCapacity API request.
func (r UpdateFleetCapacityRequest) Send() (*UpdateFleetCapacityOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateFleetCapacityOutput), nil
}

// UpdateFleetCapacityRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates capacity settings for a fleet. Use this action to specify the number
// of EC2 instances (hosts) that you want this fleet to contain. Before calling
// this action, you may want to call DescribeEC2InstanceLimits to get the maximum
// capacity based on the fleet's EC2 instance type.
//
// Specify minimum and maximum number of instances. Amazon GameLift will not
// change fleet capacity to values fall outside of this range. This is particularly
// important when using auto-scaling (see PutScalingPolicy) to allow capacity
// to adjust based on player demand while imposing limits on automatic adjustments.
//
// To update fleet capacity, specify the fleet ID and the number of instances
// you want the fleet to host. If successful, Amazon GameLift starts or terminates
// instances so that the fleet's active instance count matches the desired instance
// count. You can view a fleet's current capacity information by calling DescribeFleetCapacity.
// If the desired instance count is higher than the instance type's limit, the
// "Limit Exceeded" exception occurs.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the UpdateFleetCapacityRequest method.
//    req := client.UpdateFleetCapacityRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetCapacity
func (c *GameLift) UpdateFleetCapacityRequest(input *UpdateFleetCapacityInput) UpdateFleetCapacityRequest {
	op := &aws.Operation{
		Name:       opUpdateFleetCapacity,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateFleetCapacityInput{}
	}

	output := &UpdateFleetCapacityOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateFleetCapacityRequest{Request: req, Input: input, Copy: c.UpdateFleetCapacityRequest}
}

const opUpdateFleetPortSettings = "UpdateFleetPortSettings"

// UpdateFleetPortSettingsRequest is a API request type for the UpdateFleetPortSettings API operation.
type UpdateFleetPortSettingsRequest struct {
	*aws.Request
	Input *UpdateFleetPortSettingsInput
	Copy  func(*UpdateFleetPortSettingsInput) UpdateFleetPortSettingsRequest
}

// Send marshals and sends the UpdateFleetPortSettings API request.
func (r UpdateFleetPortSettingsRequest) Send() (*UpdateFleetPortSettingsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateFleetPortSettingsOutput), nil
}

// UpdateFleetPortSettingsRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates port settings for a fleet. To update settings, specify the fleet
// ID to be updated and list the permissions you want to update. List the permissions
// you want to add in InboundPermissionAuthorizations, and permissions you want
// to remove in InboundPermissionRevocations. Permissions to be removed must
// match existing fleet permissions. If successful, the fleet ID for the updated
// fleet is returned.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the UpdateFleetPortSettingsRequest method.
//    req := client.UpdateFleetPortSettingsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetPortSettings
func (c *GameLift) UpdateFleetPortSettingsRequest(input *UpdateFleetPortSettingsInput) UpdateFleetPortSettingsRequest {
	op := &aws.Operation{
		Name:       opUpdateFleetPortSettings,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateFleetPortSettingsInput{}
	}

	output := &UpdateFleetPortSettingsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateFleetPortSettingsRequest{Request: req, Input: input, Copy: c.UpdateFleetPortSettingsRequest}
}

const opUpdateGameSession = "UpdateGameSession"

// UpdateGameSessionRequest is a API request type for the UpdateGameSession API operation.
type UpdateGameSessionRequest struct {
	*aws.Request
	Input *UpdateGameSessionInput
	Copy  func(*UpdateGameSessionInput) UpdateGameSessionRequest
}

// Send marshals and sends the UpdateGameSession API request.
func (r UpdateGameSessionRequest) Send() (*UpdateGameSessionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGameSessionOutput), nil
}

// UpdateGameSessionRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates game session properties. This includes the session name, maximum
// player count, protection policy, which controls whether or not an active
// game session can be terminated during a scale-down event, and the player
// session creation policy, which controls whether or not new players can join
// the session. To update a game session, specify the game session ID and the
// values you want to change. If successful, an updated GameSession object is
// returned.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
//
//    // Example sending a request using the UpdateGameSessionRequest method.
//    req := client.UpdateGameSessionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateGameSession
func (c *GameLift) UpdateGameSessionRequest(input *UpdateGameSessionInput) UpdateGameSessionRequest {
	op := &aws.Operation{
		Name:       opUpdateGameSession,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateGameSessionInput{}
	}

	output := &UpdateGameSessionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateGameSessionRequest{Request: req, Input: input, Copy: c.UpdateGameSessionRequest}
}

const opUpdateGameSessionQueue = "UpdateGameSessionQueue"

// UpdateGameSessionQueueRequest is a API request type for the UpdateGameSessionQueue API operation.
type UpdateGameSessionQueueRequest struct {
	*aws.Request
	Input *UpdateGameSessionQueueInput
	Copy  func(*UpdateGameSessionQueueInput) UpdateGameSessionQueueRequest
}

// Send marshals and sends the UpdateGameSessionQueue API request.
func (r UpdateGameSessionQueueRequest) Send() (*UpdateGameSessionQueueOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGameSessionQueueOutput), nil
}

// UpdateGameSessionQueueRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates settings for a game session queue, which determines how new game
// session requests in the queue are processed. To update settings, specify
// the queue name to be updated and provide the new settings. When updating
// destinations, provide a complete list of destinations.
//
// Queue-related operations include:
//
//    * CreateGameSessionQueue
//
//    * DescribeGameSessionQueues
//
//    * UpdateGameSessionQueue
//
//    * DeleteGameSessionQueue
//
//    // Example sending a request using the UpdateGameSessionQueueRequest method.
//    req := client.UpdateGameSessionQueueRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateGameSessionQueue
func (c *GameLift) UpdateGameSessionQueueRequest(input *UpdateGameSessionQueueInput) UpdateGameSessionQueueRequest {
	op := &aws.Operation{
		Name:       opUpdateGameSessionQueue,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateGameSessionQueueInput{}
	}

	output := &UpdateGameSessionQueueOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateGameSessionQueueRequest{Request: req, Input: input, Copy: c.UpdateGameSessionQueueRequest}
}

const opUpdateMatchmakingConfiguration = "UpdateMatchmakingConfiguration"

// UpdateMatchmakingConfigurationRequest is a API request type for the UpdateMatchmakingConfiguration API operation.
type UpdateMatchmakingConfigurationRequest struct {
	*aws.Request
	Input *UpdateMatchmakingConfigurationInput
	Copy  func(*UpdateMatchmakingConfigurationInput) UpdateMatchmakingConfigurationRequest
}

// Send marshals and sends the UpdateMatchmakingConfiguration API request.
func (r UpdateMatchmakingConfigurationRequest) Send() (*UpdateMatchmakingConfigurationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateMatchmakingConfigurationOutput), nil
}

// UpdateMatchmakingConfigurationRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates settings for a FlexMatch matchmaking configuration. To update settings,
// specify the configuration name to be updated and provide the new settings.
//
// Operations related to match configurations and rule sets include:
//
//    * CreateMatchmakingConfiguration
//
//    * DescribeMatchmakingConfigurations
//
//    * UpdateMatchmakingConfiguration
//
//    * DeleteMatchmakingConfiguration
//
//    * CreateMatchmakingRuleSet
//
//    * DescribeMatchmakingRuleSets
//
//    * ValidateMatchmakingRuleSet
//
//    // Example sending a request using the UpdateMatchmakingConfigurationRequest method.
//    req := client.UpdateMatchmakingConfigurationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateMatchmakingConfiguration
func (c *GameLift) UpdateMatchmakingConfigurationRequest(input *UpdateMatchmakingConfigurationInput) UpdateMatchmakingConfigurationRequest {
	op := &aws.Operation{
		Name:       opUpdateMatchmakingConfiguration,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateMatchmakingConfigurationInput{}
	}

	output := &UpdateMatchmakingConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateMatchmakingConfigurationRequest{Request: req, Input: input, Copy: c.UpdateMatchmakingConfigurationRequest}
}

const opUpdateRuntimeConfiguration = "UpdateRuntimeConfiguration"

// UpdateRuntimeConfigurationRequest is a API request type for the UpdateRuntimeConfiguration API operation.
type UpdateRuntimeConfigurationRequest struct {
	*aws.Request
	Input *UpdateRuntimeConfigurationInput
	Copy  func(*UpdateRuntimeConfigurationInput) UpdateRuntimeConfigurationRequest
}

// Send marshals and sends the UpdateRuntimeConfiguration API request.
func (r UpdateRuntimeConfigurationRequest) Send() (*UpdateRuntimeConfigurationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRuntimeConfigurationOutput), nil
}

// UpdateRuntimeConfigurationRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Updates the current run-time configuration for the specified fleet, which
// tells Amazon GameLift how to launch server processes on instances in the
// fleet. You can update a fleet's run-time configuration at any time after
// the fleet is created; it does not need to be in an ACTIVE status.
//
// To update run-time configuration, specify the fleet ID and provide a RuntimeConfiguration
// object with the updated collection of server process configurations.
//
// Each instance in a Amazon GameLift fleet checks regularly for an updated
// run-time configuration and changes how it launches server processes to comply
// with the latest version. Existing server processes are not affected by the
// update; they continue to run until they end, while Amazon GameLift simply
// adds new server processes to fit the current run-time configuration. As a
// result, the run-time configuration changes are applied gradually as existing
// processes shut down and new processes are launched in Amazon GameLift's normal
// process recycling activity.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
//
//    // Example sending a request using the UpdateRuntimeConfigurationRequest method.
//    req := client.UpdateRuntimeConfigurationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateRuntimeConfiguration
func (c *GameLift) UpdateRuntimeConfigurationRequest(input *UpdateRuntimeConfigurationInput) UpdateRuntimeConfigurationRequest {
	op := &aws.Operation{
		Name:       opUpdateRuntimeConfiguration,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateRuntimeConfigurationInput{}
	}

	output := &UpdateRuntimeConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateRuntimeConfigurationRequest{Request: req, Input: input, Copy: c.UpdateRuntimeConfigurationRequest}
}

const opValidateMatchmakingRuleSet = "ValidateMatchmakingRuleSet"

// ValidateMatchmakingRuleSetRequest is a API request type for the ValidateMatchmakingRuleSet API operation.
type ValidateMatchmakingRuleSetRequest struct {
	*aws.Request
	Input *ValidateMatchmakingRuleSetInput
	Copy  func(*ValidateMatchmakingRuleSetInput) ValidateMatchmakingRuleSetRequest
}

// Send marshals and sends the ValidateMatchmakingRuleSet API request.
func (r ValidateMatchmakingRuleSetRequest) Send() (*ValidateMatchmakingRuleSetOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ValidateMatchmakingRuleSetOutput), nil
}

// ValidateMatchmakingRuleSetRequest returns a request value for making API operation for
// Amazon GameLift.
//
// Validates the syntax of a matchmaking rule or rule set. This operation checks
// that the rule set uses syntactically correct JSON and that it conforms to
// allowed property expressions. To validate syntax, provide a rule set string.
//
// Operations related to match configurations and rule sets include:
//
//    * CreateMatchmakingConfiguration
//
//    * DescribeMatchmakingConfigurations
//
//    * UpdateMatchmakingConfiguration
//
//    * DeleteMatchmakingConfiguration
//
//    * CreateMatchmakingRuleSet
//
//    * DescribeMatchmakingRuleSets
//
//    * ValidateMatchmakingRuleSet
//
//    // Example sending a request using the ValidateMatchmakingRuleSetRequest method.
//    req := client.ValidateMatchmakingRuleSetRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ValidateMatchmakingRuleSet
func (c *GameLift) ValidateMatchmakingRuleSetRequest(input *ValidateMatchmakingRuleSetInput) ValidateMatchmakingRuleSetRequest {
	op := &aws.Operation{
		Name:       opValidateMatchmakingRuleSet,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ValidateMatchmakingRuleSetInput{}
	}

	output := &ValidateMatchmakingRuleSetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ValidateMatchmakingRuleSetRequest{Request: req, Input: input, Copy: c.ValidateMatchmakingRuleSetRequest}
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/AcceptMatchInput
type AcceptMatchInput struct {
	_ struct{} `type:"structure"`

	// Player response to the proposed match.
	//
	// AcceptanceType is a required field
	AcceptanceType AcceptanceType `type:"string" required:"true" enum:"true"`

	// Unique identifier for a player delivering the response. This parameter can
	// include one or multiple player IDs.
	//
	// PlayerIds is a required field
	PlayerIds []string `type:"list" required:"true"`

	// Unique identifier for a matchmaking ticket. The ticket must be in status
	// REQUIRES_ACCEPTANCE; otherwise this request will fail.
	//
	// TicketId is a required field
	TicketId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s AcceptMatchInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AcceptMatchInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AcceptMatchInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AcceptMatchInput"}
	if len(s.AcceptanceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("AcceptanceType"))
	}

	if s.PlayerIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("PlayerIds"))
	}

	if s.TicketId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TicketId"))
	}
	if s.TicketId != nil && len(*s.TicketId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TicketId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/AcceptMatchOutput
type AcceptMatchOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AcceptMatchOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AcceptMatchOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AcceptMatchOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Properties describing a fleet alias.
//
// Alias-related operations include:
//
//    * CreateAlias
//
//    * ListAliases
//
//    * DescribeAlias
//
//    * UpdateAlias
//
//    * DeleteAlias
//
//    * ResolveAlias
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/Alias
type Alias struct {
	_ struct{} `type:"structure"`

	// Unique identifier for an alias; alias ARNs are unique across all regions.
	AliasArn *string `min:"1" type:"string"`

	// Unique identifier for an alias; alias IDs are unique within a region.
	AliasId *string `type:"string"`

	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Human-readable description of an alias.
	Description *string `type:"string"`

	// Time stamp indicating when this data object was last modified. Format is
	// a number expressed in Unix time as milliseconds (for example "1469498468.057").
	LastUpdatedTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Descriptive label that is associated with an alias. Alias names do not need
	// to be unique.
	Name *string `min:"1" type:"string"`

	// Alias configuration for the alias, including routing type and settings.
	RoutingStrategy *RoutingStrategy `type:"structure"`
}

// String returns the string representation
func (s Alias) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Alias) GoString() string {
	return s.String()
}

// Values for use in Player attribute key:value pairs. This object lets you
// specify an attribute value using any of the valid data types: string, number,
// string array or data map. Each AttributeValue object can use only one of
// the available properties.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/AttributeValue
type AttributeValue struct {
	_ struct{} `type:"structure"`

	// For number values, expressed as double.
	N *float64 `type:"double"`

	// For single string values. Maximum string length is 100 characters.
	S *string `min:"1" type:"string"`

	// For a map of up to 10 data type:value pairs. Maximum length for each string
	// value is 100 characters.
	SDM map[string]float64 `type:"map"`

	// For a list of up to 10 strings. Maximum length for each string is 100 characters.
	// Duplicate values are not recognized; all occurrences of the repeated value
	// after the first of a repeated value are ignored.
	SL []string `type:"list"`
}

// String returns the string representation
func (s AttributeValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeValue) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttributeValue) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttributeValue"}
	if s.S != nil && len(*s.S) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("S", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Temporary access credentials used for uploading game build files to Amazon
// GameLift. They are valid for a limited time. If they expire before you upload
// your game build, get a new set by calling RequestUploadCredentials.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/AwsCredentials
type AwsCredentials struct {
	_ struct{} `type:"structure"`

	// Temporary key allowing access to the Amazon GameLift S3 account.
	AccessKeyId *string `min:"1" type:"string"`

	// Temporary secret key allowing access to the Amazon GameLift S3 account.
	SecretAccessKey *string `min:"1" type:"string"`

	// Token used to associate a specific build ID with the files uploaded using
	// these credentials.
	SessionToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s AwsCredentials) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AwsCredentials) GoString() string {
	return s.String()
}

// Properties describing a game build.
//
// Build-related operations include:
//
//    * CreateBuild
//
//    * ListBuilds
//
//    * DescribeBuild
//
//    * UpdateBuild
//
//    * DeleteBuild
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/Build
type Build struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a build.
	BuildId *string `type:"string"`

	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Descriptive label that is associated with a build. Build names do not need
	// to be unique. It can be set using CreateBuild or UpdateBuild.
	Name *string `type:"string"`

	// Operating system that the game server binaries are built to run on. This
	// value determines the type of fleet resources that you can use for this build.
	OperatingSystem OperatingSystem `type:"string" enum:"true"`

	// File size of the uploaded game build, expressed in bytes. When the build
	// status is INITIALIZED, this value is 0.
	SizeOnDisk *int64 `min:"1" type:"long"`

	// Current status of the build.
	//
	// Possible build statuses include the following:
	//
	//    * INITIALIZED -- A new build has been defined, but no files have been
	//    uploaded. You cannot create fleets for builds that are in this status.
	//    When a build is successfully created, the build status is set to this
	//    value.
	//
	//    * READY -- The game build has been successfully uploaded. You can now
	//    create new fleets for this build.
	//
	//    * FAILED -- The game build upload failed. You cannot create new fleets
	//    for this build.
	Status BuildStatus `type:"string" enum:"true"`

	// Version that is associated with this build. Version strings do not need to
	// be unique. This value can be set using CreateBuild or UpdateBuild.
	Version *string `type:"string"`
}

// String returns the string representation
func (s Build) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Build) GoString() string {
	return s.String()
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateAliasInput
type CreateAliasInput struct {
	_ struct{} `type:"structure"`

	// Human-readable description of an alias.
	Description *string `min:"1" type:"string"`

	// Descriptive label that is associated with an alias. Alias names do not need
	// to be unique.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// Object that specifies the fleet and routing type to use for the alias.
	//
	// RoutingStrategy is a required field
	RoutingStrategy *RoutingStrategy `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateAliasInput"}
	if s.Description != nil && len(*s.Description) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Description", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.RoutingStrategy == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoutingStrategy"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateAliasOutput
type CreateAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the newly created alias record.
	Alias *Alias `type:"structure"`
}

// String returns the string representation
func (s CreateAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateBuildInput
type CreateBuildInput struct {
	_ struct{} `type:"structure"`

	// Descriptive label that is associated with a build. Build names do not need
	// to be unique. You can use UpdateBuild to change this value later.
	Name *string `min:"1" type:"string"`

	// Operating system that the game server binaries are built to run on. This
	// value determines the type of fleet resources that you can use for this build.
	// If your game build contains multiple executables, they all must run on the
	// same operating system. If an operating system is not specified when creating
	// a build, Amazon GameLift uses the default value (WINDOWS_2012). This value
	// cannot be changed later.
	OperatingSystem OperatingSystem `type:"string" enum:"true"`

	// Information indicating where your game build files are stored. Use this parameter
	// only when creating a build with files stored in an Amazon S3 bucket that
	// you own. The storage location must specify an Amazon S3 bucket name and key,
	// as well as a role ARN that you set up to allow Amazon GameLift to access
	// your Amazon S3 bucket. The S3 bucket must be in the same region that you
	// want to create a new build in.
	StorageLocation *S3Location `type:"structure"`

	// Version that is associated with this build. Version strings do not need to
	// be unique. You can use UpdateBuild to change this value later.
	Version *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateBuildInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBuildInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBuildInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateBuildInput"}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}
	if s.StorageLocation != nil {
		if err := s.StorageLocation.Validate(); err != nil {
			invalidParams.AddNested("StorageLocation", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateBuildOutput
type CreateBuildOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The newly created build record, including a unique build ID and status.
	Build *Build `type:"structure"`

	// Amazon S3 location for your game build file, including bucket name and key.
	StorageLocation *S3Location `type:"structure"`

	// This element is returned only when the operation is called without a storage
	// location. It contains credentials to use when you are uploading a build file
	// to an Amazon S3 bucket that is owned by Amazon GameLift. Credentials have
	// a limited life span. To refresh these credentials, call RequestUploadCredentials.
	UploadCredentials *AwsCredentials `type:"structure"`
}

// String returns the string representation
func (s CreateBuildOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBuildOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateBuildOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateFleetInput
type CreateFleetInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a build to be deployed on the new fleet. The build
	// must have been successfully uploaded to Amazon GameLift and be in a READY
	// status. This fleet setting cannot be changed once the fleet is created.
	//
	// BuildId is a required field
	BuildId *string `type:"string" required:"true"`

	// Human-readable description of a fleet.
	Description *string `min:"1" type:"string"`

	// Range of IP addresses and port settings that permit inbound traffic to access
	// server processes running on the fleet. If no inbound permissions are set,
	// including both IP address range and port range, the server processes in the
	// fleet cannot accept connections. You can specify one or more sets of permissions
	// for a fleet.
	EC2InboundPermissions []IpPermission `type:"list"`

	// Name of an EC2 instance type that is supported in Amazon GameLift. A fleet
	// instance type determines the computing resources of each instance in the
	// fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift
	// supports the following EC2 instance types. See Amazon EC2 Instance Types
	// (http://aws.amazon.com/ec2/instance-types/) for detailed descriptions.
	//
	// EC2InstanceType is a required field
	EC2InstanceType EC2InstanceType `type:"string" required:"true" enum:"true"`

	// Indicates whether to use on-demand instances or spot instances for this fleet.
	// If empty, the default is ON_DEMAND. Both categories of instances use identical
	// hardware and configurations, based on the instance type selected for this
	// fleet. You can acquire on-demand instances at any time for a fixed price
	// and keep them as long as you need them. Spot instances have lower prices,
	// but spot pricing is variable, and while in use they can be interrupted (with
	// a two-minute notification). Learn more about Amazon GameLift spot instances
	// with at  Choose Computing Resources (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-ec2-instances.html).
	FleetType FleetType `type:"string" enum:"true"`

	// This parameter is no longer used. Instead, to specify where Amazon GameLift
	// should store log files once a server process shuts down, use the Amazon GameLift
	// server API ProcessReady() and specify one or more directory paths in logParameters.
	// See more information in the Server API Reference (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api-ref.html#gamelift-sdk-server-api-ref-dataypes-process).
	LogPaths []string `type:"list"`

	// Name of a metric group to add this fleet to. A metric group tracks metrics
	// across all fleets in the group. Use an existing metric group name to add
	// this fleet to the group, or use a new name to create a new metric group.
	// A fleet can only be included in one metric group at a time.
	MetricGroups []string `type:"list"`

	// Descriptive label that is associated with a fleet. Fleet names do not need
	// to be unique.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// Game session protection policy to apply to all instances in this fleet. If
	// this parameter is not set, instances in this fleet default to no protection.
	// You can change a fleet's protection policy using UpdateFleetAttributes, but
	// this change will only affect sessions created after the policy change. You
	// can also set protection for individual instances using UpdateGameSession.
	//
	//    * NoProtection -- The game session can be terminated during a scale-down
	//    event.
	//
	//    * FullProtection -- If the game session is in an ACTIVE status, it cannot
	//    be terminated during a scale-down event.
	NewGameSessionProtectionPolicy ProtectionPolicy `type:"string" enum:"true"`

	// Unique identifier for the AWS account with the VPC that you want to peer
	// your Amazon GameLift fleet with. You can find your Account ID in the AWS
	// Management Console under account settings.
	PeerVpcAwsAccountId *string `min:"1" type:"string"`

	// Unique identifier for a VPC with resources to be accessed by your Amazon
	// GameLift fleet. The VPC must be in the same region where your fleet is deployed.
	// To get VPC information, including IDs, use the Virtual Private Cloud service
	// tools, including the VPC Dashboard in the AWS Management Console.
	PeerVpcId *string `min:"1" type:"string"`

	// Policy that limits the number of game sessions an individual player can create
	// over a span of time for this fleet.
	ResourceCreationLimitPolicy *ResourceCreationLimitPolicy `type:"structure"`

	// Instructions for launching server processes on each instance in the fleet.
	// The run-time configuration for a fleet has a collection of server process
	// configurations, one for each type of server process to run on an instance.
	// A server process configuration specifies the location of the server executable,
	// launch parameters, and the number of concurrent processes with that configuration
	// to maintain on each instance. A CreateFleet request must include a run-time
	// configuration with at least one server process configuration; otherwise the
	// request fails with an invalid request exception. (This parameter replaces
	// the parameters ServerLaunchPath and ServerLaunchParameters; requests that
	// contain values for these parameters instead of a run-time configuration will
	// continue to work.)
	RuntimeConfiguration *RuntimeConfiguration `type:"structure"`

	// This parameter is no longer used. Instead, specify server launch parameters
	// in the RuntimeConfiguration parameter. (Requests that specify a server launch
	// path and launch parameters instead of a run-time configuration will continue
	// to work.)
	ServerLaunchParameters *string `min:"1" type:"string"`

	// This parameter is no longer used. Instead, specify a server launch path using
	// the RuntimeConfiguration parameter. (Requests that specify a server launch
	// path and launch parameters instead of a run-time configuration will continue
	// to work.)
	ServerLaunchPath *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateFleetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFleetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateFleetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateFleetInput"}

	if s.BuildId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BuildId"))
	}
	if s.Description != nil && len(*s.Description) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Description", 1))
	}
	if len(s.EC2InstanceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("EC2InstanceType"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.PeerVpcAwsAccountId != nil && len(*s.PeerVpcAwsAccountId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PeerVpcAwsAccountId", 1))
	}
	if s.PeerVpcId != nil && len(*s.PeerVpcId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PeerVpcId", 1))
	}
	if s.ServerLaunchParameters != nil && len(*s.ServerLaunchParameters) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ServerLaunchParameters", 1))
	}
	if s.ServerLaunchPath != nil && len(*s.ServerLaunchPath) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ServerLaunchPath", 1))
	}
	if s.EC2InboundPermissions != nil {
		for i, v := range s.EC2InboundPermissions {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "EC2InboundPermissions", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.RuntimeConfiguration != nil {
		if err := s.RuntimeConfiguration.Validate(); err != nil {
			invalidParams.AddNested("RuntimeConfiguration", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateFleetOutput
type CreateFleetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Properties for the newly created fleet.
	FleetAttributes *FleetAttributes `type:"structure"`
}

// String returns the string representation
func (s CreateFleetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateFleetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateFleetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateGameSessionInput
type CreateGameSessionInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for an alias associated with the fleet to create a game
	// session in. Each request must reference either a fleet ID or alias ID, but
	// not both.
	AliasId *string `type:"string"`

	// Unique identifier for a player or entity creating the game session. This
	// ID is used to enforce a resource protection policy (if one exists) that limits
	// the number of concurrent active game sessions one player can have.
	CreatorId *string `min:"1" type:"string"`

	// Unique identifier for a fleet to create a game session in. Each request must
	// reference either a fleet ID or alias ID, but not both.
	FleetId *string `type:"string"`

	// Set of custom properties for a game session, formatted as key:value pairs.
	// These properties are passed to a game server process in the GameSession object
	// with a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameProperties []GameProperty `type:"list"`

	// Set of custom game session properties, formatted as a single string value.
	// This data is passed to a game server process in the GameSession object with
	// a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameSessionData *string `min:"1" type:"string"`

	// This parameter is no longer preferred. Please use IdempotencyToken instead.
	// Custom string that uniquely identifies a request for a new game session.
	// Maximum token length is 48 characters. If provided, this string is included
	// in the new game session's ID. (A game session ARN has the following format:
	// arn:aws:gamelift:<region>::gamesession/<fleet ID>/<custom ID string or idempotency
	// token>.)
	GameSessionId *string `min:"1" type:"string"`

	// Custom string that uniquely identifies a request for a new game session.
	// Maximum token length is 48 characters. If provided, this string is included
	// in the new game session's ID. (A game session ARN has the following format:
	// arn:aws:gamelift:<region>::gamesession/<fleet ID>/<custom ID string or idempotency
	// token>.) Idempotency tokens remain in use for 30 days after a game session
	// has ended; game session objects are retained for this time period and then
	// deleted.
	IdempotencyToken *string `min:"1" type:"string"`

	// Maximum number of players that can be connected simultaneously to the game
	// session.
	//
	// MaximumPlayerSessionCount is a required field
	MaximumPlayerSessionCount *int64 `type:"integer" required:"true"`

	// Descriptive label that is associated with a game session. Session names do
	// not need to be unique.
	Name *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateGameSessionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGameSessionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateGameSessionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateGameSessionInput"}
	if s.CreatorId != nil && len(*s.CreatorId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CreatorId", 1))
	}
	if s.GameSessionData != nil && len(*s.GameSessionData) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionData", 1))
	}
	if s.GameSessionId != nil && len(*s.GameSessionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionId", 1))
	}
	if s.IdempotencyToken != nil && len(*s.IdempotencyToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("IdempotencyToken", 1))
	}

	if s.MaximumPlayerSessionCount == nil {
		invalidParams.Add(aws.NewErrParamRequired("MaximumPlayerSessionCount"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.GameProperties != nil {
		for i, v := range s.GameProperties {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "GameProperties", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateGameSessionOutput
type CreateGameSessionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the newly created game session record.
	GameSession *GameSession `type:"structure"`
}

// String returns the string representation
func (s CreateGameSessionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGameSessionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateGameSessionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateGameSessionQueueInput
type CreateGameSessionQueueInput struct {
	_ struct{} `type:"structure"`

	// List of fleets that can be used to fulfill game session placement requests
	// in the queue. Fleets are identified by either a fleet ARN or a fleet alias
	// ARN. Destinations are listed in default preference order.
	Destinations []GameSessionQueueDestination `type:"list"`

	// Descriptive label that is associated with game session queue. Queue names
	// must be unique within each region.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// Collection of latency policies to apply when processing game sessions placement
	// requests with player latency information. Multiple policies are evaluated
	// in order of the maximum latency value, starting with the lowest latency values.
	// With just one policy, it is enforced at the start of the game session placement
	// for the duration period. With multiple policies, each policy is enforced
	// consecutively for its duration period. For example, a queue might enforce
	// a 60-second policy followed by a 120-second policy, and then no policy for
	// the remainder of the placement. A player latency policy must set a value
	// for MaximumIndividualPlayerLatencyMilliseconds; if none is set, this API
	// requests will fail.
	PlayerLatencyPolicies []PlayerLatencyPolicy `type:"list"`

	// Maximum time, in seconds, that a new game session placement request remains
	// in the queue. When a request exceeds this time, the game session placement
	// changes to a TIMED_OUT status.
	TimeoutInSeconds *int64 `type:"integer"`
}

// String returns the string representation
func (s CreateGameSessionQueueInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGameSessionQueueInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateGameSessionQueueInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateGameSessionQueueInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.Destinations != nil {
		for i, v := range s.Destinations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Destinations", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateGameSessionQueueOutput
type CreateGameSessionQueueOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the newly created game session queue.
	GameSessionQueue *GameSessionQueue `type:"structure"`
}

// String returns the string representation
func (s CreateGameSessionQueueOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGameSessionQueueOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateGameSessionQueueOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateMatchmakingConfigurationInput
type CreateMatchmakingConfigurationInput struct {
	_ struct{} `type:"structure"`

	// Flag that determines whether or not a match that was created with this configuration
	// must be accepted by the matched players. To require acceptance, set to TRUE.
	//
	// AcceptanceRequired is a required field
	AcceptanceRequired *bool `type:"boolean" required:"true"`

	// Length of time (in seconds) to wait for players to accept a proposed match.
	// If any player rejects the match or fails to accept before the timeout, the
	// ticket continues to look for an acceptable match.
	AcceptanceTimeoutSeconds *int64 `min:"1" type:"integer"`

	// Number of player slots in a match to keep open for future players. For example,
	// if the configuration's rule set specifies a match for a single 12-person
	// team, and the additional player count is set to 2, only 10 players are selected
	// for the match.
	AdditionalPlayerCount *int64 `type:"integer"`

	// Information to attached to all events related to the matchmaking configuration.
	CustomEventData *string `type:"string"`

	// Meaningful description of the matchmaking configuration.
	Description *string `min:"1" type:"string"`

	// Set of custom properties for a game session, formatted as key:value pairs.
	// These properties are passed to a game server process in the GameSession object
	// with a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// This information is added to the new GameSession object that is created for
	// a successful match.
	GameProperties []GameProperty `type:"list"`

	// Set of custom game session properties, formatted as a single string value.
	// This data is passed to a game server process in the GameSession object with
	// a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// This information is added to the new GameSession object that is created for
	// a successful match.
	GameSessionData *string `min:"1" type:"string"`

	// Amazon Resource Name (ARN (http://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html))
	// that is assigned to a game session queue and uniquely identifies it. Format
	// is arn:aws:gamelift:<region>::fleet/fleet-a1234567-b8c9-0d1e-2fa3-b45c6d7e8912.
	// These queues are used when placing game sessions for matches that are created
	// with this matchmaking configuration. Queues can be located in any region.
	//
	// GameSessionQueueArns is a required field
	GameSessionQueueArns []string `type:"list" required:"true"`

	// Unique identifier for a matchmaking configuration. This name is used to identify
	// the configuration associated with a matchmaking request or ticket.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// SNS topic ARN that is set up to receive matchmaking notifications.
	NotificationTarget *string `type:"string"`

	// Maximum duration, in seconds, that a matchmaking ticket can remain in process
	// before timing out. Requests that time out can be resubmitted as needed.
	//
	// RequestTimeoutSeconds is a required field
	RequestTimeoutSeconds *int64 `min:"1" type:"integer" required:"true"`

	// Unique identifier for a matchmaking rule set to use with this configuration.
	// A matchmaking configuration can only use rule sets that are defined in the
	// same region.
	//
	// RuleSetName is a required field
	RuleSetName *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateMatchmakingConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateMatchmakingConfigurationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateMatchmakingConfigurationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateMatchmakingConfigurationInput"}

	if s.AcceptanceRequired == nil {
		invalidParams.Add(aws.NewErrParamRequired("AcceptanceRequired"))
	}
	if s.AcceptanceTimeoutSeconds != nil && *s.AcceptanceTimeoutSeconds < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("AcceptanceTimeoutSeconds", 1))
	}
	if s.Description != nil && len(*s.Description) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Description", 1))
	}
	if s.GameSessionData != nil && len(*s.GameSessionData) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionData", 1))
	}

	if s.GameSessionQueueArns == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameSessionQueueArns"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.RequestTimeoutSeconds == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestTimeoutSeconds"))
	}
	if s.RequestTimeoutSeconds != nil && *s.RequestTimeoutSeconds < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("RequestTimeoutSeconds", 1))
	}

	if s.RuleSetName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleSetName"))
	}
	if s.RuleSetName != nil && len(*s.RuleSetName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleSetName", 1))
	}
	if s.GameProperties != nil {
		for i, v := range s.GameProperties {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "GameProperties", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateMatchmakingConfigurationOutput
type CreateMatchmakingConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the newly created matchmaking configuration.
	Configuration *MatchmakingConfiguration `type:"structure"`
}

// String returns the string representation
func (s CreateMatchmakingConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateMatchmakingConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateMatchmakingConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateMatchmakingRuleSetInput
type CreateMatchmakingRuleSetInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a matchmaking rule set. This name is used to identify
	// the rule set associated with a matchmaking configuration.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// Collection of matchmaking rules, formatted as a JSON string. (Note that comments
	// are not allowed in JSON, but most elements support a description field.)
	//
	// RuleSetBody is a required field
	RuleSetBody *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateMatchmakingRuleSetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateMatchmakingRuleSetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateMatchmakingRuleSetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateMatchmakingRuleSetInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if s.RuleSetBody == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleSetBody"))
	}
	if s.RuleSetBody != nil && len(*s.RuleSetBody) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleSetBody", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateMatchmakingRuleSetOutput
type CreateMatchmakingRuleSetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the newly created matchmaking rule set.
	//
	// RuleSet is a required field
	RuleSet *MatchmakingRuleSet `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateMatchmakingRuleSetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateMatchmakingRuleSetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateMatchmakingRuleSetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreatePlayerSessionInput
type CreatePlayerSessionInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for the game session to add a player to.
	//
	// GameSessionId is a required field
	GameSessionId *string `min:"1" type:"string" required:"true"`

	// Developer-defined information related to a player. Amazon GameLift does not
	// use this data, so it can be formatted as needed for use in the game.
	PlayerData *string `min:"1" type:"string"`

	// Unique identifier for a player. Player IDs are developer-defined.
	//
	// PlayerId is a required field
	PlayerId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreatePlayerSessionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePlayerSessionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreatePlayerSessionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreatePlayerSessionInput"}

	if s.GameSessionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameSessionId"))
	}
	if s.GameSessionId != nil && len(*s.GameSessionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionId", 1))
	}
	if s.PlayerData != nil && len(*s.PlayerData) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerData", 1))
	}

	if s.PlayerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PlayerId"))
	}
	if s.PlayerId != nil && len(*s.PlayerId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreatePlayerSessionOutput
type CreatePlayerSessionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the newly created player session record.
	PlayerSession *PlayerSession `type:"structure"`
}

// String returns the string representation
func (s CreatePlayerSessionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePlayerSessionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreatePlayerSessionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreatePlayerSessionsInput
type CreatePlayerSessionsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for the game session to add players to.
	//
	// GameSessionId is a required field
	GameSessionId *string `min:"1" type:"string" required:"true"`

	// Map of string pairs, each specifying a player ID and a set of developer-defined
	// information related to the player. Amazon GameLift does not use this data,
	// so it can be formatted as needed for use in the game. Player data strings
	// for player IDs not included in the PlayerIds parameter are ignored.
	PlayerDataMap map[string]string `type:"map"`

	// List of unique identifiers for the players to be added.
	//
	// PlayerIds is a required field
	PlayerIds []string `min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s CreatePlayerSessionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePlayerSessionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreatePlayerSessionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreatePlayerSessionsInput"}

	if s.GameSessionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameSessionId"))
	}
	if s.GameSessionId != nil && len(*s.GameSessionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionId", 1))
	}

	if s.PlayerIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("PlayerIds"))
	}
	if s.PlayerIds != nil && len(s.PlayerIds) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerIds", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreatePlayerSessionsOutput
type CreatePlayerSessionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of player session objects created for the added players.
	PlayerSessions []PlayerSession `type:"list"`
}

// String returns the string representation
func (s CreatePlayerSessionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePlayerSessionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreatePlayerSessionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateVpcPeeringAuthorizationInput
type CreateVpcPeeringAuthorizationInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for the AWS account that you use to manage your Amazon
	// GameLift fleet. You can find your Account ID in the AWS Management Console
	// under account settings.
	//
	// GameLiftAwsAccountId is a required field
	GameLiftAwsAccountId *string `min:"1" type:"string" required:"true"`

	// Unique identifier for a VPC with resources to be accessed by your Amazon
	// GameLift fleet. The VPC must be in the same region where your fleet is deployed.
	// To get VPC information, including IDs, use the Virtual Private Cloud service
	// tools, including the VPC Dashboard in the AWS Management Console.
	//
	// PeerVpcId is a required field
	PeerVpcId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateVpcPeeringAuthorizationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVpcPeeringAuthorizationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateVpcPeeringAuthorizationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateVpcPeeringAuthorizationInput"}

	if s.GameLiftAwsAccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameLiftAwsAccountId"))
	}
	if s.GameLiftAwsAccountId != nil && len(*s.GameLiftAwsAccountId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameLiftAwsAccountId", 1))
	}

	if s.PeerVpcId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PeerVpcId"))
	}
	if s.PeerVpcId != nil && len(*s.PeerVpcId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PeerVpcId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateVpcPeeringAuthorizationOutput
type CreateVpcPeeringAuthorizationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Details on the requested VPC peering authorization, including expiration.
	VpcPeeringAuthorization *VpcPeeringAuthorization `type:"structure"`
}

// String returns the string representation
func (s CreateVpcPeeringAuthorizationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVpcPeeringAuthorizationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateVpcPeeringAuthorizationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateVpcPeeringConnectionInput
type CreateVpcPeeringConnectionInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet. This tells Amazon GameLift which GameLift
	// VPC to peer with.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Unique identifier for the AWS account with the VPC that you want to peer
	// your Amazon GameLift fleet with. You can find your Account ID in the AWS
	// Management Console under account settings.
	//
	// PeerVpcAwsAccountId is a required field
	PeerVpcAwsAccountId *string `min:"1" type:"string" required:"true"`

	// Unique identifier for a VPC with resources to be accessed by your Amazon
	// GameLift fleet. The VPC must be in the same region where your fleet is deployed.
	// To get VPC information, including IDs, use the Virtual Private Cloud service
	// tools, including the VPC Dashboard in the AWS Management Console.
	//
	// PeerVpcId is a required field
	PeerVpcId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateVpcPeeringConnectionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVpcPeeringConnectionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateVpcPeeringConnectionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateVpcPeeringConnectionInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if s.PeerVpcAwsAccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PeerVpcAwsAccountId"))
	}
	if s.PeerVpcAwsAccountId != nil && len(*s.PeerVpcAwsAccountId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PeerVpcAwsAccountId", 1))
	}

	if s.PeerVpcId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PeerVpcId"))
	}
	if s.PeerVpcId != nil && len(*s.PeerVpcId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PeerVpcId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/CreateVpcPeeringConnectionOutput
type CreateVpcPeeringConnectionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateVpcPeeringConnectionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVpcPeeringConnectionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateVpcPeeringConnectionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteAliasInput
type DeleteAliasInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet alias. Specify the alias you want to delete.
	//
	// AliasId is a required field
	AliasId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteAliasInput"}

	if s.AliasId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AliasId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteAliasOutput
type DeleteAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteBuildInput
type DeleteBuildInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a build to delete.
	//
	// BuildId is a required field
	BuildId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBuildInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBuildInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBuildInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBuildInput"}

	if s.BuildId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BuildId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteBuildOutput
type DeleteBuildOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBuildOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBuildOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBuildOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteFleetInput
type DeleteFleetInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet to be deleted.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteFleetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFleetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteFleetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteFleetInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteFleetOutput
type DeleteFleetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteFleetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFleetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteFleetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteGameSessionQueueInput
type DeleteGameSessionQueueInput struct {
	_ struct{} `type:"structure"`

	// Descriptive label that is associated with game session queue. Queue names
	// must be unique within each region.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteGameSessionQueueInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGameSessionQueueInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteGameSessionQueueInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteGameSessionQueueInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteGameSessionQueueOutput
type DeleteGameSessionQueueOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteGameSessionQueueOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGameSessionQueueOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteGameSessionQueueOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteMatchmakingConfigurationInput
type DeleteMatchmakingConfigurationInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a matchmaking configuration
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteMatchmakingConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMatchmakingConfigurationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteMatchmakingConfigurationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteMatchmakingConfigurationInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteMatchmakingConfigurationOutput
type DeleteMatchmakingConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteMatchmakingConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMatchmakingConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteMatchmakingConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteScalingPolicyInput
type DeleteScalingPolicyInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet to be deleted.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Descriptive label that is associated with a scaling policy. Policy names
	// do not need to be unique.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteScalingPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteScalingPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteScalingPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteScalingPolicyInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteScalingPolicyOutput
type DeleteScalingPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteScalingPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteScalingPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteScalingPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteVpcPeeringAuthorizationInput
type DeleteVpcPeeringAuthorizationInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for the AWS account that you use to manage your Amazon
	// GameLift fleet. You can find your Account ID in the AWS Management Console
	// under account settings.
	//
	// GameLiftAwsAccountId is a required field
	GameLiftAwsAccountId *string `min:"1" type:"string" required:"true"`

	// Unique identifier for a VPC with resources to be accessed by your Amazon
	// GameLift fleet. The VPC must be in the same region where your fleet is deployed.
	// To get VPC information, including IDs, use the Virtual Private Cloud service
	// tools, including the VPC Dashboard in the AWS Management Console.
	//
	// PeerVpcId is a required field
	PeerVpcId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteVpcPeeringAuthorizationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVpcPeeringAuthorizationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteVpcPeeringAuthorizationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteVpcPeeringAuthorizationInput"}

	if s.GameLiftAwsAccountId == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameLiftAwsAccountId"))
	}
	if s.GameLiftAwsAccountId != nil && len(*s.GameLiftAwsAccountId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameLiftAwsAccountId", 1))
	}

	if s.PeerVpcId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PeerVpcId"))
	}
	if s.PeerVpcId != nil && len(*s.PeerVpcId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PeerVpcId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteVpcPeeringAuthorizationOutput
type DeleteVpcPeeringAuthorizationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteVpcPeeringAuthorizationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVpcPeeringAuthorizationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteVpcPeeringAuthorizationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteVpcPeeringConnectionInput
type DeleteVpcPeeringConnectionInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet. This value must match the fleet ID referenced
	// in the VPC peering connection record.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Unique identifier for a VPC peering connection. This value is included in
	// the VpcPeeringConnection object, which can be retrieved by calling DescribeVpcPeeringConnections.
	//
	// VpcPeeringConnectionId is a required field
	VpcPeeringConnectionId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteVpcPeeringConnectionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVpcPeeringConnectionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteVpcPeeringConnectionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteVpcPeeringConnectionInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if s.VpcPeeringConnectionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VpcPeeringConnectionId"))
	}
	if s.VpcPeeringConnectionId != nil && len(*s.VpcPeeringConnectionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("VpcPeeringConnectionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DeleteVpcPeeringConnectionOutput
type DeleteVpcPeeringConnectionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteVpcPeeringConnectionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVpcPeeringConnectionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteVpcPeeringConnectionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeAliasInput
type DescribeAliasInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet alias. Specify the alias you want to retrieve.
	//
	// AliasId is a required field
	AliasId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeAliasInput"}

	if s.AliasId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AliasId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeAliasOutput
type DescribeAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that contains the requested alias.
	Alias *Alias `type:"structure"`
}

// String returns the string representation
func (s DescribeAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeBuildInput
type DescribeBuildInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a build to retrieve properties for.
	//
	// BuildId is a required field
	BuildId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeBuildInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBuildInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeBuildInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeBuildInput"}

	if s.BuildId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BuildId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeBuildOutput
type DescribeBuildOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Set of properties describing the requested build.
	Build *Build `type:"structure"`
}

// String returns the string representation
func (s DescribeBuildOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBuildOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeBuildOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeEC2InstanceLimitsInput
type DescribeEC2InstanceLimitsInput struct {
	_ struct{} `type:"structure"`

	// Name of an EC2 instance type that is supported in Amazon GameLift. A fleet
	// instance type determines the computing resources of each instance in the
	// fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift
	// supports the following EC2 instance types. See Amazon EC2 Instance Types
	// (http://aws.amazon.com/ec2/instance-types/) for detailed descriptions. Leave
	// this parameter blank to retrieve limits for all types.
	EC2InstanceType EC2InstanceType `type:"string" enum:"true"`
}

// String returns the string representation
func (s DescribeEC2InstanceLimitsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEC2InstanceLimitsInput) GoString() string {
	return s.String()
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeEC2InstanceLimitsOutput
type DescribeEC2InstanceLimitsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that contains the maximum number of instances for the specified instance
	// type.
	EC2InstanceLimits []EC2InstanceLimit `type:"list"`
}

// String returns the string representation
func (s DescribeEC2InstanceLimitsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEC2InstanceLimitsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeEC2InstanceLimitsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetAttributesInput
type DescribeFleetAttributesInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet(s) to retrieve attributes for. To request attributes
	// for all fleets, leave this parameter empty.
	FleetIds []string `min:"1" type:"list"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages. This parameter is ignored when
	// the request specifies one or a list of fleet IDs.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value. This parameter
	// is ignored when the request specifies one or a list of fleet IDs.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeFleetAttributesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetAttributesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeFleetAttributesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeFleetAttributesInput"}
	if s.FleetIds != nil && len(s.FleetIds) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FleetIds", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetAttributesOutput
type DescribeFleetAttributesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects containing attribute metadata for each requested fleet
	// ID.
	FleetAttributes []FleetAttributes `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeFleetAttributesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetAttributesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeFleetAttributesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetCapacityInput
type DescribeFleetCapacityInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet(s) to retrieve capacity information for. To
	// request capacity information for all fleets, leave this parameter empty.
	FleetIds []string `min:"1" type:"list"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages. This parameter is ignored when
	// the request specifies one or a list of fleet IDs.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value. This parameter
	// is ignored when the request specifies one or a list of fleet IDs.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeFleetCapacityInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetCapacityInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeFleetCapacityInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeFleetCapacityInput"}
	if s.FleetIds != nil && len(s.FleetIds) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FleetIds", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetCapacityOutput
type DescribeFleetCapacityOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects containing capacity information for each requested
	// fleet ID. Leave this parameter empty to retrieve capacity information for
	// all fleets.
	FleetCapacity []FleetCapacity `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeFleetCapacityOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetCapacityOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeFleetCapacityOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetEventsInput
type DescribeFleetEventsInput struct {
	_ struct{} `type:"structure"`

	// Most recent date to retrieve event logs for. If no end time is specified,
	// this call returns entries from the specified start time up to the present.
	// Format is a number expressed in Unix time as milliseconds (ex: "1469498468.057").
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique identifier for a fleet to get event logs for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`

	// Earliest date to retrieve event logs for. If no start time is specified,
	// this call returns entries starting from when the fleet was created to the
	// specified end time. Format is a number expressed in Unix time as milliseconds
	// (ex: "1469498468.057").
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s DescribeFleetEventsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetEventsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeFleetEventsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeFleetEventsInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetEventsOutput
type DescribeFleetEventsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects containing event log entries for the specified fleet.
	Events []Event `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeFleetEventsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetEventsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeFleetEventsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetPortSettingsInput
type DescribeFleetPortSettingsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet to retrieve port settings for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeFleetPortSettingsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetPortSettingsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeFleetPortSettingsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeFleetPortSettingsInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetPortSettingsOutput
type DescribeFleetPortSettingsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that contains port settings for the requested fleet ID.
	InboundPermissions []IpPermission `type:"list"`
}

// String returns the string representation
func (s DescribeFleetPortSettingsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetPortSettingsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeFleetPortSettingsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetUtilizationInput
type DescribeFleetUtilizationInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet(s) to retrieve utilization data for. To request
	// utilization data for all fleets, leave this parameter empty.
	FleetIds []string `min:"1" type:"list"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages. This parameter is ignored when
	// the request specifies one or a list of fleet IDs.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value. This parameter
	// is ignored when the request specifies one or a list of fleet IDs.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeFleetUtilizationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetUtilizationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeFleetUtilizationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeFleetUtilizationInput"}
	if s.FleetIds != nil && len(s.FleetIds) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FleetIds", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeFleetUtilizationOutput
type DescribeFleetUtilizationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects containing utilization information for each requested
	// fleet ID.
	FleetUtilization []FleetUtilization `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeFleetUtilizationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeFleetUtilizationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeFleetUtilizationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionDetailsInput
type DescribeGameSessionDetailsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for an alias associated with the fleet to retrieve all
	// game sessions for.
	AliasId *string `type:"string"`

	// Unique identifier for a fleet to retrieve all game sessions active on the
	// fleet.
	FleetId *string `type:"string"`

	// Unique identifier for the game session to retrieve.
	GameSessionId *string `min:"1" type:"string"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`

	// Game session status to filter results on. Possible game session statuses
	// include ACTIVE, TERMINATED, ACTIVATING and TERMINATING (the last two are
	// transitory).
	StatusFilter *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeGameSessionDetailsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGameSessionDetailsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeGameSessionDetailsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeGameSessionDetailsInput"}
	if s.GameSessionId != nil && len(*s.GameSessionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionId", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}
	if s.StatusFilter != nil && len(*s.StatusFilter) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StatusFilter", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionDetailsOutput
type DescribeGameSessionDetailsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects containing game session properties and the protection
	// policy currently in force for each session matching the request.
	GameSessionDetails []GameSessionDetail `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeGameSessionDetailsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGameSessionDetailsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeGameSessionDetailsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionPlacementInput
type DescribeGameSessionPlacementInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a game session placement to retrieve.
	//
	// PlacementId is a required field
	PlacementId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeGameSessionPlacementInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGameSessionPlacementInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeGameSessionPlacementInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeGameSessionPlacementInput"}

	if s.PlacementId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PlacementId"))
	}
	if s.PlacementId != nil && len(*s.PlacementId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlacementId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionPlacementOutput
type DescribeGameSessionPlacementOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the requested game session placement.
	GameSessionPlacement *GameSessionPlacement `type:"structure"`
}

// String returns the string representation
func (s DescribeGameSessionPlacementOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGameSessionPlacementOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeGameSessionPlacementOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionQueuesInput
type DescribeGameSessionQueuesInput struct {
	_ struct{} `type:"structure"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// List of queue names to retrieve information for. To request settings for
	// all queues, leave this parameter empty.
	Names []string `type:"list"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeGameSessionQueuesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGameSessionQueuesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeGameSessionQueuesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeGameSessionQueuesInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionQueuesOutput
type DescribeGameSessionQueuesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects that describes the requested game session queues.
	GameSessionQueues []GameSessionQueue `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeGameSessionQueuesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGameSessionQueuesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeGameSessionQueuesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionsInput
type DescribeGameSessionsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for an alias associated with the fleet to retrieve all
	// game sessions for.
	AliasId *string `type:"string"`

	// Unique identifier for a fleet to retrieve all game sessions for.
	FleetId *string `type:"string"`

	// Unique identifier for the game session to retrieve. You can use either a
	// GameSessionId or GameSessionArn value.
	GameSessionId *string `min:"1" type:"string"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`

	// Game session status to filter results on. Possible game session statuses
	// include ACTIVE, TERMINATED, ACTIVATING, and TERMINATING (the last two are
	// transitory).
	StatusFilter *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeGameSessionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGameSessionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeGameSessionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeGameSessionsInput"}
	if s.GameSessionId != nil && len(*s.GameSessionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionId", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}
	if s.StatusFilter != nil && len(*s.StatusFilter) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StatusFilter", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeGameSessionsOutput
type DescribeGameSessionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects containing game session properties for each session
	// matching the request.
	GameSessions []GameSession `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeGameSessionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGameSessionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeGameSessionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeInstancesInput
type DescribeInstancesInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet to retrieve instance information for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Unique identifier for an instance to retrieve. Specify an instance ID or
	// leave blank to retrieve all instances in the fleet.
	InstanceId *string `type:"string"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeInstancesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeInstancesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeInstancesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeInstancesInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeInstancesOutput
type DescribeInstancesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects containing properties for each instance returned.
	Instances []Instance `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeInstancesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeInstancesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeInstancesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmakingConfigurationsInput
type DescribeMatchmakingConfigurationsInput struct {
	_ struct{} `type:"structure"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages. This parameter is limited to 10.
	Limit *int64 `min:"1" type:"integer"`

	// Unique identifier for a matchmaking configuration(s) to retrieve. To request
	// all existing configurations, leave this parameter empty.
	Names []string `type:"list"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`

	// Unique identifier for a matchmaking rule set. Use this parameter to retrieve
	// all matchmaking configurations that use this rule set.
	RuleSetName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeMatchmakingConfigurationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMatchmakingConfigurationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeMatchmakingConfigurationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeMatchmakingConfigurationsInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}
	if s.RuleSetName != nil && len(*s.RuleSetName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleSetName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmakingConfigurationsOutput
type DescribeMatchmakingConfigurationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of requested matchmaking configuration objects.
	Configurations []MatchmakingConfiguration `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeMatchmakingConfigurationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMatchmakingConfigurationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeMatchmakingConfigurationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmakingInput
type DescribeMatchmakingInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a matchmaking ticket. You can include up to 10 ID values.
	//
	// TicketIds is a required field
	TicketIds []string `type:"list" required:"true"`
}

// String returns the string representation
func (s DescribeMatchmakingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMatchmakingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeMatchmakingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeMatchmakingInput"}

	if s.TicketIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("TicketIds"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmakingOutput
type DescribeMatchmakingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of existing matchmaking ticket objects matching the request.
	TicketList []MatchmakingTicket `type:"list"`
}

// String returns the string representation
func (s DescribeMatchmakingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMatchmakingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeMatchmakingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmakingRuleSetsInput
type DescribeMatchmakingRuleSetsInput struct {
	_ struct{} `type:"structure"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Unique identifier for a matchmaking rule set. This name is used to identify
	// the rule set associated with a matchmaking configuration.
	Names []string `min:"1" type:"list"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribeMatchmakingRuleSetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMatchmakingRuleSetsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeMatchmakingRuleSetsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeMatchmakingRuleSetsInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Names != nil && len(s.Names) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Names", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeMatchmakingRuleSetsOutput
type DescribeMatchmakingRuleSetsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`

	// Collection of requested matchmaking rule set objects.
	//
	// RuleSets is a required field
	RuleSets []MatchmakingRuleSet `type:"list" required:"true"`
}

// String returns the string representation
func (s DescribeMatchmakingRuleSetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMatchmakingRuleSetsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeMatchmakingRuleSetsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribePlayerSessionsInput
type DescribePlayerSessionsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for the game session to retrieve player sessions for.
	GameSessionId *string `min:"1" type:"string"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages. If a player session ID is specified,
	// this parameter is ignored.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value. If a player session
	// ID is specified, this parameter is ignored.
	NextToken *string `min:"1" type:"string"`

	// Unique identifier for a player to retrieve player sessions for.
	PlayerId *string `min:"1" type:"string"`

	// Unique identifier for a player session to retrieve.
	PlayerSessionId *string `type:"string"`

	// Player session status to filter results on.
	//
	// Possible player session statuses include the following:
	//
	//    * RESERVED -- The player session request has been received, but the player
	//    has not yet connected to the server process and/or been validated.
	//
	//    * ACTIVE -- The player has been validated by the server process and is
	//    currently connected.
	//
	//    * COMPLETED -- The player connection has been dropped.
	//
	//    * TIMEDOUT -- A player session request was received, but the player did
	//    not connect and/or was not validated within the timeout limit (60 seconds).
	PlayerSessionStatusFilter *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DescribePlayerSessionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribePlayerSessionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribePlayerSessionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribePlayerSessionsInput"}
	if s.GameSessionId != nil && len(*s.GameSessionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionId", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}
	if s.PlayerId != nil && len(*s.PlayerId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerId", 1))
	}
	if s.PlayerSessionStatusFilter != nil && len(*s.PlayerSessionStatusFilter) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerSessionStatusFilter", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribePlayerSessionsOutput
type DescribePlayerSessionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`

	// Collection of objects containing properties for each player session that
	// matches the request.
	PlayerSessions []PlayerSession `type:"list"`
}

// String returns the string representation
func (s DescribePlayerSessionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribePlayerSessionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribePlayerSessionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeRuntimeConfigurationInput
type DescribeRuntimeConfigurationInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet to get the run-time configuration for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeRuntimeConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRuntimeConfigurationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeRuntimeConfigurationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeRuntimeConfigurationInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeRuntimeConfigurationOutput
type DescribeRuntimeConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Instructions describing how server processes should be launched and maintained
	// on each instance in the fleet.
	RuntimeConfiguration *RuntimeConfiguration `type:"structure"`
}

// String returns the string representation
func (s DescribeRuntimeConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeRuntimeConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeRuntimeConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeScalingPoliciesInput
type DescribeScalingPoliciesInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet to retrieve scaling policies for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`

	// Scaling policy status to filter results on. A scaling policy is only in force
	// when in an ACTIVE status.
	//
	//    * ACTIVE -- The scaling policy is currently in force.
	//
	//    * UPDATEREQUESTED -- A request to update the scaling policy has been received.
	//
	//    * UPDATING -- A change is being made to the scaling policy.
	//
	//    * DELETEREQUESTED -- A request to delete the scaling policy has been received.
	//
	//    * DELETING -- The scaling policy is being deleted.
	//
	//    * DELETED -- The scaling policy has been deleted.
	//
	//    * ERROR -- An error occurred in creating the policy. It should be removed
	//    and recreated.
	StatusFilter ScalingStatusType `type:"string" enum:"true"`
}

// String returns the string representation
func (s DescribeScalingPoliciesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeScalingPoliciesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeScalingPoliciesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeScalingPoliciesInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeScalingPoliciesOutput
type DescribeScalingPoliciesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`

	// Collection of objects containing the scaling policies matching the request.
	ScalingPolicies []ScalingPolicy `type:"list"`
}

// String returns the string representation
func (s DescribeScalingPoliciesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeScalingPoliciesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeScalingPoliciesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeVpcPeeringAuthorizationsInput
type DescribeVpcPeeringAuthorizationsInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DescribeVpcPeeringAuthorizationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeVpcPeeringAuthorizationsInput) GoString() string {
	return s.String()
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeVpcPeeringAuthorizationsOutput
type DescribeVpcPeeringAuthorizationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects that describe all valid VPC peering operations for
	// the current AWS account.
	VpcPeeringAuthorizations []VpcPeeringAuthorization `type:"list"`
}

// String returns the string representation
func (s DescribeVpcPeeringAuthorizationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeVpcPeeringAuthorizationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeVpcPeeringAuthorizationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeVpcPeeringConnectionsInput
type DescribeVpcPeeringConnectionsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet.
	FleetId *string `type:"string"`
}

// String returns the string representation
func (s DescribeVpcPeeringConnectionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeVpcPeeringConnectionsInput) GoString() string {
	return s.String()
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DescribeVpcPeeringConnectionsOutput
type DescribeVpcPeeringConnectionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of VPC peering connection records that match the request.
	VpcPeeringConnections []VpcPeeringConnection `type:"list"`
}

// String returns the string representation
func (s DescribeVpcPeeringConnectionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeVpcPeeringConnectionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeVpcPeeringConnectionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Player information for use when creating player sessions using a game session
// placement request with StartGameSessionPlacement.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/DesiredPlayerSession
type DesiredPlayerSession struct {
	_ struct{} `type:"structure"`

	// Developer-defined information related to a player. Amazon GameLift does not
	// use this data, so it can be formatted as needed for use in the game.
	PlayerData *string `min:"1" type:"string"`

	// Unique identifier for a player to associate with the player session.
	PlayerId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DesiredPlayerSession) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DesiredPlayerSession) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DesiredPlayerSession) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DesiredPlayerSession"}
	if s.PlayerData != nil && len(*s.PlayerData) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerData", 1))
	}
	if s.PlayerId != nil && len(*s.PlayerId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Current status of fleet capacity. The number of active instances should match
// or be in the process of matching the number of desired instances. Pending
// and terminating counts are non-zero only if fleet capacity is adjusting to
// an UpdateFleetCapacity request, or if access to resources is temporarily
// affected.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/EC2InstanceCounts
type EC2InstanceCounts struct {
	_ struct{} `type:"structure"`

	// Actual number of active instances in the fleet.
	ACTIVE *int64 `type:"integer"`

	// Ideal number of active instances in the fleet.
	DESIRED *int64 `type:"integer"`

	// Number of active instances in the fleet that are not currently hosting a
	// game session.
	IDLE *int64 `type:"integer"`

	// Maximum value allowed for the fleet's instance count.
	MAXIMUM *int64 `type:"integer"`

	// Minimum value allowed for the fleet's instance count.
	MINIMUM *int64 `type:"integer"`

	// Number of instances in the fleet that are starting but not yet active.
	PENDING *int64 `type:"integer"`

	// Number of instances in the fleet that are no longer active but haven't yet
	// been terminated.
	TERMINATING *int64 `type:"integer"`
}

// String returns the string representation
func (s EC2InstanceCounts) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EC2InstanceCounts) GoString() string {
	return s.String()
}

// Maximum number of instances allowed based on the Amazon Elastic Compute Cloud
// (Amazon EC2) instance type. Instance limits can be retrieved by calling DescribeEC2InstanceLimits.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/EC2InstanceLimit
type EC2InstanceLimit struct {
	_ struct{} `type:"structure"`

	// Number of instances of the specified type that are currently in use by this
	// AWS account.
	CurrentInstances *int64 `type:"integer"`

	// Name of an EC2 instance type that is supported in Amazon GameLift. A fleet
	// instance type determines the computing resources of each instance in the
	// fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift
	// supports the following EC2 instance types. See Amazon EC2 Instance Types
	// (http://aws.amazon.com/ec2/instance-types/) for detailed descriptions.
	EC2InstanceType EC2InstanceType `type:"string" enum:"true"`

	// Number of instances allowed.
	InstanceLimit *int64 `type:"integer"`
}

// String returns the string representation
func (s EC2InstanceLimit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EC2InstanceLimit) GoString() string {
	return s.String()
}

// Log entry describing an event that involves Amazon GameLift resources (such
// as a fleet). In addition to tracking activity, event codes and messages can
// provide additional information for troubleshooting and debugging problems.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/Event
type Event struct {
	_ struct{} `type:"structure"`

	// Type of event being logged. The following events are currently in use:
	//
	// Fleet creation events:
	//
	//    * FLEET_CREATED -- A fleet record was successfully created with a status
	//    of NEW. Event messaging includes the fleet ID.
	//
	//    * FLEET_STATE_DOWNLOADING -- Fleet status changed from NEW to DOWNLOADING.
	//    The compressed build has started downloading to a fleet instance for installation.
	//
	//    *  FLEET_BINARY_DOWNLOAD_FAILED -- The build failed to download to the
	//    fleet instance.
	//
	//    * FLEET_CREATION_EXTRACTING_BUILD – The game server build was successfully
	//    downloaded to an instance, and the build files are now being extracted
	//    from the uploaded build and saved to an instance. Failure at this stage
	//    prevents a fleet from moving to ACTIVE status. Logs for this stage display
	//    a list of the files that are extracted and saved on the instance. Access
	//    the logs by using the URL in PreSignedLogUrl.
	//
	//    * FLEET_CREATION_RUNNING_INSTALLER – The game server build files were
	//    successfully extracted, and the Amazon GameLift is now running the build's
	//    install script (if one is included). Failure in this stage prevents a
	//    fleet from moving to ACTIVE status. Logs for this stage list the installation
	//    steps and whether or not the install completed successfully. Access the
	//    logs by using the URL in PreSignedLogUrl.
	//
	//    * FLEET_CREATION_VALIDATING_RUNTIME_CONFIG -- The build process was successful,
	//    and the Amazon GameLift is now verifying that the game server launch paths,
	//    which are specified in the fleet's run-time configuration, exist. If any
	//    listed launch path exists, Amazon GameLift tries to launch a game server
	//    process and waits for the process to report ready. Failures in this stage
	//    prevent a fleet from moving to ACTIVE status. Logs for this stage list
	//    the launch paths in the run-time configuration and indicate whether each
	//    is found. Access the logs by using the URL in PreSignedLogUrl.
	//
	//    * FLEET_STATE_VALIDATING -- Fleet status changed from DOWNLOADING to VALIDATING.
	//
	//    *  FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND -- Validation of the run-time
	//    configuration failed because the executable specified in a launch path
	//    does not exist on the instance.
	//
	//    * FLEET_STATE_BUILDING -- Fleet status changed from VALIDATING to BUILDING.
	//
	//    * FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE -- Validation of the run-time
	//    configuration failed because the executable specified in a launch path
	//    failed to run on the fleet instance.
	//
	//    * FLEET_STATE_ACTIVATING -- Fleet status changed from BUILDING to ACTIVATING.
	//
	//
	//    *  FLEET_ACTIVATION_FAILED - The fleet failed to successfully complete
	//    one of the steps in the fleet activation process. This event code indicates
	//    that the game build was successfully downloaded to a fleet instance, built,
	//    and validated, but was not able to start a server process. A possible
	//    reason for failure is that the game server is not reporting "process ready"
	//    to the Amazon GameLift service.
	//
	//    * FLEET_STATE_ACTIVE -- The fleet's status changed from ACTIVATING to
	//    ACTIVE. The fleet is now ready to host game sessions.
	//
	// VPC peering events:
	//
	//    * FLEET_VPC_PEERING_SUCCEEDED -- A VPC peering connection has been established
	//    between the VPC for an Amazon GameLift fleet and a VPC in your AWS account.
	//
	//    * FLEET_VPC_PEERING_FAILED -- A requested VPC peering connection has failed.
	//    Event details and status information (see DescribeVpcPeeringConnections)
	//    provide additional detail. A common reason for peering failure is that
	//    the two VPCs have overlapping CIDR blocks of IPv4 addresses. To resolve
	//    this, change the CIDR block for the VPC in your AWS account. For more
	//    information on VPC peering failures, see http://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide/invalid-peering-configurations.html
	//    (http://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide/invalid-peering-configurations.html)
	//
	//    * FLEET_VPC_PEERING_DELETED -- A VPC peering connection has been successfully
	//    deleted.
	//
	// Spot instance events:
	//
	//    *  INSTANCE_INTERRUPTED -- A spot instance was interrupted by EC2 with
	//    a two-minute notification.
	//
	// Other fleet events:
	//
	//    * FLEET_SCALING_EVENT -- A change was made to the fleet's capacity settings
	//    (desired instances, minimum/maximum scaling limits). Event messaging includes
	//    the new capacity settings.
	//
	//    * FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED -- A change was made
	//    to the fleet's game session protection policy setting. Event messaging
	//    includes both the old and new policy setting.
	//
	//    * FLEET_DELETED -- A request to delete a fleet was initiated.
	//
	//    *  GENERIC_EVENT -- An unspecified event has occurred.
	EventCode EventCode `type:"string" enum:"true"`

	// Unique identifier for a fleet event.
	EventId *string `min:"1" type:"string"`

	// Time stamp indicating when this event occurred. Format is a number expressed
	// in Unix time as milliseconds (for example "1469498468.057").
	EventTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Additional information related to the event.
	Message *string `min:"1" type:"string"`

	// Location of stored logs with additional detail that is related to the event.
	// This is useful for debugging issues. The URL is valid for 15 minutes. You
	// can also access fleet creation logs through the Amazon GameLift console.
	PreSignedLogUrl *string `min:"1" type:"string"`

	// Unique identifier for an event resource, such as a fleet ID.
	ResourceId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s Event) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Event) GoString() string {
	return s.String()
}

// General properties describing a fleet.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/FleetAttributes
type FleetAttributes struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a build.
	BuildId *string `type:"string"`

	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Human-readable description of the fleet.
	Description *string `min:"1" type:"string"`

	// Identifier for a fleet that is unique across all regions.
	FleetArn *string `min:"1" type:"string"`

	// Unique identifier for a fleet.
	FleetId *string `type:"string"`

	// Indicates whether the fleet uses on-demand or spot instances. A spot instance
	// in use may be interrupted with a two-minute notification.
	FleetType FleetType `type:"string" enum:"true"`

	// EC2 instance type indicating the computing resources of each instance in
	// the fleet, including CPU, memory, storage, and networking capacity. See Amazon
	// EC2 Instance Types (http://aws.amazon.com/ec2/instance-types/) for detailed
	// descriptions.
	InstanceType EC2InstanceType `type:"string" enum:"true"`

	// Location of default log files. When a server process is shut down, Amazon
	// GameLift captures and stores any log files in this location. These logs are
	// in addition to game session logs; see more on game session logs in the Amazon
	// GameLift Developer Guide (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-api-server-code).
	// If no default log path for a fleet is specified, Amazon GameLift automatically
	// uploads logs that are stored on each instance at C:\game\logs (for Windows)
	// or /local/game/logs (for Linux). Use the Amazon GameLift console to access
	// stored logs.
	LogPaths []string `type:"list"`

	// Names of metric groups that this fleet is included in. In Amazon CloudWatch,
	// you can view metrics for an individual fleet or aggregated metrics for fleets
	// that are in a fleet metric group. A fleet can be included in only one metric
	// group at a time.
	MetricGroups []string `type:"list"`

	// Descriptive label that is associated with a fleet. Fleet names do not need
	// to be unique.
	Name *string `min:"1" type:"string"`

	// Type of game session protection to set for all new instances started in the
	// fleet.
	//
	//    * NoProtection -- The game session can be terminated during a scale-down
	//    event.
	//
	//    * FullProtection -- If the game session is in an ACTIVE status, it cannot
	//    be terminated during a scale-down event.
	NewGameSessionProtectionPolicy ProtectionPolicy `type:"string" enum:"true"`

	// Operating system of the fleet's computing resources. A fleet's operating
	// system depends on the OS specified for the build that is deployed on this
	// fleet.
	OperatingSystem OperatingSystem `type:"string" enum:"true"`

	// Fleet policy to limit the number of game sessions an individual player can
	// create over a span of time.
	ResourceCreationLimitPolicy *ResourceCreationLimitPolicy `type:"structure"`

	// Game server launch parameters specified for fleets created before 2016-08-04
	// (or AWS SDK v. 0.12.16). Server launch parameters for fleets created after
	// this date are specified in the fleet's RuntimeConfiguration.
	ServerLaunchParameters *string `min:"1" type:"string"`

	// Path to a game server executable in the fleet's build, specified for fleets
	// created before 2016-08-04 (or AWS SDK v. 0.12.16). Server launch paths for
	// fleets created after this date are specified in the fleet's RuntimeConfiguration.
	ServerLaunchPath *string `min:"1" type:"string"`

	// Current status of the fleet.
	//
	// Possible fleet statuses include the following:
	//
	//    * NEW -- A new fleet has been defined and desired instances is set to
	//    1.
	//
	//    * DOWNLOADING/VALIDATING/BUILDING/ACTIVATING -- Amazon GameLift is setting
	//    up the new fleet, creating new instances with the game build and starting
	//    server processes.
	//
	//    * ACTIVE -- Hosts can now accept game sessions.
	//
	//    * ERROR -- An error occurred when downloading, validating, building, or
	//    activating the fleet.
	//
	//    * DELETING -- Hosts are responding to a delete fleet request.
	//
	//    * TERMINATED -- The fleet no longer exists.
	Status FleetStatus `type:"string" enum:"true"`

	// List of fleet actions that have been suspended using StopFleetActions. This
	// includes auto-scaling.
	StoppedActions []FleetAction `min:"1" type:"list"`

	// Time stamp indicating when this data object was terminated. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	TerminationTime *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s FleetAttributes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FleetAttributes) GoString() string {
	return s.String()
}

// Information about the fleet's capacity. Fleet capacity is measured in EC2
// instances. By default, new fleets have a capacity of one instance, but can
// be updated as needed. The maximum number of instances for a fleet is determined
// by the fleet's instance type.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/FleetCapacity
type FleetCapacity struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet.
	FleetId *string `type:"string"`

	// Current status of fleet capacity.
	InstanceCounts *EC2InstanceCounts `type:"structure"`

	// Name of an EC2 instance type that is supported in Amazon GameLift. A fleet
	// instance type determines the computing resources of each instance in the
	// fleet, including CPU, memory, storage, and networking capacity. Amazon GameLift
	// supports the following EC2 instance types. See Amazon EC2 Instance Types
	// (http://aws.amazon.com/ec2/instance-types/) for detailed descriptions.
	InstanceType EC2InstanceType `type:"string" enum:"true"`
}

// String returns the string representation
func (s FleetCapacity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FleetCapacity) GoString() string {
	return s.String()
}

// Current status of fleet utilization, including the number of game and player
// sessions being hosted.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/FleetUtilization
type FleetUtilization struct {
	_ struct{} `type:"structure"`

	// Number of active game sessions currently being hosted on all instances in
	// the fleet.
	ActiveGameSessionCount *int64 `type:"integer"`

	// Number of server processes in an ACTIVE status currently running across all
	// instances in the fleet
	ActiveServerProcessCount *int64 `type:"integer"`

	// Number of active player sessions currently being hosted on all instances
	// in the fleet.
	CurrentPlayerSessionCount *int64 `type:"integer"`

	// Unique identifier for a fleet.
	FleetId *string `type:"string"`

	// Maximum players allowed across all game sessions currently being hosted on
	// all instances in the fleet.
	MaximumPlayerSessionCount *int64 `type:"integer"`
}

// String returns the string representation
func (s FleetUtilization) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FleetUtilization) GoString() string {
	return s.String()
}

// Set of key-value pairs that contain information about a game session. When
// included in a game session request, these properties communicate details
// to be used when setting up the new game session, such as to specify a game
// mode, level, or map. Game properties are passed to the game server process
// when initiating a new game session; the server process uses the properties
// as appropriate. For more information, see the  Amazon GameLift Developer
// Guide (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-client-api.html#gamelift-sdk-client-api-create).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GameProperty
type GameProperty struct {
	_ struct{} `type:"structure"`

	// Game property identifier.
	//
	// Key is a required field
	Key *string `type:"string" required:"true"`

	// Game property value.
	//
	// Value is a required field
	Value *string `type:"string" required:"true"`
}

// String returns the string representation
func (s GameProperty) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GameProperty) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GameProperty) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GameProperty"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Properties describing a game session.
//
// A game session in ACTIVE status can host players. When a game session ends,
// its status is set to TERMINATED.
//
// Once the session ends, the game session object is retained for 30 days. This
// means you can reuse idempotency token values after this time. Game session
// logs are retained for 14 days.
//
// Game-session-related operations include:
//
//    * CreateGameSession
//
//    * DescribeGameSessions
//
//    * DescribeGameSessionDetails
//
//    * SearchGameSessions
//
//    * UpdateGameSession
//
//    * GetGameSessionLogUrl
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GameSession
type GameSession struct {
	_ struct{} `type:"structure"`

	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique identifier for a player. This ID is used to enforce a resource protection
	// policy (if one exists), that limits the number of game sessions a player
	// can create.
	CreatorId *string `min:"1" type:"string"`

	// Number of players currently in the game session.
	CurrentPlayerSessionCount *int64 `type:"integer"`

	// Unique identifier for a fleet that the game session is running on.
	FleetId *string `type:"string"`

	// Set of custom properties for a game session, formatted as key:value pairs.
	// These properties are passed to a game server process in the GameSession object
	// with a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// You can search for active game sessions based on this custom data with SearchGameSessions.
	GameProperties []GameProperty `type:"list"`

	// Set of custom game session properties, formatted as a single string value.
	// This data is passed to a game server process in the GameSession object with
	// a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameSessionData *string `min:"1" type:"string"`

	// Unique identifier for the game session. A game session ARN has the following
	// format: arn:aws:gamelift:<region>::gamesession/<fleet ID>/<custom ID string
	// or idempotency token>.
	GameSessionId *string `min:"1" type:"string"`

	// IP address of the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number.
	IpAddress *string `type:"string"`

	// Information about the matchmaking process that was used to create the game
	// session. It is in JSON syntax, formatted as a string. In addition the matchmaking
	// configuration used, it contains data on all players assigned to the match,
	// including player attributes and team assignments. For more details on matchmaker
	// data, see Match Data (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-server.html#match-server-data).
	// Matchmaker data is useful when requesting match backfills, and is updated
	// whenever new players are added during a successful backfill (see StartMatchBackfill).
	MatchmakerData *string `min:"1" type:"string"`

	// Maximum number of players that can be connected simultaneously to the game
	// session.
	MaximumPlayerSessionCount *int64 `type:"integer"`

	// Descriptive label that is associated with a game session. Session names do
	// not need to be unique.
	Name *string `min:"1" type:"string"`

	// Indicates whether or not the game session is accepting new players.
	PlayerSessionCreationPolicy PlayerSessionCreationPolicy `type:"string" enum:"true"`

	// Port number for the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number.
	Port *int64 `min:"1" type:"integer"`

	// Current status of the game session. A game session must have an ACTIVE status
	// to have player sessions.
	Status GameSessionStatus `type:"string" enum:"true"`

	// Provides additional information about game session status. INTERRUPTED indicates
	// that the game session was hosted on a spot instance that was reclaimed, causing
	// the active game session to be terminated.
	StatusReason GameSessionStatusReason `type:"string" enum:"true"`

	// Time stamp indicating when this data object was terminated. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	TerminationTime *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s GameSession) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GameSession) GoString() string {
	return s.String()
}

// Connection information for the new game session that is created with matchmaking.
// (with StartMatchmaking). Once a match is set, the FlexMatch engine places
// the match and creates a new game session for it. This information, including
// the game session endpoint and player sessions for each player in the original
// matchmaking request, is added to the MatchmakingTicket, which can be retrieved
// by calling DescribeMatchmaking.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GameSessionConnectionInfo
type GameSessionConnectionInfo struct {
	_ struct{} `type:"structure"`

	// Amazon Resource Name (ARN (http://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html))
	// that is assigned to a game session and uniquely identifies it.
	GameSessionArn *string `min:"1" type:"string"`

	// IP address of the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number.
	IpAddress *string `type:"string"`

	// Collection of player session IDs, one for each player ID that was included
	// in the original matchmaking request.
	MatchedPlayerSessions []MatchedPlayerSession `type:"list"`

	// Port number for the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number.
	Port *int64 `min:"1" type:"integer"`
}

// String returns the string representation
func (s GameSessionConnectionInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GameSessionConnectionInfo) GoString() string {
	return s.String()
}

// A game session's properties plus the protection policy currently in force.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GameSessionDetail
type GameSessionDetail struct {
	_ struct{} `type:"structure"`

	// Object that describes a game session.
	GameSession *GameSession `type:"structure"`

	// Current status of protection for the game session.
	//
	//    * NoProtection -- The game session can be terminated during a scale-down
	//    event.
	//
	//    * FullProtection -- If the game session is in an ACTIVE status, it cannot
	//    be terminated during a scale-down event.
	ProtectionPolicy ProtectionPolicy `type:"string" enum:"true"`
}

// String returns the string representation
func (s GameSessionDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GameSessionDetail) GoString() string {
	return s.String()
}

// Object that describes a StartGameSessionPlacement request. This object includes
// the full details of the original request plus the current status and start/end
// time stamps.
//
// Game session placement-related operations include:
//
//    * StartGameSessionPlacement
//
//    * DescribeGameSessionPlacement
//
//    * StopGameSessionPlacement
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GameSessionPlacement
type GameSessionPlacement struct {
	_ struct{} `type:"structure"`

	// Time stamp indicating when this request was completed, canceled, or timed
	// out.
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Set of custom properties for a game session, formatted as key:value pairs.
	// These properties are passed to a game server process in the GameSession object
	// with a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameProperties []GameProperty `type:"list"`

	// Identifier for the game session created by this placement request. This value
	// is set once the new game session is placed (placement status is FULFILLED).
	// This identifier is unique across all regions. You can use this value as a
	// GameSessionId value as needed.
	GameSessionArn *string `min:"1" type:"string"`

	// Set of custom game session properties, formatted as a single string value.
	// This data is passed to a game server process in the GameSession object with
	// a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameSessionData *string `min:"1" type:"string"`

	// Unique identifier for the game session. This value is set once the new game
	// session is placed (placement status is FULFILLED).
	GameSessionId *string `min:"1" type:"string"`

	// Descriptive label that is associated with a game session. Session names do
	// not need to be unique.
	GameSessionName *string `min:"1" type:"string"`

	// Descriptive label that is associated with game session queue. Queue names
	// must be unique within each region.
	GameSessionQueueName *string `min:"1" type:"string"`

	// Name of the region where the game session created by this placement request
	// is running. This value is set once the new game session is placed (placement
	// status is FULFILLED).
	GameSessionRegion *string `min:"1" type:"string"`

	// IP address of the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number. This value is set once
	// the new game session is placed (placement status is FULFILLED).
	IpAddress *string `type:"string"`

	// Information on the matchmaking process for this game. Data is in JSON syntax,
	// formatted as a string. It identifies the matchmaking configuration used to
	// create the match, and contains data on all players assigned to the match,
	// including player attributes and team assignments. For more details on matchmaker
	// data, see Match Data (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-server.html#match-server-data).
	MatchmakerData *string `min:"1" type:"string"`

	// Maximum number of players that can be connected simultaneously to the game
	// session.
	MaximumPlayerSessionCount *int64 `type:"integer"`

	// Collection of information on player sessions created in response to the game
	// session placement request. These player sessions are created only once a
	// new game session is successfully placed (placement status is FULFILLED).
	// This information includes the player ID (as provided in the placement request)
	// and the corresponding player session ID. Retrieve full player sessions by
	// calling DescribePlayerSessions with the player session ID.
	PlacedPlayerSessions []PlacedPlayerSession `type:"list"`

	// Unique identifier for a game session placement.
	PlacementId *string `min:"1" type:"string"`

	// Set of values, expressed in milliseconds, indicating the amount of latency
	// that a player experiences when connected to AWS regions.
	PlayerLatencies []PlayerLatency `type:"list"`

	// Port number for the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number. This value is set once
	// the new game session is placed (placement status is FULFILLED).
	Port *int64 `min:"1" type:"integer"`

	// Time stamp indicating when this request was placed in the queue. Format is
	// a number expressed in Unix time as milliseconds (for example "1469498468.057").
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Current status of the game session placement request.
	//
	//    * PENDING -- The placement request is currently in the queue waiting to
	//    be processed.
	//
	//    * FULFILLED -- A new game session and player sessions (if requested) have
	//    been successfully created. Values for GameSessionArn and GameSessionRegion
	//    are available.
	//
	//    * CANCELLED -- The placement request was canceled with a call to StopGameSessionPlacement.
	//
	//    * TIMED_OUT -- A new game session was not successfully created before
	//    the time limit expired. You can resubmit the placement request as needed.
	Status GameSessionPlacementState `type:"string" enum:"true"`
}

// String returns the string representation
func (s GameSessionPlacement) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GameSessionPlacement) GoString() string {
	return s.String()
}

// Configuration of a queue that is used to process game session placement requests.
// The queue configuration identifies several game features:
//
//    * The destinations where a new game session can potentially be hosted.
//    Amazon GameLift tries these destinations in an order based on either the
//    queue's default order or player latency information, if provided in a
//    placement request. With latency information, Amazon GameLift can place
//    game sessions where the majority of players are reporting the lowest possible
//    latency.
//
//    * The length of time that placement requests can wait in the queue before
//    timing out.
//
//    * A set of optional latency policies that protect individual players from
//    high latencies, preventing game sessions from being placed where any individual
//    player is reporting latency higher than a policy's maximum.
//
// Queue-related operations include:
//
//    * CreateGameSessionQueue
//
//    * DescribeGameSessionQueues
//
//    * UpdateGameSessionQueue
//
//    * DeleteGameSessionQueue
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GameSessionQueue
type GameSessionQueue struct {
	_ struct{} `type:"structure"`

	// List of fleets that can be used to fulfill game session placement requests
	// in the queue. Fleets are identified by either a fleet ARN or a fleet alias
	// ARN. Destinations are listed in default preference order.
	Destinations []GameSessionQueueDestination `type:"list"`

	// Amazon Resource Name (ARN (http://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html))
	// that is assigned to a game session queue and uniquely identifies it. Format
	// is arn:aws:gamelift:<region>::fleet/fleet-a1234567-b8c9-0d1e-2fa3-b45c6d7e8912.
	GameSessionQueueArn *string `min:"1" type:"string"`

	// Descriptive label that is associated with game session queue. Queue names
	// must be unique within each region.
	Name *string `min:"1" type:"string"`

	// Collection of latency policies to apply when processing game sessions placement
	// requests with player latency information. Multiple policies are evaluated
	// in order of the maximum latency value, starting with the lowest latency values.
	// With just one policy, it is enforced at the start of the game session placement
	// for the duration period. With multiple policies, each policy is enforced
	// consecutively for its duration period. For example, a queue might enforce
	// a 60-second policy followed by a 120-second policy, and then no policy for
	// the remainder of the placement.
	PlayerLatencyPolicies []PlayerLatencyPolicy `type:"list"`

	// Maximum time, in seconds, that a new game session placement request remains
	// in the queue. When a request exceeds this time, the game session placement
	// changes to a TIMED_OUT status.
	TimeoutInSeconds *int64 `type:"integer"`
}

// String returns the string representation
func (s GameSessionQueue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GameSessionQueue) GoString() string {
	return s.String()
}

// Fleet designated in a game session queue. Requests for new game sessions
// in the queue are fulfilled by starting a new game session on any destination
// configured for a queue.
//
// Queue-related operations include:
//
//    * CreateGameSessionQueue
//
//    * DescribeGameSessionQueues
//
//    * UpdateGameSessionQueue
//
//    * DeleteGameSessionQueue
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GameSessionQueueDestination
type GameSessionQueueDestination struct {
	_ struct{} `type:"structure"`

	// Amazon Resource Name (ARN) assigned to fleet or fleet alias. ARNs, which
	// include a fleet ID or alias ID and a region name, provide a unique identifier
	// across all regions.
	DestinationArn *string `min:"1" type:"string"`
}

// String returns the string representation
func (s GameSessionQueueDestination) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GameSessionQueueDestination) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GameSessionQueueDestination) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GameSessionQueueDestination"}
	if s.DestinationArn != nil && len(*s.DestinationArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DestinationArn", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GetGameSessionLogUrlInput
type GetGameSessionLogUrlInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for the game session to get logs for.
	//
	// GameSessionId is a required field
	GameSessionId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetGameSessionLogUrlInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGameSessionLogUrlInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetGameSessionLogUrlInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetGameSessionLogUrlInput"}

	if s.GameSessionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameSessionId"))
	}
	if s.GameSessionId != nil && len(*s.GameSessionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GetGameSessionLogUrlOutput
type GetGameSessionLogUrlOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Location of the requested game session logs, available for download.
	PreSignedUrl *string `min:"1" type:"string"`
}

// String returns the string representation
func (s GetGameSessionLogUrlOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGameSessionLogUrlOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetGameSessionLogUrlOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GetInstanceAccessInput
type GetInstanceAccessInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet that contains the instance you want access
	// to. The fleet can be in any of the following statuses: ACTIVATING, ACTIVE,
	// or ERROR. Fleets with an ERROR status may be accessible for a short time
	// before they are deleted.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Unique identifier for an instance you want to get access to. You can access
	// an instance in any status.
	//
	// InstanceId is a required field
	InstanceId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s GetInstanceAccessInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetInstanceAccessInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetInstanceAccessInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetInstanceAccessInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if s.InstanceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("InstanceId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/GetInstanceAccessOutput
type GetInstanceAccessOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that contains connection information for a fleet instance, including
	// IP address and access credentials.
	InstanceAccess *InstanceAccess `type:"structure"`
}

// String returns the string representation
func (s GetInstanceAccessOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetInstanceAccessOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetInstanceAccessOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Properties that describe an instance of a virtual computing resource that
// hosts one or more game servers. A fleet may contain zero or more instances.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/Instance
type Instance struct {
	_ struct{} `type:"structure"`

	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique identifier for a fleet that the instance is in.
	FleetId *string `type:"string"`

	// Unique identifier for an instance.
	InstanceId *string `type:"string"`

	// IP address assigned to the instance.
	IpAddress *string `type:"string"`

	// Operating system that is running on this instance.
	OperatingSystem OperatingSystem `type:"string" enum:"true"`

	// Current status of the instance. Possible statuses include the following:
	//
	//    * PENDING -- The instance is in the process of being created and launching
	//    server processes as defined in the fleet's run-time configuration.
	//
	//    * ACTIVE -- The instance has been successfully created and at least one
	//    server process has successfully launched and reported back to Amazon GameLift
	//    that it is ready to host a game session. The instance is now considered
	//    ready to host game sessions.
	//
	//    * TERMINATING -- The instance is in the process of shutting down. This
	//    may happen to reduce capacity during a scaling down event or to recycle
	//    resources in the event of a problem.
	Status InstanceStatus `type:"string" enum:"true"`

	// EC2 instance type that defines the computing resources of this instance.
	Type EC2InstanceType `type:"string" enum:"true"`
}

// String returns the string representation
func (s Instance) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Instance) GoString() string {
	return s.String()
}

// Information required to remotely connect to a fleet instance. Access is requested
// by calling GetInstanceAccess.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/InstanceAccess
type InstanceAccess struct {
	_ struct{} `type:"structure"`

	// Credentials required to access the instance.
	Credentials *InstanceCredentials `type:"structure"`

	// Unique identifier for a fleet containing the instance being accessed.
	FleetId *string `type:"string"`

	// Unique identifier for an instance being accessed.
	InstanceId *string `type:"string"`

	// IP address assigned to the instance.
	IpAddress *string `type:"string"`

	// Operating system that is running on the instance.
	OperatingSystem OperatingSystem `type:"string" enum:"true"`
}

// String returns the string representation
func (s InstanceAccess) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InstanceAccess) GoString() string {
	return s.String()
}

// Set of credentials required to remotely access a fleet instance. Access credentials
// are requested by calling GetInstanceAccess and returned in an InstanceAccess
// object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/InstanceCredentials
type InstanceCredentials struct {
	_ struct{} `type:"structure"`

	// Secret string. For Windows instances, the secret is a password for use with
	// Windows Remote Desktop. For Linux instances, it is a private key (which must
	// be saved as a .pem file) for use with SSH.
	Secret *string `min:"1" type:"string"`

	// User login string.
	UserName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s InstanceCredentials) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InstanceCredentials) GoString() string {
	return s.String()
}

// A range of IP addresses and port settings that allow inbound traffic to connect
// to server processes on Amazon GameLift. Each game session hosted on a fleet
// is assigned a unique combination of IP address and port number, which must
// fall into the fleet's allowed ranges. This combination is included in the
// GameSession object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/IpPermission
type IpPermission struct {
	_ struct{} `type:"structure"`

	// Starting value for a range of allowed port numbers.
	//
	// FromPort is a required field
	FromPort *int64 `min:"1" type:"integer" required:"true"`

	// Range of allowed IP addresses. This value must be expressed in CIDR notation.
	// Example: "000.000.000.000/[subnet mask]" or optionally the shortened version
	// "0.0.0.0/[subnet mask]".
	//
	// IpRange is a required field
	IpRange *string `type:"string" required:"true"`

	// Network communication protocol used by the fleet.
	//
	// Protocol is a required field
	Protocol IpProtocol `type:"string" required:"true" enum:"true"`

	// Ending value for a range of allowed port numbers. Port numbers are end-inclusive.
	// This value must be higher than FromPort.
	//
	// ToPort is a required field
	ToPort *int64 `min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s IpPermission) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s IpPermission) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *IpPermission) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "IpPermission"}

	if s.FromPort == nil {
		invalidParams.Add(aws.NewErrParamRequired("FromPort"))
	}
	if s.FromPort != nil && *s.FromPort < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("FromPort", 1))
	}

	if s.IpRange == nil {
		invalidParams.Add(aws.NewErrParamRequired("IpRange"))
	}
	if len(s.Protocol) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Protocol"))
	}

	if s.ToPort == nil {
		invalidParams.Add(aws.NewErrParamRequired("ToPort"))
	}
	if s.ToPort != nil && *s.ToPort < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("ToPort", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListAliasesInput
type ListAliasesInput struct {
	_ struct{} `type:"structure"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Descriptive label that is associated with an alias. Alias names do not need
	// to be unique.
	Name *string `min:"1" type:"string"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`

	// Type of routing to filter results on. Use this parameter to retrieve only
	// aliases of a certain type. To retrieve all aliases, leave this parameter
	// empty.
	//
	// Possible routing types include the following:
	//
	//    * SIMPLE -- The alias resolves to one specific fleet. Use this type when
	//    routing to active fleets.
	//
	//    * TERMINAL -- The alias does not resolve to a fleet but instead can be
	//    used to display a message to the user. A terminal alias throws a TerminalRoutingStrategyException
	//    with the RoutingStrategy message embedded.
	RoutingStrategyType RoutingStrategyType `type:"string" enum:"true"`
}

// String returns the string representation
func (s ListAliasesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAliasesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListAliasesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListAliasesInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListAliasesOutput
type ListAliasesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of alias records that match the list request.
	Aliases []Alias `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s ListAliasesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAliasesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListAliasesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListBuildsInput
type ListBuildsInput struct {
	_ struct{} `type:"structure"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`

	// Build status to filter results by. To retrieve all builds, leave this parameter
	// empty.
	//
	// Possible build statuses include the following:
	//
	//    * INITIALIZED -- A new build has been defined, but no files have been
	//    uploaded. You cannot create fleets for builds that are in this status.
	//    When a build is successfully created, the build status is set to this
	//    value.
	//
	//    * READY -- The game build has been successfully uploaded. You can now
	//    create new fleets for this build.
	//
	//    * FAILED -- The game build upload failed. You cannot create new fleets
	//    for this build.
	Status BuildStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s ListBuildsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBuildsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBuildsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBuildsInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListBuildsOutput
type ListBuildsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of build records that match the request.
	Builds []Build `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s ListBuildsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBuildsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBuildsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListFleetsInput
type ListFleetsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a build to return fleets for. Use this parameter to
	// return only fleets using the specified build. To retrieve all fleets, leave
	// this parameter empty.
	BuildId *string `type:"string"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s ListFleetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListFleetsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListFleetsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListFleetsInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ListFleetsOutput
type ListFleetsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Set of fleet IDs matching the list request. You can retrieve additional information
	// about all returned fleets by passing this result set to a call to DescribeFleetAttributes,
	// DescribeFleetCapacity, or DescribeFleetUtilization.
	FleetIds []string `min:"1" type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s ListFleetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListFleetsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListFleetsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents a new player session that is created as a result of a successful
// FlexMatch match. A successful match automatically creates new player sessions
// for every player ID in the original matchmaking request.
//
// When players connect to the match's game session, they must include both
// player ID and player session ID in order to claim their assigned player slot.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/MatchedPlayerSession
type MatchedPlayerSession struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a player
	PlayerId *string `min:"1" type:"string"`

	// Unique identifier for a player session
	PlayerSessionId *string `type:"string"`
}

// String returns the string representation
func (s MatchedPlayerSession) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MatchedPlayerSession) GoString() string {
	return s.String()
}

// Guidelines for use with FlexMatch to match players into games. All matchmaking
// requests must specify a matchmaking configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/MatchmakingConfiguration
type MatchmakingConfiguration struct {
	_ struct{} `type:"structure"`

	// Flag that determines whether or not a match that was created with this configuration
	// must be accepted by the matched players. To require acceptance, set to TRUE.
	AcceptanceRequired *bool `type:"boolean"`

	// Length of time (in seconds) to wait for players to accept a proposed match.
	// If any player rejects the match or fails to accept before the timeout, the
	// ticket continues to look for an acceptable match.
	AcceptanceTimeoutSeconds *int64 `min:"1" type:"integer"`

	// Number of player slots in a match to keep open for future players. For example,
	// if the configuration's rule set specifies a match for a single 12-person
	// team, and the additional player count is set to 2, only 10 players are selected
	// for the match.
	AdditionalPlayerCount *int64 `type:"integer"`

	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Information to attached to all events related to the matchmaking configuration.
	CustomEventData *string `type:"string"`

	// Descriptive label that is associated with matchmaking configuration.
	Description *string `min:"1" type:"string"`

	// Set of custom properties for a game session, formatted as key:value pairs.
	// These properties are passed to a game server process in the GameSession object
	// with a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// This information is added to the new GameSession object that is created for
	// a successful match.
	GameProperties []GameProperty `type:"list"`

	// Set of custom game session properties, formatted as a single string value.
	// This data is passed to a game server process in the GameSession object with
	// a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// This information is added to the new GameSession object that is created for
	// a successful match.
	GameSessionData *string `min:"1" type:"string"`

	// Amazon Resource Name (ARN (http://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html))
	// that is assigned to a game session queue and uniquely identifies it. Format
	// is arn:aws:gamelift:<region>::fleet/fleet-a1234567-b8c9-0d1e-2fa3-b45c6d7e8912.
	// These queues are used when placing game sessions for matches that are created
	// with this matchmaking configuration. Queues can be located in any region.
	GameSessionQueueArns []string `type:"list"`

	// Unique identifier for a matchmaking configuration. This name is used to identify
	// the configuration associated with a matchmaking request or ticket.
	Name *string `min:"1" type:"string"`

	// SNS topic ARN that is set up to receive matchmaking notifications.
	NotificationTarget *string `type:"string"`

	// Maximum duration, in seconds, that a matchmaking ticket can remain in process
	// before timing out. Requests that time out can be resubmitted as needed.
	RequestTimeoutSeconds *int64 `min:"1" type:"integer"`

	// Unique identifier for a matchmaking rule set to use with this configuration.
	// A matchmaking configuration can only use rule sets that are defined in the
	// same region.
	RuleSetName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s MatchmakingConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MatchmakingConfiguration) GoString() string {
	return s.String()
}

// Set of rule statements, used with FlexMatch, that determine how to build
// a certain kind of player match. Each rule set describes a type of group to
// be created and defines the parameters for acceptable player matches. Rule
// sets are used in MatchmakingConfiguration objects.
//
// A rule set may define the following elements for a match. For detailed information
// and examples showing how to construct a rule set, see Build a FlexMatch Rule
// Set (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-rulesets.html).
//
//    * Teams -- Required. A rule set must define one or multiple teams for
//    the match and set minimum and maximum team sizes. For example, a rule
//    set might describe a 4x4 match that requires all eight slots to be filled.
//
//
//    * Player attributes -- Optional. These attributes specify a set of player
//    characteristics to evaluate when looking for a match. Matchmaking requests
//    that use a rule set with player attributes must provide the corresponding
//    attribute values. For example, an attribute might specify a player's skill
//    or level.
//
//    * Rules -- Optional. Rules define how to evaluate potential players for
//    a match based on player attributes. A rule might specify minimum requirements
//    for individual players, teams, or entire matches. For example, a rule
//    might require each player to meet a certain skill level, each team to
//    have at least one player in a certain role, or the match to have a minimum
//    average skill level. or may describe an entire group--such as all teams
//    must be evenly matched or have at least one player in a certain role.
//
//
//    * Expansions -- Optional. Expansions allow you to relax the rules after
//    a period of time when no acceptable matches are found. This feature lets
//    you balance getting players into games in a reasonable amount of time
//    instead of making them wait indefinitely for the best possible match.
//    For example, you might use an expansion to increase the maximum skill
//    variance between players after 30 seconds.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/MatchmakingRuleSet
type MatchmakingRuleSet struct {
	_ struct{} `type:"structure"`

	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Collection of matchmaking rules, formatted as a JSON string. (Note that comments14
	// are not allowed in JSON, but most elements support a description field.)
	//
	// RuleSetBody is a required field
	RuleSetBody *string `min:"1" type:"string" required:"true"`

	// Unique identifier for a matchmaking rule set
	RuleSetName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s MatchmakingRuleSet) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MatchmakingRuleSet) GoString() string {
	return s.String()
}

// Ticket generated to track the progress of a matchmaking request. Each ticket
// is uniquely identified by a ticket ID, supplied by the requester, when creating
// a matchmaking request with StartMatchmaking. Tickets can be retrieved by
// calling DescribeMatchmaking with the ticket ID.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/MatchmakingTicket
type MatchmakingTicket struct {
	_ struct{} `type:"structure"`

	// Name of the MatchmakingConfiguration that is used with this ticket. Matchmaking
	// configurations determine how players are grouped into a match and how a new
	// game session is created for the match.
	ConfigurationName *string `min:"1" type:"string"`

	// Time stamp indicating when this matchmaking request stopped being processed
	// due to success, failure, or cancellation. Format is a number expressed in
	// Unix time as milliseconds (for example "1469498468.057").
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Average amount of time (in seconds) that players are currently waiting for
	// a match. If there is not enough recent data, this property may be empty.
	EstimatedWaitTime *int64 `type:"integer"`

	// Identifier and connection information of the game session created for the
	// match. This information is added to the ticket only after the matchmaking
	// request has been successfully completed.
	GameSessionConnectionInfo *GameSessionConnectionInfo `type:"structure"`

	// A set of Player objects, each representing a player to find matches for.
	// Players are identified by a unique player ID and may include latency data
	// for use during matchmaking. If the ticket is in status COMPLETED, the Player
	// objects include the team the players were assigned to in the resulting match.
	Players []Player `type:"list"`

	// Time stamp indicating when this matchmaking request was received. Format
	// is a number expressed in Unix time as milliseconds (for example "1469498468.057").
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Current status of the matchmaking request.
	//
	//    * QUEUED -- The matchmaking request has been received and is currently
	//    waiting to be processed.
	//
	//    * SEARCHING -- The matchmaking request is currently being processed.
	//
	//    * REQUIRES_ACCEPTANCE -- A match has been proposed and the players must
	//    accept the match (see AcceptMatch). This status is used only with requests
	//    that use a matchmaking configuration with a player acceptance requirement.
	//
	//    * PLACING -- The FlexMatch engine has matched players and is in the process
	//    of placing a new game session for the match.
	//
	//    * COMPLETED -- Players have been matched and a game session is ready to
	//    host the players. A ticket in this state contains the necessary connection
	//    information for players.
	//
	//    * FAILED -- The matchmaking request was not completed. Tickets with players
	//    who fail to accept a proposed match are placed in FAILED status.
	//
	//    * CANCELLED -- The matchmaking request was canceled with a call to StopMatchmaking.
	//
	//    * TIMED_OUT -- The matchmaking request was not successful within the duration
	//    specified in the matchmaking configuration.
	//
	// Matchmaking requests that fail to successfully complete (statuses FAILED,
	// CANCELLED, TIMED_OUT) can be resubmitted as new requests with new ticket
	// IDs.
	Status MatchmakingConfigurationStatus `type:"string" enum:"true"`

	// Additional information about the current status.
	StatusMessage *string `type:"string"`

	// Code to explain the current status. For example, a status reason may indicate
	// when a ticket has returned to SEARCHING status after a proposed match fails
	// to receive player acceptances.
	StatusReason *string `type:"string"`

	// Unique identifier for a matchmaking ticket.
	TicketId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s MatchmakingTicket) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MatchmakingTicket) GoString() string {
	return s.String()
}

// Information about a player session that was created as part of a StartGameSessionPlacement
// request. This object contains only the player ID and player session ID. To
// retrieve full details on a player session, call DescribePlayerSessions with
// the player session ID.
//
// Player-session-related operations include:
//
//    * CreatePlayerSession
//
//    * CreatePlayerSessions
//
//    * DescribePlayerSessions
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/PlacedPlayerSession
type PlacedPlayerSession struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a player that is associated with this player session.
	PlayerId *string `min:"1" type:"string"`

	// Unique identifier for a player session.
	PlayerSessionId *string `type:"string"`
}

// String returns the string representation
func (s PlacedPlayerSession) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PlacedPlayerSession) GoString() string {
	return s.String()
}

// Represents a player in matchmaking. When starting a matchmaking request,
// a player has a player ID, attributes, and may have latency data. Team information
// is added after a match has been successfully completed.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/Player
type Player struct {
	_ struct{} `type:"structure"`

	// Set of values, expressed in milliseconds, indicating the amount of latency
	// that a player experiences when connected to AWS regions. If this property
	// is present, FlexMatch considers placing the match only in regions for which
	// latency is reported.
	//
	// If a matchmaker has a rule that evaluates player latency, players must report
	// latency in order to be matched. If no latency is reported in this scenario,
	// FlexMatch assumes that no regions are available to the player and the ticket
	// is not matchable.
	LatencyInMs map[string]int64 `type:"map"`

	// Collection of key:value pairs containing player information for use in matchmaking.
	// Player attribute keys must match the playerAttributes used in a matchmaking
	// rule set. Example: "PlayerAttributes": {"skill": {"N": "23"}, "gameMode":
	// {"S": "deathmatch"}}.
	PlayerAttributes map[string]AttributeValue `type:"map"`

	// Unique identifier for a player
	PlayerId *string `min:"1" type:"string"`

	// Name of the team that the player is assigned to in a match. Team names are
	// defined in a matchmaking rule set.
	Team *string `min:"1" type:"string"`
}

// String returns the string representation
func (s Player) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Player) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Player) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Player"}
	if s.PlayerId != nil && len(*s.PlayerId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerId", 1))
	}
	if s.Team != nil && len(*s.Team) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Team", 1))
	}
	if s.PlayerAttributes != nil {
		for i, v := range s.PlayerAttributes {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "PlayerAttributes", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Regional latency information for a player, used when requesting a new game
// session with StartGameSessionPlacement. This value indicates the amount of
// time lag that exists when the player is connected to a fleet in the specified
// region. The relative difference between a player's latency values for multiple
// regions are used to determine which fleets are best suited to place a new
// game session for the player.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/PlayerLatency
type PlayerLatency struct {
	_ struct{} `type:"structure"`

	// Amount of time that represents the time lag experienced by the player when
	// connected to the specified region.
	LatencyInMilliseconds *float64 `type:"float"`

	// Unique identifier for a player associated with the latency data.
	PlayerId *string `min:"1" type:"string"`

	// Name of the region that is associated with the latency value.
	RegionIdentifier *string `min:"1" type:"string"`
}

// String returns the string representation
func (s PlayerLatency) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PlayerLatency) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PlayerLatency) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PlayerLatency"}
	if s.PlayerId != nil && len(*s.PlayerId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlayerId", 1))
	}
	if s.RegionIdentifier != nil && len(*s.RegionIdentifier) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RegionIdentifier", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Queue setting that determines the highest latency allowed for individual
// players when placing a game session. When a latency policy is in force, a
// game session cannot be placed at any destination in a region where a player
// is reporting latency higher than the cap. Latency policies are only enforced
// when the placement request contains player latency information.
//
// Queue-related operations include:
//
//    * CreateGameSessionQueue
//
//    * DescribeGameSessionQueues
//
//    * UpdateGameSessionQueue
//
//    * DeleteGameSessionQueue
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/PlayerLatencyPolicy
type PlayerLatencyPolicy struct {
	_ struct{} `type:"structure"`

	// The maximum latency value that is allowed for any player, in milliseconds.
	// All policies must have a value set for this property.
	MaximumIndividualPlayerLatencyMilliseconds *int64 `type:"integer"`

	// The length of time, in seconds, that the policy is enforced while placing
	// a new game session. A null value for this property means that the policy
	// is enforced until the queue times out.
	PolicyDurationSeconds *int64 `type:"integer"`
}

// String returns the string representation
func (s PlayerLatencyPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PlayerLatencyPolicy) GoString() string {
	return s.String()
}

// Properties describing a player session. Player session objects are created
// either by creating a player session for a specific game session, or as part
// of a game session placement. A player session represents either a player
// reservation for a game session (status RESERVED) or actual player activity
// in a game session (status ACTIVE). A player session object (including player
// data) is automatically passed to a game session when the player connects
// to the game session and is validated.
//
// When a player disconnects, the player session status changes to COMPLETED.
// Once the session ends, the player session object is retained for 30 days
// and then removed.
//
// Player-session-related operations include:
//
//    * CreatePlayerSession
//
//    * CreatePlayerSessions
//
//    * DescribePlayerSessions
//
//    * Game session placements
//
// StartGameSessionPlacement
//
// DescribeGameSessionPlacement
//
// StopGameSessionPlacement
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/PlayerSession
type PlayerSession struct {
	_ struct{} `type:"structure"`

	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique identifier for a fleet that the player's game session is running on.
	FleetId *string `type:"string"`

	// Unique identifier for the game session that the player session is connected
	// to.
	GameSessionId *string `min:"1" type:"string"`

	// IP address of the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number.
	IpAddress *string `type:"string"`

	// Developer-defined information related to a player. Amazon GameLift does not
	// use this data, so it can be formatted as needed for use in the game.
	PlayerData *string `min:"1" type:"string"`

	// Unique identifier for a player that is associated with this player session.
	PlayerId *string `min:"1" type:"string"`

	// Unique identifier for a player session.
	PlayerSessionId *string `type:"string"`

	// Port number for the game session. To connect to a Amazon GameLift server
	// process, an app needs both the IP address and port number.
	Port *int64 `min:"1" type:"integer"`

	// Current status of the player session.
	//
	// Possible player session statuses include the following:
	//
	//    * RESERVED -- The player session request has been received, but the player
	//    has not yet connected to the server process and/or been validated.
	//
	//    * ACTIVE -- The player has been validated by the server process and is
	//    currently connected.
	//
	//    * COMPLETED -- The player connection has been dropped.
	//
	//    * TIMEDOUT -- A player session request was received, but the player did
	//    not connect and/or was not validated within the timeout limit (60 seconds).
	Status PlayerSessionStatus `type:"string" enum:"true"`

	// Time stamp indicating when this data object was terminated. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	TerminationTime *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s PlayerSession) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PlayerSession) GoString() string {
	return s.String()
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/PutScalingPolicyInput
type PutScalingPolicyInput struct {
	_ struct{} `type:"structure"`

	// Comparison operator to use when measuring the metric against the threshold
	// value.
	ComparisonOperator ComparisonOperatorType `type:"string" enum:"true"`

	// Length of time (in minutes) the metric must be at or beyond the threshold
	// before a scaling event is triggered.
	EvaluationPeriods *int64 `min:"1" type:"integer"`

	// Unique identifier for a fleet to apply this policy to. The fleet cannot be
	// in any of the following statuses: ERROR or DELETING.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling
	// adjustment. For detailed descriptions of fleet metrics, see Monitor Amazon
	// GameLift with Amazon CloudWatch (http://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html).
	//
	//    * ActivatingGameSessions -- Game sessions in the process of being created.
	//
	//    * ActiveGameSessions -- Game sessions that are currently running.
	//
	//    * ActiveInstances -- Fleet instances that are currently running at least
	//    one game session.
	//
	//    * AvailableGameSessions -- Additional game sessions that fleet could host
	//    simultaneously, given current capacity.
	//
	//    * AvailablePlayerSessions -- Empty player slots in currently active game
	//    sessions. This includes game sessions that are not currently accepting
	//    players. Reserved player slots are not included.
	//
	//    * CurrentPlayerSessions -- Player slots in active game sessions that are
	//    being used by a player or are reserved for a player.
	//
	//    * IdleInstances -- Active instances that are currently hosting zero game
	//    sessions.
	//
	//    * PercentAvailableGameSessions -- Unused percentage of the total number
	//    of game sessions that a fleet could host simultaneously, given current
	//    capacity. Use this metric for a target-based scaling policy.
	//
	//    * PercentIdleInstances -- Percentage of the total number of active instances
	//    that are hosting zero game sessions.
	//
	//    * QueueDepth -- Pending game session placement requests, in any queue,
	//    where the current fleet is the top-priority destination.
	//
	//    * WaitTime -- Current wait time for pending game session placement requests,
	//    in any queue, where the current fleet is the top-priority destination.
	//
	// MetricName is a required field
	MetricName MetricName `type:"string" required:"true" enum:"true"`

	// Descriptive label that is associated with a scaling policy. Policy names
	// do not need to be unique. A fleet can have only one scaling policy with the
	// same name.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// Type of scaling policy to create. For a target-based policy, set the parameter
	// MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration.
	// For a rule-based policy set the following parameters: MetricName, ComparisonOperator,
	// Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType PolicyType `type:"string" enum:"true"`

	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment *int64 `type:"integer"`

	// Type of adjustment to make to a fleet's instance count (see FleetCapacity):
	//
	//    * ChangeInCapacity -- add (or subtract) the scaling adjustment value from
	//    the current instance count. Positive values scale up while negative values
	//    scale down.
	//
	//    * ExactCapacity -- set the instance count to the scaling adjustment value.
	//
	//    * PercentChangeInCapacity -- increase or reduce the current instance count
	//    by the scaling adjustment, read as a percentage. Positive values scale
	//    up while negative values scale down; for example, a value of "-10" scales
	//    the fleet down by 10%.
	ScalingAdjustmentType ScalingAdjustmentType `type:"string" enum:"true"`

	// Object that contains settings for a target-based scaling policy.
	TargetConfiguration *TargetConfiguration `type:"structure"`

	// Metric value used to trigger a scaling event.
	Threshold *float64 `type:"double"`
}

// String returns the string representation
func (s PutScalingPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutScalingPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutScalingPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutScalingPolicyInput"}
	if s.EvaluationPeriods != nil && *s.EvaluationPeriods < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("EvaluationPeriods", 1))
	}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}
	if len(s.MetricName) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("MetricName"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.TargetConfiguration != nil {
		if err := s.TargetConfiguration.Validate(); err != nil {
			invalidParams.AddNested("TargetConfiguration", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/PutScalingPolicyOutput
type PutScalingPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Descriptive label that is associated with a scaling policy. Policy names
	// do not need to be unique.
	Name *string `min:"1" type:"string"`
}

// String returns the string representation
func (s PutScalingPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutScalingPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutScalingPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/RequestUploadCredentialsInput
type RequestUploadCredentialsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a build to get credentials for.
	//
	// BuildId is a required field
	BuildId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s RequestUploadCredentialsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RequestUploadCredentialsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RequestUploadCredentialsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RequestUploadCredentialsInput"}

	if s.BuildId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BuildId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/RequestUploadCredentialsOutput
type RequestUploadCredentialsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Amazon S3 path and key, identifying where the game build files are stored.
	StorageLocation *S3Location `type:"structure"`

	// AWS credentials required when uploading a game build to the storage location.
	// These credentials have a limited lifespan and are valid only for the build
	// they were issued for.
	UploadCredentials *AwsCredentials `type:"structure"`
}

// String returns the string representation
func (s RequestUploadCredentialsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RequestUploadCredentialsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RequestUploadCredentialsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ResolveAliasInput
type ResolveAliasInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for the alias you want to resolve.
	//
	// AliasId is a required field
	AliasId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s ResolveAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResolveAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ResolveAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ResolveAliasInput"}

	if s.AliasId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AliasId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ResolveAliasOutput
type ResolveAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Fleet identifier that is associated with the requested alias.
	FleetId *string `type:"string"`
}

// String returns the string representation
func (s ResolveAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResolveAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ResolveAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Policy that limits the number of game sessions a player can create on the
// same fleet. This optional policy gives game owners control over how players
// can consume available game server resources. A resource creation policy makes
// the following statement: "An individual player can create a maximum number
// of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session.
// For example, with a policy of 10 new game sessions and a time period of 60
// minutes, on receiving a CreateGameSession request, Amazon GameLift checks
// that the player (identified by CreatorId) has created fewer than 10 game
// sessions in the past 60 minutes.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ResourceCreationLimitPolicy
type ResourceCreationLimitPolicy struct {
	_ struct{} `type:"structure"`

	// Maximum number of game sessions that an individual can create during the
	// policy period.
	NewGameSessionsPerCreator *int64 `type:"integer"`

	// Time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int64 `type:"integer"`
}

// String returns the string representation
func (s ResourceCreationLimitPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourceCreationLimitPolicy) GoString() string {
	return s.String()
}

// Routing configuration for a fleet alias.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/RoutingStrategy
type RoutingStrategy struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet that the alias points to.
	FleetId *string `type:"string"`

	// Message text to be used with a terminal routing strategy.
	Message *string `type:"string"`

	// Type of routing strategy.
	//
	// Possible routing types include the following:
	//
	//    * SIMPLE -- The alias resolves to one specific fleet. Use this type when
	//    routing to active fleets.
	//
	//    * TERMINAL -- The alias does not resolve to a fleet but instead can be
	//    used to display a message to the user. A terminal alias throws a TerminalRoutingStrategyException
	//    with the RoutingStrategy message embedded.
	Type RoutingStrategyType `type:"string" enum:"true"`
}

// String returns the string representation
func (s RoutingStrategy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RoutingStrategy) GoString() string {
	return s.String()
}

// A collection of server process configurations that describe what processes
// to run on each instance in a fleet. All fleets must have a run-time configuration.
// Each instance in the fleet launches the server processes specified in the
// run-time configuration and launches new ones as existing processes end. Each
// instance regularly checks for an updated run-time configuration and follows
// the new instructions.
//
// The run-time configuration enables the instances in a fleet to run multiple
// processes simultaneously. Potential scenarios are as follows: (1) Run multiple
// processes of a single game server executable to maximize usage of your hosting
// resources. (2) Run one or more processes of different build executables,
// such as your game server executable and a related program, or two or more
// different versions of a game server. (3) Run multiple processes of a single
// game server but with different launch parameters, for example to run one
// process on each instance in debug mode.
//
// A Amazon GameLift instance is limited to 50 processes running simultaneously.
// A run-time configuration must specify fewer than this limit. To calculate
// the total number of processes specified in a run-time configuration, add
// the values of the ConcurrentExecutions parameter for each ServerProcess object
// in the run-time configuration.
//
// Fleet-related operations include:
//
//    * CreateFleet
//
//    * ListFleets
//
//    * DeleteFleet
//
//    * Describe fleets:
//
// DescribeFleetAttributes
//
// DescribeFleetCapacity
//
// DescribeFleetPortSettings
//
// DescribeFleetUtilization
//
// DescribeRuntimeConfiguration
//
// DescribeEC2InstanceLimits
//
// DescribeFleetEvents
//
//    * Update fleets:
//
// UpdateFleetAttributes
//
// UpdateFleetCapacity
//
// UpdateFleetPortSettings
//
// UpdateRuntimeConfiguration
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/RuntimeConfiguration
type RuntimeConfiguration struct {
	_ struct{} `type:"structure"`

	// Maximum amount of time (in seconds) that a game session can remain in status
	// ACTIVATING. If the game session is not active before the timeout, activation
	// is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds *int64 `min:"1" type:"integer"`

	// Maximum number of game sessions with status ACTIVATING to allow on an instance
	// simultaneously. This setting limits the amount of instance resources that
	// can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations *int64 `min:"1" type:"integer"`

	// Collection of server process configurations that describe which server processes
	// to run on each instance in a fleet.
	ServerProcesses []ServerProcess `min:"1" type:"list"`
}

// String returns the string representation
func (s RuntimeConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RuntimeConfiguration) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RuntimeConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RuntimeConfiguration"}
	if s.GameSessionActivationTimeoutSeconds != nil && *s.GameSessionActivationTimeoutSeconds < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("GameSessionActivationTimeoutSeconds", 1))
	}
	if s.MaxConcurrentGameSessionActivations != nil && *s.MaxConcurrentGameSessionActivations < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxConcurrentGameSessionActivations", 1))
	}
	if s.ServerProcesses != nil && len(s.ServerProcesses) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ServerProcesses", 1))
	}
	if s.ServerProcesses != nil {
		for i, v := range s.ServerProcesses {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ServerProcesses", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Location in Amazon Simple Storage Service (Amazon S3) where build files can
// be stored for access by Amazon GameLift. This location is specified in a
// CreateBuild request. For more details, see the Create a Build with Files
// in Amazon S3 (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-build-cli-uploading.html#gamelift-build-cli-uploading-create-build).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/S3Location
type S3Location struct {
	_ struct{} `type:"structure"`

	// Amazon S3 bucket identifier. This is the name of your S3 bucket.
	Bucket *string `min:"1" type:"string"`

	// Name of the zip file containing your build files.
	Key *string `min:"1" type:"string"`

	// Amazon Resource Name (ARN (http://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html))
	// for the access role that allows Amazon GameLift to access your S3 bucket.
	RoleArn *string `min:"1" type:"string"`
}

// String returns the string representation
func (s S3Location) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s S3Location) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Location) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Location"}
	if s.Bucket != nil && len(*s.Bucket) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Bucket", 1))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified
// by the combination of name and fleet ID.
//
// Operations related to fleet capacity scaling include:
//
//    * DescribeFleetCapacity
//
//    * UpdateFleetCapacity
//
//    * DescribeEC2InstanceLimits
//
//    * Manage scaling policies:
//
// PutScalingPolicy (auto-scaling)
//
// DescribeScalingPolicies (auto-scaling)
//
// DeleteScalingPolicy (auto-scaling)
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ScalingPolicy
type ScalingPolicy struct {
	_ struct{} `type:"structure"`

	// Comparison operator to use when measuring a metric against the threshold
	// value.
	ComparisonOperator ComparisonOperatorType `type:"string" enum:"true"`

	// Length of time (in minutes) the metric must be at or beyond the threshold
	// before a scaling event is triggered.
	EvaluationPeriods *int64 `min:"1" type:"integer"`

	// Unique identifier for a fleet that is associated with this scaling policy.
	FleetId *string `type:"string"`

	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling
	// adjustment. For detailed descriptions of fleet metrics, see Monitor Amazon
	// GameLift with Amazon CloudWatch (http://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html).
	//
	//    * ActivatingGameSessions -- Game sessions in the process of being created.
	//
	//    * ActiveGameSessions -- Game sessions that are currently running.
	//
	//    * ActiveInstances -- Fleet instances that are currently running at least
	//    one game session.
	//
	//    * AvailableGameSessions -- Additional game sessions that fleet could host
	//    simultaneously, given current capacity.
	//
	//    * AvailablePlayerSessions -- Empty player slots in currently active game
	//    sessions. This includes game sessions that are not currently accepting
	//    players. Reserved player slots are not included.
	//
	//    * CurrentPlayerSessions -- Player slots in active game sessions that are
	//    being used by a player or are reserved for a player.
	//
	//    * IdleInstances -- Active instances that are currently hosting zero game
	//    sessions.
	//
	//    * PercentAvailableGameSessions -- Unused percentage of the total number
	//    of game sessions that a fleet could host simultaneously, given current
	//    capacity. Use this metric for a target-based scaling policy.
	//
	//    * PercentIdleInstances -- Percentage of the total number of active instances
	//    that are hosting zero game sessions.
	//
	//    * QueueDepth -- Pending game session placement requests, in any queue,
	//    where the current fleet is the top-priority destination.
	//
	//    * WaitTime -- Current wait time for pending game session placement requests,
	//    in any queue, where the current fleet is the top-priority destination.
	MetricName MetricName `type:"string" enum:"true"`

	// Descriptive label that is associated with a scaling policy. Policy names
	// do not need to be unique.
	Name *string `min:"1" type:"string"`

	// Type of scaling policy to create. For a target-based policy, set the parameter
	// MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration.
	// For a rule-based policy set the following parameters: MetricName, ComparisonOperator,
	// Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType PolicyType `type:"string" enum:"true"`

	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment *int64 `type:"integer"`

	// Type of adjustment to make to a fleet's instance count (see FleetCapacity):
	//
	//    * ChangeInCapacity -- add (or subtract) the scaling adjustment value from
	//    the current instance count. Positive values scale up while negative values
	//    scale down.
	//
	//    * ExactCapacity -- set the instance count to the scaling adjustment value.
	//
	//    * PercentChangeInCapacity -- increase or reduce the current instance count
	//    by the scaling adjustment, read as a percentage. Positive values scale
	//    up while negative values scale down.
	ScalingAdjustmentType ScalingAdjustmentType `type:"string" enum:"true"`

	// Current status of the scaling policy. The scaling policy can be in force
	// only when in an ACTIVE status. Scaling policies can be suspended for individual
	// fleets (see StopFleetActions; if suspended for a fleet, the policy status
	// does not change. View a fleet's stopped actions by calling DescribeFleetCapacity.
	//
	//    * ACTIVE -- The scaling policy can be used for auto-scaling a fleet.
	//
	//    * UPDATE_REQUESTED -- A request to update the scaling policy has been
	//    received.
	//
	//    * UPDATING -- A change is being made to the scaling policy.
	//
	//    * DELETE_REQUESTED -- A request to delete the scaling policy has been
	//    received.
	//
	//    * DELETING -- The scaling policy is being deleted.
	//
	//    * DELETED -- The scaling policy has been deleted.
	//
	//    * ERROR -- An error occurred in creating the policy. It should be removed
	//    and recreated.
	Status ScalingStatusType `type:"string" enum:"true"`

	// Object that contains settings for a target-based scaling policy.
	TargetConfiguration *TargetConfiguration `type:"structure"`

	// Metric value used to trigger a scaling event.
	Threshold *float64 `type:"double"`
}

// String returns the string representation
func (s ScalingPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ScalingPolicy) GoString() string {
	return s.String()
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/SearchGameSessionsInput
type SearchGameSessionsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for an alias associated with the fleet to search for active
	// game sessions. Each request must reference either a fleet ID or alias ID,
	// but not both.
	AliasId *string `type:"string"`

	// String containing the search criteria for the session search. If no filter
	// expression is included, the request returns results for all game sessions
	// in the fleet that are in ACTIVE status.
	//
	// A filter expression can contain one or multiple conditions. Each condition
	// consists of the following:
	//
	//    * Operand -- Name of a game session attribute. Valid values are gameSessionName,
	//    gameSessionId, gameSessionProperties, maximumSessions, creationTimeMillis,
	//    playerSessionCount, hasAvailablePlayerSessions.
	//
	//    * Comparator -- Valid comparators are: =, <>, <, >, <=, >=.
	//
	//    * Value -- Value to be searched for. Values may be numbers, boolean values
	//    (true/false) or strings depending on the operand. String values are case
	//    sensitive and must be enclosed in single quotes. Special characters must
	//    be escaped. Boolean and string values can only be used with the comparators
	//    = and <>. For example, the following filter expression searches on gameSessionName:
	//    "FilterExpression": "gameSessionName = 'Matt\\'s Awesome Game 1'".
	//
	// To chain multiple conditions in a single expression, use the logical keywords
	// AND, OR, and NOT and parentheses as needed. For example: x AND y AND NOT
	// z, NOT (x OR y).
	//
	// Session search evaluates conditions from left to right using the following
	// precedence rules:
	//
	// =, <>, <, >, <=, >=
	//
	// Parentheses
	//
	// NOT
	//
	// AND
	//
	// OR
	//
	// For example, this filter expression retrieves game sessions hosting at least
	// ten players that have an open player slot: "maximumSessions>=10 AND hasAvailablePlayerSessions=true".
	FilterExpression *string `min:"1" type:"string"`

	// Unique identifier for a fleet to search for active game sessions. Each request
	// must reference either a fleet ID or alias ID, but not both.
	FleetId *string `type:"string"`

	// Maximum number of results to return. Use this parameter with NextToken to
	// get results as a set of sequential pages. The maximum number of results returned
	// is 20, even if this value is not set or is set higher than 20.
	Limit *int64 `min:"1" type:"integer"`

	// Token that indicates the start of the next sequential page of results. Use
	// the token that is returned with a previous call to this action. To start
	// at the beginning of the result set, do not specify a value.
	NextToken *string `min:"1" type:"string"`

	// Instructions on how to sort the search results. If no sort expression is
	// included, the request returns results in random order. A sort expression
	// consists of the following elements:
	//
	//    * Operand -- Name of a game session attribute. Valid values are gameSessionName,
	//    gameSessionId, gameSessionProperties, maximumSessions, creationTimeMillis,
	//    playerSessionCount, hasAvailablePlayerSessions.
	//
	//    * Order -- Valid sort orders are ASC (ascending) and DESC (descending).
	//
	// For example, this sort expression returns the oldest active sessions first:
	// "SortExpression": "creationTimeMillis ASC". Results with a null value for
	// the sort operand are returned at the end of the list.
	SortExpression *string `min:"1" type:"string"`
}

// String returns the string representation
func (s SearchGameSessionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SearchGameSessionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SearchGameSessionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SearchGameSessionsInput"}
	if s.FilterExpression != nil && len(*s.FilterExpression) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FilterExpression", 1))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}
	if s.SortExpression != nil && len(*s.SortExpression) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SortExpression", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/SearchGameSessionsOutput
type SearchGameSessionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Collection of objects containing game session properties for each session
	// matching the request.
	GameSessions []GameSession `type:"list"`

	// Token that indicates where to resume retrieving results on the next call
	// to this action. If no token is returned, these results represent the end
	// of the list.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s SearchGameSessionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SearchGameSessionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SearchGameSessionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// A set of instructions for launching server processes on each instance in
// a fleet. Each instruction set identifies the location of the server executable,
// optional launch parameters, and the number of server processes with this
// configuration to maintain concurrently on the instance. Server process configurations
// make up a fleet's RuntimeConfiguration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ServerProcess
type ServerProcess struct {
	_ struct{} `type:"structure"`

	// Number of server processes using this configuration to run concurrently on
	// an instance.
	//
	// ConcurrentExecutions is a required field
	ConcurrentExecutions *int64 `min:"1" type:"integer" required:"true"`

	// Location of the server executable in a game build. All game builds are installed
	// on instances at the root : for Windows instances C:\game, and for Linux instances
	// /local/game. A Windows game build with an executable file located at MyGame\latest\server.exe
	// must have a launch path of "C:\game\MyGame\latest\server.exe". A Linux game
	// build with an executable file located at MyGame/latest/server.exe must have
	// a launch path of "/local/game/MyGame/latest/server.exe".
	//
	// LaunchPath is a required field
	LaunchPath *string `min:"1" type:"string" required:"true"`

	// Optional list of parameters to pass to the server executable on launch.
	Parameters *string `min:"1" type:"string"`
}

// String returns the string representation
func (s ServerProcess) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ServerProcess) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ServerProcess) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ServerProcess"}

	if s.ConcurrentExecutions == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConcurrentExecutions"))
	}
	if s.ConcurrentExecutions != nil && *s.ConcurrentExecutions < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("ConcurrentExecutions", 1))
	}

	if s.LaunchPath == nil {
		invalidParams.Add(aws.NewErrParamRequired("LaunchPath"))
	}
	if s.LaunchPath != nil && len(*s.LaunchPath) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("LaunchPath", 1))
	}
	if s.Parameters != nil && len(*s.Parameters) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Parameters", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartFleetActionsInput
type StartFleetActionsInput struct {
	_ struct{} `type:"structure"`

	// List of actions to restart on the fleet.
	//
	// Actions is a required field
	Actions []FleetAction `min:"1" type:"list" required:"true"`

	// Unique identifier for a fleet
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s StartFleetActionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartFleetActionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartFleetActionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartFleetActionsInput"}

	if s.Actions == nil {
		invalidParams.Add(aws.NewErrParamRequired("Actions"))
	}
	if s.Actions != nil && len(s.Actions) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Actions", 1))
	}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartFleetActionsOutput
type StartFleetActionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s StartFleetActionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartFleetActionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartFleetActionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartGameSessionPlacementInput
type StartGameSessionPlacementInput struct {
	_ struct{} `type:"structure"`

	// Set of information on each player to create a player session for.
	DesiredPlayerSessions []DesiredPlayerSession `type:"list"`

	// Set of custom properties for a game session, formatted as key:value pairs.
	// These properties are passed to a game server process in the GameSession object
	// with a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameProperties []GameProperty `type:"list"`

	// Set of custom game session properties, formatted as a single string value.
	// This data is passed to a game server process in the GameSession object with
	// a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameSessionData *string `min:"1" type:"string"`

	// Descriptive label that is associated with a game session. Session names do
	// not need to be unique.
	GameSessionName *string `min:"1" type:"string"`

	// Name of the queue to use to place the new game session.
	//
	// GameSessionQueueName is a required field
	GameSessionQueueName *string `min:"1" type:"string" required:"true"`

	// Maximum number of players that can be connected simultaneously to the game
	// session.
	//
	// MaximumPlayerSessionCount is a required field
	MaximumPlayerSessionCount *int64 `type:"integer" required:"true"`

	// Unique identifier to assign to the new game session placement. This value
	// is developer-defined. The value must be unique across all regions and cannot
	// be reused unless you are resubmitting a canceled or timed-out placement request.
	//
	// PlacementId is a required field
	PlacementId *string `min:"1" type:"string" required:"true"`

	// Set of values, expressed in milliseconds, indicating the amount of latency
	// that a player experiences when connected to AWS regions. This information
	// is used to try to place the new game session where it can offer the best
	// possible gameplay experience for the players.
	PlayerLatencies []PlayerLatency `type:"list"`
}

// String returns the string representation
func (s StartGameSessionPlacementInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartGameSessionPlacementInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartGameSessionPlacementInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartGameSessionPlacementInput"}
	if s.GameSessionData != nil && len(*s.GameSessionData) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionData", 1))
	}
	if s.GameSessionName != nil && len(*s.GameSessionName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionName", 1))
	}

	if s.GameSessionQueueName == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameSessionQueueName"))
	}
	if s.GameSessionQueueName != nil && len(*s.GameSessionQueueName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionQueueName", 1))
	}

	if s.MaximumPlayerSessionCount == nil {
		invalidParams.Add(aws.NewErrParamRequired("MaximumPlayerSessionCount"))
	}

	if s.PlacementId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PlacementId"))
	}
	if s.PlacementId != nil && len(*s.PlacementId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlacementId", 1))
	}
	if s.DesiredPlayerSessions != nil {
		for i, v := range s.DesiredPlayerSessions {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "DesiredPlayerSessions", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.GameProperties != nil {
		for i, v := range s.GameProperties {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "GameProperties", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.PlayerLatencies != nil {
		for i, v := range s.PlayerLatencies {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "PlayerLatencies", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartGameSessionPlacementOutput
type StartGameSessionPlacementOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the newly created game session placement. This object
	// includes all the information provided in the request, as well as start/end
	// time stamps and placement status.
	GameSessionPlacement *GameSessionPlacement `type:"structure"`
}

// String returns the string representation
func (s StartGameSessionPlacementOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartGameSessionPlacementOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartGameSessionPlacementOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartMatchBackfillInput
type StartMatchBackfillInput struct {
	_ struct{} `type:"structure"`

	// Name of the matchmaker to use for this request. The name of the matchmaker
	// that was used with the original game session is listed in the GameSession
	// object, MatchmakerData property. This property contains a matchmaking configuration
	// ARN value, which includes the matchmaker name. (In the ARN value "arn:aws:gamelift:us-west-2:111122223333:matchmakingconfiguration/MM-4v4",
	// the matchmaking configuration name is "MM-4v4".) Use only the name for this
	// parameter.
	//
	// ConfigurationName is a required field
	ConfigurationName *string `min:"1" type:"string" required:"true"`

	// Amazon Resource Name (ARN (http://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html))
	// that is assigned to a game session and uniquely identifies it.
	//
	// GameSessionArn is a required field
	GameSessionArn *string `min:"1" type:"string" required:"true"`

	// Match information on all players that are currently assigned to the game
	// session. This information is used by the matchmaker to find new players and
	// add them to the existing game.
	//
	//    * PlayerID, PlayerAttributes, Team -\\- This information is maintained
	//    in the GameSession object, MatchmakerData property, for all players who
	//    are currently assigned to the game session. The matchmaker data is in
	//    JSON syntax, formatted as a string. For more details, see  Match Data
	//    (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-server.html#match-server-data).
	//
	//
	//    * LatencyInMs -\\- If the matchmaker uses player latency, include a latency
	//    value, in milliseconds, for the region that the game session is currently
	//    in. Do not include latency values for any other region.
	//
	// Players is a required field
	Players []Player `type:"list" required:"true"`

	// Unique identifier for a matchmaking ticket. If no ticket ID is specified
	// here, Amazon GameLift will generate one in the form of a UUID. Use this identifier
	// to track the match backfill ticket status and retrieve match results.
	TicketId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s StartMatchBackfillInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartMatchBackfillInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartMatchBackfillInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartMatchBackfillInput"}

	if s.ConfigurationName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConfigurationName"))
	}
	if s.ConfigurationName != nil && len(*s.ConfigurationName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ConfigurationName", 1))
	}

	if s.GameSessionArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameSessionArn"))
	}
	if s.GameSessionArn != nil && len(*s.GameSessionArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionArn", 1))
	}

	if s.Players == nil {
		invalidParams.Add(aws.NewErrParamRequired("Players"))
	}
	if s.TicketId != nil && len(*s.TicketId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TicketId", 1))
	}
	if s.Players != nil {
		for i, v := range s.Players {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Players", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartMatchBackfillOutput
type StartMatchBackfillOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Ticket representing the backfill matchmaking request. This object includes
	// the information in the request, ticket status, and match results as generated
	// during the matchmaking process.
	MatchmakingTicket *MatchmakingTicket `type:"structure"`
}

// String returns the string representation
func (s StartMatchBackfillOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartMatchBackfillOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartMatchBackfillOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartMatchmakingInput
type StartMatchmakingInput struct {
	_ struct{} `type:"structure"`

	// Name of the matchmaking configuration to use for this request. Matchmaking
	// configurations must exist in the same region as this request.
	//
	// ConfigurationName is a required field
	ConfigurationName *string `min:"1" type:"string" required:"true"`

	// Information on each player to be matched. This information must include a
	// player ID, and may contain player attributes and latency data to be used
	// in the matchmaking process. After a successful match, Player objects contain
	// the name of the team the player is assigned to.
	//
	// Players is a required field
	Players []Player `type:"list" required:"true"`

	// Unique identifier for a matchmaking ticket. If no ticket ID is specified
	// here, Amazon GameLift will generate one in the form of a UUID. Use this identifier
	// to track the matchmaking ticket status and retrieve match results.
	TicketId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s StartMatchmakingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartMatchmakingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartMatchmakingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartMatchmakingInput"}

	if s.ConfigurationName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConfigurationName"))
	}
	if s.ConfigurationName != nil && len(*s.ConfigurationName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ConfigurationName", 1))
	}

	if s.Players == nil {
		invalidParams.Add(aws.NewErrParamRequired("Players"))
	}
	if s.TicketId != nil && len(*s.TicketId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TicketId", 1))
	}
	if s.Players != nil {
		for i, v := range s.Players {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Players", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StartMatchmakingOutput
type StartMatchmakingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Ticket representing the matchmaking request. This object include the information
	// included in the request, ticket status, and match results as generated during
	// the matchmaking process.
	MatchmakingTicket *MatchmakingTicket `type:"structure"`
}

// String returns the string representation
func (s StartMatchmakingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartMatchmakingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartMatchmakingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopFleetActionsInput
type StopFleetActionsInput struct {
	_ struct{} `type:"structure"`

	// List of actions to suspend on the fleet.
	//
	// Actions is a required field
	Actions []FleetAction `min:"1" type:"list" required:"true"`

	// Unique identifier for a fleet
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s StopFleetActionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopFleetActionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StopFleetActionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StopFleetActionsInput"}

	if s.Actions == nil {
		invalidParams.Add(aws.NewErrParamRequired("Actions"))
	}
	if s.Actions != nil && len(s.Actions) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Actions", 1))
	}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopFleetActionsOutput
type StopFleetActionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s StopFleetActionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopFleetActionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StopFleetActionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopGameSessionPlacementInput
type StopGameSessionPlacementInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a game session placement to cancel.
	//
	// PlacementId is a required field
	PlacementId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s StopGameSessionPlacementInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopGameSessionPlacementInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StopGameSessionPlacementInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StopGameSessionPlacementInput"}

	if s.PlacementId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PlacementId"))
	}
	if s.PlacementId != nil && len(*s.PlacementId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PlacementId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopGameSessionPlacementOutput
type StopGameSessionPlacementOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the canceled game session placement, with CANCELLED
	// status and an end time stamp.
	GameSessionPlacement *GameSessionPlacement `type:"structure"`
}

// String returns the string representation
func (s StopGameSessionPlacementOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopGameSessionPlacementOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StopGameSessionPlacementOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopMatchmakingInput
type StopMatchmakingInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a matchmaking ticket.
	//
	// TicketId is a required field
	TicketId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s StopMatchmakingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopMatchmakingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StopMatchmakingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StopMatchmakingInput"}

	if s.TicketId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TicketId"))
	}
	if s.TicketId != nil && len(*s.TicketId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TicketId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/StopMatchmakingOutput
type StopMatchmakingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s StopMatchmakingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StopMatchmakingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StopMatchmakingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Settings for a target-based scaling policy (see ScalingPolicy. A target-based
// policy tracks a particular fleet metric specifies a target value for the
// metric. As player usage changes, the policy triggers Amazon GameLift to adjust
// capacity so that the metric returns to the target value. The target configuration
// specifies settings as needed for the target based policy, including the target
// value.
//
// Operations related to fleet capacity scaling include:
//
//    * DescribeFleetCapacity
//
//    * UpdateFleetCapacity
//
//    * DescribeEC2InstanceLimits
//
//    * Manage scaling policies:
//
// PutScalingPolicy (auto-scaling)
//
// DescribeScalingPolicies (auto-scaling)
//
// DeleteScalingPolicy (auto-scaling)
//
//    * Manage fleet actions:
//
// StartFleetActions
//
// StopFleetActions
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/TargetConfiguration
type TargetConfiguration struct {
	_ struct{} `type:"structure"`

	// Desired value to use with a target-based scaling policy. The value must be
	// relevant for whatever metric the scaling policy is using. For example, in
	// a policy using the metric PercentAvailableGameSessions, the target value
	// should be the preferred size of the fleet's buffer (the percent of capacity
	// that should be idle and ready for new game sessions).
	//
	// TargetValue is a required field
	TargetValue *float64 `type:"double" required:"true"`
}

// String returns the string representation
func (s TargetConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TargetConfiguration) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TargetConfiguration) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TargetConfiguration"}

	if s.TargetValue == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetValue"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateAliasInput
type UpdateAliasInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet alias. Specify the alias you want to update.
	//
	// AliasId is a required field
	AliasId *string `type:"string" required:"true"`

	// Human-readable description of an alias.
	Description *string `min:"1" type:"string"`

	// Descriptive label that is associated with an alias. Alias names do not need
	// to be unique.
	Name *string `min:"1" type:"string"`

	// Object that specifies the fleet and routing type to use for the alias.
	RoutingStrategy *RoutingStrategy `type:"structure"`
}

// String returns the string representation
func (s UpdateAliasInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateAliasInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateAliasInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateAliasInput"}

	if s.AliasId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AliasId"))
	}
	if s.Description != nil && len(*s.Description) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Description", 1))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateAliasOutput
type UpdateAliasOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that contains the updated alias configuration.
	Alias *Alias `type:"structure"`
}

// String returns the string representation
func (s UpdateAliasOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateAliasOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateAliasOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateBuildInput
type UpdateBuildInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a build to update.
	//
	// BuildId is a required field
	BuildId *string `type:"string" required:"true"`

	// Descriptive label that is associated with a build. Build names do not need
	// to be unique.
	Name *string `min:"1" type:"string"`

	// Version that is associated with this build. Version strings do not need to
	// be unique.
	Version *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateBuildInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBuildInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateBuildInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateBuildInput"}

	if s.BuildId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BuildId"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.Version != nil && len(*s.Version) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateBuildOutput
type UpdateBuildOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that contains the updated build record.
	Build *Build `type:"structure"`
}

// String returns the string representation
func (s UpdateBuildOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBuildOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateBuildOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetAttributesInput
type UpdateFleetAttributesInput struct {
	_ struct{} `type:"structure"`

	// Human-readable description of a fleet.
	Description *string `min:"1" type:"string"`

	// Unique identifier for a fleet to update attribute metadata for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Names of metric groups to include this fleet in. Amazon CloudWatch uses a
	// fleet metric group is to aggregate metrics from multiple fleets. Use an existing
	// metric group name to add this fleet to the group. Or use a new name to create
	// a new metric group. A fleet can only be included in one metric group at a
	// time.
	MetricGroups []string `type:"list"`

	// Descriptive label that is associated with a fleet. Fleet names do not need
	// to be unique.
	Name *string `min:"1" type:"string"`

	// Game session protection policy to apply to all new instances created in this
	// fleet. Instances that already exist are not affected. You can set protection
	// for individual instances using UpdateGameSession.
	//
	//    * NoProtection -- The game session can be terminated during a scale-down
	//    event.
	//
	//    * FullProtection -- If the game session is in an ACTIVE status, it cannot
	//    be terminated during a scale-down event.
	NewGameSessionProtectionPolicy ProtectionPolicy `type:"string" enum:"true"`

	// Policy that limits the number of game sessions an individual player can create
	// over a span of time.
	ResourceCreationLimitPolicy *ResourceCreationLimitPolicy `type:"structure"`
}

// String returns the string representation
func (s UpdateFleetAttributesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFleetAttributesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateFleetAttributesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateFleetAttributesInput"}
	if s.Description != nil && len(*s.Description) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Description", 1))
	}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetAttributesOutput
type UpdateFleetAttributesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Unique identifier for a fleet that was updated.
	FleetId *string `type:"string"`
}

// String returns the string representation
func (s UpdateFleetAttributesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFleetAttributesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateFleetAttributesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetCapacityInput
type UpdateFleetCapacityInput struct {
	_ struct{} `type:"structure"`

	// Number of EC2 instances you want this fleet to host.
	DesiredInstances *int64 `type:"integer"`

	// Unique identifier for a fleet to update capacity for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Maximum value allowed for the fleet's instance count. Default if not set
	// is 1.
	MaxSize *int64 `type:"integer"`

	// Minimum value allowed for the fleet's instance count. Default if not set
	// is 0.
	MinSize *int64 `type:"integer"`
}

// String returns the string representation
func (s UpdateFleetCapacityInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFleetCapacityInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateFleetCapacityInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateFleetCapacityInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetCapacityOutput
type UpdateFleetCapacityOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Unique identifier for a fleet that was updated.
	FleetId *string `type:"string"`
}

// String returns the string representation
func (s UpdateFleetCapacityOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFleetCapacityOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateFleetCapacityOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetPortSettingsInput
type UpdateFleetPortSettingsInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet to update port settings for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Collection of port settings to be added to the fleet record.
	InboundPermissionAuthorizations []IpPermission `type:"list"`

	// Collection of port settings to be removed from the fleet record.
	InboundPermissionRevocations []IpPermission `type:"list"`
}

// String returns the string representation
func (s UpdateFleetPortSettingsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFleetPortSettingsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateFleetPortSettingsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateFleetPortSettingsInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}
	if s.InboundPermissionAuthorizations != nil {
		for i, v := range s.InboundPermissionAuthorizations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "InboundPermissionAuthorizations", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.InboundPermissionRevocations != nil {
		for i, v := range s.InboundPermissionRevocations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "InboundPermissionRevocations", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateFleetPortSettingsOutput
type UpdateFleetPortSettingsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Unique identifier for a fleet that was updated.
	FleetId *string `type:"string"`
}

// String returns the string representation
func (s UpdateFleetPortSettingsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateFleetPortSettingsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateFleetPortSettingsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateGameSessionInput
type UpdateGameSessionInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for the game session to update.
	//
	// GameSessionId is a required field
	GameSessionId *string `min:"1" type:"string" required:"true"`

	// Maximum number of players that can be connected simultaneously to the game
	// session.
	MaximumPlayerSessionCount *int64 `type:"integer"`

	// Descriptive label that is associated with a game session. Session names do
	// not need to be unique.
	Name *string `min:"1" type:"string"`

	// Policy determining whether or not the game session accepts new players.
	PlayerSessionCreationPolicy PlayerSessionCreationPolicy `type:"string" enum:"true"`

	// Game session protection policy to apply to this game session only.
	//
	//    * NoProtection -- The game session can be terminated during a scale-down
	//    event.
	//
	//    * FullProtection -- If the game session is in an ACTIVE status, it cannot
	//    be terminated during a scale-down event.
	ProtectionPolicy ProtectionPolicy `type:"string" enum:"true"`
}

// String returns the string representation
func (s UpdateGameSessionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGameSessionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateGameSessionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateGameSessionInput"}

	if s.GameSessionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("GameSessionId"))
	}
	if s.GameSessionId != nil && len(*s.GameSessionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionId", 1))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateGameSessionOutput
type UpdateGameSessionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that contains the updated game session metadata.
	GameSession *GameSession `type:"structure"`
}

// String returns the string representation
func (s UpdateGameSessionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGameSessionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateGameSessionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateGameSessionQueueInput
type UpdateGameSessionQueueInput struct {
	_ struct{} `type:"structure"`

	// List of fleets that can be used to fulfill game session placement requests
	// in the queue. Fleets are identified by either a fleet ARN or a fleet alias
	// ARN. Destinations are listed in default preference order. When updating this
	// list, provide a complete list of destinations.
	Destinations []GameSessionQueueDestination `type:"list"`

	// Descriptive label that is associated with game session queue. Queue names
	// must be unique within each region.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// Collection of latency policies to apply when processing game sessions placement
	// requests with player latency information. Multiple policies are evaluated
	// in order of the maximum latency value, starting with the lowest latency values.
	// With just one policy, it is enforced at the start of the game session placement
	// for the duration period. With multiple policies, each policy is enforced
	// consecutively for its duration period. For example, a queue might enforce
	// a 60-second policy followed by a 120-second policy, and then no policy for
	// the remainder of the placement. When updating policies, provide a complete
	// collection of policies.
	PlayerLatencyPolicies []PlayerLatencyPolicy `type:"list"`

	// Maximum time, in seconds, that a new game session placement request remains
	// in the queue. When a request exceeds this time, the game session placement
	// changes to a TIMED_OUT status.
	TimeoutInSeconds *int64 `type:"integer"`
}

// String returns the string representation
func (s UpdateGameSessionQueueInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGameSessionQueueInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateGameSessionQueueInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateGameSessionQueueInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.Destinations != nil {
		for i, v := range s.Destinations {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Destinations", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateGameSessionQueueOutput
type UpdateGameSessionQueueOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the newly updated game session queue.
	GameSessionQueue *GameSessionQueue `type:"structure"`
}

// String returns the string representation
func (s UpdateGameSessionQueueOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGameSessionQueueOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateGameSessionQueueOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateMatchmakingConfigurationInput
type UpdateMatchmakingConfigurationInput struct {
	_ struct{} `type:"structure"`

	// Flag that determines whether or not a match that was created with this configuration
	// must be accepted by the matched players. To require acceptance, set to TRUE.
	AcceptanceRequired *bool `type:"boolean"`

	// Length of time (in seconds) to wait for players to accept a proposed match.
	// If any player rejects the match or fails to accept before the timeout, the
	// ticket continues to look for an acceptable match.
	AcceptanceTimeoutSeconds *int64 `min:"1" type:"integer"`

	// Number of player slots in a match to keep open for future players. For example,
	// if the configuration's rule set specifies a match for a single 12-person
	// team, and the additional player count is set to 2, only 10 players are selected
	// for the match.
	AdditionalPlayerCount *int64 `type:"integer"`

	// Information to attached to all events related to the matchmaking configuration.
	CustomEventData *string `type:"string"`

	// Descriptive label that is associated with matchmaking configuration.
	Description *string `min:"1" type:"string"`

	// Set of custom properties for a game session, formatted as key:value pairs.
	// These properties are passed to a game server process in the GameSession object
	// with a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// This information is added to the new GameSession object that is created for
	// a successful match.
	GameProperties []GameProperty `type:"list"`

	// Set of custom game session properties, formatted as a single string value.
	// This data is passed to a game server process in the GameSession object with
	// a request to start a new game session (see Start a Game Session (http://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// This information is added to the new GameSession object that is created for
	// a successful match.
	GameSessionData *string `min:"1" type:"string"`

	// Amazon Resource Name (ARN (http://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html))
	// that is assigned to a game session queue and uniquely identifies it. Format
	// is arn:aws:gamelift:<region>::fleet/fleet-a1234567-b8c9-0d1e-2fa3-b45c6d7e8912.
	// These queues are used when placing game sessions for matches that are created
	// with this matchmaking configuration. Queues can be located in any region.
	GameSessionQueueArns []string `type:"list"`

	// Unique identifier for a matchmaking configuration to update.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// SNS topic ARN that is set up to receive matchmaking notifications. See  Setting
	// up Notifications for Matchmaking (http://docs.aws.amazon.com/gamelift/latest/developerguide/match-notification.html)
	// for more information.
	NotificationTarget *string `type:"string"`

	// Maximum duration, in seconds, that a matchmaking ticket can remain in process
	// before timing out. Requests that time out can be resubmitted as needed.
	RequestTimeoutSeconds *int64 `min:"1" type:"integer"`

	// Unique identifier for a matchmaking rule set to use with this configuration.
	// A matchmaking configuration can only use rule sets that are defined in the
	// same region.
	RuleSetName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateMatchmakingConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateMatchmakingConfigurationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateMatchmakingConfigurationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateMatchmakingConfigurationInput"}
	if s.AcceptanceTimeoutSeconds != nil && *s.AcceptanceTimeoutSeconds < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("AcceptanceTimeoutSeconds", 1))
	}
	if s.Description != nil && len(*s.Description) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Description", 1))
	}
	if s.GameSessionData != nil && len(*s.GameSessionData) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GameSessionData", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if s.RequestTimeoutSeconds != nil && *s.RequestTimeoutSeconds < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("RequestTimeoutSeconds", 1))
	}
	if s.RuleSetName != nil && len(*s.RuleSetName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleSetName", 1))
	}
	if s.GameProperties != nil {
		for i, v := range s.GameProperties {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "GameProperties", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateMatchmakingConfigurationOutput
type UpdateMatchmakingConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Object that describes the updated matchmaking configuration.
	Configuration *MatchmakingConfiguration `type:"structure"`
}

// String returns the string representation
func (s UpdateMatchmakingConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateMatchmakingConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateMatchmakingConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateRuntimeConfigurationInput
type UpdateRuntimeConfigurationInput struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet to update run-time configuration for.
	//
	// FleetId is a required field
	FleetId *string `type:"string" required:"true"`

	// Instructions for launching server processes on each instance in the fleet.
	// The run-time configuration for a fleet has a collection of server process
	// configurations, one for each type of server process to run on an instance.
	// A server process configuration specifies the location of the server executable,
	// launch parameters, and the number of concurrent processes with that configuration
	// to maintain on each instance.
	//
	// RuntimeConfiguration is a required field
	RuntimeConfiguration *RuntimeConfiguration `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateRuntimeConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRuntimeConfigurationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateRuntimeConfigurationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateRuntimeConfigurationInput"}

	if s.FleetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("FleetId"))
	}

	if s.RuntimeConfiguration == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuntimeConfiguration"))
	}
	if s.RuntimeConfiguration != nil {
		if err := s.RuntimeConfiguration.Validate(); err != nil {
			invalidParams.AddNested("RuntimeConfiguration", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/UpdateRuntimeConfigurationOutput
type UpdateRuntimeConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The run-time configuration currently in force. If the update was successful,
	// this object matches the one in the request.
	RuntimeConfiguration *RuntimeConfiguration `type:"structure"`
}

// String returns the string representation
func (s UpdateRuntimeConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRuntimeConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateRuntimeConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input for a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ValidateMatchmakingRuleSetInput
type ValidateMatchmakingRuleSetInput struct {
	_ struct{} `type:"structure"`

	// Collection of matchmaking rules to validate, formatted as a JSON string.
	//
	// RuleSetBody is a required field
	RuleSetBody *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ValidateMatchmakingRuleSetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ValidateMatchmakingRuleSetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ValidateMatchmakingRuleSetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ValidateMatchmakingRuleSetInput"}

	if s.RuleSetBody == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleSetBody"))
	}
	if s.RuleSetBody != nil && len(*s.RuleSetBody) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleSetBody", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the returned data in response to a request action.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/ValidateMatchmakingRuleSetOutput
type ValidateMatchmakingRuleSetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Response indicating whether or not the rule set is valid.
	Valid *bool `type:"boolean"`
}

// String returns the string representation
func (s ValidateMatchmakingRuleSetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ValidateMatchmakingRuleSetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ValidateMatchmakingRuleSetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents an authorization for a VPC peering connection between the VPC
// for an Amazon GameLift fleet and another VPC on an account you have access
// to. This authorization must exist and be valid for the peering connection
// to be established. Authorizations are valid for 24 hours after they are issued.
//
// VPC peering connection operations include:
//
//    * CreateVpcPeeringAuthorization
//
//    * DescribeVpcPeeringAuthorizations
//
//    * DeleteVpcPeeringAuthorization
//
//    * CreateVpcPeeringConnection
//
//    * DescribeVpcPeeringConnections
//
//    * DeleteVpcPeeringConnection
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/VpcPeeringAuthorization
type VpcPeeringAuthorization struct {
	_ struct{} `type:"structure"`

	// Time stamp indicating when this authorization was issued. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Time stamp indicating when this authorization expires (24 hours after issuance).
	// Format is a number expressed in Unix time as milliseconds (for example "1469498468.057").
	ExpirationTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Unique identifier for the AWS account that you use to manage your Amazon
	// GameLift fleet. You can find your Account ID in the AWS Management Console
	// under account settings.
	GameLiftAwsAccountId *string `min:"1" type:"string"`

	PeerVpcAwsAccountId *string `min:"1" type:"string"`

	// Unique identifier for a VPC with resources to be accessed by your Amazon
	// GameLift fleet. The VPC must be in the same region where your fleet is deployed.
	// To get VPC information, including IDs, use the Virtual Private Cloud service
	// tools, including the VPC Dashboard in the AWS Management Console.
	PeerVpcId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s VpcPeeringAuthorization) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VpcPeeringAuthorization) GoString() string {
	return s.String()
}

// Represents a peering connection between a VPC on one of your AWS accounts
// and the VPC for your Amazon GameLift fleets. This record may be for an active
// peering connection or a pending connection that has not yet been established.
//
// VPC peering connection operations include:
//
//    * CreateVpcPeeringAuthorization
//
//    * DescribeVpcPeeringAuthorizations
//
//    * DeleteVpcPeeringAuthorization
//
//    * CreateVpcPeeringConnection
//
//    * DescribeVpcPeeringConnections
//
//    * DeleteVpcPeeringConnection
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/VpcPeeringConnection
type VpcPeeringConnection struct {
	_ struct{} `type:"structure"`

	// Unique identifier for a fleet. This ID determines the ID of the Amazon GameLift
	// VPC for your fleet.
	FleetId *string `type:"string"`

	// Unique identifier for the VPC that contains the Amazon GameLift fleet for
	// this connection. This VPC is managed by Amazon GameLift and does not appear
	// in your AWS account.
	GameLiftVpcId *string `min:"1" type:"string"`

	// CIDR block of IPv4 addresses assigned to the VPC peering connection for the
	// GameLift VPC. The peered VPC also has an IPv4 CIDR block associated with
	// it; these blocks cannot overlap or the peering connection cannot be created.
	IpV4CidrBlock *string `min:"1" type:"string"`

	// Unique identifier for a VPC with resources to be accessed by your Amazon
	// GameLift fleet. The VPC must be in the same region where your fleet is deployed.
	// To get VPC information, including IDs, use the Virtual Private Cloud service
	// tools, including the VPC Dashboard in the AWS Management Console.
	PeerVpcId *string `min:"1" type:"string"`

	// Object that contains status information about the connection. Status indicates
	// if a connection is pending, successful, or failed.
	Status *VpcPeeringConnectionStatus `type:"structure"`

	// Unique identifier that is automatically assigned to the connection record.
	// This ID is referenced in VPC peering connection events, and is used when
	// deleting a connection with DeleteVpcPeeringConnection.
	VpcPeeringConnectionId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s VpcPeeringConnection) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VpcPeeringConnection) GoString() string {
	return s.String()
}

// Represents status information for a VPC peering connection. Status is associated
// with a VpcPeeringConnection object. Status codes and messages are provided
// from EC2 (see VpcPeeringConnectionStateReason (http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpcPeeringConnectionStateReason.html)).
// Connection status information is also communicated as a fleet Event.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/gamelift-2015-10-01/VpcPeeringConnectionStatus
type VpcPeeringConnectionStatus struct {
	_ struct{} `type:"structure"`

	// Code indicating the status of a VPC peering connection.
	Code *string `min:"1" type:"string"`

	// Additional messaging associated with the connection status.
	Message *string `min:"1" type:"string"`
}

// String returns the string representation
func (s VpcPeeringConnectionStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VpcPeeringConnectionStatus) GoString() string {
	return s.String()
}

type AcceptanceType string

// Enum values for AcceptanceType
const (
	AcceptanceTypeAccept AcceptanceType = "ACCEPT"
	AcceptanceTypeReject AcceptanceType = "REJECT"
)

func (enum AcceptanceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AcceptanceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type BuildStatus string

// Enum values for BuildStatus
const (
	BuildStatusInitialized BuildStatus = "INITIALIZED"
	BuildStatusReady       BuildStatus = "READY"
	BuildStatusFailed      BuildStatus = "FAILED"
)

func (enum BuildStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BuildStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ComparisonOperatorType string

// Enum values for ComparisonOperatorType
const (
	ComparisonOperatorTypeGreaterThanOrEqualToThreshold ComparisonOperatorType = "GreaterThanOrEqualToThreshold"
	ComparisonOperatorTypeGreaterThanThreshold          ComparisonOperatorType = "GreaterThanThreshold"
	ComparisonOperatorTypeLessThanThreshold             ComparisonOperatorType = "LessThanThreshold"
	ComparisonOperatorTypeLessThanOrEqualToThreshold    ComparisonOperatorType = "LessThanOrEqualToThreshold"
)

func (enum ComparisonOperatorType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ComparisonOperatorType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type EC2InstanceType string

// Enum values for EC2InstanceType
const (
	EC2InstanceTypeT2Micro    EC2InstanceType = "t2.micro"
	EC2InstanceTypeT2Small    EC2InstanceType = "t2.small"
	EC2InstanceTypeT2Medium   EC2InstanceType = "t2.medium"
	EC2InstanceTypeT2Large    EC2InstanceType = "t2.large"
	EC2InstanceTypeC3Large    EC2InstanceType = "c3.large"
	EC2InstanceTypeC3Xlarge   EC2InstanceType = "c3.xlarge"
	EC2InstanceTypeC32xlarge  EC2InstanceType = "c3.2xlarge"
	EC2InstanceTypeC34xlarge  EC2InstanceType = "c3.4xlarge"
	EC2InstanceTypeC38xlarge  EC2InstanceType = "c3.8xlarge"
	EC2InstanceTypeC4Large    EC2InstanceType = "c4.large"
	EC2InstanceTypeC4Xlarge   EC2InstanceType = "c4.xlarge"
	EC2InstanceTypeC42xlarge  EC2InstanceType = "c4.2xlarge"
	EC2InstanceTypeC44xlarge  EC2InstanceType = "c4.4xlarge"
	EC2InstanceTypeC48xlarge  EC2InstanceType = "c4.8xlarge"
	EC2InstanceTypeR3Large    EC2InstanceType = "r3.large"
	EC2InstanceTypeR3Xlarge   EC2InstanceType = "r3.xlarge"
	EC2InstanceTypeR32xlarge  EC2InstanceType = "r3.2xlarge"
	EC2InstanceTypeR34xlarge  EC2InstanceType = "r3.4xlarge"
	EC2InstanceTypeR38xlarge  EC2InstanceType = "r3.8xlarge"
	EC2InstanceTypeR4Large    EC2InstanceType = "r4.large"
	EC2InstanceTypeR4Xlarge   EC2InstanceType = "r4.xlarge"
	EC2InstanceTypeR42xlarge  EC2InstanceType = "r4.2xlarge"
	EC2InstanceTypeR44xlarge  EC2InstanceType = "r4.4xlarge"
	EC2InstanceTypeR48xlarge  EC2InstanceType = "r4.8xlarge"
	EC2InstanceTypeR416xlarge EC2InstanceType = "r4.16xlarge"
	EC2InstanceTypeM3Medium   EC2InstanceType = "m3.medium"
	EC2InstanceTypeM3Large    EC2InstanceType = "m3.large"
	EC2InstanceTypeM3Xlarge   EC2InstanceType = "m3.xlarge"
	EC2InstanceTypeM32xlarge  EC2InstanceType = "m3.2xlarge"
	EC2InstanceTypeM4Large    EC2InstanceType = "m4.large"
	EC2InstanceTypeM4Xlarge   EC2InstanceType = "m4.xlarge"
	EC2InstanceTypeM42xlarge  EC2InstanceType = "m4.2xlarge"
	EC2InstanceTypeM44xlarge  EC2InstanceType = "m4.4xlarge"
	EC2InstanceTypeM410xlarge EC2InstanceType = "m4.10xlarge"
)

func (enum EC2InstanceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EC2InstanceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type EventCode string

// Enum values for EventCode
const (
	EventCodeGenericEvent                               EventCode = "GENERIC_EVENT"
	EventCodeFleetCreated                               EventCode = "FLEET_CREATED"
	EventCodeFleetDeleted                               EventCode = "FLEET_DELETED"
	EventCodeFleetScalingEvent                          EventCode = "FLEET_SCALING_EVENT"
	EventCodeFleetStateDownloading                      EventCode = "FLEET_STATE_DOWNLOADING"
	EventCodeFleetStateValidating                       EventCode = "FLEET_STATE_VALIDATING"
	EventCodeFleetStateBuilding                         EventCode = "FLEET_STATE_BUILDING"
	EventCodeFleetStateActivating                       EventCode = "FLEET_STATE_ACTIVATING"
	EventCodeFleetStateActive                           EventCode = "FLEET_STATE_ACTIVE"
	EventCodeFleetStateError                            EventCode = "FLEET_STATE_ERROR"
	EventCodeFleetInitializationFailed                  EventCode = "FLEET_INITIALIZATION_FAILED"
	EventCodeFleetBinaryDownloadFailed                  EventCode = "FLEET_BINARY_DOWNLOAD_FAILED"
	EventCodeFleetValidationLaunchPathNotFound          EventCode = "FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND"
	EventCodeFleetValidationExecutableRuntimeFailure    EventCode = "FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE"
	EventCodeFleetValidationTimedOut                    EventCode = "FLEET_VALIDATION_TIMED_OUT"
	EventCodeFleetActivationFailed                      EventCode = "FLEET_ACTIVATION_FAILED"
	EventCodeFleetActivationFailedNoInstances           EventCode = "FLEET_ACTIVATION_FAILED_NO_INSTANCES"
	EventCodeFleetNewGameSessionProtectionPolicyUpdated EventCode = "FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED"
	EventCodeServerProcessInvalidPath                   EventCode = "SERVER_PROCESS_INVALID_PATH"
	EventCodeServerProcessSdkInitializationTimeout      EventCode = "SERVER_PROCESS_SDK_INITIALIZATION_TIMEOUT"
	EventCodeServerProcessProcessReadyTimeout           EventCode = "SERVER_PROCESS_PROCESS_READY_TIMEOUT"
	EventCodeServerProcessCrashed                       EventCode = "SERVER_PROCESS_CRASHED"
	EventCodeServerProcessTerminatedUnhealthy           EventCode = "SERVER_PROCESS_TERMINATED_UNHEALTHY"
	EventCodeServerProcessForceTerminated               EventCode = "SERVER_PROCESS_FORCE_TERMINATED"
	EventCodeServerProcessProcessExitTimeout            EventCode = "SERVER_PROCESS_PROCESS_EXIT_TIMEOUT"
	EventCodeGameSessionActivationTimeout               EventCode = "GAME_SESSION_ACTIVATION_TIMEOUT"
	EventCodeFleetCreationExtractingBuild               EventCode = "FLEET_CREATION_EXTRACTING_BUILD"
	EventCodeFleetCreationRunningInstaller              EventCode = "FLEET_CREATION_RUNNING_INSTALLER"
	EventCodeFleetCreationValidatingRuntimeConfig       EventCode = "FLEET_CREATION_VALIDATING_RUNTIME_CONFIG"
	EventCodeFleetVpcPeeringSucceeded                   EventCode = "FLEET_VPC_PEERING_SUCCEEDED"
	EventCodeFleetVpcPeeringFailed                      EventCode = "FLEET_VPC_PEERING_FAILED"
	EventCodeFleetVpcPeeringDeleted                     EventCode = "FLEET_VPC_PEERING_DELETED"
	EventCodeInstanceInterrupted                        EventCode = "INSTANCE_INTERRUPTED"
)

func (enum EventCode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EventCode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type FleetAction string

// Enum values for FleetAction
const (
	FleetActionAutoScaling FleetAction = "AUTO_SCALING"
)

func (enum FleetAction) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum FleetAction) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type FleetStatus string

// Enum values for FleetStatus
const (
	FleetStatusNew         FleetStatus = "NEW"
	FleetStatusDownloading FleetStatus = "DOWNLOADING"
	FleetStatusValidating  FleetStatus = "VALIDATING"
	FleetStatusBuilding    FleetStatus = "BUILDING"
	FleetStatusActivating  FleetStatus = "ACTIVATING"
	FleetStatusActive      FleetStatus = "ACTIVE"
	FleetStatusDeleting    FleetStatus = "DELETING"
	FleetStatusError       FleetStatus = "ERROR"
	FleetStatusTerminated  FleetStatus = "TERMINATED"
)

func (enum FleetStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum FleetStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type FleetType string

// Enum values for FleetType
const (
	FleetTypeOnDemand FleetType = "ON_DEMAND"
	FleetTypeSpot     FleetType = "SPOT"
)

func (enum FleetType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum FleetType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type GameSessionPlacementState string

// Enum values for GameSessionPlacementState
const (
	GameSessionPlacementStatePending   GameSessionPlacementState = "PENDING"
	GameSessionPlacementStateFulfilled GameSessionPlacementState = "FULFILLED"
	GameSessionPlacementStateCancelled GameSessionPlacementState = "CANCELLED"
	GameSessionPlacementStateTimedOut  GameSessionPlacementState = "TIMED_OUT"
)

func (enum GameSessionPlacementState) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum GameSessionPlacementState) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type GameSessionStatus string

// Enum values for GameSessionStatus
const (
	GameSessionStatusActive      GameSessionStatus = "ACTIVE"
	GameSessionStatusActivating  GameSessionStatus = "ACTIVATING"
	GameSessionStatusTerminated  GameSessionStatus = "TERMINATED"
	GameSessionStatusTerminating GameSessionStatus = "TERMINATING"
	GameSessionStatusError       GameSessionStatus = "ERROR"
)

func (enum GameSessionStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum GameSessionStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type GameSessionStatusReason string

// Enum values for GameSessionStatusReason
const (
	GameSessionStatusReasonInterrupted GameSessionStatusReason = "INTERRUPTED"
)

func (enum GameSessionStatusReason) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum GameSessionStatusReason) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type InstanceStatus string

// Enum values for InstanceStatus
const (
	InstanceStatusPending     InstanceStatus = "PENDING"
	InstanceStatusActive      InstanceStatus = "ACTIVE"
	InstanceStatusTerminating InstanceStatus = "TERMINATING"
)

func (enum InstanceStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum InstanceStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type IpProtocol string

// Enum values for IpProtocol
const (
	IpProtocolTcp IpProtocol = "TCP"
	IpProtocolUdp IpProtocol = "UDP"
)

func (enum IpProtocol) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum IpProtocol) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type MatchmakingConfigurationStatus string

// Enum values for MatchmakingConfigurationStatus
const (
	MatchmakingConfigurationStatusCancelled          MatchmakingConfigurationStatus = "CANCELLED"
	MatchmakingConfigurationStatusCompleted          MatchmakingConfigurationStatus = "COMPLETED"
	MatchmakingConfigurationStatusFailed             MatchmakingConfigurationStatus = "FAILED"
	MatchmakingConfigurationStatusPlacing            MatchmakingConfigurationStatus = "PLACING"
	MatchmakingConfigurationStatusQueued             MatchmakingConfigurationStatus = "QUEUED"
	MatchmakingConfigurationStatusRequiresAcceptance MatchmakingConfigurationStatus = "REQUIRES_ACCEPTANCE"
	MatchmakingConfigurationStatusSearching          MatchmakingConfigurationStatus = "SEARCHING"
	MatchmakingConfigurationStatusTimedOut           MatchmakingConfigurationStatus = "TIMED_OUT"
)

func (enum MatchmakingConfigurationStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum MatchmakingConfigurationStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type MetricName string

// Enum values for MetricName
const (
	MetricNameActivatingGameSessions       MetricName = "ActivatingGameSessions"
	MetricNameActiveGameSessions           MetricName = "ActiveGameSessions"
	MetricNameActiveInstances              MetricName = "ActiveInstances"
	MetricNameAvailableGameSessions        MetricName = "AvailableGameSessions"
	MetricNameAvailablePlayerSessions      MetricName = "AvailablePlayerSessions"
	MetricNameCurrentPlayerSessions        MetricName = "CurrentPlayerSessions"
	MetricNameIdleInstances                MetricName = "IdleInstances"
	MetricNamePercentAvailableGameSessions MetricName = "PercentAvailableGameSessions"
	MetricNamePercentIdleInstances         MetricName = "PercentIdleInstances"
	MetricNameQueueDepth                   MetricName = "QueueDepth"
	MetricNameWaitTime                     MetricName = "WaitTime"
)

func (enum MetricName) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum MetricName) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type OperatingSystem string

// Enum values for OperatingSystem
const (
	OperatingSystemWindows2012 OperatingSystem = "WINDOWS_2012"
	OperatingSystemAmazonLinux OperatingSystem = "AMAZON_LINUX"
)

func (enum OperatingSystem) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum OperatingSystem) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type PlayerSessionCreationPolicy string

// Enum values for PlayerSessionCreationPolicy
const (
	PlayerSessionCreationPolicyAcceptAll PlayerSessionCreationPolicy = "ACCEPT_ALL"
	PlayerSessionCreationPolicyDenyAll   PlayerSessionCreationPolicy = "DENY_ALL"
)

func (enum PlayerSessionCreationPolicy) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum PlayerSessionCreationPolicy) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type PlayerSessionStatus string

// Enum values for PlayerSessionStatus
const (
	PlayerSessionStatusReserved  PlayerSessionStatus = "RESERVED"
	PlayerSessionStatusActive    PlayerSessionStatus = "ACTIVE"
	PlayerSessionStatusCompleted PlayerSessionStatus = "COMPLETED"
	PlayerSessionStatusTimedout  PlayerSessionStatus = "TIMEDOUT"
)

func (enum PlayerSessionStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum PlayerSessionStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type PolicyType string

// Enum values for PolicyType
const (
	PolicyTypeRuleBased   PolicyType = "RuleBased"
	PolicyTypeTargetBased PolicyType = "TargetBased"
)

func (enum PolicyType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum PolicyType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ProtectionPolicy string

// Enum values for ProtectionPolicy
const (
	ProtectionPolicyNoProtection   ProtectionPolicy = "NoProtection"
	ProtectionPolicyFullProtection ProtectionPolicy = "FullProtection"
)

func (enum ProtectionPolicy) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ProtectionPolicy) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RoutingStrategyType string

// Enum values for RoutingStrategyType
const (
	RoutingStrategyTypeSimple   RoutingStrategyType = "SIMPLE"
	RoutingStrategyTypeTerminal RoutingStrategyType = "TERMINAL"
)

func (enum RoutingStrategyType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RoutingStrategyType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ScalingAdjustmentType string

// Enum values for ScalingAdjustmentType
const (
	ScalingAdjustmentTypeChangeInCapacity        ScalingAdjustmentType = "ChangeInCapacity"
	ScalingAdjustmentTypeExactCapacity           ScalingAdjustmentType = "ExactCapacity"
	ScalingAdjustmentTypePercentChangeInCapacity ScalingAdjustmentType = "PercentChangeInCapacity"
)

func (enum ScalingAdjustmentType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ScalingAdjustmentType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ScalingStatusType string

// Enum values for ScalingStatusType
const (
	ScalingStatusTypeActive          ScalingStatusType = "ACTIVE"
	ScalingStatusTypeUpdateRequested ScalingStatusType = "UPDATE_REQUESTED"
	ScalingStatusTypeUpdating        ScalingStatusType = "UPDATING"
	ScalingStatusTypeDeleteRequested ScalingStatusType = "DELETE_REQUESTED"
	ScalingStatusTypeDeleting        ScalingStatusType = "DELETING"
	ScalingStatusTypeDeleted         ScalingStatusType = "DELETED"
	ScalingStatusTypeError           ScalingStatusType = "ERROR"
)

func (enum ScalingStatusType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ScalingStatusType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
