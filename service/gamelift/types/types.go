// Code generated by smithy-go-codegen DO NOT EDIT.

package types

import (
	"time"
)

// Properties that describe an alias resource.
//
//     * CreateAlias ()
//
//     *
// ListAliases ()
//
//     * DescribeAlias ()
//
//     * UpdateAlias ()
//
//     * DeleteAlias
// ()
//
//     * ResolveAlias ()
type Alias struct {
	// The routing configuration, including routing type and fleet target, for the
	// alias.
	RoutingStrategy *RoutingStrategy
	// The time that this data object was last modified. Format is a number expressed
	// in Unix time as milliseconds (for example "1469498468.057").
	LastUpdatedTime *time.Time
	// A unique identifier for an alias. Alias IDs are unique within a Region.
	AliasId *string
	// A descriptive label that is associated with an alias. Alias names do not need to
	// be unique.
	Name *string
	// A time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
	// A human-readable description of an alias.
	Description *string
	// Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a GameLift alias resource and uniquely identifies it. ARNs
	// are unique across all Regions. In a GameLift alias ARN, the resource ID matches
	// the alias ID value.
	AliasArn *string
}

// Values for use in Player () attribute key-value pairs. This object lets you
// specify an attribute value using any of the valid data types: string, number,
// string array, or data map. Each AttributeValue object can use only one of the
// available properties.
type AttributeValue struct {
	// For a list of up to 10 strings. Maximum length for each string is 100
	// characters. Duplicate values are not recognized; all occurrences of the repeated
	// value after the first of a repeated value are ignored.
	SL []*string
	// For a map of up to 10 data type:value pairs. Maximum length for each string
	// value is 100 characters.
	SDM map[string]*float64
	// For single string values. Maximum string length is 100 characters.
	S *string
	// For number values, expressed as double.
	N *float64
}

// Temporary access credentials used for uploading game build files to Amazon
// GameLift. They are valid for a limited time. If they expire before you upload
// your game build, get a new set by calling RequestUploadCredentials ().
type AwsCredentials struct {
	// Temporary key allowing access to the Amazon GameLift S3 account.
	AccessKeyId *string
	// Token used to associate a specific build ID with the files uploaded using these
	// credentials.
	SessionToken *string
	// Temporary secret key allowing access to the Amazon GameLift S3 account.
	SecretAccessKey *string
}

// Properties describing a custom game build. Related operations
//
//     * CreateBuild
// ()
//
//     * ListBuilds ()
//
//     * DescribeBuild ()
//
//     * UpdateBuild ()
//
//     *
// DeleteBuild ()
type Build struct {
	// A unique identifier for a build.
	BuildId *string
	// Current status of the build. Possible build statuses include the following:
	//
	//
	// * INITIALIZED -- A new build has been defined, but no files have been uploaded.
	// You cannot create fleets for builds that are in this status. When a build is
	// successfully created, the build status is set to this value.
	//
	//     * READY -- The
	// game build has been successfully uploaded. You can now create new fleets for
	// this build.
	//
	//     * FAILED -- The game build upload failed. You cannot create new
	// fleets for this build.
	Status BuildStatus
	// Version information that is associated with a build or script. Version strings
	// do not need to be unique. This value can be set using CreateBuild () or
	// UpdateBuild ().
	Version *string
	// A descriptive label that is associated with a build. Build names do not need to
	// be unique. It can be set using CreateBuild () or UpdateBuild ().
	Name *string
	// Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a GameLift build resource and uniquely identifies it. ARNs
	// are unique across all Regions. In a GameLift build ARN, the resource ID matches
	// the BuildId value.
	BuildArn *string
	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
	// File size of the uploaded game build, expressed in bytes. When the build status
	// is INITIALIZED, this value is 0.
	SizeOnDisk *int64
	// Operating system that the game server binaries are built to run on. This value
	// determines the type of fleet resources that you can use for this build.
	OperatingSystem OperatingSystem
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate
// generation is enabled at the fleet level, with one certificate generated for the
// fleet. When this feature is enabled, the certificate can be retrieved using the
// GameLift Server SDK
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk.html)
// call GetInstanceCertificate. All instances in a fleet share the same
// certificate.
type CertificateConfiguration struct {
	// Indicates whether a TLS/SSL certificate was generated for a fleet.
	CertificateType CertificateType
}

// Player information for use when creating player sessions using a game session
// placement request with StartGameSessionPlacement ().
type DesiredPlayerSession struct {
	// Developer-defined information related to a player. Amazon GameLift does not use
	// this data, so it can be formatted as needed for use in the game.
	PlayerData *string
	// A unique identifier for a player to associate with the player session.
	PlayerId *string
}

// Current status of fleet capacity. The number of active instances should match or
// be in the process of matching the number of desired instances. Pending and
// terminating counts are non-zero only if fleet capacity is adjusting to an
// UpdateFleetCapacity () request, or if access to resources is temporarily
// affected.
//
//     * CreateFleet ()
//
//     * ListFleets ()
//
//     * DeleteFleet ()
//
//
// * DescribeFleetAttributes ()
//
//     * UpdateFleetAttributes ()
//
//     *
// StartFleetActions () or StopFleetActions ()
type EC2InstanceCounts struct {
	// Number of instances in the fleet that are no longer active but haven't yet been
	// terminated.
	TERMINATING *int32
	// Actual number of active instances in the fleet.
	ACTIVE *int32
	// Number of active instances in the fleet that are not currently hosting a game
	// session.
	IDLE *int32
	// The maximum value allowed for the fleet's instance count.
	MAXIMUM *int32
	// Number of instances in the fleet that are starting but not yet active.
	PENDING *int32
	// Ideal number of active instances in the fleet.
	DESIRED *int32
	// The minimum value allowed for the fleet's instance count.
	MINIMUM *int32
}

// The maximum number of instances allowed based on the Amazon Elastic Compute
// Cloud (Amazon EC2) instance type. Instance limits can be retrieved by calling
// DescribeEC2InstanceLimits ().
type EC2InstanceLimit struct {
	// Number of instances of the specified type that are currently in use by this AWS
	// account.
	CurrentInstances *int32
	// Name of an EC2 instance type that is supported in Amazon GameLift. A fleet
	// instance type determines the computing resources of each instance in the fleet,
	// including CPU, memory, storage, and networking capacity. Amazon GameLift
	// supports the following EC2 instance types. See Amazon EC2 Instance Types
	// (http://aws.amazon.com/ec2/instance-types/) for detailed descriptions.
	EC2InstanceType EC2InstanceType
	// Number of instances allowed.
	InstanceLimit *int32
}

// Log entry describing an event that involves Amazon GameLift resources (such as a
// fleet). In addition to tracking activity, event codes and messages can provide
// additional information for troubleshooting and debugging problems.
type Event struct {
	// A unique identifier for a fleet event.
	EventId *string
	// Location of stored logs with additional detail that is related to the event.
	// This is useful for debugging issues. The URL is valid for 15 minutes. You can
	// also access fleet creation logs through the Amazon GameLift console.
	PreSignedLogUrl *string
	// A unique identifier for an event resource, such as a fleet ID.
	ResourceId *string
	// Additional information related to the event.
	Message *string
	// Time stamp indicating when this event occurred. Format is a number expressed in
	// Unix time as milliseconds (for example "1469498468.057").
	EventTime *time.Time
	// The type of event being logged. Fleet creation events (ordered by fleet creation
	// activity):
	//
	//     * FLEET_CREATED -- A fleet resource was successfully created
	// with a status of NEW. Event messaging includes the fleet ID.
	//
	//     *
	// FLEET_STATE_DOWNLOADING -- Fleet status changed from NEW to DOWNLOADING. The
	// compressed build has started downloading to a fleet instance for installation.
	//
	//
	// * FLEET_BINARY_DOWNLOAD_FAILED -- The build failed to download to the fleet
	// instance.
	//
	//     * FLEET_CREATION_EXTRACTING_BUILD – The game server build was
	// successfully downloaded to an instance, and the build files are now being
	// extracted from the uploaded build and saved to an instance. Failure at this
	// stage prevents a fleet from moving to ACTIVE status. Logs for this stage display
	// a list of the files that are extracted and saved on the instance. Access the
	// logs by using the URL in PreSignedLogUrl.
	//
	//     *
	// FLEET_CREATION_RUNNING_INSTALLER – The game server build files were successfully
	// extracted, and the Amazon GameLift is now running the build's install script (if
	// one is included). Failure in this stage prevents a fleet from moving to ACTIVE
	// status. Logs for this stage list the installation steps and whether or not the
	// install completed successfully. Access the logs by using the URL in
	// PreSignedLogUrl.
	//
	//     * FLEET_CREATION_VALIDATING_RUNTIME_CONFIG -- The build
	// process was successful, and the Amazon GameLift is now verifying that the game
	// server launch paths, which are specified in the fleet's runtime configuration,
	// exist. If any listed launch path exists, Amazon GameLift tries to launch a game
	// server process and waits for the process to report ready. Failures in this stage
	// prevent a fleet from moving to ACTIVE status. Logs for this stage list the
	// launch paths in the runtime configuration and indicate whether each is found.
	// Access the logs by using the URL in PreSignedLogUrl.  </p> </li> <li>
	// <p>FLEET_STATE_VALIDATING -- Fleet status changed from <code>DOWNLOADING</code>
	// to <code>VALIDATING</code>.</p> </li> <li> <p>
	// FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND -- Validation of the runtime
	// configuration failed because the executable specified in a launch path does not
	// exist on the instance.</p> </li> <li> <p>FLEET_STATE_BUILDING -- Fleet status
	// changed from <code>VALIDATING</code> to <code>BUILDING</code>.</p> </li> <li>
	// <p>FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE -- Validation of the runtime
	// configuration failed because the executable specified in a launch path failed to
	// run on the fleet instance.</p> </li> <li> <p>FLEET_STATE_ACTIVATING -- Fleet
	// status changed from <code>BUILDING</code> to <code>ACTIVATING</code>. </p> </li>
	// <li> <p> FLEET_ACTIVATION_FAILED - The fleet failed to successfully complete one
	// of the steps in the fleet activation process. This event code indicates that the
	// game build was successfully downloaded to a fleet instance, built, and
	// validated, but was not able to start a server process. Learn more at <a
	// href="https://docs.aws.amazon.com/gamelift/latest/developerguide/fleets-creating-debug.html#fleets-creating-debug-creation">
	// Debug Fleet Creation Issues</a> </p> </li> <li> <p>FLEET_STATE_ACTIVE -- The
	// fleet's status changed from <code>ACTIVATING</code> to <code>ACTIVE</code>. The
	// fleet is now ready to host game sessions.</p> </li> </ul> <p> <b>VPC peering
	// events:</b> </p> <ul> <li> <p>FLEET_VPC_PEERING_SUCCEEDED -- A VPC peering
	// connection has been established between the VPC for an Amazon GameLift fleet and
	// a VPC in your AWS account.</p> </li> <li> <p>FLEET_VPC_PEERING_FAILED -- A
	// requested VPC peering connection has failed. Event details and status
	// information (see <a>DescribeVpcPeeringConnections</a>) provide additional
	// detail. A common reason for peering failure is that the two VPCs have
	// overlapping CIDR blocks of IPv4 addresses. To resolve this, change the CIDR
	// block for the VPC in your AWS account. For more information on VPC peering
	// failures, see <a
	// href="https://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide/invalid-peering-configurations.html">https://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide/invalid-peering-configurations.html</a>
	// </p> </li> <li> <p>FLEET_VPC_PEERING_DELETED -- A VPC peering connection has
	// been successfully deleted.</p> </li> </ul> <p> <b>Spot instance events:</b> </p>
	// <ul> <li> <p> INSTANCE_INTERRUPTED -- A spot instance was interrupted by EC2
	// with a two-minute notification.</p> </li> </ul> <p> <b>Other fleet events:</b>
	// </p> <ul> <li> <p>FLEET_SCALING_EVENT -- A change was made to the fleet's
	// capacity settings (desired instances, minimum/maximum scaling limits). Event
	// messaging includes the new capacity settings.</p> </li> <li>
	// <p>FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED -- A change was made to the
	// fleet's game session protection policy setting. Event messaging includes both
	// the old and new policy setting. </p> </li> <li> <p>FLEET_DELETED -- A request to
	// delete a fleet was initiated.</p> </li> <li> <p> GENERIC_EVENT -- An unspecified
	// event has occurred.</p> </li> </ul>
	EventCode EventCode
}

// General properties describing a fleet.
//
//     * CreateFleet ()
//
//     * ListFleets
// ()
//
//     * DeleteFleet ()
//
//     * DescribeFleetAttributes ()
//
//     *
// UpdateFleetAttributes ()
//
//     * StartFleetActions () or StopFleetActions ()
type FleetAttributes struct {
	// List of fleet actions that have been suspended using StopFleetActions (). This
	// includes auto-scaling.
	StoppedActions []FleetAction
	// Current status of the fleet. Possible fleet statuses include the following:
	//
	//
	// * NEW -- A new fleet has been defined and desired instances is set to 1.
	//
	//     *
	// DOWNLOADING/VALIDATING/BUILDING/ACTIVATING -- Amazon GameLift is setting up the
	// new fleet, creating new instances with the game build or Realtime script and
	// starting server processes.
	//
	//     * ACTIVE -- Hosts can now accept game
	// sessions.
	//
	//     * ERROR -- An error occurred when downloading, validating,
	// building, or activating the fleet.
	//
	//     * DELETING -- Hosts are responding to a
	// delete fleet request.
	//
	//     * TERMINATED -- The fleet no longer exists.
	Status FleetStatus
	// Human-readable description of the fleet.
	Description *string
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// associated with the GameLift script resource that is deployed on instances in
	// this fleet. In a GameLift script ARN, the resource ID matches the ScriptId
	// value.
	ScriptArn *string
	// Indicates whether the fleet uses on-demand or spot instances. A spot instance in
	// use may be interrupted with a two-minute notification.
	FleetType FleetType
	// The type of game session protection to set for all new instances started in the
	// fleet.
	//
	//     * NoProtection -- The game session can be terminated during a
	// scale-down event.
	//
	//     * FullProtection -- If the game session is in an ACTIVE
	// status, it cannot be terminated during a scale-down event.
	NewGameSessionProtectionPolicy ProtectionPolicy
	// Fleet policy to limit the number of game sessions an individual player can
	// create over a span of time.
	ResourceCreationLimitPolicy *ResourceCreationLimitPolicy
	// A unique identifier for a Realtime script.
	ScriptId *string
	// Location of default log files. When a server process is shut down, Amazon
	// GameLift captures and stores any log files in this location. These logs are in
	// addition to game session logs; see more on game session logs in the Amazon
	// GameLift Developer Guide
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-api-server-code).
	// If no default log path for a fleet is specified, Amazon GameLift automatically
	// uploads logs that are stored on each instance at C:\game\logs (for Windows) or
	// /local/game/logs (for Linux). Use the Amazon GameLift console to access stored
	// logs.
	LogPaths []*string
	// Time stamp indicating when this data object was terminated. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	TerminationTime *time.Time
	// Path to a game server executable in the fleet's build, specified for fleets
	// created before 2016-08-04 (or AWS SDK v. 0.12.16). Server launch paths for
	// fleets created after this date are specified in the fleet's RuntimeConfiguration
	// ().
	ServerLaunchPath *string
	// A descriptive label that is associated with a fleet. Fleet names do not need to
	// be unique.
	Name *string
	// Names of metric groups that this fleet is included in. In Amazon CloudWatch, you
	// can view metrics for an individual fleet or aggregated metrics for fleets that
	// are in a fleet metric group. A fleet can be included in only one metric group at
	// a time.
	MetricGroups []*string
	// A unique identifier for a build.
	BuildId *string
	// A unique identifier for a fleet.
	FleetId *string
	// A unique identifier for an AWS IAM role that manages access to your AWS
	// services. With an instance role ARN set, any application that runs on an
	// instance in this fleet can assume the role, including install scripts, server
	// processes, and daemons (background processes). Create a role or look up a role's
	// ARN from the IAM dashboard (https://console.aws.amazon.com/iam/) in the AWS
	// Management Console. Learn more about using on-box credentials for your game
	// servers at  Access external resources from a game server
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-resources.html).
	InstanceRoleArn *string
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// associated with the GameLift build resource that is deployed on instances in
	// this fleet. In a GameLift build ARN, the resource ID matches the BuildId value.
	BuildArn *string
	// Indicates whether a TLS/SSL certificate was generated for the fleet.
	CertificateConfiguration *CertificateConfiguration
	// Game server launch parameters specified for fleets created before 2016-08-04 (or
	// AWS SDK v. 0.12.16). Server launch parameters for fleets created after this date
	// are specified in the fleet's RuntimeConfiguration ().
	ServerLaunchParameters *string
	// EC2 instance type indicating the computing resources of each instance in the
	// fleet, including CPU, memory, storage, and networking capacity. See Amazon EC2
	// Instance Types (http://aws.amazon.com/ec2/instance-types/) for detailed
	// descriptions.
	InstanceType EC2InstanceType
	// Operating system of the fleet's computing resources. A fleet's operating system
	// depends on the OS specified for the build that is deployed on this fleet.
	OperatingSystem OperatingSystem
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a GameLift fleet resource and uniquely identifies it. ARNs
	// are unique across all Regions. In a GameLift fleet ARN, the resource ID matches
	// the FleetId value.
	FleetArn *string
	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
}

// Information about the fleet's capacity. Fleet capacity is measured in EC2
// instances. By default, new fleets have a capacity of one instance, but can be
// updated as needed. The maximum number of instances for a fleet is determined by
// the fleet's instance type.
//
//     * CreateFleet ()
//
//     * ListFleets ()
//
//     *
// DeleteFleet ()
//
//     * DescribeFleetAttributes ()
//
//     * UpdateFleetAttributes
// ()
//
//     * StartFleetActions () or StopFleetActions ()
type FleetCapacity struct {
	// Current status of fleet capacity.
	InstanceCounts *EC2InstanceCounts
	// Name of an EC2 instance type that is supported in Amazon GameLift. A fleet
	// instance type determines the computing resources of each instance in the fleet,
	// including CPU, memory, storage, and networking capacity. Amazon GameLift
	// supports the following EC2 instance types. See Amazon EC2 Instance Types
	// (http://aws.amazon.com/ec2/instance-types/) for detailed descriptions.
	InstanceType EC2InstanceType
	// A unique identifier for a fleet.
	FleetId *string
}

// Current status of fleet utilization, including the number of game and player
// sessions being hosted.
//
//     * CreateFleet ()
//
//     * ListFleets ()
//
//     *
// DeleteFleet ()
//
//     * DescribeFleetAttributes ()
//
//     * UpdateFleetAttributes
// ()
//
//     * StartFleetActions () or StopFleetActions ()
type FleetUtilization struct {
	// The maximum number of players allowed across all game sessions currently being
	// hosted on all instances in the fleet.
	MaximumPlayerSessionCount *int32
	// Number of active player sessions currently being hosted on all instances in the
	// fleet.
	CurrentPlayerSessionCount *int32
	// A unique identifier for a fleet.
	FleetId *string
	// Number of active game sessions currently being hosted on all instances in the
	// fleet.
	ActiveGameSessionCount *int32
	// Number of server processes in an ACTIVE status currently running across all
	// instances in the fleet
	ActiveServerProcessCount *int32
}

// Set of key-value pairs that contain information about a game session. When
// included in a game session request, these properties communicate details to be
// used when setting up the new game session. For example, a game property might
// specify a game mode, level, or map. Game properties are passed to the game
// server process when initiating a new game session. For more information, see the
// Amazon GameLift Developer Guide
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-client-api.html#gamelift-sdk-client-api-create).
type GameProperty struct {
	// The game property value.
	Value *string
	// The game property identifier.
	Key *string
}

// This data type is part of Amazon GameLift FleetIQ with game server groups, which
// is in preview release and is subject to change. Properties describing a game
// server resource. A game server resource is created by a successful call to
// RegisterGameServer () and deleted by calling DeregisterGameServer ().
type GameServer struct {
	// The unique identifier for the instance where the game server is located.
	InstanceId *string
	// Time stamp indicating when the game server resource was created with a
	// RegisterGameServer () request. Format is a number expressed in Unix time as
	// milliseconds (for example "1469498468.057").
	RegistrationTime *time.Time
	// Indicates whether the game server is currently available for new games or is
	// busy. Possible statuses include:
	//
	//     * AVAILABLE - The game server is available
	// to be claimed. A game server that has been claimed remains in this status until
	// it reports game hosting activity.
	//
	//     * IN_USE - The game server is currently
	// hosting a game session with players.
	UtilizationStatus GameServerUtilizationStatus
	// A custom string that uniquely identifies the game server. Game server IDs are
	// developer-defined and are unique across all game server groups in an AWS
	// account.
	GameServerId *string
	// The ARN identifier for the game server group where the game server is located.
	GameServerGroupArn *string
	// Time stamp indicating the last time the game server was updated with health
	// status using an UpdateGameServer () request. Format is a number expressed in
	// Unix time as milliseconds (for example "1469498468.057"). After game server
	// registration, this property is only changed when a game server update specifies
	// a health check value.
	LastHealthCheckTime *time.Time
	// Indicates when an available game server has been reserved but has not yet
	// started hosting a game. Once it is claimed, game server remains in CLAIMED
	// status for a maximum of one minute. During this time, game clients must connect
	// to the game server and start the game, which triggers the game server to update
	// its utilization status. After one minute, the game server claim status reverts
	// to null.
	ClaimStatus GameServerClaimStatus
	// The port and IP address that must be used to establish a client connection to
	// the game server.
	ConnectionInfo *string
	// A set of custom game server properties, formatted as a single string value. This
	// data is passed to a game client or service in response to requests
	// ListGameServers () or ClaimGameServer (). This property can be updated using
	// UpdateGameServer ().
	GameServerData *string
	// The name identifier for the game server group where the game server is located.
	GameServerGroupName *string
	// Time stamp indicating the last time the game server was claimed with a
	// ClaimGameServer () request. Format is a number expressed in Unix time as
	// milliseconds (for example "1469498468.057"). This value is used to calculate
	// when the game server's claim status.
	LastClaimTime *time.Time
	// A game server tag that can be used to request sorted lists of game servers when
	// calling ListGameServers (). Custom sort keys are developer-defined. This
	// property can be updated using UpdateGameServer ().
	CustomSortKey *string
}

// This data type is part of Amazon GameLift FleetIQ with game server groups, which
// is in preview release and is subject to change. Properties describing a game
// server group resource. A game server group manages certain properties of a
// corresponding EC2 Auto Scaling group. A game server group is created by a
// successful call to CreateGameServerGroup () and deleted by calling
// DeleteGameServerGroup (). Game server group activity can be temporarily
// suspended and resumed by calling SuspendGameServerGroup () and
// ResumeGameServerGroup ().
type GameServerGroup struct {
	// A time stamp indicating when this game server group was last updated.
	LastUpdatedTime *time.Time
	// Additional information about the current game server group status. This
	// information may provide additional insight on groups that in ERROR status.
	StatusReason *string
	// A generated unique ID for the game server group.
	GameServerGroupArn *string
	// A developer-defined identifier for the game server group. The name is unique per
	// Region per AWS account.
	GameServerGroupName *string
	// The fallback balancing method to use for the game server group when Spot
	// instances in a Region become unavailable or are not viable for game hosting.
	// Once triggered, this method remains active until Spot instances can once again
	// be used. Method options include:
	//
	//     * SPOT_ONLY -- If Spot instances are
	// unavailable, the game server group provides no hosting capacity. No new
	// instances are started, and the existing nonviable Spot instances are terminated
	// (once current gameplay ends) and not replaced.
	//
	//     * SPOT_PREFERRED -- If Spot
	// instances are unavailable, the game server group continues to provide hosting
	// capacity by using On-Demand instances. Existing nonviable Spot instances are
	// terminated (once current gameplay ends) and replaced with new On-Demand
	// instances.
	BalancingStrategy BalancingStrategy
	// A generated unique ID for the EC2 Auto Scaling group with is associated with
	// this game server group.
	AutoScalingGroupArn *string
	// A flag that indicates whether instances in the game server group are protected
	// from early termination. Unprotected instances that have active game servers
	// running may be terminated during a scale-down event, causing players to be
	// dropped from the game. Protected instances cannot be terminated while there are
	// active game servers running except in the event of a forced game server group
	// deletion (see DeleteGameServerGroup ()). An exception to this is Spot Instances,
	// which may be terminated by AWS regardless of protection status.
	GameServerProtectionPolicy GameServerProtectionPolicy
	// The current status of the game server group. Possible statuses include:
	//
	//     *
	// NEW - GameLift FleetIQ has validated the CreateGameServerGroup() request.
	//
	//     *
	// ACTIVATING - GameLift FleetIQ is setting up a game server group, which includes
	// creating an autoscaling group in your AWS account.
	//
	//     * ACTIVE - The game
	// server group has been successfully created.
	//
	//     * DELETE_SCHEDULED - A request
	// to delete the game server group has been received.
	//
	//     * DELETING - GameLift
	// FleetIQ has received a valid DeleteGameServerGroup() request and is processing
	// it. GameLift FleetIQ must first complete and release hosts before it deletes the
	// autoscaling group and the game server group.
	//
	//     * DELETED - The game server
	// group has been successfully deleted.
	//
	//     * ERROR - The asynchronous processes
	// of activating or deleting a game server group has failed, resulting in an error
	// state.
	Status GameServerGroupStatus
	// A list of activities that are currently suspended for this game server group. If
	// this property is empty, all activities are occurring.
	SuspendedActions []GameServerGroupAction
	// The set of EC2 instance types that GameLift FleetIQ can use when rebalancing and
	// autoscaling instances in the group.
	InstanceDefinitions []*InstanceDefinition
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html)) for an IAM
	// role that allows Amazon GameLift to access your EC2 Auto Scaling groups. The
	// submitted role is validated to ensure that it contains the necessary permissions
	// for game server groups.
	RoleArn *string
	// A time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
}

// This data type is part of Amazon GameLift FleetIQ with game server groups, which
// is in preview release and is subject to change. Configuration settings for
// intelligent autoscaling that uses target tracking. An autoscaling policy can be
// specified when a new game server group is created with CreateGameServerGroup ().
// If a group has an autoscaling policy, the Auto Scaling group takes action based
// on this policy, in addition to (and potentially in conflict with) any other
// autoscaling policies that are separately applied to the Auto Scaling group.
type GameServerGroupAutoScalingPolicy struct {
	// Settings for a target-based scaling policy applied to Auto Scaling group. These
	// settings are used to create a target-based policy that tracks the GameLift
	// FleetIQ metric "PercentUtilizedGameServers" and specifies a target value for the
	// metric. As player usage changes, the policy triggers to adjust the game server
	// group capacity so that the metric returns to the target value.
	TargetTrackingConfiguration *TargetTrackingConfiguration
	// Length of time, in seconds, it takes for a new instance to start new game server
	// processes and register with GameLift FleetIQ. Specifying a warm-up time can be
	// useful, particularly with game servers that take a long time to start up,
	// because it avoids prematurely starting new instances
	EstimatedInstanceWarmup *int32
}

// Properties describing a game session. A game session in ACTIVE status can host
// players. When a game session ends, its status is set to TERMINATED. Once the
// session ends, the game session object is retained for 30 days. This means you
// can reuse idempotency token values after this time. Game session logs are
// retained for 14 days.
//
//     * CreateGameSession ()
//
//     * DescribeGameSessions
// ()
//
//     * DescribeGameSessionDetails ()
//
//     * SearchGameSessions ()
//
//     *
// UpdateGameSession ()
//
//     * GetGameSessionLogUrl ()
//
//     * Game session
// placements
//
//         * StartGameSessionPlacement ()
//
//         *
// DescribeGameSessionPlacement ()
//
//         * StopGameSessionPlacement ()
type GameSession struct {
	// Set of custom game session properties, formatted as a single string value. This
	// data is passed to a game server process in the GameSession () object with a
	// request to start a new game session (see Start a Game Session
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameSessionData *string
	// Current status of the game session. A game session must have an ACTIVE status to
	// have player sessions.
	Status GameSessionStatus
	// Set of custom properties for a game session, formatted as key:value pairs. These
	// properties are passed to a game server process in the GameSession () object with
	// a request to start a new game session (see Start a Game Session
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// You can search for active game sessions based on this custom data with
	// SearchGameSessions ().
	GameProperties []*GameProperty
	// DNS identifier assigned to the instance that is running the game session. Values
	// have the following format:
	//
	//     * TLS-enabled fleets: ..amazongamelift.com.
	//
	//
	// * Non-TLS-enabled fleets: ec2-.compute.amazonaws.com. (See Amazon EC2 Instance
	// IP Addressing
	// (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses).)
	//
	// When
	// connecting to a game session that is running on a TLS-enabled fleet, you must
	// use the DNS name, not the IP address.
	DnsName *string
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// associated with the GameLift fleet that this game session is running on.
	FleetArn *string
	// Information about the matchmaking process that was used to create the game
	// session. It is in JSON syntax, formatted as a string. In addition the
	// matchmaking configuration used, it contains data on all players assigned to the
	// match, including player attributes and team assignments. For more details on
	// matchmaker data, see Match Data
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-server.html#match-server-data).
	// Matchmaker data is useful when requesting match backfills, and is updated
	// whenever new players are added during a successful backfill (see
	// StartMatchBackfill ()).
	MatchmakerData *string
	// A descriptive label that is associated with a game session. Session names do not
	// need to be unique.
	Name *string
	// Number of players currently in the game session.
	CurrentPlayerSessionCount *int32
	// A unique identifier for the game session. A game session ARN has the following
	// format: arn:aws:gamelift:::gamesession//.
	GameSessionId *string
	// Time stamp indicating when this data object was terminated. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	TerminationTime *time.Time
	// Provides additional information about game session status. INTERRUPTED indicates
	// that the game session was hosted on a spot instance that was reclaimed, causing
	// the active game session to be terminated.
	StatusReason GameSessionStatusReason
	// Indicates whether or not the game session is accepting new players.
	PlayerSessionCreationPolicy PlayerSessionCreationPolicy
	// The maximum number of players that can be connected simultaneously to the game
	// session.
	MaximumPlayerSessionCount *int32
	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
	// A unique identifier for a player. This ID is used to enforce a resource
	// protection policy (if one exists), that limits the number of game sessions a
	// player can create.
	CreatorId *string
	// Port number for the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number.
	Port *int32
	// A unique identifier for a fleet that the game session is running on.
	FleetId *string
	// IP address of the instance that is running the game session. When connecting to
	// a Amazon GameLift game server, a client needs to reference an IP address (or DNS
	// name) and port number.
	IpAddress *string
}

// Connection information for the new game session that is created with
// matchmaking. (with StartMatchmaking ()). Once a match is set, the FlexMatch
// engine places the match and creates a new game session for it. This information,
// including the game session endpoint and player sessions for each player in the
// original matchmaking request, is added to the MatchmakingTicket (), which can be
// retrieved by calling DescribeMatchmaking ().
type GameSessionConnectionInfo struct {
	// Port number for the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number.
	Port *int32
	// DNS identifier assigned to the instance that is running the game session. Values
	// have the following format:
	//
	//     * TLS-enabled fleets: ..amazongamelift.com.
	//
	//
	// * Non-TLS-enabled fleets: ec2-.compute.amazonaws.com. (See Amazon EC2 Instance
	// IP Addressing
	// (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses).)
	//
	// When
	// connecting to a game session that is running on a TLS-enabled fleet, you must
	// use the DNS name, not the IP address.
	DnsName *string
	// A collection of player session IDs, one for each player ID that was included in
	// the original matchmaking request.
	MatchedPlayerSessions []*MatchedPlayerSession
	// Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a game session and uniquely identifies it.
	GameSessionArn *string
	// IP address of the instance that is running the game session. When connecting to
	// a Amazon GameLift game server, a client needs to reference an IP address (or DNS
	// name) and port number.
	IpAddress *string
}

// A game session's properties plus the protection policy currently in force.
type GameSessionDetail struct {
	// Object that describes a game session.
	GameSession *GameSession
	// Current status of protection for the game session.
	//
	//     * NoProtection -- The
	// game session can be terminated during a scale-down event.
	//
	//     * FullProtection
	// -- If the game session is in an ACTIVE status, it cannot be terminated during a
	// scale-down event.
	ProtectionPolicy ProtectionPolicy
}

// Object that describes a StartGameSessionPlacement () request. This object
// includes the full details of the original request plus the current status and
// start/end time stamps. Game session placement-related operations include:
//
//     *
// StartGameSessionPlacement ()
//
//     * DescribeGameSessionPlacement ()
//
//     *
// StopGameSessionPlacement ()
type GameSessionPlacement struct {
	// A descriptive label that is associated with game session queue. Queue names must
	// be unique within each Region.
	GameSessionQueueName *string
	// Identifier for the game session created by this placement request. This value is
	// set once the new game session is placed (placement status is FULFILLED). This
	// identifier is unique across all Regions. You can use this value as a
	// GameSessionId value as needed.
	GameSessionArn *string
	// The maximum number of players that can be connected simultaneously to the game
	// session.
	MaximumPlayerSessionCount *int32
	// A unique identifier for a game session placement.
	PlacementId *string
	// Information on the matchmaking process for this game. Data is in JSON syntax,
	// formatted as a string. It identifies the matchmaking configuration used to
	// create the match, and contains data on all players assigned to the match,
	// including player attributes and team assignments. For more details on matchmaker
	// data, see Match Data
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-server.html#match-server-data).
	MatchmakerData *string
	// A unique identifier for the game session. This value is set once the new game
	// session is placed (placement status is FULFILLED).
	GameSessionId *string
	// DNS identifier assigned to the instance that is running the game session. Values
	// have the following format:
	//
	//     * TLS-enabled fleets: ..amazongamelift.com.
	//
	//
	// * Non-TLS-enabled fleets: ec2-.compute.amazonaws.com. (See Amazon EC2 Instance
	// IP Addressing
	// (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses).)
	//
	// When
	// connecting to a game session that is running on a TLS-enabled fleet, you must
	// use the DNS name, not the IP address.
	DnsName *string
	// A descriptive label that is associated with a game session. Session names do not
	// need to be unique.
	GameSessionName *string
	// Port number for the game session. To connect to a Amazon GameLift game server,
	// an app needs both the IP address and port number. This value is set once the new
	// game session is placed (placement status is FULFILLED).
	Port *int32
	// Name of the Region where the game session created by this placement request is
	// running. This value is set once the new game session is placed (placement status
	// is FULFILLED).
	GameSessionRegion *string
	// IP address of the instance that is running the game session. When connecting to
	// a Amazon GameLift game server, a client needs to reference an IP address (or DNS
	// name) and port number. This value is set once the new game session is placed
	// (placement status is FULFILLED).
	IpAddress *string
	// Current status of the game session placement request.
	//
	//     * PENDING -- The
	// placement request is currently in the queue waiting to be processed.
	//
	//     *
	// FULFILLED -- A new game session and player sessions (if requested) have been
	// successfully created. Values for GameSessionArn and GameSessionRegion are
	// available.
	//
	//     * CANCELLED -- The placement request was canceled with a call to
	// StopGameSessionPlacement ().
	//
	//     * TIMED_OUT -- A new game session was not
	// successfully created before the time limit expired. You can resubmit the
	// placement request as needed.
	//
	//     * FAILED -- GameLift is not able to complete
	// the process of placing the game session. Common reasons are the game session
	// terminated before the placement process was completed, or an unexpected internal
	// error.
	Status GameSessionPlacementState
	// Set of custom properties for a game session, formatted as key:value pairs. These
	// properties are passed to a game server process in the GameSession () object with
	// a request to start a new game session (see Start a Game Session
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameProperties []*GameProperty
	// Set of custom game session properties, formatted as a single string value. This
	// data is passed to a game server process in the GameSession () object with a
	// request to start a new game session (see Start a Game Session
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	GameSessionData *string
	// Time stamp indicating when this request was placed in the queue. Format is a
	// number expressed in Unix time as milliseconds (for example "1469498468.057").
	StartTime *time.Time
	// A collection of information on player sessions created in response to the game
	// session placement request. These player sessions are created only once a new
	// game session is successfully placed (placement status is FULFILLED). This
	// information includes the player ID (as provided in the placement request) and
	// the corresponding player session ID. Retrieve full player sessions by calling
	// DescribePlayerSessions () with the player session ID.
	PlacedPlayerSessions []*PlacedPlayerSession
	// Set of values, expressed in milliseconds, indicating the amount of latency that
	// a player experiences when connected to AWS Regions.
	PlayerLatencies []*PlayerLatency
	// Time stamp indicating when this request was completed, canceled, or timed out.
	EndTime *time.Time
}

// Configuration of a queue that is used to process game session placement
// requests. The queue configuration identifies several game features:
//
//     * The
// destinations where a new game session can potentially be hosted. Amazon GameLift
// tries these destinations in an order based on either the queue's default order
// or player latency information, if provided in a placement request. With latency
// information, Amazon GameLift can place game sessions where the majority of
// players are reporting the lowest possible latency.
//
//     * The length of time
// that placement requests can wait in the queue before timing out.
//
//     * A set of
// optional latency policies that protect individual players from high latencies,
// preventing game sessions from being placed where any individual player is
// reporting latency higher than a policy's maximum.
//
//     * CreateGameSessionQueue
// ()
//
//     * DescribeGameSessionQueues ()
//
//     * UpdateGameSessionQueue ()
//
//     *
// DeleteGameSessionQueue ()
type GameSessionQueue struct {
	// A descriptive label that is associated with game session queue. Queue names must
	// be unique within each Region.
	Name *string
	// A collection of latency policies to apply when processing game sessions
	// placement requests with player latency information. Multiple policies are
	// evaluated in order of the maximum latency value, starting with the lowest
	// latency values. With just one policy, the policy is enforced at the start of the
	// game session placement for the duration period. With multiple policies, each
	// policy is enforced consecutively for its duration period. For example, a queue
	// might enforce a 60-second policy followed by a 120-second policy, and then no
	// policy for the remainder of the placement.
	PlayerLatencyPolicies []*PlayerLatencyPolicy
	// Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a GameLift game session queue resource and uniquely
	// identifies it. ARNs are unique across all Regions. In a GameLift game session
	// queue ARN, the resource ID matches the Name value.
	GameSessionQueueArn *string
	// A list of fleets that can be used to fulfill game session placement requests in
	// the queue. Fleets are identified by either a fleet ARN or a fleet alias ARN.
	// Destinations are listed in default preference order.
	Destinations []*GameSessionQueueDestination
	// The maximum time, in seconds, that a new game session placement request remains
	// in the queue. When a request exceeds this time, the game session placement
	// changes to a TIMED_OUT status.
	TimeoutInSeconds *int32
}

// Fleet designated in a game session queue. Requests for new game sessions in the
// queue are fulfilled by starting a new game session on any destination that is
// configured for a queue.
//
//     * CreateGameSessionQueue ()
//
//     *
// DescribeGameSessionQueues ()
//
//     * UpdateGameSessionQueue ()
//
//     *
// DeleteGameSessionQueue ()
type GameSessionQueueDestination struct {
	// The Amazon Resource Name (ARN) that is assigned to fleet or fleet alias. ARNs,
	// which include a fleet ID or alias ID and a Region name, provide a unique
	// identifier across all Regions.
	DestinationArn *string
}

// Properties that describe an instance of a virtual computing resource that hosts
// one or more game servers. A fleet may contain zero or more instances.
type Instance struct {
	// EC2 instance type that defines the computing resources of this instance.
	Type EC2InstanceType
	// Current status of the instance. Possible statuses include the following:
	//
	//     *
	// PENDING -- The instance is in the process of being created and launching server
	// processes as defined in the fleet's run-time configuration.
	//
	//     * ACTIVE -- The
	// instance has been successfully created and at least one server process has
	// successfully launched and reported back to Amazon GameLift that it is ready to
	// host a game session. The instance is now considered ready to host game
	// sessions.
	//
	//     * TERMINATING -- The instance is in the process of shutting down.
	// This may happen to reduce capacity during a scaling down event or to recycle
	// resources in the event of a problem.
	Status InstanceStatus
	// DNS identifier assigned to the instance that is running the game session. Values
	// have the following format:
	//
	//     * TLS-enabled fleets: ..amazongamelift.com.
	//
	//
	// * Non-TLS-enabled fleets: ec2-.compute.amazonaws.com. (See Amazon EC2 Instance
	// IP Addressing
	// (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses).)
	//
	// When
	// connecting to a game session that is running on a TLS-enabled fleet, you must
	// use the DNS name, not the IP address.
	DnsName *string
	// IP address that is assigned to the instance.
	IpAddress *string
	// A unique identifier for a fleet that the instance is in.
	FleetId *string
	// A unique identifier for an instance.
	InstanceId *string
	// Operating system that is running on this instance.
	OperatingSystem OperatingSystem
	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
}

// Information required to remotely connect to a fleet instance. Access is
// requested by calling GetInstanceAccess ().
type InstanceAccess struct {
	// Operating system that is running on the instance.
	OperatingSystem OperatingSystem
	// Credentials required to access the instance.
	Credentials *InstanceCredentials
	// A unique identifier for an instance being accessed.
	InstanceId *string
	// IP address that is assigned to the instance.
	IpAddress *string
	// A unique identifier for a fleet containing the instance being accessed.
	FleetId *string
}

// Set of credentials required to remotely access a fleet instance. Access
// credentials are requested by calling GetInstanceAccess () and returned in an
// InstanceAccess () object.
type InstanceCredentials struct {
	// User login string.
	UserName *string
	// Secret string. For Windows instances, the secret is a password for use with
	// Windows Remote Desktop. For Linux instances, it is a private key (which must be
	// saved as a .pem file) for use with SSH.
	Secret *string
}

// This data type is part of Amazon GameLift FleetIQ with game server groups, which
// is in preview release and is subject to change. An allowed instance type for
// your game server group. GameLift FleetIQ periodically evaluates each defined
// instance type for viability. It then updates the Auto Scaling group with the
// list of viable instance types.
type InstanceDefinition struct {
	// Instance weighting that indicates how much this instance type contributes to the
	// total capacity of a game server group. Instance weights are used by GameLift
	// FleetIQ to calculate the instance type's cost per unit hour and better identify
	// the most cost-effective options. For detailed information on weighting instance
	// capacity, see Instance Weighting
	// (https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-weighting.html)
	// in the Amazon EC2 Auto Scaling User Guide. Default value is "1".
	WeightedCapacity *string
	// An EC2 instance type designation.
	InstanceType GameServerGroupInstanceType
}

// A range of IP addresses and port settings that allow inbound traffic to connect
// to server processes on an Amazon GameLift hosting resource. New game sessions
// that are started on the fleet are assigned an IP address/port number
// combination, which must fall into the fleet's allowed ranges. For fleets created
// with a custom game server, the ranges reflect the server's game session
// assignments. For Realtime Servers fleets, Amazon GameLift automatically opens
// two port ranges, one for TCP messaging and one for UDP for use by the Realtime
// servers.
type IpPermission struct {
	// A range of allowed IP addresses. This value must be expressed in CIDR notation.
	// Example: "000.000.000.000/[subnet mask]" or optionally the shortened version
	// "0.0.0.0/[subnet mask]".
	IpRange *string
	// An ending value for a range of allowed port numbers. Port numbers are
	// end-inclusive. This value must be higher than FromPort.
	ToPort *int32
	// The network communication protocol used by the fleet.
	Protocol IpProtocol
	// A starting value for a range of allowed port numbers.
	FromPort *int32
}

// This data type is part of Amazon GameLift FleetIQ with game server groups, which
// is in preview release and is subject to change. An EC2 launch template that
// contains configuration settings and game server code to be deployed to all
// instances in a game server group.
type LaunchTemplateSpecification struct {
	// A readable identifier for an existing EC2 launch template.
	LaunchTemplateName *string
	// The version of the EC2 launch template to use. If no version is specified, the
	// default version will be used. EC2 allows you to specify a default version for a
	// launch template, if none is set, the default is the first version created.
	Version *string
	// A unique identifier for an existing EC2 launch template.
	LaunchTemplateId *string
}

// Represents a new player session that is created as a result of a successful
// FlexMatch match. A successful match automatically creates new player sessions
// for every player ID in the original matchmaking request. When players connect to
// the match's game session, they must include both player ID and player session ID
// in order to claim their assigned player slot.
type MatchedPlayerSession struct {
	// A unique identifier for a player
	PlayerId *string
	// A unique identifier for a player session
	PlayerSessionId *string
}

// Guidelines for use with FlexMatch to match players into games. All matchmaking
// requests must specify a matchmaking configuration.
type MatchmakingConfiguration struct {
	// The method used to backfill game sessions created with this matchmaking
	// configuration. MANUAL indicates that the game makes backfill requests or does
	// not use the match backfill feature. AUTOMATIC indicates that GameLift creates
	// StartMatchBackfill () requests whenever a game session has one or more open
	// slots. Learn more about manual and automatic backfill in Backfill Existing Games
	// with FlexMatch
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-backfill.html).
	BackfillMode BackfillMode
	// A flag that indicates whether a match that was created with this configuration
	// must be accepted by the matched players. To require acceptance, set to TRUE.
	AcceptanceRequired *bool
	// Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a GameLift matchmaking configuration resource and uniquely
	// identifies it. ARNs are unique across all Regions. In a GameLift configuration
	// ARN, the resource ID matches the Name value.
	ConfigurationArn *string
	// The time stamp indicating when this data object was created. The format is a
	// number expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
	// A descriptive label that is associated with matchmaking configuration.
	Description *string
	// Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a GameLift game session queue resource and uniquely
	// identifies it. ARNs are unique across all Regions. GameLift uses the listed
	// queues when placing game sessions for matches that are created with this
	// matchmaking configuration. Queues can be located in any Region.
	GameSessionQueueArns []*string
	// A set of custom game session properties, formatted as a single string value.
	// This data is passed to a game server process in the GameSession () object with a
	// request to start a new game session (see Start a Game Session
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// This information is added to the new GameSession () object that is created for a
	// successful match.
	GameSessionData *string
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// associated with the GameLift matchmaking rule set resource that this
	// configuration uses.
	RuleSetArn *string
	// The number of player slots in a match to keep open for future players. For
	// example, assume that the configuration's rule set specifies a match for a single
	// 12-person team. If the additional player count is set to 2, only 10 players are
	// initially selected for the match.
	AdditionalPlayerCount *int32
	// A unique identifier for a matchmaking rule set to use with this configuration. A
	// matchmaking configuration can only use rule sets that are defined in the same
	// Region.
	RuleSetName *string
	// A set of custom properties for a game session, formatted as key-value pairs.
	// These properties are passed to a game server process in the GameSession ()
	// object with a request to start a new game session (see Start a Game Session
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-sdk-server-api.html#gamelift-sdk-server-startsession)).
	// This information is added to the new GameSession () object that is created for a
	// successful match.
	GameProperties []*GameProperty
	// The length of time (in seconds) to wait for players to accept a proposed match.
	// If any player rejects the match or fails to accept before the timeout, the
	// ticket continues to look for an acceptable match.
	AcceptanceTimeoutSeconds *int32
	// An SNS topic ARN that is set up to receive matchmaking notifications.
	NotificationTarget *string
	// The maximum duration, in seconds, that a matchmaking ticket can remain in
	// process before timing out. Requests that fail due to timing out can be
	// resubmitted as needed.
	RequestTimeoutSeconds *int32
	// Information to attach to all events related to the matchmaking configuration.
	CustomEventData *string
	// A unique identifier for a matchmaking configuration. This name is used to
	// identify the configuration associated with a matchmaking request or ticket.
	Name *string
}

// Set of rule statements, used with FlexMatch, that determine how to build your
// player matches. Each rule set describes a type of group to be created and
// defines the parameters for acceptable player matches. Rule sets are used in
// MatchmakingConfiguration () objects. A rule set may define the following
// elements for a match. For detailed information and examples showing how to
// construct a rule set, see Build a FlexMatch Rule Set
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-rulesets.html).
//
//
// * Teams -- Required. A rule set must define one or multiple teams for the match
// and set minimum and maximum team sizes. For example, a rule set might describe a
// 4x4 match that requires all eight slots to be filled.
//
//     * Player attributes
// -- Optional. These attributes specify a set of player characteristics to
// evaluate when looking for a match. Matchmaking requests that use a rule set with
// player attributes must provide the corresponding attribute values. For example,
// an attribute might specify a player's skill or level.
//
//     * Rules -- Optional.
// Rules define how to evaluate potential players for a match based on player
// attributes. A rule might specify minimum requirements for individual players,
// teams, or entire matches. For example, a rule might require each player to meet
// a certain skill level, each team to have at least one player in a certain role,
// or the match to have a minimum average skill level. or may describe an entire
// group--such as all teams must be evenly matched or have at least one player in a
// certain role.
//
//     * Expansions -- Optional. Expansions allow you to relax the
// rules after a period of time when no acceptable matches are found. This feature
// lets you balance getting players into games in a reasonable amount of time
// instead of making them wait indefinitely for the best possible match. For
// example, you might use an expansion to increase the maximum skill variance
// between players after 30 seconds.
type MatchmakingRuleSet struct {
	// A unique identifier for a matchmaking rule set
	RuleSetName *string
	// A collection of matchmaking rules, formatted as a JSON string. Comments are not
	// allowed in JSON, but most elements support a description field.
	RuleSetBody *string
	// The time stamp indicating when this data object was created. The format is a
	// number expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
	// Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a GameLift matchmaking rule set resource and uniquely
	// identifies it. ARNs are unique across all Regions. In a GameLift rule set ARN,
	// the resource ID matches the RuleSetName value.
	RuleSetArn *string
}

// Ticket generated to track the progress of a matchmaking request. Each ticket is
// uniquely identified by a ticket ID, supplied by the requester, when creating a
// matchmaking request with StartMatchmaking (). Tickets can be retrieved by
// calling DescribeMatchmaking () with the ticket ID.
type MatchmakingTicket struct {
	// A unique identifier for a matchmaking ticket.
	TicketId *string
	// Name of the MatchmakingConfiguration () that is used with this ticket.
	// Matchmaking configurations determine how players are grouped into a match and
	// how a new game session is created for the match.
	ConfigurationName *string
	// Average amount of time (in seconds) that players are currently waiting for a
	// match. If there is not enough recent data, this property may be empty.
	EstimatedWaitTime *int32
	// Identifier and connection information of the game session created for the match.
	// This information is added to the ticket only after the matchmaking request has
	// been successfully completed.
	GameSessionConnectionInfo *GameSessionConnectionInfo
	// Current status of the matchmaking request.
	//
	//     * QUEUED -- The matchmaking
	// request has been received and is currently waiting to be processed.
	//
	//     *
	// SEARCHING -- The matchmaking request is currently being processed.
	//
	//     *
	// REQUIRES_ACCEPTANCE -- A match has been proposed and the players must accept the
	// match (see AcceptMatch ()). This status is used only with requests that use a
	// matchmaking configuration with a player acceptance requirement.
	//
	//     * PLACING
	// -- The FlexMatch engine has matched players and is in the process of placing a
	// new game session for the match.
	//
	//     * COMPLETED -- Players have been matched
	// and a game session is ready to host the players. A ticket in this state contains
	// the necessary connection information for players.
	//
	//     * FAILED -- The
	// matchmaking request was not completed.
	//
	//     * CANCELLED -- The matchmaking
	// request was canceled. This may be the result of a call to StopMatchmaking () or
	// a proposed match that one or more players failed to accept.
	//
	//     * TIMED_OUT --
	// The matchmaking request was not successful within the duration specified in the
	// matchmaking configuration.
	//
	// Matchmaking requests that fail to successfully
	// complete (statuses FAILED, CANCELLED, TIMED_OUT) can be resubmitted as new
	// requests with new ticket IDs.
	Status MatchmakingConfigurationStatus
	// Time stamp indicating when this matchmaking request was received. Format is a
	// number expressed in Unix time as milliseconds (for example "1469498468.057").
	StartTime *time.Time
	// Code to explain the current status. For example, a status reason may indicate
	// when a ticket has returned to SEARCHING status after a proposed match fails to
	// receive player acceptances.
	StatusReason *string
	// Additional information about the current status.
	StatusMessage *string
	// Time stamp indicating when this matchmaking request stopped being processed due
	// to success, failure, or cancellation. Format is a number expressed in Unix time
	// as milliseconds (for example "1469498468.057").
	EndTime *time.Time
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// associated with the GameLift matchmaking configuration resource that is used
	// with this ticket.
	ConfigurationArn *string
	// A set of Player objects, each representing a player to find matches for. Players
	// are identified by a unique player ID and may include latency data for use during
	// matchmaking. If the ticket is in status COMPLETED, the Player objects include
	// the team the players were assigned to in the resulting match.
	Players []*Player
}

// Information about a player session that was created as part of a
// StartGameSessionPlacement () request. This object contains only the player ID
// and player session ID. To retrieve full details on a player session, call
// DescribePlayerSessions () with the player session ID.
//
//     * CreatePlayerSession
// ()
//
//     * CreatePlayerSessions ()
//
//     * DescribePlayerSessions ()
//
//     * Game
// session placements
//
//         * StartGameSessionPlacement ()
//
//         *
// DescribeGameSessionPlacement ()
//
//         * StopGameSessionPlacement ()
type PlacedPlayerSession struct {
	// A unique identifier for a player that is associated with this player session.
	PlayerId *string
	// A unique identifier for a player session.
	PlayerSessionId *string
}

// Represents a player in matchmaking. When starting a matchmaking request, a
// player has a player ID, attributes, and may have latency data. Team information
// is added after a match has been successfully completed.
type Player struct {
	// Set of values, expressed in milliseconds, indicating the amount of latency that
	// a player experiences when connected to AWS Regions. If this property is present,
	// FlexMatch considers placing the match only in Regions for which latency is
	// reported. If a matchmaker has a rule that evaluates player latency, players must
	// report latency in order to be matched. If no latency is reported in this
	// scenario, FlexMatch assumes that no Regions are available to the player and the
	// ticket is not matchable.
	LatencyInMs map[string]*int32
	// A collection of key:value pairs containing player information for use in
	// matchmaking. Player attribute keys must match the playerAttributes used in a
	// matchmaking rule set. Example: "PlayerAttributes": {"skill": {"N": "23"},
	// "gameMode": {"S": "deathmatch"}}.
	PlayerAttributes map[string]*AttributeValue
	// Name of the team that the player is assigned to in a match. Team names are
	// defined in a matchmaking rule set.
	Team *string
	// A unique identifier for a player
	PlayerId *string
}

// Regional latency information for a player, used when requesting a new game
// session with StartGameSessionPlacement (). This value indicates the amount of
// time lag that exists when the player is connected to a fleet in the specified
// Region. The relative difference between a player's latency values for multiple
// Regions are used to determine which fleets are best suited to place a new game
// session for the player.
type PlayerLatency struct {
	// A unique identifier for a player associated with the latency data.
	PlayerId *string
	// Amount of time that represents the time lag experienced by the player when
	// connected to the specified Region.
	LatencyInMilliseconds *float32
	// Name of the Region that is associated with the latency value.
	RegionIdentifier *string
}

// Queue setting that determines the highest latency allowed for individual players
// when placing a game session. When a latency policy is in force, a game session
// cannot be placed with any fleet in a Region where a player reports latency
// higher than the cap. Latency policies are only enforced when the placement
// request contains player latency information.
//
//     * CreateGameSessionQueue ()
//
//
// * DescribeGameSessionQueues ()
//
//     * UpdateGameSessionQueue ()
//
//     *
// DeleteGameSessionQueue ()
type PlayerLatencyPolicy struct {
	// The maximum latency value that is allowed for any player, in milliseconds. All
	// policies must have a value set for this property.
	MaximumIndividualPlayerLatencyMilliseconds *int32
	// The length of time, in seconds, that the policy is enforced while placing a new
	// game session. A null value for this property means that the policy is enforced
	// until the queue times out.
	PolicyDurationSeconds *int32
}

// Properties describing a player session. Player session objects are created
// either by creating a player session for a specific game session, or as part of a
// game session placement. A player session represents either a player reservation
// for a game session (status RESERVED) or actual player activity in a game session
// (status ACTIVE). A player session object (including player data) is
// automatically passed to a game session when the player connects to the game
// session and is validated. When a player disconnects, the player session status
// changes to COMPLETED. Once the session ends, the player session object is
// retained for 30 days and then removed.
//
//     * CreatePlayerSession ()
//
//     *
// CreatePlayerSessions ()
//
//     * DescribePlayerSessions ()
//
//     * Game session
// placements
//
//         * StartGameSessionPlacement ()
//
//         *
// DescribeGameSessionPlacement ()
//
//         * StopGameSessionPlacement ()
type PlayerSession struct {
	// A unique identifier for the game session that the player session is connected
	// to.
	GameSessionId *string
	// Current status of the player session. Possible player session statuses include
	// the following:
	//
	//     * RESERVED -- The player session request has been received,
	// but the player has not yet connected to the server process and/or been
	// validated.
	//
	//     * ACTIVE -- The player has been validated by the server process
	// and is currently connected.
	//
	//     * COMPLETED -- The player connection has been
	// dropped.
	//
	//     * TIMEDOUT -- A player session request was received, but the
	// player did not connect and/or was not validated within the timeout limit (60
	// seconds).
	Status PlayerSessionStatus
	// Port number for the game session. To connect to a Amazon GameLift server
	// process, an app needs both the IP address and port number.
	Port *int32
	// A unique identifier for a player that is associated with this player session.
	PlayerId *string
	// A unique identifier for a fleet that the player's game session is running on.
	FleetId *string
	// DNS identifier assigned to the instance that is running the game session. Values
	// have the following format:
	//
	//     * TLS-enabled fleets: ..amazongamelift.com.
	//
	//
	// * Non-TLS-enabled fleets: ec2-.compute.amazonaws.com. (See Amazon EC2 Instance
	// IP Addressing
	// (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses).)
	//
	// When
	// connecting to a game session that is running on a TLS-enabled fleet, you must
	// use the DNS name, not the IP address.
	DnsName *string
	// A unique identifier for a player session.
	PlayerSessionId *string
	// Time stamp indicating when this data object was created. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
	// Time stamp indicating when this data object was terminated. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	TerminationTime *time.Time
	// IP address of the instance that is running the game session. When connecting to
	// a Amazon GameLift game server, a client needs to reference an IP address (or DNS
	// name) and port number.
	IpAddress *string
	// Developer-defined information related to a player. Amazon GameLift does not use
	// this data, so it can be formatted as needed for use in the game.
	PlayerData *string
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// associated with the GameLift fleet that the player's game session is running on.
	FleetArn *string
}

// A policy that limits the number of game sessions a player can create on the same
// fleet. This optional policy gives game owners control over how players can
// consume available game server resources. A resource creation policy makes the
// following statement: "An individual player can create a maximum number of new
// game sessions within a specified time period". The policy is evaluated when a
// player tries to create a new game session. For example: Assume you have a policy
// of 10 new game sessions and a time period of 60 minutes. On receiving a
// CreateGameSession request, Amazon GameLift checks that the player (identified by
// CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type ResourceCreationLimitPolicy struct {
	// The maximum number of game sessions that an individual can create during the
	// policy period.
	NewGameSessionsPerCreator *int32
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int32
}

// The routing configuration for a fleet alias.
//
//     * CreateAlias ()
//
//     *
// ListAliases ()
//
//     * DescribeAlias ()
//
//     * UpdateAlias ()
//
//     * DeleteAlias
// ()
//
//     * ResolveAlias ()
type RoutingStrategy struct {
	// The type of routing strategy for the alias. Possible routing types include the
	// following:
	//
	//     * SIMPLE - The alias resolves to one specific fleet. Use this
	// type when routing to active fleets.
	//
	//     * TERMINAL - The alias does not resolve
	// to a fleet but instead can be used to display a message to the user. A terminal
	// alias throws a TerminalRoutingStrategyException with the RoutingStrategy ()
	// message embedded.
	Type RoutingStrategyType
	// The unique identifier for a fleet that the alias points to. This value is the
	// fleet ID, not the fleet ARN.
	FleetId *string
	// The message text to be used with a terminal routing strategy.
	Message *string
}

// A collection of server process configurations that describe what processes to
// run on each instance in a fleet. Server processes run either a custom game build
// executable or a Realtime Servers script. Each instance in the fleet starts the
// specified server processes and continues to start new processes as existing
// processes end. Each instance regularly checks for an updated runtime
// configuration. The runtime configuration enables the instances in a fleet to run
// multiple processes simultaneously. Learn more about  Running Multiple Processes
// on a Fleet
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/fleets-multiprocess.html).
// A Amazon GameLift instance is limited to 50 processes running simultaneously. To
// calculate the total number of processes in a runtime configuration, add the
// values of the ConcurrentExecutions parameter for each ServerProcess () object.
//
//
// * CreateFleet ()
//
//     * ListFleets ()
//
//     * DeleteFleet ()
//
//     *
// DescribeFleetAttributes ()
//
//     * UpdateFleetAttributes ()
//
//     *
// StartFleetActions () or StopFleetActions ()
type RuntimeConfiguration struct {
	// The maximum number of game sessions with status ACTIVATING to allow on an
	// instance simultaneously. This setting limits the amount of instance resources
	// that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations *int32
	// A collection of server process configurations that describe which server
	// processes to run on each instance in a fleet.
	ServerProcesses []*ServerProcess
	// The maximum amount of time (in seconds) that a game session can remain in status
	// ACTIVATING. If the game session is not active before the timeout, activation is
	// terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds *int32
}

// The location in S3 where build or script files are stored for access by Amazon
// GameLift. This location is specified in CreateBuild (), CreateScript (), and
// UpdateScript () requests.
type S3Location struct {
	// An S3 bucket identifier. This is the name of the S3 bucket.
	Bucket *string
	// The name of the zip file that contains the build files or script files.
	Key *string
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html)) for an IAM
	// role that allows Amazon GameLift to access the S3 bucket.
	RoleArn *string
	// The version of the file, if object versioning is turned on for the bucket.
	// Amazon GameLift uses this information when retrieving files from an S3 bucket
	// that you own. Use this parameter to specify a specific version of the file. If
	// not set, the latest version of the file is retrieved.
	ObjectVersion *string
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely
// identified by the combination of name and fleet ID.
//
//     * DescribeFleetCapacity
// ()
//
//     * UpdateFleetCapacity ()
//
//     * DescribeEC2InstanceLimits ()
//
//     *
// Manage scaling policies:
//
//         * PutScalingPolicy () (auto-scaling)
//
//
// * DescribeScalingPolicies () (auto-scaling)
//
//         * DeleteScalingPolicy ()
// (auto-scaling)
//
//     * Manage fleet actions:
//
//         * StartFleetActions ()
//
//
// * StopFleetActions ()
type ScalingPolicy struct {
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling
	// adjustment. For detailed descriptions of fleet metrics, see Monitor Amazon
	// GameLift with Amazon CloudWatch
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/monitoring-cloudwatch.html).
	//
	//
	// * ActivatingGameSessions -- Game sessions in the process of being created.
	//
	//
	// * ActiveGameSessions -- Game sessions that are currently running.
	//
	//     *
	// ActiveInstances -- Fleet instances that are currently running at least one game
	// session.
	//
	//     * AvailableGameSessions -- Additional game sessions that fleet
	// could host simultaneously, given current capacity.
	//
	//     *
	// AvailablePlayerSessions -- Empty player slots in currently active game sessions.
	// This includes game sessions that are not currently accepting players. Reserved
	// player slots are not included.
	//
	//     * CurrentPlayerSessions -- Player slots in
	// active game sessions that are being used by a player or are reserved for a
	// player.
	//
	//     * IdleInstances -- Active instances that are currently hosting zero
	// game sessions.
	//
	//     * PercentAvailableGameSessions -- Unused percentage of the
	// total number of game sessions that a fleet could host simultaneously, given
	// current capacity. Use this metric for a target-based scaling policy.
	//
	//     *
	// PercentIdleInstances -- Percentage of the total number of active instances that
	// are hosting zero game sessions.
	//
	//     * QueueDepth -- Pending game session
	// placement requests, in any queue, where the current fleet is the top-priority
	// destination.
	//
	//     * WaitTime -- Current wait time for pending game session
	// placement requests, in any queue, where the current fleet is the top-priority
	// destination.
	MetricName MetricName
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment *int32
	// Current status of the scaling policy. The scaling policy can be in force only
	// when in an ACTIVE status. Scaling policies can be suspended for individual
	// fleets (see StopFleetActions (); if suspended for a fleet, the policy status
	// does not change. View a fleet's stopped actions by calling DescribeFleetCapacity
	// ().
	//
	//     * ACTIVE -- The scaling policy can be used for auto-scaling a fleet.
	//
	//
	// * UPDATE_REQUESTED -- A request to update the scaling policy has been
	// received.
	//
	//     * UPDATING -- A change is being made to the scaling policy.
	//
	//
	// * DELETE_REQUESTED -- A request to delete the scaling policy has been
	// received.
	//
	//     * DELETING -- The scaling policy is being deleted.
	//
	//     * DELETED
	// -- The scaling policy has been deleted.
	//
	//     * ERROR -- An error occurred in
	// creating the policy. It should be removed and recreated.
	Status ScalingStatusType
	// The settings for a target-based scaling policy.
	TargetConfiguration *TargetConfiguration
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator ComparisonOperatorType
	// A descriptive label that is associated with a scaling policy. Policy names do
	// not need to be unique.
	Name *string
	// Metric value used to trigger a scaling event.
	Threshold *float64
	// The type of adjustment to make to a fleet's instance count (see FleetCapacity
	// ()):
	//
	//     * ChangeInCapacity -- add (or subtract) the scaling adjustment value
	// from the current instance count. Positive values scale up while negative values
	// scale down.
	//
	//     * ExactCapacity -- set the instance count to the scaling
	// adjustment value.
	//
	//     * PercentChangeInCapacity -- increase or reduce the
	// current instance count by the scaling adjustment, read as a percentage. Positive
	// values scale up while negative values scale down.
	ScalingAdjustmentType ScalingAdjustmentType
	// Length of time (in minutes) the metric must be at or beyond the threshold before
	// a scaling event is triggered.
	EvaluationPeriods *int32
	// The type of scaling policy to create. For a target-based policy, set the
	// parameter MetricName to 'PercentAvailableGameSessions' and specify a
	// TargetConfiguration. For a rule-based policy set the following parameters:
	// MetricName, ComparisonOperator, Threshold, EvaluationPeriods,
	// ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType PolicyType
	// A unique identifier for a fleet that is associated with this scaling policy.
	FleetId *string
}

// Properties describing a Realtime script. Related operations
//
//     * CreateScript
// ()
//
//     * ListScripts ()
//
//     * DescribeScript ()
//
//     * UpdateScript ()
//
//     *
// DeleteScript ()
type Script struct {
	// The location in S3 where build or script files are stored for access by Amazon
	// GameLift. This location is specified in CreateBuild (), CreateScript (), and
	// UpdateScript () requests.
	StorageLocation *S3Location
	// The file size of the uploaded Realtime script, expressed in bytes. When files
	// are uploaded from an S3 location, this value remains at "0".
	SizeOnDisk *int64
	// Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// that is assigned to a GameLift script resource and uniquely identifies it. ARNs
	// are unique across all Regions. In a GameLift script ARN, the resource ID matches
	// the ScriptId value.
	ScriptArn *string
	// The version that is associated with a build or script. Version strings do not
	// need to be unique.
	Version *string
	// A time stamp indicating when this data object was created. The format is a
	// number expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
	// A descriptive label that is associated with a script. Script names do not need
	// to be unique.
	Name *string
	// A unique identifier for a Realtime script
	ScriptId *string
}

// A set of instructions for launching server processes on each instance in a
// fleet. Server processes run either a custom game build executable or a Realtime
// Servers script. Each instruction set identifies the location of the custom game
// build executable or Realtime launch script, optional launch parameters, and the
// number of server processes with this configuration to maintain concurrently on
// the instance. Server process configurations make up a fleet's
// RuntimeConfiguration ().
type ServerProcess struct {
	// The number of server processes that use this configuration to run concurrently
	// on an instance.
	ConcurrentExecutions *int32
	// An optional list of parameters to pass to the server executable or Realtime
	// script on launch.
	Parameters *string
	// The location of the server executable in a custom game build or the name of the
	// Realtime script file that contains the Init() function. Game builds and Realtime
	// scripts are installed on instances at the root:
	//
	//     * Windows (for custom game
	// builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	//     * Linux:
	// /local/game. Examples: "/local/game/MyGame/server.exe" or
	// "/local/game/MyRealtimeScript.js"
	LaunchPath *string
}

// A label that can be assigned to a GameLift resource. Learn more Tagging AWS
// Resources (https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in
// the AWS General Reference  AWS Tagging Strategies
// (http://aws.amazon.com/answers/account-management/aws-tagging-strategies/)
// Related operations
//
//     * TagResource ()
//
//     * UntagResource ()
//
//     *
// ListTagsForResource ()
type Tag struct {
	// The key for a developer-defined key:value pair for tagging an AWS resource.
	Key *string
	// The value for a developer-defined key:value pair for tagging an AWS resource.
	Value *string
}

// Settings for a target-based scaling policy (see ScalingPolicy (). A target-based
// policy tracks a particular fleet metric specifies a target value for the metric.
// As player usage changes, the policy triggers Amazon GameLift to adjust capacity
// so that the metric returns to the target value. The target configuration
// specifies settings as needed for the target based policy, including the target
// value.
//
//     * DescribeFleetCapacity ()
//
//     * UpdateFleetCapacity ()
//
//     *
// DescribeEC2InstanceLimits ()
//
//     * Manage scaling policies:
//
//         *
// PutScalingPolicy () (auto-scaling)
//
//         * DescribeScalingPolicies ()
// (auto-scaling)
//
//         * DeleteScalingPolicy () (auto-scaling)
//
//     * Manage
// fleet actions:
//
//         * StartFleetActions ()
//
//         * StopFleetActions ()
type TargetConfiguration struct {
	// Desired value to use with a target-based scaling policy. The value must be
	// relevant for whatever metric the scaling policy is using. For example, in a
	// policy using the metric PercentAvailableGameSessions, the target value should be
	// the preferred size of the fleet's buffer (the percent of capacity that should be
	// idle and ready for new game sessions).
	TargetValue *float64
}

// This data type is part of Amazon GameLift FleetIQ with game server groups, which
// is in preview release and is subject to change. Settings for a target-based
// scaling policy applied to Auto Scaling group. These settings are used to create
// a target-based policy that tracks the GameLift FleetIQ metric
// "PercentUtilizedGameServers" and specifies a target value for the metric. As
// player usage changes, the policy triggers to adjust the game server group
// capacity so that the metric returns to the target value.
type TargetTrackingConfiguration struct {
	// Desired value to use with a game server group target-based scaling policy.
	TargetValue *float64
}

// Represents an authorization for a VPC peering connection between the VPC for an
// Amazon GameLift fleet and another VPC on an account you have access to. This
// authorization must exist and be valid for the peering connection to be
// established. Authorizations are valid for 24 hours after they are issued.
//
//     *
// CreateVpcPeeringAuthorization ()
//
//     * DescribeVpcPeeringAuthorizations ()
//
//
// * DeleteVpcPeeringAuthorization ()
//
//     * CreateVpcPeeringConnection ()
//
//     *
// DescribeVpcPeeringConnections ()
//
//     * DeleteVpcPeeringConnection ()
type VpcPeeringAuthorization struct {
	//
	PeerVpcAwsAccountId *string
	// Time stamp indicating when this authorization expires (24 hours after issuance).
	// Format is a number expressed in Unix time as milliseconds (for example
	// "1469498468.057").
	ExpirationTime *time.Time
	// Time stamp indicating when this authorization was issued. Format is a number
	// expressed in Unix time as milliseconds (for example "1469498468.057").
	CreationTime *time.Time
	// A unique identifier for a VPC with resources to be accessed by your Amazon
	// GameLift fleet. The VPC must be in the same Region where your fleet is deployed.
	// Look up a VPC ID using the VPC Dashboard (https://console.aws.amazon.com/vpc/)
	// in the AWS Management Console. Learn more about VPC peering in VPC Peering with
	// Amazon GameLift Fleets
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html).
	PeerVpcId *string
	// A unique identifier for the AWS account that you use to manage your Amazon
	// GameLift fleet. You can find your Account ID in the AWS Management Console under
	// account settings.
	GameLiftAwsAccountId *string
}

// Represents a peering connection between a VPC on one of your AWS accounts and
// the VPC for your Amazon GameLift fleets. This record may be for an active
// peering connection or a pending connection that has not yet been established.
//
//
// * CreateVpcPeeringAuthorization ()
//
//     * DescribeVpcPeeringAuthorizations ()
//
//
// * DeleteVpcPeeringAuthorization ()
//
//     * CreateVpcPeeringConnection ()
//
//     *
// DescribeVpcPeeringConnections ()
//
//     * DeleteVpcPeeringConnection ()
type VpcPeeringConnection struct {
	// The status information about the connection. Status indicates if a connection is
	// pending, successful, or failed.
	Status *VpcPeeringConnectionStatus
	// A unique identifier that is automatically assigned to the connection record.
	// This ID is referenced in VPC peering connection events, and is used when
	// deleting a connection with DeleteVpcPeeringConnection ().
	VpcPeeringConnectionId *string
	// The Amazon Resource Name (ARN
	// (https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html))
	// associated with the GameLift fleet resource for this connection.
	FleetArn *string
	// CIDR block of IPv4 addresses assigned to the VPC peering connection for the
	// GameLift VPC. The peered VPC also has an IPv4 CIDR block associated with it;
	// these blocks cannot overlap or the peering connection cannot be created.
	IpV4CidrBlock *string
	// A unique identifier for the VPC that contains the Amazon GameLift fleet for this
	// connection. This VPC is managed by Amazon GameLift and does not appear in your
	// AWS account.
	GameLiftVpcId *string
	// A unique identifier for a fleet. This ID determines the ID of the Amazon
	// GameLift VPC for your fleet.
	FleetId *string
	// A unique identifier for a VPC with resources to be accessed by your Amazon
	// GameLift fleet. The VPC must be in the same Region where your fleet is deployed.
	// Look up a VPC ID using the VPC Dashboard (https://console.aws.amazon.com/vpc/)
	// in the AWS Management Console. Learn more about VPC peering in VPC Peering with
	// Amazon GameLift Fleets
	// (https://docs.aws.amazon.com/gamelift/latest/developerguide/vpc-peering.html).
	PeerVpcId *string
}

// Represents status information for a VPC peering connection. Status is associated
// with a VpcPeeringConnection () object. Status codes and messages are provided
// from EC2 (see VpcPeeringConnectionStateReason
// (https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpcPeeringConnectionStateReason.html)).
// Connection status information is also communicated as a fleet Event ().
type VpcPeeringConnectionStatus struct {
	// Code indicating the status of a VPC peering connection.
	Code *string
	// Additional messaging associated with the connection status.
	Message *string
}
