// Code generated by smithy-go-codegen DO NOT EDIT.

package gamelift

import (
	"context"
	awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
	"github.com/aws/aws-sdk-go-v2/aws/retry"
	"github.com/aws/aws-sdk-go-v2/aws/signer/v4"
	"github.com/aws/aws-sdk-go-v2/service/gamelift/types"
	smithy "github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

// Uses FlexMatch to create a game match for a group of players based on custom
// matchmaking rules, and starts a new game for the matched players. Each
// matchmaking request specifies the type of match to build (team configuration,
// rules for an acceptable match, etc.). The request also specifies the players to
// find a match for and where to host the new game session for optimal performance.
// A matchmaking request might start with a single player or a group of players who
// want to play together. FlexMatch finds additional players as needed to fill the
// match. Match type, rules, and the queue used to place a new game session are
// defined in a MatchmakingConfiguration. To start matchmaking, provide a unique
// ticket ID, specify a matchmaking configuration, and include the players to be
// matched. You must also include a set of player attributes relevant for the
// matchmaking configuration. If successful, a matchmaking ticket is returned with
// status set to QUEUED. Track the status of the ticket to respond as needed and
// acquire game session connection information for successfully completed matches.
// Tracking ticket status -- A couple of options are available for tracking the
// status of matchmaking requests:
//
//     * Polling -- Call DescribeMatchmaking. This
// operation returns the full ticket object, including current status and (for
// completed tickets) game session connection info. We recommend polling no more
// than once every 10 seconds.
//
//     * Notifications -- Get event notifications for
// changes in ticket status using Amazon Simple Notification Service (SNS).
// Notifications are easy to set up (see CreateMatchmakingConfiguration ()) and
// typically deliver match status changes faster and more efficiently than polling.
// We recommend that you use polling to back up to notifications (since delivery is
// not guaranteed) and call DescribeMatchmaking only when notifications are not
// received within 30 seconds.
//
// Processing a matchmaking request -- FlexMatch
// handles a matchmaking request as follows:
//
//     * Your client code submits a
// StartMatchmaking request for one or more players and tracks the status of the
// request ticket.
//
//     * FlexMatch uses this ticket and others in process to build
// an acceptable match. When a potential match is identified, all tickets in the
// proposed match are advanced to the next status.
//
//     * If the match requires
// player acceptance (set in the matchmaking configuration), the tickets move into
// status REQUIRES_ACCEPTANCE. This status triggers your client code to solicit
// acceptance from all players in every ticket involved in the match, and then call
// AcceptMatch () for each player. If any player rejects or fails to accept the
// match before a specified timeout, the proposed match is dropped (see AcceptMatch
// for more details).
//
//     * Once a match is proposed and accepted, the matchmaking
// tickets move into status PLACING. FlexMatch locates resources for a new game
// session using the game session queue (set in the matchmaking configuration) and
// creates the game session based on the match data.
//
//     * When the match is
// successfully placed, the matchmaking tickets move into COMPLETED status.
// Connection information (including game session endpoint and player session) is
// added to the matchmaking tickets. Matched players can use the connection
// information to join the game.
//
// Learn more  Add FlexMatch to a Game Client
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-client.html)
// Set Up FlexMatch Event Notification
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-notification.html)
// FlexMatch Integration Roadmap
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-tasks.html)
// How GameLift FlexMatch Works
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-match.html)
// Related operations
//
//     * StartMatchmaking ()
//
//     * DescribeMatchmaking ()
//
//
// * StopMatchmaking ()
//
//     * AcceptMatch ()
//
//     * StartMatchBackfill ()
func (c *Client) StartMatchmaking(ctx context.Context, params *StartMatchmakingInput, optFns ...func(*Options)) (*StartMatchmakingOutput, error) {
	stack := middleware.NewStack("StartMatchmaking", smithyhttp.NewStackRequest)
	options := c.options.Copy()
	for _, fn := range optFns {
		fn(&options)
	}
	addawsAwsjson11_serdeOpStartMatchmakingMiddlewares(stack)
	awsmiddleware.AddRequestInvocationIDMiddleware(stack)
	smithyhttp.AddContentLengthMiddleware(stack)
	AddResolveEndpointMiddleware(stack, options)
	v4.AddComputePayloadSHA256Middleware(stack)
	retry.AddRetryMiddlewares(stack, options)
	addHTTPSignerV4Middleware(stack, options)
	awsmiddleware.AddAttemptClockSkewMiddleware(stack)
	addClientUserAgent(stack)
	smithyhttp.AddErrorCloseResponseBodyMiddleware(stack)
	smithyhttp.AddCloseResponseBodyMiddleware(stack)
	addOpStartMatchmakingValidationMiddleware(stack)
	stack.Initialize.Add(newServiceMetadataMiddleware_opStartMatchmaking(options.Region), middleware.Before)
	addResponseErrorWrapper(stack)

	for _, fn := range options.APIOptions {
		if err := fn(stack); err != nil {
			return nil, err
		}
	}
	handler := middleware.DecorateHandler(smithyhttp.NewClientHandler(options.HTTPClient), stack)
	result, metadata, err := handler.Handle(ctx, params)
	if err != nil {
		return nil, &smithy.OperationError{
			ServiceID:     ServiceID,
			OperationName: "StartMatchmaking",
			Err:           err,
		}
	}
	out := result.(*StartMatchmakingOutput)
	out.ResultMetadata = metadata
	return out, nil
}

// Represents the input for a request action.
type StartMatchmakingInput struct {
	// Name of the matchmaking configuration to use for this request. Matchmaking
	// configurations must exist in the same Region as this request. You can use either
	// the configuration name or ARN value.
	ConfigurationName *string
	// A unique identifier for a matchmaking ticket. If no ticket ID is specified here,
	// Amazon GameLift will generate one in the form of a UUID. Use this identifier to
	// track the matchmaking ticket status and retrieve match results.
	TicketId *string
	// Information on each player to be matched. This information must include a player
	// ID, and may contain player attributes and latency data to be used in the
	// matchmaking process. After a successful match, Player objects contain the name
	// of the team the player is assigned to.
	Players []*types.Player
}

// Represents the returned data in response to a request action.
type StartMatchmakingOutput struct {
	// Ticket representing the matchmaking request. This object include the information
	// included in the request, ticket status, and match results as generated during
	// the matchmaking process.
	MatchmakingTicket *types.MatchmakingTicket

	// Metadata pertaining to the operation's result.
	ResultMetadata middleware.Metadata
}

func addawsAwsjson11_serdeOpStartMatchmakingMiddlewares(stack *middleware.Stack) {
	stack.Serialize.Add(&awsAwsjson11_serializeOpStartMatchmaking{}, middleware.After)
	stack.Deserialize.Add(&awsAwsjson11_deserializeOpStartMatchmaking{}, middleware.After)
}

func newServiceMetadataMiddleware_opStartMatchmaking(region string) awsmiddleware.RegisterServiceMetadata {
	return awsmiddleware.RegisterServiceMetadata{
		Region:        region,
		ServiceID:     ServiceID,
		SigningName:   "gamelift",
		OperationName: "StartMatchmaking",
	}
}
