// Code generated by smithy-go-codegen DO NOT EDIT.

package gamelift

import (
	"context"
	awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
	"github.com/aws/aws-sdk-go-v2/aws/signer/v4"
	"github.com/aws/aws-sdk-go-v2/service/gamelift/types"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

// Uses FlexMatch to create a game match for a group of players based on custom
// matchmaking rules, and starts a new game for the matched players. Each
// matchmaking request specifies the type of match to build (team configuration,
// rules for an acceptable match, etc.). The request also specifies the players to
// find a match for and where to host the new game session for optimal performance.
// A matchmaking request might start with a single player or a group of players who
// want to play together. FlexMatch finds additional players as needed to fill the
// match. Match type, rules, and the queue used to place a new game session are
// defined in a MatchmakingConfiguration. To start matchmaking, provide a unique
// ticket ID, specify a matchmaking configuration, and include the players to be
// matched. You must also include a set of player attributes relevant for the
// matchmaking configuration. If successful, a matchmaking ticket is returned with
// status set to QUEUED. Track the status of the ticket to respond as needed and
// acquire game session connection information for successfully completed matches.
// Tracking ticket status -- A couple of options are available for tracking the
// status of matchmaking requests:
//
//     * Polling -- Call DescribeMatchmaking. This
// operation returns the full ticket object, including current status and (for
// completed tickets) game session connection info. We recommend polling no more
// than once every 10 seconds.
//
//     * Notifications -- Get event notifications for
// changes in ticket status using Amazon Simple Notification Service (SNS).
// Notifications are easy to set up (see CreateMatchmakingConfiguration) and
// typically deliver match status changes faster and more efficiently than polling.
// We recommend that you use polling to back up to notifications (since delivery is
// not guaranteed) and call DescribeMatchmaking only when notifications are not
// received within 30 seconds.
//
// Processing a matchmaking request -- FlexMatch
// handles a matchmaking request as follows:
//
//     * Your client code submits a
// StartMatchmaking request for one or more players and tracks the status of the
// request ticket.
//
//     * FlexMatch uses this ticket and others in process to build
// an acceptable match. When a potential match is identified, all tickets in the
// proposed match are advanced to the next status.
//
//     * If the match requires
// player acceptance (set in the matchmaking configuration), the tickets move into
// status REQUIRES_ACCEPTANCE. This status triggers your client code to solicit
// acceptance from all players in every ticket involved in the match, and then call
// AcceptMatch for each player. If any player rejects or fails to accept the match
// before a specified timeout, the proposed match is dropped (see AcceptMatch for
// more details).
//
//     * Once a match is proposed and accepted, the matchmaking
// tickets move into status PLACING. FlexMatch locates resources for a new game
// session using the game session queue (set in the matchmaking configuration) and
// creates the game session based on the match data.
//
//     * When the match is
// successfully placed, the matchmaking tickets move into COMPLETED status.
// Connection information (including game session endpoint and player session) is
// added to the matchmaking tickets. Matched players can use the connection
// information to join the game.
//
// Learn more  Add FlexMatch to a Game Client
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-client.html)
// Set Up FlexMatch Event Notification
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-notification.html)
// FlexMatch Integration Roadmap
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-tasks.html)
// How GameLift FlexMatch Works
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-match.html)
// Related operations
//
//     * StartMatchmaking
//
//     * DescribeMatchmaking
//
//     *
// StopMatchmaking
//
//     * AcceptMatch
//
//     * StartMatchBackfill
func (c *Client) StartMatchmaking(ctx context.Context, params *StartMatchmakingInput, optFns ...func(*Options)) (*StartMatchmakingOutput, error) {
	if params == nil {
		params = &StartMatchmakingInput{}
	}

	result, metadata, err := c.invokeOperation(ctx, "StartMatchmaking", params, optFns, addOperationStartMatchmakingMiddlewares)
	if err != nil {
		return nil, err
	}

	out := result.(*StartMatchmakingOutput)
	out.ResultMetadata = metadata
	return out, nil
}

// Represents the input for a request action.
type StartMatchmakingInput struct {

	// Name of the matchmaking configuration to use for this request. Matchmaking
	// configurations must exist in the same Region as this request. You can use either
	// the configuration name or ARN value.
	//
	// This member is required.
	ConfigurationName *string

	// Information on each player to be matched. This information must include a player
	// ID, and may contain player attributes and latency data to be used in the
	// matchmaking process. After a successful match, Player objects contain the name
	// of the team the player is assigned to.
	//
	// This member is required.
	Players []*types.Player

	// A unique identifier for a matchmaking ticket. If no ticket ID is specified here,
	// Amazon GameLift will generate one in the form of a UUID. Use this identifier to
	// track the matchmaking ticket status and retrieve match results.
	TicketId *string
}

// Represents the returned data in response to a request action.
type StartMatchmakingOutput struct {

	// Ticket representing the matchmaking request. This object include the information
	// included in the request, ticket status, and match results as generated during
	// the matchmaking process.
	MatchmakingTicket *types.MatchmakingTicket

	// Metadata pertaining to the operation's result.
	ResultMetadata middleware.Metadata
}

func addOperationStartMatchmakingMiddlewares(stack *middleware.Stack, options Options) (err error) {
	err = stack.Serialize.Add(&awsAwsjson11_serializeOpStartMatchmaking{}, middleware.After)
	if err != nil {
		return err
	}
	err = stack.Deserialize.Add(&awsAwsjson11_deserializeOpStartMatchmaking{}, middleware.After)
	if err != nil {
		return err
	}
	awsmiddleware.AddRequestInvocationIDMiddleware(stack)
	smithyhttp.AddContentLengthMiddleware(stack)
	addResolveEndpointMiddleware(stack, options)
	v4.AddComputePayloadSHA256Middleware(stack)
	addRetryMiddlewares(stack, options)
	addHTTPSignerV4Middleware(stack, options)
	awsmiddleware.AddAttemptClockSkewMiddleware(stack)
	addClientUserAgent(stack)
	smithyhttp.AddErrorCloseResponseBodyMiddleware(stack)
	smithyhttp.AddCloseResponseBodyMiddleware(stack)
	addOpStartMatchmakingValidationMiddleware(stack)
	stack.Initialize.Add(newServiceMetadataMiddleware_opStartMatchmaking(options.Region), middleware.Before)
	addRequestIDRetrieverMiddleware(stack)
	addResponseErrorMiddleware(stack)
	return nil
}

func newServiceMetadataMiddleware_opStartMatchmaking(region string) awsmiddleware.RegisterServiceMetadata {
	return awsmiddleware.RegisterServiceMetadata{
		Region:        region,
		ServiceID:     ServiceID,
		SigningName:   "gamelift",
		OperationName: "StartMatchmaking",
	}
}
