// Code generated by smithy-go-codegen DO NOT EDIT.

package gamelift

import (
	"context"
	awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
	"github.com/aws/aws-sdk-go-v2/aws/signer/v4"
	"github.com/aws/aws-sdk-go-v2/service/gamelift/types"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

// Uses FlexMatch to create a game match for a group of players based on custom
// matchmaking rules, and starts a new game for the matched players. Each
// matchmaking request specifies the type of match to build (team configuration,
// rules for an acceptable match, etc.). The request also specifies the players to
// find a match for and where to host the new game session for optimal performance.
// A matchmaking request might start with a single player or a group of players who
// want to play together. FlexMatch finds additional players as needed to fill the
// match. Match type, rules, and the queue used to place a new game session are
// defined in a MatchmakingConfiguration. To start matchmaking, provide a unique
// ticket ID, specify a matchmaking configuration, and include the players to be
// matched. You must also include a set of player attributes relevant for the
// matchmaking configuration. If successful, a matchmaking ticket is returned with
// status set to QUEUED. Track the status of the ticket to respond as needed and
// acquire game session connection information for successfully completed matches.
// Ticket status updates are tracked using event notification through Amazon Simple
// Notification Service (SNS), which is defined in the matchmaking configuration.
// Processing a matchmaking request -- FlexMatch handles a matchmaking request as
// follows:
//
// * Your client code submits a StartMatchmaking request for one or more
// players and tracks the status of the request ticket.
//
// * FlexMatch uses this
// ticket and others in process to build an acceptable match. When a potential
// match is identified, all tickets in the proposed match are advanced to the next
// status.
//
// * If the match requires player acceptance (set in the matchmaking
// configuration), the tickets move into status REQUIRES_ACCEPTANCE. This status
// triggers your client code to solicit acceptance from all players in every ticket
// involved in the match, and then call AcceptMatch for each player. If any player
// rejects or fails to accept the match before a specified timeout, the proposed
// match is dropped (see AcceptMatch for more details).
//
// * Once a match is proposed
// and accepted, the matchmaking tickets move into status PLACING. FlexMatch
// locates resources for a new game session using the game session queue (set in
// the matchmaking configuration) and creates the game session based on the match
// data.
//
// * When the match is successfully placed, the matchmaking tickets move
// into COMPLETED status. Connection information (including game session endpoint
// and player session) is added to the matchmaking tickets. Matched players can use
// the connection information to join the game.
//
// Learn more  Add FlexMatch to a
// Game Client
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-client.html)
// Set Up FlexMatch Event Notification
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-notification.html)
// FlexMatch Integration Roadmap
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/match-tasks.html)
// How GameLift FlexMatch Works
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-match.html)
// Related operations
//
// * StartMatchmaking
//
// * DescribeMatchmaking
//
// *
// StopMatchmaking
//
// * AcceptMatch
//
// * StartMatchBackfill
func (c *Client) StartMatchmaking(ctx context.Context, params *StartMatchmakingInput, optFns ...func(*Options)) (*StartMatchmakingOutput, error) {
	if params == nil {
		params = &StartMatchmakingInput{}
	}

	result, metadata, err := c.invokeOperation(ctx, "StartMatchmaking", params, optFns, addOperationStartMatchmakingMiddlewares)
	if err != nil {
		return nil, err
	}

	out := result.(*StartMatchmakingOutput)
	out.ResultMetadata = metadata
	return out, nil
}

// Represents the input for a request operation.
type StartMatchmakingInput struct {

	// Name of the matchmaking configuration to use for this request. Matchmaking
	// configurations must exist in the same Region as this request. You can use either
	// the configuration name or ARN value.
	//
	// This member is required.
	ConfigurationName *string

	// Information on each player to be matched. This information must include a player
	// ID, and may contain player attributes and latency data to be used in the
	// matchmaking process. After a successful match, Player objects contain the name
	// of the team the player is assigned to.
	//
	// This member is required.
	Players []types.Player

	// A unique identifier for a matchmaking ticket. If no ticket ID is specified here,
	// Amazon GameLift will generate one in the form of a UUID. Use this identifier to
	// track the matchmaking ticket status and retrieve match results.
	TicketId *string
}

// Represents the returned data in response to a request operation.
type StartMatchmakingOutput struct {

	// Ticket representing the matchmaking request. This object include the information
	// included in the request, ticket status, and match results as generated during
	// the matchmaking process.
	MatchmakingTicket *types.MatchmakingTicket

	// Metadata pertaining to the operation's result.
	ResultMetadata middleware.Metadata
}

func addOperationStartMatchmakingMiddlewares(stack *middleware.Stack, options Options) (err error) {
	err = stack.Serialize.Add(&awsAwsjson11_serializeOpStartMatchmaking{}, middleware.After)
	if err != nil {
		return err
	}
	err = stack.Deserialize.Add(&awsAwsjson11_deserializeOpStartMatchmaking{}, middleware.After)
	if err != nil {
		return err
	}
	if err = addSetLoggerMiddleware(stack, options); err != nil {
		return err
	}
	if err = awsmiddleware.AddClientRequestIDMiddleware(stack); err != nil {
		return err
	}
	if err = smithyhttp.AddComputeContentLengthMiddleware(stack); err != nil {
		return err
	}
	if err = addResolveEndpointMiddleware(stack, options); err != nil {
		return err
	}
	if err = v4.AddComputePayloadSHA256Middleware(stack); err != nil {
		return err
	}
	if err = addRetryMiddlewares(stack, options); err != nil {
		return err
	}
	if err = addHTTPSignerV4Middleware(stack, options); err != nil {
		return err
	}
	if err = awsmiddleware.AddAttemptClockSkewMiddleware(stack); err != nil {
		return err
	}
	if err = addClientUserAgent(stack); err != nil {
		return err
	}
	if err = smithyhttp.AddErrorCloseResponseBodyMiddleware(stack); err != nil {
		return err
	}
	if err = smithyhttp.AddCloseResponseBodyMiddleware(stack); err != nil {
		return err
	}
	if err = addOpStartMatchmakingValidationMiddleware(stack); err != nil {
		return err
	}
	if err = stack.Initialize.Add(newServiceMetadataMiddleware_opStartMatchmaking(options.Region), middleware.Before); err != nil {
		return err
	}
	if err = addRequestIDRetrieverMiddleware(stack); err != nil {
		return err
	}
	if err = addResponseErrorMiddleware(stack); err != nil {
		return err
	}
	if err = addRequestResponseLogging(stack, options); err != nil {
		return err
	}
	return nil
}

func newServiceMetadataMiddleware_opStartMatchmaking(region string) *awsmiddleware.RegisterServiceMetadata {
	return &awsmiddleware.RegisterServiceMetadata{
		Region:        region,
		ServiceID:     ServiceID,
		SigningName:   "gamelift",
		OperationName: "StartMatchmaking",
	}
}
