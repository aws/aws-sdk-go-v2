// Code generated by smithy-go-codegen DO NOT EDIT.

package gamelift

import (
	"context"
	awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
	"github.com/aws/aws-sdk-go-v2/aws/retry"
	"github.com/aws/aws-sdk-go-v2/aws/signer/v4"
	"github.com/aws/aws-sdk-go-v2/service/gamelift/types"
	smithy "github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

// Establishes a new queue for processing requests to place new game sessions. A
// queue identifies where new game sessions can be hosted -- by specifying a list
// of destinations (fleets or aliases) -- and how long requests can wait in the
// queue before timing out. You can set up a queue to try to place game sessions on
// fleets in multiple Regions. To add placement requests to a queue, call
// StartGameSessionPlacement () and reference the queue name. Destination order.
// When processing a request for a game session, Amazon GameLift tries each
// destination in order until it finds one with available resources to host the new
// game session. A queue's default order is determined by how destinations are
// listed. The default order is overridden when a game session placement request
// provides player latency information. Player latency information enables Amazon
// GameLift to prioritize destinations where players report the lowest average
// latency, as a result placing the new game session where the majority of players
// will have the best possible gameplay experience. Player latency policies. For
// placement requests containing player latency information, use player latency
// policies to protect individual players from very high latencies. With a latency
// cap, even when a destination can deliver a low latency for most players, the
// game is not placed where any individual player is reporting latency higher than
// a policy's maximum. A queue can have multiple latency policies, which are
// enforced consecutively starting with the policy with the lowest latency cap. Use
// multiple policies to gradually relax latency controls; for example, you might
// set a policy with a low latency cap for the first 60 seconds, a second policy
// with a higher cap for the next 60 seconds, etc. To create a new queue, provide a
// name, timeout value, a list of destinations and, if desired, a set of latency
// policies. If successful, a new queue object is returned. Learn more  Design a
// Game Session Queue
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/queues-design.html)
// Create a Game Session Queue
// (https://docs.aws.amazon.com/gamelift/latest/developerguide/queues-creating.html)
// Related operations
//
//     * CreateGameSessionQueue ()
//
//     *
// DescribeGameSessionQueues ()
//
//     * UpdateGameSessionQueue ()
//
//     *
// DeleteGameSessionQueue ()
func (c *Client) CreateGameSessionQueue(ctx context.Context, params *CreateGameSessionQueueInput, optFns ...func(*Options)) (*CreateGameSessionQueueOutput, error) {
	stack := middleware.NewStack("CreateGameSessionQueue", smithyhttp.NewStackRequest)
	options := c.options.Copy()
	for _, fn := range optFns {
		fn(&options)
	}
	addawsAwsjson11_serdeOpCreateGameSessionQueueMiddlewares(stack)
	awsmiddleware.AddRequestInvocationIDMiddleware(stack)
	smithyhttp.AddContentLengthMiddleware(stack)
	AddResolveEndpointMiddleware(stack, options)
	v4.AddComputePayloadSHA256Middleware(stack)
	retry.AddRetryMiddlewares(stack, options)
	addHTTPSignerV4Middleware(stack, options)
	awsmiddleware.AddAttemptClockSkewMiddleware(stack)
	addClientUserAgent(stack)
	smithyhttp.AddErrorCloseResponseBodyMiddleware(stack)
	smithyhttp.AddCloseResponseBodyMiddleware(stack)
	addOpCreateGameSessionQueueValidationMiddleware(stack)
	stack.Initialize.Add(newServiceMetadataMiddleware_opCreateGameSessionQueue(options.Region), middleware.Before)

	for _, fn := range options.APIOptions {
		if err := fn(stack); err != nil {
			return nil, err
		}
	}
	handler := middleware.DecorateHandler(smithyhttp.NewClientHandler(options.HTTPClient), stack)
	result, metadata, err := handler.Handle(ctx, params)
	if err != nil {
		return nil, &smithy.OperationError{
			ServiceID:     ServiceID,
			OperationName: "CreateGameSessionQueue",
			Err:           err,
		}
	}
	out := result.(*CreateGameSessionQueueOutput)
	out.ResultMetadata = metadata
	return out, nil
}

// Represents the input for a request action.
type CreateGameSessionQueueInput struct {
	// A list of labels to assign to the new game session queue resource. Tags are
	// developer-defined key-value pairs. Tagging AWS resources are useful for resource
	// management, access management and cost allocation. For more information, see
	// Tagging AWS Resources
	// (https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the AWS
	// General Reference. Once the resource is created, you can use TagResource (),
	// UntagResource (), and ListTagsForResource () to add, remove, and view tags. The
	// maximum tag limit may be lower than stated. See the AWS General Reference for
	// actual tagging limits.
	Tags []*types.Tag
	// A descriptive label that is associated with game session queue. Queue names must
	// be unique within each Region.
	Name *string
	// A list of fleets that can be used to fulfill game session placement requests in
	// the queue. Fleets are identified by either a fleet ARN or a fleet alias ARN.
	// Destinations are listed in default preference order.
	Destinations []*types.GameSessionQueueDestination
	// The maximum time, in seconds, that a new game session placement request remains
	// in the queue. When a request exceeds this time, the game session placement
	// changes to a TIMED_OUT status.
	TimeoutInSeconds *int32
	// A collection of latency policies to apply when processing game sessions
	// placement requests with player latency information. Multiple policies are
	// evaluated in order of the maximum latency value, starting with the lowest
	// latency values. With just one policy, the policy is enforced at the start of the
	// game session placement for the duration period. With multiple policies, each
	// policy is enforced consecutively for its duration period. For example, a queue
	// might enforce a 60-second policy followed by a 120-second policy, and then no
	// policy for the remainder of the placement. A player latency policy must set a
	// value for MaximumIndividualPlayerLatencyMilliseconds. If none is set, this API
	// request fails.
	PlayerLatencyPolicies []*types.PlayerLatencyPolicy
}

// Represents the returned data in response to a request action.
type CreateGameSessionQueueOutput struct {
	// An object that describes the newly created game session queue.
	GameSessionQueue *types.GameSessionQueue

	// Metadata pertaining to the operation's result.
	ResultMetadata middleware.Metadata
}

func addawsAwsjson11_serdeOpCreateGameSessionQueueMiddlewares(stack *middleware.Stack) {
	stack.Serialize.Add(&awsAwsjson11_serializeOpCreateGameSessionQueue{}, middleware.After)
	stack.Deserialize.Add(&awsAwsjson11_deserializeOpCreateGameSessionQueue{}, middleware.After)
}

func newServiceMetadataMiddleware_opCreateGameSessionQueue(region string) awsmiddleware.RegisterServiceMetadata {
	return awsmiddleware.RegisterServiceMetadata{
		Region:        region,
		ServiceID:     ServiceID,
		SigningName:   "gamelift",
		OperationName: "CreateGameSessionQueue",
	}
}
