// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package machinelearning

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
)

const opAddTags = "AddTags"

// AddTagsRequest is a API request type for the AddTags API operation.
type AddTagsRequest struct {
	*aws.Request
	Input *AddTagsInput
	Copy  func(*AddTagsInput) AddTagsRequest
}

// Send marshals and sends the AddTags API request.
func (r AddTagsRequest) Send() (*AddTagsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AddTagsOutput), nil
}

// AddTagsRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Adds one or more tags to an object, up to a limit of 10. Each tag consists
// of a key and an optional value. If you add a tag using a key that is already
// associated with the ML object, AddTags updates the tag's value.
//
//    // Example sending a request using the AddTagsRequest method.
//    req := client.AddTagsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) AddTagsRequest(input *AddTagsInput) AddTagsRequest {
	op := &aws.Operation{
		Name:       opAddTags,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &AddTagsInput{}
	}

	output := &AddTagsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AddTagsRequest{Request: req, Input: input, Copy: c.AddTagsRequest}
}

const opCreateBatchPrediction = "CreateBatchPrediction"

// CreateBatchPredictionRequest is a API request type for the CreateBatchPrediction API operation.
type CreateBatchPredictionRequest struct {
	*aws.Request
	Input *CreateBatchPredictionInput
	Copy  func(*CreateBatchPredictionInput) CreateBatchPredictionRequest
}

// Send marshals and sends the CreateBatchPrediction API request.
func (r CreateBatchPredictionRequest) Send() (*CreateBatchPredictionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateBatchPredictionOutput), nil
}

// CreateBatchPredictionRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Generates predictions for a group of observations. The observations to process
// exist in one or more data files referenced by a DataSource. This operation
// creates a new BatchPrediction, and uses an MLModel and the data files referenced
// by the DataSource as information sources.
//
// CreateBatchPrediction is an asynchronous operation. In response to CreateBatchPrediction,
// Amazon Machine Learning (Amazon ML) immediately returns and sets the BatchPrediction
// status to PENDING. After the BatchPrediction completes, Amazon ML sets the
// status to COMPLETED.
//
// You can poll for status updates by using the GetBatchPrediction operation
// and checking the Status parameter of the result. After the COMPLETED status
// appears, the results are available in the location specified by the OutputUri
// parameter.
//
//    // Example sending a request using the CreateBatchPredictionRequest method.
//    req := client.CreateBatchPredictionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) CreateBatchPredictionRequest(input *CreateBatchPredictionInput) CreateBatchPredictionRequest {
	op := &aws.Operation{
		Name:       opCreateBatchPrediction,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateBatchPredictionInput{}
	}

	output := &CreateBatchPredictionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBatchPredictionRequest{Request: req, Input: input, Copy: c.CreateBatchPredictionRequest}
}

const opCreateDataSourceFromRDS = "CreateDataSourceFromRDS"

// CreateDataSourceFromRDSRequest is a API request type for the CreateDataSourceFromRDS API operation.
type CreateDataSourceFromRDSRequest struct {
	*aws.Request
	Input *CreateDataSourceFromRDSInput
	Copy  func(*CreateDataSourceFromRDSInput) CreateDataSourceFromRDSRequest
}

// Send marshals and sends the CreateDataSourceFromRDS API request.
func (r CreateDataSourceFromRDSRequest) Send() (*CreateDataSourceFromRDSOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateDataSourceFromRDSOutput), nil
}

// CreateDataSourceFromRDSRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Creates a DataSource object from an  Amazon Relational Database Service (http://aws.amazon.com/rds/)
// (Amazon RDS). A DataSource references data that can be used to perform CreateMLModel,
// CreateEvaluation, or CreateBatchPrediction operations.
//
// CreateDataSourceFromRDS is an asynchronous operation. In response to CreateDataSourceFromRDS,
// Amazon Machine Learning (Amazon ML) immediately returns and sets the DataSource
// status to PENDING. After the DataSource is created and ready for use, Amazon
// ML sets the Status parameter to COMPLETED. DataSource in the COMPLETED or
// PENDING state can be used only to perform >CreateMLModel>, CreateEvaluation,
// or CreateBatchPrediction operations.
//
// If Amazon ML cannot accept the input source, it sets the Status parameter
// to FAILED and includes an error message in the Message attribute of the GetDataSource
// operation response.
//
//    // Example sending a request using the CreateDataSourceFromRDSRequest method.
//    req := client.CreateDataSourceFromRDSRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) CreateDataSourceFromRDSRequest(input *CreateDataSourceFromRDSInput) CreateDataSourceFromRDSRequest {
	op := &aws.Operation{
		Name:       opCreateDataSourceFromRDS,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateDataSourceFromRDSInput{}
	}

	output := &CreateDataSourceFromRDSOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDataSourceFromRDSRequest{Request: req, Input: input, Copy: c.CreateDataSourceFromRDSRequest}
}

const opCreateDataSourceFromRedshift = "CreateDataSourceFromRedshift"

// CreateDataSourceFromRedshiftRequest is a API request type for the CreateDataSourceFromRedshift API operation.
type CreateDataSourceFromRedshiftRequest struct {
	*aws.Request
	Input *CreateDataSourceFromRedshiftInput
	Copy  func(*CreateDataSourceFromRedshiftInput) CreateDataSourceFromRedshiftRequest
}

// Send marshals and sends the CreateDataSourceFromRedshift API request.
func (r CreateDataSourceFromRedshiftRequest) Send() (*CreateDataSourceFromRedshiftOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateDataSourceFromRedshiftOutput), nil
}

// CreateDataSourceFromRedshiftRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Creates a DataSource from a database hosted on an Amazon Redshift cluster.
// A DataSource references data that can be used to perform either CreateMLModel,
// CreateEvaluation, or CreateBatchPrediction operations.
//
// CreateDataSourceFromRedshift is an asynchronous operation. In response to
// CreateDataSourceFromRedshift, Amazon Machine Learning (Amazon ML) immediately
// returns and sets the DataSource status to PENDING. After the DataSource is
// created and ready for use, Amazon ML sets the Status parameter to COMPLETED.
// DataSource in COMPLETED or PENDING states can be used to perform only CreateMLModel,
// CreateEvaluation, or CreateBatchPrediction operations.
//
// If Amazon ML can't accept the input source, it sets the Status parameter
// to FAILED and includes an error message in the Message attribute of the GetDataSource
// operation response.
//
// The observations should be contained in the database hosted on an Amazon
// Redshift cluster and should be specified by a SelectSqlQuery query. Amazon
// ML executes an Unload command in Amazon Redshift to transfer the result set
// of the SelectSqlQuery query to S3StagingLocation.
//
// After the DataSource has been created, it's ready for use in evaluations
// and batch predictions. If you plan to use the DataSource to train an MLModel,
// the DataSource also requires a recipe. A recipe describes how each input
// variable will be used in training an MLModel. Will the variable be included
// or excluded from training? Will the variable be manipulated; for example,
// will it be combined with another variable or will it be split apart into
// word combinations? The recipe provides answers to these questions.
//
// You can't change an existing datasource, but you can copy and modify the
// settings from an existing Amazon Redshift datasource to create a new datasource.
// To do so, call GetDataSource for an existing datasource and copy the values
// to a CreateDataSource call. Change the settings that you want to change and
// make sure that all required fields have the appropriate values.
//
//    // Example sending a request using the CreateDataSourceFromRedshiftRequest method.
//    req := client.CreateDataSourceFromRedshiftRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) CreateDataSourceFromRedshiftRequest(input *CreateDataSourceFromRedshiftInput) CreateDataSourceFromRedshiftRequest {
	op := &aws.Operation{
		Name:       opCreateDataSourceFromRedshift,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateDataSourceFromRedshiftInput{}
	}

	output := &CreateDataSourceFromRedshiftOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDataSourceFromRedshiftRequest{Request: req, Input: input, Copy: c.CreateDataSourceFromRedshiftRequest}
}

const opCreateDataSourceFromS3 = "CreateDataSourceFromS3"

// CreateDataSourceFromS3Request is a API request type for the CreateDataSourceFromS3 API operation.
type CreateDataSourceFromS3Request struct {
	*aws.Request
	Input *CreateDataSourceFromS3Input
	Copy  func(*CreateDataSourceFromS3Input) CreateDataSourceFromS3Request
}

// Send marshals and sends the CreateDataSourceFromS3 API request.
func (r CreateDataSourceFromS3Request) Send() (*CreateDataSourceFromS3Output, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateDataSourceFromS3Output), nil
}

// CreateDataSourceFromS3Request returns a request value for making API operation for
// Amazon Machine Learning.
//
// Creates a DataSource object. A DataSource references data that can be used
// to perform CreateMLModel, CreateEvaluation, or CreateBatchPrediction operations.
//
// CreateDataSourceFromS3 is an asynchronous operation. In response to CreateDataSourceFromS3,
// Amazon Machine Learning (Amazon ML) immediately returns and sets the DataSource
// status to PENDING. After the DataSource has been created and is ready for
// use, Amazon ML sets the Status parameter to COMPLETED. DataSource in the
// COMPLETED or PENDING state can be used to perform only CreateMLModel, CreateEvaluation
// or CreateBatchPrediction operations.
//
// If Amazon ML can't accept the input source, it sets the Status parameter
// to FAILED and includes an error message in the Message attribute of the GetDataSource
// operation response.
//
// The observation data used in a DataSource should be ready to use; that is,
// it should have a consistent structure, and missing data values should be
// kept to a minimum. The observation data must reside in one or more .csv files
// in an Amazon Simple Storage Service (Amazon S3) location, along with a schema
// that describes the data items by name and type. The same schema must be used
// for all of the data files referenced by the DataSource.
//
// After the DataSource has been created, it's ready to use in evaluations and
// batch predictions. If you plan to use the DataSource to train an MLModel,
// the DataSource also needs a recipe. A recipe describes how each input variable
// will be used in training an MLModel. Will the variable be included or excluded
// from training? Will the variable be manipulated; for example, will it be
// combined with another variable or will it be split apart into word combinations?
// The recipe provides answers to these questions.
//
//    // Example sending a request using the CreateDataSourceFromS3Request method.
//    req := client.CreateDataSourceFromS3Request(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) CreateDataSourceFromS3Request(input *CreateDataSourceFromS3Input) CreateDataSourceFromS3Request {
	op := &aws.Operation{
		Name:       opCreateDataSourceFromS3,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateDataSourceFromS3Input{}
	}

	output := &CreateDataSourceFromS3Output{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDataSourceFromS3Request{Request: req, Input: input, Copy: c.CreateDataSourceFromS3Request}
}

const opCreateEvaluation = "CreateEvaluation"

// CreateEvaluationRequest is a API request type for the CreateEvaluation API operation.
type CreateEvaluationRequest struct {
	*aws.Request
	Input *CreateEvaluationInput
	Copy  func(*CreateEvaluationInput) CreateEvaluationRequest
}

// Send marshals and sends the CreateEvaluation API request.
func (r CreateEvaluationRequest) Send() (*CreateEvaluationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateEvaluationOutput), nil
}

// CreateEvaluationRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Creates a new Evaluation of an MLModel. An MLModel is evaluated on a set
// of observations associated to a DataSource. Like a DataSource for an MLModel,
// the DataSource for an Evaluation contains values for the Target Variable.
// The Evaluation compares the predicted result for each observation to the
// actual outcome and provides a summary so that you know how effective the
// MLModel functions on the test data. Evaluation generates a relevant performance
// metric, such as BinaryAUC, RegressionRMSE or MulticlassAvgFScore based on
// the corresponding MLModelType: BINARY, REGRESSION or MULTICLASS.
//
// CreateEvaluation is an asynchronous operation. In response to CreateEvaluation,
// Amazon Machine Learning (Amazon ML) immediately returns and sets the evaluation
// status to PENDING. After the Evaluation is created and ready for use, Amazon
// ML sets the status to COMPLETED.
//
// You can use the GetEvaluation operation to check progress of the evaluation
// during the creation operation.
//
//    // Example sending a request using the CreateEvaluationRequest method.
//    req := client.CreateEvaluationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) CreateEvaluationRequest(input *CreateEvaluationInput) CreateEvaluationRequest {
	op := &aws.Operation{
		Name:       opCreateEvaluation,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateEvaluationInput{}
	}

	output := &CreateEvaluationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateEvaluationRequest{Request: req, Input: input, Copy: c.CreateEvaluationRequest}
}

const opCreateMLModel = "CreateMLModel"

// CreateMLModelRequest is a API request type for the CreateMLModel API operation.
type CreateMLModelRequest struct {
	*aws.Request
	Input *CreateMLModelInput
	Copy  func(*CreateMLModelInput) CreateMLModelRequest
}

// Send marshals and sends the CreateMLModel API request.
func (r CreateMLModelRequest) Send() (*CreateMLModelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateMLModelOutput), nil
}

// CreateMLModelRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Creates a new MLModel using the DataSource and the recipe as information
// sources.
//
// An MLModel is nearly immutable. Users can update only the MLModelName and
// the ScoreThreshold in an MLModel without creating a new MLModel.
//
// CreateMLModel is an asynchronous operation. In response to CreateMLModel,
// Amazon Machine Learning (Amazon ML) immediately returns and sets the MLModel
// status to PENDING. After the MLModel has been created and ready is for use,
// Amazon ML sets the status to COMPLETED.
//
// You can use the GetMLModel operation to check the progress of the MLModel
// during the creation operation.
//
// CreateMLModel requires a DataSource with computed statistics, which can be
// created by setting ComputeStatistics to true in CreateDataSourceFromRDS,
// CreateDataSourceFromS3, or CreateDataSourceFromRedshift operations.
//
//    // Example sending a request using the CreateMLModelRequest method.
//    req := client.CreateMLModelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) CreateMLModelRequest(input *CreateMLModelInput) CreateMLModelRequest {
	op := &aws.Operation{
		Name:       opCreateMLModel,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateMLModelInput{}
	}

	output := &CreateMLModelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateMLModelRequest{Request: req, Input: input, Copy: c.CreateMLModelRequest}
}

const opCreateRealtimeEndpoint = "CreateRealtimeEndpoint"

// CreateRealtimeEndpointRequest is a API request type for the CreateRealtimeEndpoint API operation.
type CreateRealtimeEndpointRequest struct {
	*aws.Request
	Input *CreateRealtimeEndpointInput
	Copy  func(*CreateRealtimeEndpointInput) CreateRealtimeEndpointRequest
}

// Send marshals and sends the CreateRealtimeEndpoint API request.
func (r CreateRealtimeEndpointRequest) Send() (*CreateRealtimeEndpointOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateRealtimeEndpointOutput), nil
}

// CreateRealtimeEndpointRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Creates a real-time endpoint for the MLModel. The endpoint contains the URI
// of the MLModel; that is, the location to send real-time prediction requests
// for the specified MLModel.
//
//    // Example sending a request using the CreateRealtimeEndpointRequest method.
//    req := client.CreateRealtimeEndpointRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) CreateRealtimeEndpointRequest(input *CreateRealtimeEndpointInput) CreateRealtimeEndpointRequest {
	op := &aws.Operation{
		Name:       opCreateRealtimeEndpoint,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateRealtimeEndpointInput{}
	}

	output := &CreateRealtimeEndpointOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateRealtimeEndpointRequest{Request: req, Input: input, Copy: c.CreateRealtimeEndpointRequest}
}

const opDeleteBatchPrediction = "DeleteBatchPrediction"

// DeleteBatchPredictionRequest is a API request type for the DeleteBatchPrediction API operation.
type DeleteBatchPredictionRequest struct {
	*aws.Request
	Input *DeleteBatchPredictionInput
	Copy  func(*DeleteBatchPredictionInput) DeleteBatchPredictionRequest
}

// Send marshals and sends the DeleteBatchPrediction API request.
func (r DeleteBatchPredictionRequest) Send() (*DeleteBatchPredictionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBatchPredictionOutput), nil
}

// DeleteBatchPredictionRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Assigns the DELETED status to a BatchPrediction, rendering it unusable.
//
// After using the DeleteBatchPrediction operation, you can use the GetBatchPrediction
// operation to verify that the status of the BatchPrediction changed to DELETED.
//
// Caution: The result of the DeleteBatchPrediction operation is irreversible.
//
//    // Example sending a request using the DeleteBatchPredictionRequest method.
//    req := client.DeleteBatchPredictionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DeleteBatchPredictionRequest(input *DeleteBatchPredictionInput) DeleteBatchPredictionRequest {
	op := &aws.Operation{
		Name:       opDeleteBatchPrediction,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteBatchPredictionInput{}
	}

	output := &DeleteBatchPredictionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBatchPredictionRequest{Request: req, Input: input, Copy: c.DeleteBatchPredictionRequest}
}

const opDeleteDataSource = "DeleteDataSource"

// DeleteDataSourceRequest is a API request type for the DeleteDataSource API operation.
type DeleteDataSourceRequest struct {
	*aws.Request
	Input *DeleteDataSourceInput
	Copy  func(*DeleteDataSourceInput) DeleteDataSourceRequest
}

// Send marshals and sends the DeleteDataSource API request.
func (r DeleteDataSourceRequest) Send() (*DeleteDataSourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteDataSourceOutput), nil
}

// DeleteDataSourceRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Assigns the DELETED status to a DataSource, rendering it unusable.
//
// After using the DeleteDataSource operation, you can use the GetDataSource
// operation to verify that the status of the DataSource changed to DELETED.
//
// Caution: The results of the DeleteDataSource operation are irreversible.
//
//    // Example sending a request using the DeleteDataSourceRequest method.
//    req := client.DeleteDataSourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DeleteDataSourceRequest(input *DeleteDataSourceInput) DeleteDataSourceRequest {
	op := &aws.Operation{
		Name:       opDeleteDataSource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteDataSourceInput{}
	}

	output := &DeleteDataSourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteDataSourceRequest{Request: req, Input: input, Copy: c.DeleteDataSourceRequest}
}

const opDeleteEvaluation = "DeleteEvaluation"

// DeleteEvaluationRequest is a API request type for the DeleteEvaluation API operation.
type DeleteEvaluationRequest struct {
	*aws.Request
	Input *DeleteEvaluationInput
	Copy  func(*DeleteEvaluationInput) DeleteEvaluationRequest
}

// Send marshals and sends the DeleteEvaluation API request.
func (r DeleteEvaluationRequest) Send() (*DeleteEvaluationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteEvaluationOutput), nil
}

// DeleteEvaluationRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Assigns the DELETED status to an Evaluation, rendering it unusable.
//
// After invoking the DeleteEvaluation operation, you can use the GetEvaluation
// operation to verify that the status of the Evaluation changed to DELETED.
//
// CautionThe results of the DeleteEvaluation operation are irreversible.
//
//    // Example sending a request using the DeleteEvaluationRequest method.
//    req := client.DeleteEvaluationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DeleteEvaluationRequest(input *DeleteEvaluationInput) DeleteEvaluationRequest {
	op := &aws.Operation{
		Name:       opDeleteEvaluation,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteEvaluationInput{}
	}

	output := &DeleteEvaluationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteEvaluationRequest{Request: req, Input: input, Copy: c.DeleteEvaluationRequest}
}

const opDeleteMLModel = "DeleteMLModel"

// DeleteMLModelRequest is a API request type for the DeleteMLModel API operation.
type DeleteMLModelRequest struct {
	*aws.Request
	Input *DeleteMLModelInput
	Copy  func(*DeleteMLModelInput) DeleteMLModelRequest
}

// Send marshals and sends the DeleteMLModel API request.
func (r DeleteMLModelRequest) Send() (*DeleteMLModelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteMLModelOutput), nil
}

// DeleteMLModelRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Assigns the DELETED status to an MLModel, rendering it unusable.
//
// After using the DeleteMLModel operation, you can use the GetMLModel operation
// to verify that the status of the MLModel changed to DELETED.
//
// Caution: The result of the DeleteMLModel operation is irreversible.
//
//    // Example sending a request using the DeleteMLModelRequest method.
//    req := client.DeleteMLModelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DeleteMLModelRequest(input *DeleteMLModelInput) DeleteMLModelRequest {
	op := &aws.Operation{
		Name:       opDeleteMLModel,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteMLModelInput{}
	}

	output := &DeleteMLModelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteMLModelRequest{Request: req, Input: input, Copy: c.DeleteMLModelRequest}
}

const opDeleteRealtimeEndpoint = "DeleteRealtimeEndpoint"

// DeleteRealtimeEndpointRequest is a API request type for the DeleteRealtimeEndpoint API operation.
type DeleteRealtimeEndpointRequest struct {
	*aws.Request
	Input *DeleteRealtimeEndpointInput
	Copy  func(*DeleteRealtimeEndpointInput) DeleteRealtimeEndpointRequest
}

// Send marshals and sends the DeleteRealtimeEndpoint API request.
func (r DeleteRealtimeEndpointRequest) Send() (*DeleteRealtimeEndpointOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteRealtimeEndpointOutput), nil
}

// DeleteRealtimeEndpointRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Deletes a real time endpoint of an MLModel.
//
//    // Example sending a request using the DeleteRealtimeEndpointRequest method.
//    req := client.DeleteRealtimeEndpointRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DeleteRealtimeEndpointRequest(input *DeleteRealtimeEndpointInput) DeleteRealtimeEndpointRequest {
	op := &aws.Operation{
		Name:       opDeleteRealtimeEndpoint,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteRealtimeEndpointInput{}
	}

	output := &DeleteRealtimeEndpointOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteRealtimeEndpointRequest{Request: req, Input: input, Copy: c.DeleteRealtimeEndpointRequest}
}

const opDeleteTags = "DeleteTags"

// DeleteTagsRequest is a API request type for the DeleteTags API operation.
type DeleteTagsRequest struct {
	*aws.Request
	Input *DeleteTagsInput
	Copy  func(*DeleteTagsInput) DeleteTagsRequest
}

// Send marshals and sends the DeleteTags API request.
func (r DeleteTagsRequest) Send() (*DeleteTagsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTagsOutput), nil
}

// DeleteTagsRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Deletes the specified tags associated with an ML object. After this operation
// is complete, you can't recover deleted tags.
//
// If you specify a tag that doesn't exist, Amazon ML ignores it.
//
//    // Example sending a request using the DeleteTagsRequest method.
//    req := client.DeleteTagsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DeleteTagsRequest(input *DeleteTagsInput) DeleteTagsRequest {
	op := &aws.Operation{
		Name:       opDeleteTags,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteTagsInput{}
	}

	output := &DeleteTagsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTagsRequest{Request: req, Input: input, Copy: c.DeleteTagsRequest}
}

const opDescribeBatchPredictions = "DescribeBatchPredictions"

// DescribeBatchPredictionsRequest is a API request type for the DescribeBatchPredictions API operation.
type DescribeBatchPredictionsRequest struct {
	*aws.Request
	Input *DescribeBatchPredictionsInput
	Copy  func(*DescribeBatchPredictionsInput) DescribeBatchPredictionsRequest
}

// Send marshals and sends the DescribeBatchPredictions API request.
func (r DescribeBatchPredictionsRequest) Send() (*DescribeBatchPredictionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeBatchPredictionsOutput), nil
}

// DescribeBatchPredictionsRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Returns a list of BatchPrediction operations that match the search criteria
// in the request.
//
//    // Example sending a request using the DescribeBatchPredictionsRequest method.
//    req := client.DescribeBatchPredictionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DescribeBatchPredictionsRequest(input *DescribeBatchPredictionsInput) DescribeBatchPredictionsRequest {
	op := &aws.Operation{
		Name:       opDescribeBatchPredictions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeBatchPredictionsInput{}
	}

	output := &DescribeBatchPredictionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeBatchPredictionsRequest{Request: req, Input: input, Copy: c.DescribeBatchPredictionsRequest}
}

// Paginate pages iterates over the pages of a DescribeBatchPredictionsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeBatchPredictions operation.
//		req := client.DescribeBatchPredictionsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeBatchPredictionsRequest) Paginate(opts ...aws.Option) DescribeBatchPredictionsPager {
	return DescribeBatchPredictionsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *DescribeBatchPredictionsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// DescribeBatchPredictionsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeBatchPredictionsPager struct {
	aws.Pager
}

func (p *DescribeBatchPredictionsPager) CurrentPage() *DescribeBatchPredictionsOutput {
	return p.Pager.CurrentPage().(*DescribeBatchPredictionsOutput)
}

const opDescribeDataSources = "DescribeDataSources"

// DescribeDataSourcesRequest is a API request type for the DescribeDataSources API operation.
type DescribeDataSourcesRequest struct {
	*aws.Request
	Input *DescribeDataSourcesInput
	Copy  func(*DescribeDataSourcesInput) DescribeDataSourcesRequest
}

// Send marshals and sends the DescribeDataSources API request.
func (r DescribeDataSourcesRequest) Send() (*DescribeDataSourcesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeDataSourcesOutput), nil
}

// DescribeDataSourcesRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Returns a list of DataSource that match the search criteria in the request.
//
//    // Example sending a request using the DescribeDataSourcesRequest method.
//    req := client.DescribeDataSourcesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DescribeDataSourcesRequest(input *DescribeDataSourcesInput) DescribeDataSourcesRequest {
	op := &aws.Operation{
		Name:       opDescribeDataSources,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeDataSourcesInput{}
	}

	output := &DescribeDataSourcesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeDataSourcesRequest{Request: req, Input: input, Copy: c.DescribeDataSourcesRequest}
}

// Paginate pages iterates over the pages of a DescribeDataSourcesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeDataSources operation.
//		req := client.DescribeDataSourcesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeDataSourcesRequest) Paginate(opts ...aws.Option) DescribeDataSourcesPager {
	return DescribeDataSourcesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *DescribeDataSourcesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// DescribeDataSourcesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeDataSourcesPager struct {
	aws.Pager
}

func (p *DescribeDataSourcesPager) CurrentPage() *DescribeDataSourcesOutput {
	return p.Pager.CurrentPage().(*DescribeDataSourcesOutput)
}

const opDescribeEvaluations = "DescribeEvaluations"

// DescribeEvaluationsRequest is a API request type for the DescribeEvaluations API operation.
type DescribeEvaluationsRequest struct {
	*aws.Request
	Input *DescribeEvaluationsInput
	Copy  func(*DescribeEvaluationsInput) DescribeEvaluationsRequest
}

// Send marshals and sends the DescribeEvaluations API request.
func (r DescribeEvaluationsRequest) Send() (*DescribeEvaluationsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeEvaluationsOutput), nil
}

// DescribeEvaluationsRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Returns a list of DescribeEvaluations that match the search criteria in the
// request.
//
//    // Example sending a request using the DescribeEvaluationsRequest method.
//    req := client.DescribeEvaluationsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DescribeEvaluationsRequest(input *DescribeEvaluationsInput) DescribeEvaluationsRequest {
	op := &aws.Operation{
		Name:       opDescribeEvaluations,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeEvaluationsInput{}
	}

	output := &DescribeEvaluationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeEvaluationsRequest{Request: req, Input: input, Copy: c.DescribeEvaluationsRequest}
}

// Paginate pages iterates over the pages of a DescribeEvaluationsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeEvaluations operation.
//		req := client.DescribeEvaluationsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeEvaluationsRequest) Paginate(opts ...aws.Option) DescribeEvaluationsPager {
	return DescribeEvaluationsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *DescribeEvaluationsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// DescribeEvaluationsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeEvaluationsPager struct {
	aws.Pager
}

func (p *DescribeEvaluationsPager) CurrentPage() *DescribeEvaluationsOutput {
	return p.Pager.CurrentPage().(*DescribeEvaluationsOutput)
}

const opDescribeMLModels = "DescribeMLModels"

// DescribeMLModelsRequest is a API request type for the DescribeMLModels API operation.
type DescribeMLModelsRequest struct {
	*aws.Request
	Input *DescribeMLModelsInput
	Copy  func(*DescribeMLModelsInput) DescribeMLModelsRequest
}

// Send marshals and sends the DescribeMLModels API request.
func (r DescribeMLModelsRequest) Send() (*DescribeMLModelsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeMLModelsOutput), nil
}

// DescribeMLModelsRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Returns a list of MLModel that match the search criteria in the request.
//
//    // Example sending a request using the DescribeMLModelsRequest method.
//    req := client.DescribeMLModelsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DescribeMLModelsRequest(input *DescribeMLModelsInput) DescribeMLModelsRequest {
	op := &aws.Operation{
		Name:       opDescribeMLModels,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeMLModelsInput{}
	}

	output := &DescribeMLModelsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeMLModelsRequest{Request: req, Input: input, Copy: c.DescribeMLModelsRequest}
}

// Paginate pages iterates over the pages of a DescribeMLModelsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeMLModels operation.
//		req := client.DescribeMLModelsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeMLModelsRequest) Paginate(opts ...aws.Option) DescribeMLModelsPager {
	return DescribeMLModelsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *DescribeMLModelsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// DescribeMLModelsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeMLModelsPager struct {
	aws.Pager
}

func (p *DescribeMLModelsPager) CurrentPage() *DescribeMLModelsOutput {
	return p.Pager.CurrentPage().(*DescribeMLModelsOutput)
}

const opDescribeTags = "DescribeTags"

// DescribeTagsRequest is a API request type for the DescribeTags API operation.
type DescribeTagsRequest struct {
	*aws.Request
	Input *DescribeTagsInput
	Copy  func(*DescribeTagsInput) DescribeTagsRequest
}

// Send marshals and sends the DescribeTags API request.
func (r DescribeTagsRequest) Send() (*DescribeTagsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeTagsOutput), nil
}

// DescribeTagsRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Describes one or more of the tags for your Amazon ML object.
//
//    // Example sending a request using the DescribeTagsRequest method.
//    req := client.DescribeTagsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) DescribeTagsRequest(input *DescribeTagsInput) DescribeTagsRequest {
	op := &aws.Operation{
		Name:       opDescribeTags,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeTagsInput{}
	}

	output := &DescribeTagsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeTagsRequest{Request: req, Input: input, Copy: c.DescribeTagsRequest}
}

const opGetBatchPrediction = "GetBatchPrediction"

// GetBatchPredictionRequest is a API request type for the GetBatchPrediction API operation.
type GetBatchPredictionRequest struct {
	*aws.Request
	Input *GetBatchPredictionInput
	Copy  func(*GetBatchPredictionInput) GetBatchPredictionRequest
}

// Send marshals and sends the GetBatchPrediction API request.
func (r GetBatchPredictionRequest) Send() (*GetBatchPredictionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBatchPredictionOutput), nil
}

// GetBatchPredictionRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Returns a BatchPrediction that includes detailed metadata, status, and data
// file information for a Batch Prediction request.
//
//    // Example sending a request using the GetBatchPredictionRequest method.
//    req := client.GetBatchPredictionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) GetBatchPredictionRequest(input *GetBatchPredictionInput) GetBatchPredictionRequest {
	op := &aws.Operation{
		Name:       opGetBatchPrediction,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetBatchPredictionInput{}
	}

	output := &GetBatchPredictionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBatchPredictionRequest{Request: req, Input: input, Copy: c.GetBatchPredictionRequest}
}

const opGetDataSource = "GetDataSource"

// GetDataSourceRequest is a API request type for the GetDataSource API operation.
type GetDataSourceRequest struct {
	*aws.Request
	Input *GetDataSourceInput
	Copy  func(*GetDataSourceInput) GetDataSourceRequest
}

// Send marshals and sends the GetDataSource API request.
func (r GetDataSourceRequest) Send() (*GetDataSourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDataSourceOutput), nil
}

// GetDataSourceRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Returns a DataSource that includes metadata and data file information, as
// well as the current status of the DataSource.
//
// GetDataSource provides results in normal or verbose format. The verbose format
// adds the schema description and the list of files pointed to by the DataSource
// to the normal format.
//
//    // Example sending a request using the GetDataSourceRequest method.
//    req := client.GetDataSourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) GetDataSourceRequest(input *GetDataSourceInput) GetDataSourceRequest {
	op := &aws.Operation{
		Name:       opGetDataSource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetDataSourceInput{}
	}

	output := &GetDataSourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDataSourceRequest{Request: req, Input: input, Copy: c.GetDataSourceRequest}
}

const opGetEvaluation = "GetEvaluation"

// GetEvaluationRequest is a API request type for the GetEvaluation API operation.
type GetEvaluationRequest struct {
	*aws.Request
	Input *GetEvaluationInput
	Copy  func(*GetEvaluationInput) GetEvaluationRequest
}

// Send marshals and sends the GetEvaluation API request.
func (r GetEvaluationRequest) Send() (*GetEvaluationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetEvaluationOutput), nil
}

// GetEvaluationRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Returns an Evaluation that includes metadata as well as the current status
// of the Evaluation.
//
//    // Example sending a request using the GetEvaluationRequest method.
//    req := client.GetEvaluationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) GetEvaluationRequest(input *GetEvaluationInput) GetEvaluationRequest {
	op := &aws.Operation{
		Name:       opGetEvaluation,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetEvaluationInput{}
	}

	output := &GetEvaluationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetEvaluationRequest{Request: req, Input: input, Copy: c.GetEvaluationRequest}
}

const opGetMLModel = "GetMLModel"

// GetMLModelRequest is a API request type for the GetMLModel API operation.
type GetMLModelRequest struct {
	*aws.Request
	Input *GetMLModelInput
	Copy  func(*GetMLModelInput) GetMLModelRequest
}

// Send marshals and sends the GetMLModel API request.
func (r GetMLModelRequest) Send() (*GetMLModelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetMLModelOutput), nil
}

// GetMLModelRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Returns an MLModel that includes detailed metadata, data source information,
// and the current status of the MLModel.
//
// GetMLModel provides results in normal or verbose format.
//
//    // Example sending a request using the GetMLModelRequest method.
//    req := client.GetMLModelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) GetMLModelRequest(input *GetMLModelInput) GetMLModelRequest {
	op := &aws.Operation{
		Name:       opGetMLModel,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetMLModelInput{}
	}

	output := &GetMLModelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetMLModelRequest{Request: req, Input: input, Copy: c.GetMLModelRequest}
}

const opPredict = "Predict"

// PredictRequest is a API request type for the Predict API operation.
type PredictRequest struct {
	*aws.Request
	Input *PredictInput
	Copy  func(*PredictInput) PredictRequest
}

// Send marshals and sends the Predict API request.
func (r PredictRequest) Send() (*PredictOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PredictOutput), nil
}

// PredictRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Generates a prediction for the observation using the specified ML Model.
//
// NoteNot all response parameters will be populated. Whether a response parameter
// is populated depends on the type of model requested.
//
//    // Example sending a request using the PredictRequest method.
//    req := client.PredictRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) PredictRequest(input *PredictInput) PredictRequest {
	op := &aws.Operation{
		Name:       opPredict,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PredictInput{}
	}

	output := &PredictOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PredictRequest{Request: req, Input: input, Copy: c.PredictRequest}
}

const opUpdateBatchPrediction = "UpdateBatchPrediction"

// UpdateBatchPredictionRequest is a API request type for the UpdateBatchPrediction API operation.
type UpdateBatchPredictionRequest struct {
	*aws.Request
	Input *UpdateBatchPredictionInput
	Copy  func(*UpdateBatchPredictionInput) UpdateBatchPredictionRequest
}

// Send marshals and sends the UpdateBatchPrediction API request.
func (r UpdateBatchPredictionRequest) Send() (*UpdateBatchPredictionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateBatchPredictionOutput), nil
}

// UpdateBatchPredictionRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Updates the BatchPredictionName of a BatchPrediction.
//
// You can use the GetBatchPrediction operation to view the contents of the
// updated data element.
//
//    // Example sending a request using the UpdateBatchPredictionRequest method.
//    req := client.UpdateBatchPredictionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) UpdateBatchPredictionRequest(input *UpdateBatchPredictionInput) UpdateBatchPredictionRequest {
	op := &aws.Operation{
		Name:       opUpdateBatchPrediction,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateBatchPredictionInput{}
	}

	output := &UpdateBatchPredictionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateBatchPredictionRequest{Request: req, Input: input, Copy: c.UpdateBatchPredictionRequest}
}

const opUpdateDataSource = "UpdateDataSource"

// UpdateDataSourceRequest is a API request type for the UpdateDataSource API operation.
type UpdateDataSourceRequest struct {
	*aws.Request
	Input *UpdateDataSourceInput
	Copy  func(*UpdateDataSourceInput) UpdateDataSourceRequest
}

// Send marshals and sends the UpdateDataSource API request.
func (r UpdateDataSourceRequest) Send() (*UpdateDataSourceOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDataSourceOutput), nil
}

// UpdateDataSourceRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Updates the DataSourceName of a DataSource.
//
// You can use the GetDataSource operation to view the contents of the updated
// data element.
//
//    // Example sending a request using the UpdateDataSourceRequest method.
//    req := client.UpdateDataSourceRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) UpdateDataSourceRequest(input *UpdateDataSourceInput) UpdateDataSourceRequest {
	op := &aws.Operation{
		Name:       opUpdateDataSource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateDataSourceInput{}
	}

	output := &UpdateDataSourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateDataSourceRequest{Request: req, Input: input, Copy: c.UpdateDataSourceRequest}
}

const opUpdateEvaluation = "UpdateEvaluation"

// UpdateEvaluationRequest is a API request type for the UpdateEvaluation API operation.
type UpdateEvaluationRequest struct {
	*aws.Request
	Input *UpdateEvaluationInput
	Copy  func(*UpdateEvaluationInput) UpdateEvaluationRequest
}

// Send marshals and sends the UpdateEvaluation API request.
func (r UpdateEvaluationRequest) Send() (*UpdateEvaluationOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateEvaluationOutput), nil
}

// UpdateEvaluationRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Updates the EvaluationName of an Evaluation.
//
// You can use the GetEvaluation operation to view the contents of the updated
// data element.
//
//    // Example sending a request using the UpdateEvaluationRequest method.
//    req := client.UpdateEvaluationRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) UpdateEvaluationRequest(input *UpdateEvaluationInput) UpdateEvaluationRequest {
	op := &aws.Operation{
		Name:       opUpdateEvaluation,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateEvaluationInput{}
	}

	output := &UpdateEvaluationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateEvaluationRequest{Request: req, Input: input, Copy: c.UpdateEvaluationRequest}
}

const opUpdateMLModel = "UpdateMLModel"

// UpdateMLModelRequest is a API request type for the UpdateMLModel API operation.
type UpdateMLModelRequest struct {
	*aws.Request
	Input *UpdateMLModelInput
	Copy  func(*UpdateMLModelInput) UpdateMLModelRequest
}

// Send marshals and sends the UpdateMLModel API request.
func (r UpdateMLModelRequest) Send() (*UpdateMLModelOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateMLModelOutput), nil
}

// UpdateMLModelRequest returns a request value for making API operation for
// Amazon Machine Learning.
//
// Updates the MLModelName and the ScoreThreshold of an MLModel.
//
// You can use the GetMLModel operation to view the contents of the updated
// data element.
//
//    // Example sending a request using the UpdateMLModelRequest method.
//    req := client.UpdateMLModelRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *MachineLearning) UpdateMLModelRequest(input *UpdateMLModelInput) UpdateMLModelRequest {
	op := &aws.Operation{
		Name:       opUpdateMLModel,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateMLModelInput{}
	}

	output := &UpdateMLModelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateMLModelRequest{Request: req, Input: input, Copy: c.UpdateMLModelRequest}
}

type AddTagsInput struct {
	_ struct{} `type:"structure"`

	// The ID of the ML object to tag. For example, exampleModelId.
	//
	// ResourceId is a required field
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The type of the ML object to tag.
	//
	// ResourceType is a required field
	ResourceType TaggableResourceType `type:"string" required:"true" enum:"true"`

	// The key-value pairs to use to create tags. If you specify a key without specifying
	// a value, Amazon ML creates a tag with the specified key and a value of null.
	//
	// Tags is a required field
	Tags []Tag `type:"list" required:"true"`
}

// String returns the string representation
func (s AddTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AddTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AddTagsInput"}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}
	if len(s.ResourceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResourceType"))
	}

	if s.Tags == nil {
		invalidParams.Add(aws.NewErrParamRequired("Tags"))
	}
	if s.Tags != nil {
		for i, v := range s.Tags {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Tags", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Amazon ML returns the following elements.
type AddTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the ML object that was tagged.
	ResourceId *string `min:"1" type:"string"`

	// The type of the ML object that was tagged.
	ResourceType TaggableResourceType `type:"string" enum:"true"`
}

// String returns the string representation
func (s AddTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AddTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the output of a GetBatchPrediction operation.
//
// The content consists of the detailed metadata, the status, and the data file
// information of a Batch Prediction.
type BatchPrediction struct {
	_ struct{} `type:"structure"`

	// The ID of the DataSource that points to the group of observations to predict.
	BatchPredictionDataSourceId *string `min:"1" type:"string"`

	// The ID assigned to the BatchPrediction at creation. This value should be
	// identical to the value of the BatchPredictionID in the request.
	BatchPredictionId *string `min:"1" type:"string"`

	// Long integer type that is a 64-bit signed number.
	ComputeTime *int64 `type:"long"`

	// The time that the BatchPrediction was created. The time is expressed in epoch
	// time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The AWS user account that invoked the BatchPrediction. The account type can
	// be either an AWS root account or an AWS Identity and Access Management (IAM)
	// user account.
	CreatedByIamUser *string `type:"string"`

	// A timestamp represented in epoch time.
	FinishedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The location of the data file or directory in Amazon Simple Storage Service
	// (Amazon S3).
	InputDataLocationS3 *string `type:"string"`

	// Long integer type that is a 64-bit signed number.
	InvalidRecordCount *int64 `type:"long"`

	// The time of the most recent edit to the BatchPrediction. The time is expressed
	// in epoch time.
	LastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the MLModel that generated predictions for the BatchPrediction
	// request.
	MLModelId *string `min:"1" type:"string"`

	// A description of the most recent details about processing the batch prediction
	// request.
	Message *string `type:"string"`

	// A user-supplied name or description of the BatchPrediction.
	Name *string `type:"string"`

	// The location of an Amazon S3 bucket or directory to receive the operation
	// results. The following substrings are not allowed in the s3 key portion of
	// the outputURI field: ':', '//', '/./', '/../'.
	OutputUri *string `type:"string"`

	// A timestamp represented in epoch time.
	StartedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The status of the BatchPrediction. This element can have one of the following
	// values:
	//
	//    * PENDING - Amazon Machine Learning (Amazon ML) submitted a request to
	//    generate predictions for a batch of observations.
	//    * INPROGRESS - The process is underway.
	//    * FAILED - The request to perform a batch prediction did not run to completion.
	//    It is not usable.
	//    * COMPLETED - The batch prediction process completed successfully.
	//    * DELETED - The BatchPrediction is marked as deleted. It is not usable.
	Status EntityStatus `type:"string" enum:"true"`

	// Long integer type that is a 64-bit signed number.
	TotalRecordCount *int64 `type:"long"`
}

// String returns the string representation
func (s BatchPrediction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchPrediction) GoString() string {
	return s.String()
}

type CreateBatchPredictionInput struct {
	_ struct{} `type:"structure"`

	// The ID of the DataSource that points to the group of observations to predict.
	//
	// BatchPredictionDataSourceId is a required field
	BatchPredictionDataSourceId *string `min:"1" type:"string" required:"true"`

	// A user-supplied ID that uniquely identifies the BatchPrediction.
	//
	// BatchPredictionId is a required field
	BatchPredictionId *string `min:"1" type:"string" required:"true"`

	// A user-supplied name or description of the BatchPrediction. BatchPredictionName
	// can only use the UTF-8 character set.
	BatchPredictionName *string `type:"string"`

	// The ID of the MLModel that will generate predictions for the group of observations.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`

	// The location of an Amazon Simple Storage Service (Amazon S3) bucket or directory
	// to store the batch prediction results. The following substrings are not allowed
	// in the s3 key portion of the outputURI field: ':', '//', '/./', '/../'.
	//
	// Amazon ML needs permissions to store and retrieve the logs on your behalf.
	// For information about how to set permissions, see the Amazon Machine Learning
	// Developer Guide (http://docs.aws.amazon.com/machine-learning/latest/dg).
	//
	// OutputUri is a required field
	OutputUri *string `type:"string" required:"true"`
}

// String returns the string representation
func (s CreateBatchPredictionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBatchPredictionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBatchPredictionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateBatchPredictionInput"}

	if s.BatchPredictionDataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BatchPredictionDataSourceId"))
	}
	if s.BatchPredictionDataSourceId != nil && len(*s.BatchPredictionDataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BatchPredictionDataSourceId", 1))
	}

	if s.BatchPredictionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BatchPredictionId"))
	}
	if s.BatchPredictionId != nil && len(*s.BatchPredictionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BatchPredictionId", 1))
	}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}

	if s.OutputUri == nil {
		invalidParams.Add(aws.NewErrParamRequired("OutputUri"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a CreateBatchPrediction operation, and is an acknowledgement
// that Amazon ML received the request.
//
// The CreateBatchPrediction operation is asynchronous. You can poll for status
// updates by using the >GetBatchPrediction operation and checking the Status
// parameter of the result.
type CreateBatchPredictionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the BatchPrediction. This value
	// is identical to the value of the BatchPredictionId in the request.
	BatchPredictionId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateBatchPredictionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBatchPredictionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateBatchPredictionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type CreateDataSourceFromRDSInput struct {
	_ struct{} `type:"structure"`

	// The compute statistics for a DataSource. The statistics are generated from
	// the observation data referenced by a DataSource. Amazon ML uses the statistics
	// internally during MLModel training. This parameter must be set to true if
	// the DataSource needs to be used for MLModel training.
	ComputeStatistics *bool `type:"boolean"`

	// A user-supplied ID that uniquely identifies the DataSource. Typically, an
	// Amazon Resource Number (ARN) becomes the ID for a DataSource.
	//
	// DataSourceId is a required field
	DataSourceId *string `min:"1" type:"string" required:"true"`

	// A user-supplied name or description of the DataSource.
	DataSourceName *string `type:"string"`

	// The data specification of an Amazon RDS DataSource:
	//
	// RDSData is a required field
	RDSData *RDSDataSpec `type:"structure" required:"true"`

	// The role that Amazon ML assumes on behalf of the user to create and activate
	// a data pipeline in the user's account and copy data using the SelectSqlQuery
	// query from Amazon RDS to Amazon S3.
	//
	// RoleARN is a required field
	RoleARN *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateDataSourceFromRDSInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDataSourceFromRDSInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDataSourceFromRDSInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDataSourceFromRDSInput"}

	if s.DataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceId"))
	}
	if s.DataSourceId != nil && len(*s.DataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DataSourceId", 1))
	}

	if s.RDSData == nil {
		invalidParams.Add(aws.NewErrParamRequired("RDSData"))
	}

	if s.RoleARN == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleARN"))
	}
	if s.RoleARN != nil && len(*s.RoleARN) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleARN", 1))
	}
	if s.RDSData != nil {
		if err := s.RDSData.Validate(); err != nil {
			invalidParams.AddNested("RDSData", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a CreateDataSourceFromRDS operation, and is an acknowledgement
// that Amazon ML received the request.
//
// The CreateDataSourceFromRDS> operation is asynchronous. You can poll for
// updates by using the GetBatchPrediction operation and checking the Status
// parameter. You can inspect the Message when Status shows up as FAILED. You
// can also check the progress of the copy operation by going to the DataPipeline
// console and looking up the pipeline using the pipelineId  from the describe
// call.
type CreateDataSourceFromRDSOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the datasource. This value should
	// be identical to the value of the DataSourceID in the request.
	DataSourceId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateDataSourceFromRDSOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDataSourceFromRDSOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateDataSourceFromRDSOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type CreateDataSourceFromRedshiftInput struct {
	_ struct{} `type:"structure"`

	// The compute statistics for a DataSource. The statistics are generated from
	// the observation data referenced by a DataSource. Amazon ML uses the statistics
	// internally during MLModel training. This parameter must be set to true if
	// the DataSource needs to be used for MLModel training.
	ComputeStatistics *bool `type:"boolean"`

	// A user-supplied ID that uniquely identifies the DataSource.
	//
	// DataSourceId is a required field
	DataSourceId *string `min:"1" type:"string" required:"true"`

	// A user-supplied name or description of the DataSource.
	DataSourceName *string `type:"string"`

	// The data specification of an Amazon Redshift DataSource:
	//
	//    * DatabaseInformation - DatabaseName - The name of the Amazon Redshift
	//    database.
	//  ClusterIdentifier - The unique ID for the Amazon Redshift cluster.
	//
	//    * DatabaseCredentials - The AWS Identity and Access Management (IAM) credentials
	//    that are used to connect to the Amazon Redshift database.
	//
	//    * SelectSqlQuery - The query that is used to retrieve the observation
	//    data for the Datasource.
	//
	//    * S3StagingLocation - The Amazon Simple Storage Service (Amazon S3) location
	//    for staging Amazon Redshift data. The data retrieved from Amazon Redshift
	//    using the SelectSqlQuery query is stored in this location.
	//
	//    * DataSchemaUri - The Amazon S3 location of the DataSchema.
	//
	//    * DataSchema - A JSON string representing the schema. This is not required
	//    if DataSchemaUri is specified.
	//
	//    * DataRearrangement - A JSON string that represents the splitting and
	//    rearrangement requirements for the DataSource.
	//
	//  Sample -  "{\"splitting\":{\"percentBegin\":10,\"percentEnd\":60}}"
	//
	// DataSpec is a required field
	DataSpec *RedshiftDataSpec `type:"structure" required:"true"`

	// A fully specified role Amazon Resource Name (ARN). Amazon ML assumes the
	// role on behalf of the user to create the following:
	//
	// A security group to allow Amazon ML to execute the SelectSqlQuery query on
	// an Amazon Redshift cluster
	//
	// An Amazon S3 bucket policy to grant Amazon ML read/write permissions on the
	// S3StagingLocation
	//
	// RoleARN is a required field
	RoleARN *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateDataSourceFromRedshiftInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDataSourceFromRedshiftInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDataSourceFromRedshiftInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDataSourceFromRedshiftInput"}

	if s.DataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceId"))
	}
	if s.DataSourceId != nil && len(*s.DataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DataSourceId", 1))
	}

	if s.DataSpec == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSpec"))
	}

	if s.RoleARN == nil {
		invalidParams.Add(aws.NewErrParamRequired("RoleARN"))
	}
	if s.RoleARN != nil && len(*s.RoleARN) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleARN", 1))
	}
	if s.DataSpec != nil {
		if err := s.DataSpec.Validate(); err != nil {
			invalidParams.AddNested("DataSpec", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a CreateDataSourceFromRedshift operation, and is
// an acknowledgement that Amazon ML received the request.
//
// The CreateDataSourceFromRedshift operation is asynchronous. You can poll
// for updates by using the GetBatchPrediction operation and checking the Status
// parameter.
type CreateDataSourceFromRedshiftOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the datasource. This value should
	// be identical to the value of the DataSourceID in the request.
	DataSourceId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateDataSourceFromRedshiftOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDataSourceFromRedshiftOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateDataSourceFromRedshiftOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type CreateDataSourceFromS3Input struct {
	_ struct{} `type:"structure"`

	// The compute statistics for a DataSource. The statistics are generated from
	// the observation data referenced by a DataSource. Amazon ML uses the statistics
	// internally during MLModel training. This parameter must be set to true if
	// the DataSource needs to be used for MLModel training.
	ComputeStatistics *bool `type:"boolean"`

	// A user-supplied identifier that uniquely identifies the DataSource.
	//
	// DataSourceId is a required field
	DataSourceId *string `min:"1" type:"string" required:"true"`

	// A user-supplied name or description of the DataSource.
	DataSourceName *string `type:"string"`

	// The data specification of a DataSource:
	//
	//    * DataLocationS3 - The Amazon S3 location of the observation data.
	//
	//    * DataSchemaLocationS3 - The Amazon S3 location of the DataSchema.
	//
	//    * DataSchema - A JSON string representing the schema. This is not required
	//    if DataSchemaUri is specified.
	//
	//    * DataRearrangement - A JSON string that represents the splitting and
	//    rearrangement requirements for the Datasource.
	//
	//  Sample -  "{\"splitting\":{\"percentBegin\":10,\"percentEnd\":60}}"
	//
	// DataSpec is a required field
	DataSpec *S3DataSpec `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateDataSourceFromS3Input) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDataSourceFromS3Input) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDataSourceFromS3Input) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDataSourceFromS3Input"}

	if s.DataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceId"))
	}
	if s.DataSourceId != nil && len(*s.DataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DataSourceId", 1))
	}

	if s.DataSpec == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSpec"))
	}
	if s.DataSpec != nil {
		if err := s.DataSpec.Validate(); err != nil {
			invalidParams.AddNested("DataSpec", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a CreateDataSourceFromS3 operation, and is an acknowledgement
// that Amazon ML received the request.
//
// The CreateDataSourceFromS3 operation is asynchronous. You can poll for updates
// by using the GetBatchPrediction operation and checking the Status parameter.
type CreateDataSourceFromS3Output struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the DataSource. This value should
	// be identical to the value of the DataSourceID in the request.
	DataSourceId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateDataSourceFromS3Output) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDataSourceFromS3Output) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateDataSourceFromS3Output) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type CreateEvaluationInput struct {
	_ struct{} `type:"structure"`

	// The ID of the DataSource for the evaluation. The schema of the DataSource
	// must match the schema used to create the MLModel.
	//
	// EvaluationDataSourceId is a required field
	EvaluationDataSourceId *string `min:"1" type:"string" required:"true"`

	// A user-supplied ID that uniquely identifies the Evaluation.
	//
	// EvaluationId is a required field
	EvaluationId *string `min:"1" type:"string" required:"true"`

	// A user-supplied name or description of the Evaluation.
	EvaluationName *string `type:"string"`

	// The ID of the MLModel to evaluate.
	//
	// The schema used in creating the MLModel must match the schema of the DataSource
	// used in the Evaluation.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateEvaluationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateEvaluationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateEvaluationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateEvaluationInput"}

	if s.EvaluationDataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("EvaluationDataSourceId"))
	}
	if s.EvaluationDataSourceId != nil && len(*s.EvaluationDataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("EvaluationDataSourceId", 1))
	}

	if s.EvaluationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("EvaluationId"))
	}
	if s.EvaluationId != nil && len(*s.EvaluationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("EvaluationId", 1))
	}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a CreateEvaluation operation, and is an acknowledgement
// that Amazon ML received the request.
//
// CreateEvaluation operation is asynchronous. You can poll for status updates
// by using the GetEvcaluation operation and checking the Status parameter.
type CreateEvaluationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The user-supplied ID that uniquely identifies the Evaluation. This value
	// should be identical to the value of the EvaluationId in the request.
	EvaluationId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateEvaluationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateEvaluationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateEvaluationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type CreateMLModelInput struct {
	_ struct{} `type:"structure"`

	// A user-supplied ID that uniquely identifies the MLModel.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`

	// A user-supplied name or description of the MLModel.
	MLModelName *string `type:"string"`

	// The category of supervised learning that this MLModel will address. Choose
	// from the following types:
	//
	//    * Choose REGRESSION if the MLModel will be used to predict a numeric value.
	//
	//    * Choose BINARY if the MLModel result has two possible values.
	//    * Choose MULTICLASS if the MLModel result has a limited number of values.
	//
	// For more information, see the Amazon Machine Learning Developer Guide (http://docs.aws.amazon.com/machine-learning/latest/dg).
	//
	// MLModelType is a required field
	MLModelType MLModelType `type:"string" required:"true" enum:"true"`

	// A list of the training parameters in the MLModel. The list is implemented
	// as a map of key-value pairs.
	//
	// The following is the current set of training parameters:
	//
	//    * sgd.maxMLModelSizeInBytes - The maximum allowed size of the model. Depending
	//    on the input data, the size of the model might affect its performance.
	//
	//  The value is an integer that ranges from 100000 to 2147483648. The default
	//    value is 33554432.
	//
	//    * sgd.maxPasses - The number of times that the training process traverses
	//    the observations to build the MLModel. The value is an integer that ranges
	//    from 1 to 10000. The default value is 10.
	//
	//    * sgd.shuffleType - Whether Amazon ML shuffles the training data. Shuffling
	//    the data improves a model's ability to find the optimal solution for a
	//    variety of data types. The valid values are auto and none. The default
	//    value is none. We strongly recommend that you shuffle your data.
	//
	//    * sgd.l1RegularizationAmount - The coefficient regularization L1 norm.
	//    It controls overfitting the data by penalizing large coefficients. This
	//    tends to drive coefficients to zero, resulting in a sparse feature set.
	//    If you use this parameter, start by specifying a small value, such as
	//    1.0E-08.
	//
	// The value is a double that ranges from 0 to MAX_DOUBLE. The default is to
	//    not use L1 normalization. This parameter can't be used when L2 is specified.
	//    Use this parameter sparingly.
	//
	//    * sgd.l2RegularizationAmount - The coefficient regularization L2 norm.
	//    It controls overfitting the data by penalizing large coefficients. This
	//    tends to drive coefficients to small, nonzero values. If you use this
	//    parameter, start by specifying a small value, such as 1.0E-08.
	//
	// The value is a double that ranges from 0 to MAX_DOUBLE. The default is to
	//    not use L2 normalization. This parameter can't be used when L1 is specified.
	//    Use this parameter sparingly.
	Parameters map[string]string `type:"map"`

	// The data recipe for creating the MLModel. You must specify either the recipe
	// or its URI. If you don't specify a recipe or its URI, Amazon ML creates a
	// default.
	Recipe *string `type:"string"`

	// The Amazon Simple Storage Service (Amazon S3) location and file name that
	// contains the MLModel recipe. You must specify either the recipe or its URI.
	// If you don't specify a recipe or its URI, Amazon ML creates a default.
	RecipeUri *string `type:"string"`

	// The DataSource that points to the training data.
	//
	// TrainingDataSourceId is a required field
	TrainingDataSourceId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateMLModelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateMLModelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateMLModelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateMLModelInput"}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}
	if len(s.MLModelType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("MLModelType"))
	}

	if s.TrainingDataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TrainingDataSourceId"))
	}
	if s.TrainingDataSourceId != nil && len(*s.TrainingDataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TrainingDataSourceId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a CreateMLModel operation, and is an acknowledgement
// that Amazon ML received the request.
//
// The CreateMLModel operation is asynchronous. You can poll for status updates
// by using the GetMLModel operation and checking the Status parameter.
type CreateMLModelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the MLModel. This value should
	// be identical to the value of the MLModelId in the request.
	MLModelId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CreateMLModelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateMLModelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateMLModelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type CreateRealtimeEndpointInput struct {
	_ struct{} `type:"structure"`

	// The ID assigned to the MLModel during creation.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateRealtimeEndpointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateRealtimeEndpointInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateRealtimeEndpointInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateRealtimeEndpointInput"}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of an CreateRealtimeEndpoint operation.
//
// The result contains the MLModelId and the endpoint information for the MLModel.
//
// The endpoint information includes the URI of the MLModel; that is, the location
// to send online prediction requests for the specified MLModel.
type CreateRealtimeEndpointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the MLModel. This value should
	// be identical to the value of the MLModelId in the request.
	MLModelId *string `min:"1" type:"string"`

	// The endpoint information of the MLModel
	RealtimeEndpointInfo *RealtimeEndpointInfo `type:"structure"`
}

// String returns the string representation
func (s CreateRealtimeEndpointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateRealtimeEndpointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateRealtimeEndpointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the output of the GetDataSource operation.
//
// The content consists of the detailed metadata and data file information and
// the current status of the DataSource.
type DataSource struct {
	_ struct{} `type:"structure"`

	// The parameter is true if statistics need to be generated from the observation
	// data.
	ComputeStatistics *bool `type:"boolean"`

	// Long integer type that is a 64-bit signed number.
	ComputeTime *int64 `type:"long"`

	// The time that the DataSource was created. The time is expressed in epoch
	// time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The AWS user account from which the DataSource was created. The account type
	// can be either an AWS root account or an AWS Identity and Access Management
	// (IAM) user account.
	CreatedByIamUser *string `type:"string"`

	// The location and name of the data in Amazon Simple Storage Service (Amazon
	// S3) that is used by a DataSource.
	DataLocationS3 *string `type:"string"`

	// A JSON string that represents the splitting and rearrangement requirement
	// used when this DataSource was created.
	DataRearrangement *string `type:"string"`

	// The total number of observations contained in the data files that the DataSource
	// references.
	DataSizeInBytes *int64 `type:"long"`

	// The ID that is assigned to the DataSource during creation.
	DataSourceId *string `min:"1" type:"string"`

	// A timestamp represented in epoch time.
	FinishedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The time of the most recent edit to the BatchPrediction. The time is expressed
	// in epoch time.
	LastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A description of the most recent details about creating the DataSource.
	Message *string `type:"string"`

	// A user-supplied name or description of the DataSource.
	Name *string `type:"string"`

	// The number of data files referenced by the DataSource.
	NumberOfFiles *int64 `type:"long"`

	// The datasource details that are specific to Amazon RDS.
	RDSMetadata *RDSMetadata `type:"structure"`

	// Describes the DataSource details specific to Amazon Redshift.
	RedshiftMetadata *RedshiftMetadata `type:"structure"`

	// The Amazon Resource Name (ARN) of an AWS IAM Role (http://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html#roles-about-termsandconcepts),
	// such as the following: arn:aws:iam::account:role/rolename.
	RoleARN *string `min:"1" type:"string"`

	// A timestamp represented in epoch time.
	StartedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The current status of the DataSource. This element can have one of the following
	// values:
	//
	//    * PENDING - Amazon Machine Learning (Amazon ML) submitted a request to
	//    create a DataSource.
	//    * INPROGRESS - The creation process is underway.
	//    * FAILED - The request to create a DataSource did not run to completion.
	//    It is not usable.
	//    * COMPLETED - The creation process completed successfully.
	//    * DELETED - The DataSource is marked as deleted. It is not usable.
	Status EntityStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s DataSource) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DataSource) GoString() string {
	return s.String()
}

type DeleteBatchPredictionInput struct {
	_ struct{} `type:"structure"`

	// A user-supplied ID that uniquely identifies the BatchPrediction.
	//
	// BatchPredictionId is a required field
	BatchPredictionId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBatchPredictionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBatchPredictionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBatchPredictionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBatchPredictionInput"}

	if s.BatchPredictionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BatchPredictionId"))
	}
	if s.BatchPredictionId != nil && len(*s.BatchPredictionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BatchPredictionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DeleteBatchPrediction operation.
//
// You can use the GetBatchPrediction operation and check the value of the Status
// parameter to see whether a BatchPrediction is marked as DELETED.
type DeleteBatchPredictionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the BatchPrediction. This value
	// should be identical to the value of the BatchPredictionID in the request.
	BatchPredictionId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DeleteBatchPredictionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBatchPredictionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBatchPredictionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DeleteDataSourceInput struct {
	_ struct{} `type:"structure"`

	// A user-supplied ID that uniquely identifies the DataSource.
	//
	// DataSourceId is a required field
	DataSourceId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDataSourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDataSourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteDataSourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteDataSourceInput"}

	if s.DataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceId"))
	}
	if s.DataSourceId != nil && len(*s.DataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DataSourceId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DeleteDataSource operation.
type DeleteDataSourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the DataSource. This value should
	// be identical to the value of the DataSourceID in the request.
	DataSourceId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DeleteDataSourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDataSourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteDataSourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DeleteEvaluationInput struct {
	_ struct{} `type:"structure"`

	// A user-supplied ID that uniquely identifies the Evaluation to delete.
	//
	// EvaluationId is a required field
	EvaluationId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteEvaluationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteEvaluationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteEvaluationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteEvaluationInput"}

	if s.EvaluationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("EvaluationId"))
	}
	if s.EvaluationId != nil && len(*s.EvaluationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("EvaluationId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DeleteEvaluation operation. The output indicates
// that Amazon Machine Learning (Amazon ML) received the request.
//
// You can use the GetEvaluation operation and check the value of the Status
// parameter to see whether an Evaluation is marked as DELETED.
type DeleteEvaluationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the Evaluation. This value should
	// be identical to the value of the EvaluationId in the request.
	EvaluationId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DeleteEvaluationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteEvaluationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteEvaluationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DeleteMLModelInput struct {
	_ struct{} `type:"structure"`

	// A user-supplied ID that uniquely identifies the MLModel.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteMLModelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMLModelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteMLModelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteMLModelInput"}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DeleteMLModel operation.
//
// You can use the GetMLModel operation and check the value of the Status parameter
// to see whether an MLModel is marked as DELETED.
type DeleteMLModelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the MLModel. This value should
	// be identical to the value of the MLModelID in the request.
	MLModelId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DeleteMLModelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMLModelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteMLModelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DeleteRealtimeEndpointInput struct {
	_ struct{} `type:"structure"`

	// The ID assigned to the MLModel during creation.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteRealtimeEndpointInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRealtimeEndpointInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteRealtimeEndpointInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteRealtimeEndpointInput"}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of an DeleteRealtimeEndpoint operation.
//
// The result contains the MLModelId and the endpoint information for the MLModel.
type DeleteRealtimeEndpointOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A user-supplied ID that uniquely identifies the MLModel. This value should
	// be identical to the value of the MLModelId in the request.
	MLModelId *string `min:"1" type:"string"`

	// The endpoint information of the MLModel
	RealtimeEndpointInfo *RealtimeEndpointInfo `type:"structure"`
}

// String returns the string representation
func (s DeleteRealtimeEndpointOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRealtimeEndpointOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteRealtimeEndpointOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DeleteTagsInput struct {
	_ struct{} `type:"structure"`

	// The ID of the tagged ML object. For example, exampleModelId.
	//
	// ResourceId is a required field
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The type of the tagged ML object.
	//
	// ResourceType is a required field
	ResourceType TaggableResourceType `type:"string" required:"true" enum:"true"`

	// One or more tags to delete.
	//
	// TagKeys is a required field
	TagKeys []string `type:"list" required:"true"`
}

// String returns the string representation
func (s DeleteTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTagsInput"}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}
	if len(s.ResourceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResourceType"))
	}

	if s.TagKeys == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Amazon ML returns the following elements.
type DeleteTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the ML object from which tags were deleted.
	ResourceId *string `min:"1" type:"string"`

	// The type of the ML object from which tags were deleted.
	ResourceType TaggableResourceType `type:"string" enum:"true"`
}

// String returns the string representation
func (s DeleteTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DescribeBatchPredictionsInput struct {
	_ struct{} `type:"structure"`

	// The equal to operator. The BatchPrediction results will have FilterVariable
	// values that exactly match the value specified with EQ.
	EQ *string `type:"string"`

	// Use one of the following variables to filter a list of BatchPrediction:
	//
	//    * CreatedAt - Sets the search criteria to the BatchPrediction creation
	//    date.
	//    * Status - Sets the search criteria to the BatchPrediction status.
	//    * Name - Sets the search criteria to the contents of the BatchPredictionName.
	//
	//    * IAMUser - Sets the search criteria to the user account that invoked
	//    the BatchPrediction creation.
	//    * MLModelId - Sets the search criteria to the MLModel used in the BatchPrediction.
	//
	//    * DataSourceId - Sets the search criteria to the DataSource used in the
	//    BatchPrediction.
	//    * DataURI - Sets the search criteria to the data file(s) used in the BatchPrediction.
	//    The URL can identify either a file or an Amazon Simple Storage Solution
	//    (Amazon S3) bucket or directory.
	FilterVariable BatchPredictionFilterVariable `type:"string" enum:"true"`

	// The greater than or equal to operator. The BatchPrediction results will have
	// FilterVariable values that are greater than or equal to the value specified
	// with GE.
	GE *string `type:"string"`

	// The greater than operator. The BatchPrediction results will have FilterVariable
	// values that are greater than the value specified with GT.
	GT *string `type:"string"`

	// The less than or equal to operator. The BatchPrediction results will have
	// FilterVariable values that are less than or equal to the value specified
	// with LE.
	LE *string `type:"string"`

	// The less than operator. The BatchPrediction results will have FilterVariable
	// values that are less than the value specified with LT.
	LT *string `type:"string"`

	// The number of pages of information to include in the result. The range of
	// acceptable values is 1 through 100. The default value is 100.
	Limit *int64 `min:"1" type:"integer"`

	// The not equal to operator. The BatchPrediction results will have FilterVariable
	// values not equal to the value specified with NE.
	NE *string `type:"string"`

	// An ID of the page in the paginated results.
	NextToken *string `type:"string"`

	// A string that is found at the beginning of a variable, such as Name or Id.
	//
	// For example, a Batch Prediction operation could have the Name2014-09-09-HolidayGiftMailer.
	// To search for this BatchPrediction, select Name for the FilterVariable and
	// any of the following strings for the Prefix:
	//
	//    * 2014-09
	//
	//    * 2014-09-09
	//
	//    * 2014-09-09-Holiday
	Prefix *string `type:"string"`

	// A two-value parameter that determines the sequence of the resulting list
	// of MLModels.
	//
	//    * asc - Arranges the list in ascending order (A-Z, 0-9).
	//    * dsc - Arranges the list in descending order (Z-A, 9-0).
	// Results are sorted by FilterVariable.
	SortOrder SortOrder `type:"string" enum:"true"`
}

// String returns the string representation
func (s DescribeBatchPredictionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBatchPredictionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeBatchPredictionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeBatchPredictionsInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DescribeBatchPredictions operation. The content
// is essentially a list of BatchPredictions.
type DescribeBatchPredictionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the next page in the paginated results that indicates at least
	// one more page follows.
	NextToken *string `type:"string"`

	// A list of BatchPrediction objects that meet the search criteria.
	Results []BatchPrediction `type:"list"`
}

// String returns the string representation
func (s DescribeBatchPredictionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBatchPredictionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeBatchPredictionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DescribeDataSourcesInput struct {
	_ struct{} `type:"structure"`

	// The equal to operator. The DataSource results will have FilterVariable values
	// that exactly match the value specified with EQ.
	EQ *string `type:"string"`

	// Use one of the following variables to filter a list of DataSource:
	//
	//    * CreatedAt - Sets the search criteria to DataSource creation dates.
	//    * Status - Sets the search criteria to DataSource statuses.
	//    * Name - Sets the search criteria to the contents of DataSourceName.
	//    * DataUri - Sets the search criteria to the URI of data files used to
	//    create the DataSource. The URI can identify either a file or an Amazon
	//    Simple Storage Service (Amazon S3) bucket or directory.
	//    * IAMUser - Sets the search criteria to the user account that invoked
	//    the DataSource creation.
	FilterVariable DataSourceFilterVariable `type:"string" enum:"true"`

	// The greater than or equal to operator. The DataSource results will have FilterVariable
	// values that are greater than or equal to the value specified with GE.
	GE *string `type:"string"`

	// The greater than operator. The DataSource results will have FilterVariable
	// values that are greater than the value specified with GT.
	GT *string `type:"string"`

	// The less than or equal to operator. The DataSource results will have FilterVariable
	// values that are less than or equal to the value specified with LE.
	LE *string `type:"string"`

	// The less than operator. The DataSource results will have FilterVariable values
	// that are less than the value specified with LT.
	LT *string `type:"string"`

	// The maximum number of DataSource to include in the result.
	Limit *int64 `min:"1" type:"integer"`

	// The not equal to operator. The DataSource results will have FilterVariable
	// values not equal to the value specified with NE.
	NE *string `type:"string"`

	// The ID of the page in the paginated results.
	NextToken *string `type:"string"`

	// A string that is found at the beginning of a variable, such as Name or Id.
	//
	// For example, a DataSource could have the Name2014-09-09-HolidayGiftMailer.
	// To search for this DataSource, select Name for the FilterVariable and any
	// of the following strings for the Prefix:
	//
	//    * 2014-09
	//
	//    * 2014-09-09
	//
	//    * 2014-09-09-Holiday
	Prefix *string `type:"string"`

	// A two-value parameter that determines the sequence of the resulting list
	// of DataSource.
	//
	//    * asc - Arranges the list in ascending order (A-Z, 0-9).
	//    * dsc - Arranges the list in descending order (Z-A, 9-0).
	// Results are sorted by FilterVariable.
	SortOrder SortOrder `type:"string" enum:"true"`
}

// String returns the string representation
func (s DescribeDataSourcesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeDataSourcesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeDataSourcesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeDataSourcesInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the query results from a DescribeDataSources operation. The content
// is essentially a list of DataSource.
type DescribeDataSourcesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// An ID of the next page in the paginated results that indicates at least one
	// more page follows.
	NextToken *string `type:"string"`

	// A list of DataSource that meet the search criteria.
	Results []DataSource `type:"list"`
}

// String returns the string representation
func (s DescribeDataSourcesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeDataSourcesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeDataSourcesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DescribeEvaluationsInput struct {
	_ struct{} `type:"structure"`

	// The equal to operator. The Evaluation results will have FilterVariable values
	// that exactly match the value specified with EQ.
	EQ *string `type:"string"`

	// Use one of the following variable to filter a list of Evaluation objects:
	//
	//    * CreatedAt - Sets the search criteria to the Evaluation creation date.
	//
	//    * Status - Sets the search criteria to the Evaluation status.
	//    * Name - Sets the search criteria to the contents of EvaluationName.
	//    * IAMUser - Sets the search criteria to the user account that invoked
	//    an Evaluation.
	//    * MLModelId - Sets the search criteria to the MLModel that was evaluated.
	//
	//    * DataSourceId - Sets the search criteria to the DataSource used in Evaluation.
	//
	//    * DataUri - Sets the search criteria to the data file(s) used in Evaluation.
	//    The URL can identify either a file or an Amazon Simple Storage Solution
	//    (Amazon S3) bucket or directory.
	FilterVariable EvaluationFilterVariable `type:"string" enum:"true"`

	// The greater than or equal to operator. The Evaluation results will have FilterVariable
	// values that are greater than or equal to the value specified with GE.
	GE *string `type:"string"`

	// The greater than operator. The Evaluation results will have FilterVariable
	// values that are greater than the value specified with GT.
	GT *string `type:"string"`

	// The less than or equal to operator. The Evaluation results will have FilterVariable
	// values that are less than or equal to the value specified with LE.
	LE *string `type:"string"`

	// The less than operator. The Evaluation results will have FilterVariable values
	// that are less than the value specified with LT.
	LT *string `type:"string"`

	// The maximum number of Evaluation to include in the result.
	Limit *int64 `min:"1" type:"integer"`

	// The not equal to operator. The Evaluation results will have FilterVariable
	// values not equal to the value specified with NE.
	NE *string `type:"string"`

	// The ID of the page in the paginated results.
	NextToken *string `type:"string"`

	// A string that is found at the beginning of a variable, such as Name or Id.
	//
	// For example, an Evaluation could have the Name2014-09-09-HolidayGiftMailer.
	// To search for this Evaluation, select Name for the FilterVariable and any
	// of the following strings for the Prefix:
	//
	//    * 2014-09
	//
	//    * 2014-09-09
	//
	//    * 2014-09-09-Holiday
	Prefix *string `type:"string"`

	// A two-value parameter that determines the sequence of the resulting list
	// of Evaluation.
	//
	//    * asc - Arranges the list in ascending order (A-Z, 0-9).
	//    * dsc - Arranges the list in descending order (Z-A, 9-0).
	// Results are sorted by FilterVariable.
	SortOrder SortOrder `type:"string" enum:"true"`
}

// String returns the string representation
func (s DescribeEvaluationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEvaluationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeEvaluationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeEvaluationsInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the query results from a DescribeEvaluations operation. The content
// is essentially a list of Evaluation.
type DescribeEvaluationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the next page in the paginated results that indicates at least
	// one more page follows.
	NextToken *string `type:"string"`

	// A list of Evaluation that meet the search criteria.
	Results []Evaluation `type:"list"`
}

// String returns the string representation
func (s DescribeEvaluationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEvaluationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeEvaluationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DescribeMLModelsInput struct {
	_ struct{} `type:"structure"`

	// The equal to operator. The MLModel results will have FilterVariable values
	// that exactly match the value specified with EQ.
	EQ *string `type:"string"`

	// Use one of the following variables to filter a list of MLModel:
	//
	//    * CreatedAt - Sets the search criteria to MLModel creation date.
	//    * Status - Sets the search criteria to MLModel status.
	//    * Name - Sets the search criteria to the contents of MLModelName.
	//    * IAMUser - Sets the search criteria to the user account that invoked
	//    the MLModel creation.
	//    * TrainingDataSourceId - Sets the search criteria to the DataSource used
	//    to train one or more MLModel.
	//    * RealtimeEndpointStatus - Sets the search criteria to the MLModel real-time
	//    endpoint status.
	//    * MLModelType - Sets the search criteria to MLModel type: binary, regression,
	//    or multi-class.
	//    * Algorithm - Sets the search criteria to the algorithm that the MLModel
	//    uses.
	//    * TrainingDataURI - Sets the search criteria to the data file(s) used
	//    in training a MLModel. The URL can identify either a file or an Amazon
	//    Simple Storage Service (Amazon S3) bucket or directory.
	FilterVariable MLModelFilterVariable `type:"string" enum:"true"`

	// The greater than or equal to operator. The MLModel results will have FilterVariable
	// values that are greater than or equal to the value specified with GE.
	GE *string `type:"string"`

	// The greater than operator. The MLModel results will have FilterVariable values
	// that are greater than the value specified with GT.
	GT *string `type:"string"`

	// The less than or equal to operator. The MLModel results will have FilterVariable
	// values that are less than or equal to the value specified with LE.
	LE *string `type:"string"`

	// The less than operator. The MLModel results will have FilterVariable values
	// that are less than the value specified with LT.
	LT *string `type:"string"`

	// The number of pages of information to include in the result. The range of
	// acceptable values is 1 through 100. The default value is 100.
	Limit *int64 `min:"1" type:"integer"`

	// The not equal to operator. The MLModel results will have FilterVariable values
	// not equal to the value specified with NE.
	NE *string `type:"string"`

	// The ID of the page in the paginated results.
	NextToken *string `type:"string"`

	// A string that is found at the beginning of a variable, such as Name or Id.
	//
	// For example, an MLModel could have the Name2014-09-09-HolidayGiftMailer.
	// To search for this MLModel, select Name for the FilterVariable and any of
	// the following strings for the Prefix:
	//
	//    * 2014-09
	//
	//    * 2014-09-09
	//
	//    * 2014-09-09-Holiday
	Prefix *string `type:"string"`

	// A two-value parameter that determines the sequence of the resulting list
	// of MLModel.
	//
	//    * asc - Arranges the list in ascending order (A-Z, 0-9).
	//    * dsc - Arranges the list in descending order (Z-A, 9-0).
	// Results are sorted by FilterVariable.
	SortOrder SortOrder `type:"string" enum:"true"`
}

// String returns the string representation
func (s DescribeMLModelsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMLModelsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeMLModelsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeMLModelsInput"}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DescribeMLModels operation. The content is essentially
// a list of MLModel.
type DescribeMLModelsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the next page in the paginated results that indicates at least
	// one more page follows.
	NextToken *string `type:"string"`

	// A list of MLModel that meet the search criteria.
	Results []MLModel `type:"list"`
}

// String returns the string representation
func (s DescribeMLModelsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMLModelsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeMLModelsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type DescribeTagsInput struct {
	_ struct{} `type:"structure"`

	// The ID of the ML object. For example, exampleModelId.
	//
	// ResourceId is a required field
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The type of the ML object.
	//
	// ResourceType is a required field
	ResourceType TaggableResourceType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s DescribeTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeTagsInput"}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceId", 1))
	}
	if len(s.ResourceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResourceType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Amazon ML returns the following elements.
type DescribeTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the tagged ML object.
	ResourceId *string `min:"1" type:"string"`

	// The type of the tagged ML object.
	ResourceType TaggableResourceType `type:"string" enum:"true"`

	// A list of tags associated with the ML object.
	Tags []Tag `type:"list"`
}

// String returns the string representation
func (s DescribeTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the output of GetEvaluation operation.
//
// The content consists of the detailed metadata and data file information and
// the current status of the Evaluation.
type Evaluation struct {
	_ struct{} `type:"structure"`

	// Long integer type that is a 64-bit signed number.
	ComputeTime *int64 `type:"long"`

	// The time that the Evaluation was created. The time is expressed in epoch
	// time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The AWS user account that invoked the evaluation. The account type can be
	// either an AWS root account or an AWS Identity and Access Management (IAM)
	// user account.
	CreatedByIamUser *string `type:"string"`

	// The ID of the DataSource that is used to evaluate the MLModel.
	EvaluationDataSourceId *string `min:"1" type:"string"`

	// The ID that is assigned to the Evaluation at creation.
	EvaluationId *string `min:"1" type:"string"`

	// A timestamp represented in epoch time.
	FinishedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The location and name of the data in Amazon Simple Storage Server (Amazon
	// S3) that is used in the evaluation.
	InputDataLocationS3 *string `type:"string"`

	// The time of the most recent edit to the Evaluation. The time is expressed
	// in epoch time.
	LastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID of the MLModel that is the focus of the evaluation.
	MLModelId *string `min:"1" type:"string"`

	// A description of the most recent details about evaluating the MLModel.
	Message *string `type:"string"`

	// A user-supplied name or description of the Evaluation.
	Name *string `type:"string"`

	// Measurements of how well the MLModel performed, using observations referenced
	// by the DataSource. One of the following metrics is returned, based on the
	// type of the MLModel:
	//
	//    * BinaryAUC: A binary MLModel uses the Area Under the Curve (AUC) technique
	//    to measure performance.
	//
	//    * RegressionRMSE: A regression MLModel uses the Root Mean Square Error
	//    (RMSE) technique to measure performance. RMSE measures the difference
	//    between predicted and actual values for a single variable.
	//
	//    * MulticlassAvgFScore: A multiclass MLModel uses the F1 score technique
	//    to measure performance.
	//
	// For more information about performance metrics, please see the Amazon Machine
	// Learning Developer Guide (http://docs.aws.amazon.com/machine-learning/latest/dg).
	PerformanceMetrics *PerformanceMetrics `type:"structure"`

	// A timestamp represented in epoch time.
	StartedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The status of the evaluation. This element can have one of the following
	// values:
	//
	//    * PENDING - Amazon Machine Learning (Amazon ML) submitted a request to
	//    evaluate an MLModel.
	//    * INPROGRESS - The evaluation is underway.
	//    * FAILED - The request to evaluate an MLModel did not run to completion.
	//    It is not usable.
	//    * COMPLETED - The evaluation process completed successfully.
	//    * DELETED - The Evaluation is marked as deleted. It is not usable.
	Status EntityStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s Evaluation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Evaluation) GoString() string {
	return s.String()
}

type GetBatchPredictionInput struct {
	_ struct{} `type:"structure"`

	// An ID assigned to the BatchPrediction at creation.
	//
	// BatchPredictionId is a required field
	BatchPredictionId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBatchPredictionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBatchPredictionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBatchPredictionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBatchPredictionInput"}

	if s.BatchPredictionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BatchPredictionId"))
	}
	if s.BatchPredictionId != nil && len(*s.BatchPredictionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BatchPredictionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a GetBatchPrediction operation and describes a BatchPrediction.
type GetBatchPredictionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the DataSource that was used to create the BatchPrediction.
	BatchPredictionDataSourceId *string `min:"1" type:"string"`

	// An ID assigned to the BatchPrediction at creation. This value should be identical
	// to the value of the BatchPredictionID in the request.
	BatchPredictionId *string `min:"1" type:"string"`

	// The approximate CPU time in milliseconds that Amazon Machine Learning spent
	// processing the BatchPrediction, normalized and scaled on computation resources.
	// ComputeTime is only available if the BatchPrediction is in the COMPLETED
	// state.
	ComputeTime *int64 `type:"long"`

	// The time when the BatchPrediction was created. The time is expressed in epoch
	// time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The AWS user account that invoked the BatchPrediction. The account type can
	// be either an AWS root account or an AWS Identity and Access Management (IAM)
	// user account.
	CreatedByIamUser *string `type:"string"`

	// The epoch time when Amazon Machine Learning marked the BatchPrediction as
	// COMPLETED or FAILED. FinishedAt is only available when the BatchPrediction
	// is in the COMPLETED or FAILED state.
	FinishedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The location of the data file or directory in Amazon Simple Storage Service
	// (Amazon S3).
	InputDataLocationS3 *string `type:"string"`

	// The number of invalid records that Amazon Machine Learning saw while processing
	// the BatchPrediction.
	InvalidRecordCount *int64 `type:"long"`

	// The time of the most recent edit to BatchPrediction. The time is expressed
	// in epoch time.
	LastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A link to the file that contains logs of the CreateBatchPrediction operation.
	LogUri *string `type:"string"`

	// The ID of the MLModel that generated predictions for the BatchPrediction
	// request.
	MLModelId *string `min:"1" type:"string"`

	// A description of the most recent details about processing the batch prediction
	// request.
	Message *string `type:"string"`

	// A user-supplied name or description of the BatchPrediction.
	Name *string `type:"string"`

	// The location of an Amazon S3 bucket or directory to receive the operation
	// results.
	OutputUri *string `type:"string"`

	// The epoch time when Amazon Machine Learning marked the BatchPrediction as
	// INPROGRESS. StartedAt isn't available if the BatchPrediction is in the PENDING
	// state.
	StartedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The status of the BatchPrediction, which can be one of the following values:
	//
	//    * PENDING - Amazon Machine Learning (Amazon ML) submitted a request to
	//    generate batch predictions.
	//    * INPROGRESS - The batch predictions are in progress.
	//    * FAILED - The request to perform a batch prediction did not run to completion.
	//    It is not usable.
	//    * COMPLETED - The batch prediction process completed successfully.
	//    * DELETED - The BatchPrediction is marked as deleted. It is not usable.
	Status EntityStatus `type:"string" enum:"true"`

	// The number of total records that Amazon Machine Learning saw while processing
	// the BatchPrediction.
	TotalRecordCount *int64 `type:"long"`
}

// String returns the string representation
func (s GetBatchPredictionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBatchPredictionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBatchPredictionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type GetDataSourceInput struct {
	_ struct{} `type:"structure"`

	// The ID assigned to the DataSource at creation.
	//
	// DataSourceId is a required field
	DataSourceId *string `min:"1" type:"string" required:"true"`

	// Specifies whether the GetDataSource operation should return DataSourceSchema.
	//
	// If true, DataSourceSchema is returned.
	//
	// If false, DataSourceSchema is not returned.
	Verbose *bool `type:"boolean"`
}

// String returns the string representation
func (s GetDataSourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDataSourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDataSourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDataSourceInput"}

	if s.DataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceId"))
	}
	if s.DataSourceId != nil && len(*s.DataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DataSourceId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a GetDataSource operation and describes a DataSource.
type GetDataSourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The parameter is true if statistics need to be generated from the observation
	// data.
	ComputeStatistics *bool `type:"boolean"`

	// The approximate CPU time in milliseconds that Amazon Machine Learning spent
	// processing the DataSource, normalized and scaled on computation resources.
	// ComputeTime is only available if the DataSource is in the COMPLETED state
	// and the ComputeStatistics is set to true.
	ComputeTime *int64 `type:"long"`

	// The time that the DataSource was created. The time is expressed in epoch
	// time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The AWS user account from which the DataSource was created. The account type
	// can be either an AWS root account or an AWS Identity and Access Management
	// (IAM) user account.
	CreatedByIamUser *string `type:"string"`

	// The location of the data file or directory in Amazon Simple Storage Service
	// (Amazon S3).
	DataLocationS3 *string `type:"string"`

	// A JSON string that represents the splitting and rearrangement requirement
	// used when this DataSource was created.
	DataRearrangement *string `type:"string"`

	// The total size of observations in the data files.
	DataSizeInBytes *int64 `type:"long"`

	// The ID assigned to the DataSource at creation. This value should be identical
	// to the value of the DataSourceId in the request.
	DataSourceId *string `min:"1" type:"string"`

	// The schema used by all of the data files of this DataSource.
	//
	// NoteThis parameter is provided as part of the verbose format.
	DataSourceSchema *string `type:"string"`

	// The epoch time when Amazon Machine Learning marked the DataSource as COMPLETED
	// or FAILED. FinishedAt is only available when the DataSource is in the COMPLETED
	// or FAILED state.
	FinishedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The time of the most recent edit to the DataSource. The time is expressed
	// in epoch time.
	LastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A link to the file containing logs of CreateDataSourceFrom* operations.
	LogUri *string `type:"string"`

	// The user-supplied description of the most recent details about creating the
	// DataSource.
	Message *string `type:"string"`

	// A user-supplied name or description of the DataSource.
	Name *string `type:"string"`

	// The number of data files referenced by the DataSource.
	NumberOfFiles *int64 `type:"long"`

	// The datasource details that are specific to Amazon RDS.
	RDSMetadata *RDSMetadata `type:"structure"`

	// Describes the DataSource details specific to Amazon Redshift.
	RedshiftMetadata *RedshiftMetadata `type:"structure"`

	// The Amazon Resource Name (ARN) of an AWS IAM Role (http://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html#roles-about-termsandconcepts),
	// such as the following: arn:aws:iam::account:role/rolename.
	RoleARN *string `min:"1" type:"string"`

	// The epoch time when Amazon Machine Learning marked the DataSource as INPROGRESS.
	// StartedAt isn't available if the DataSource is in the PENDING state.
	StartedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The current status of the DataSource. This element can have one of the following
	// values:
	//
	//    * PENDING - Amazon ML submitted a request to create a DataSource.
	//    * INPROGRESS - The creation process is underway.
	//    * FAILED - The request to create a DataSource did not run to completion.
	//    It is not usable.
	//    * COMPLETED - The creation process completed successfully.
	//    * DELETED - The DataSource is marked as deleted. It is not usable.
	Status EntityStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s GetDataSourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDataSourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDataSourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type GetEvaluationInput struct {
	_ struct{} `type:"structure"`

	// The ID of the Evaluation to retrieve. The evaluation of each MLModel is recorded
	// and cataloged. The ID provides the means to access the information.
	//
	// EvaluationId is a required field
	EvaluationId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetEvaluationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetEvaluationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetEvaluationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetEvaluationInput"}

	if s.EvaluationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("EvaluationId"))
	}
	if s.EvaluationId != nil && len(*s.EvaluationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("EvaluationId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a GetEvaluation operation and describes an Evaluation.
type GetEvaluationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The approximate CPU time in milliseconds that Amazon Machine Learning spent
	// processing the Evaluation, normalized and scaled on computation resources.
	// ComputeTime is only available if the Evaluation is in the COMPLETED state.
	ComputeTime *int64 `type:"long"`

	// The time that the Evaluation was created. The time is expressed in epoch
	// time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The AWS user account that invoked the evaluation. The account type can be
	// either an AWS root account or an AWS Identity and Access Management (IAM)
	// user account.
	CreatedByIamUser *string `type:"string"`

	// The DataSource used for this evaluation.
	EvaluationDataSourceId *string `min:"1" type:"string"`

	// The evaluation ID which is same as the EvaluationId in the request.
	EvaluationId *string `min:"1" type:"string"`

	// The epoch time when Amazon Machine Learning marked the Evaluation as COMPLETED
	// or FAILED. FinishedAt is only available when the Evaluation is in the COMPLETED
	// or FAILED state.
	FinishedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The location of the data file or directory in Amazon Simple Storage Service
	// (Amazon S3).
	InputDataLocationS3 *string `type:"string"`

	// The time of the most recent edit to the Evaluation. The time is expressed
	// in epoch time.
	LastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A link to the file that contains logs of the CreateEvaluation operation.
	LogUri *string `type:"string"`

	// The ID of the MLModel that was the focus of the evaluation.
	MLModelId *string `min:"1" type:"string"`

	// A description of the most recent details about evaluating the MLModel.
	Message *string `type:"string"`

	// A user-supplied name or description of the Evaluation.
	Name *string `type:"string"`

	// Measurements of how well the MLModel performed using observations referenced
	// by the DataSource. One of the following metric is returned based on the type
	// of the MLModel:
	//
	//    * BinaryAUC: A binary MLModel uses the Area Under the Curve (AUC) technique
	//    to measure performance.
	//
	//    * RegressionRMSE: A regression MLModel uses the Root Mean Square Error
	//    (RMSE) technique to measure performance. RMSE measures the difference
	//    between predicted and actual values for a single variable.
	//
	//    * MulticlassAvgFScore: A multiclass MLModel uses the F1 score technique
	//    to measure performance.
	//
	// For more information about performance metrics, please see the Amazon Machine
	// Learning Developer Guide (http://docs.aws.amazon.com/machine-learning/latest/dg).
	PerformanceMetrics *PerformanceMetrics `type:"structure"`

	// The epoch time when Amazon Machine Learning marked the Evaluation as INPROGRESS.
	// StartedAt isn't available if the Evaluation is in the PENDING state.
	StartedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The status of the evaluation. This element can have one of the following
	// values:
	//
	//    * PENDING - Amazon Machine Language (Amazon ML) submitted a request to
	//    evaluate an MLModel.
	//    * INPROGRESS - The evaluation is underway.
	//    * FAILED - The request to evaluate an MLModel did not run to completion.
	//    It is not usable.
	//    * COMPLETED - The evaluation process completed successfully.
	//    * DELETED - The Evaluation is marked as deleted. It is not usable.
	Status EntityStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s GetEvaluationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetEvaluationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetEvaluationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type GetMLModelInput struct {
	_ struct{} `type:"structure"`

	// The ID assigned to the MLModel at creation.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`

	// Specifies whether the GetMLModel operation should return Recipe.
	//
	// If true, Recipe is returned.
	//
	// If false, Recipe is not returned.
	Verbose *bool `type:"boolean"`
}

// String returns the string representation
func (s GetMLModelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMLModelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetMLModelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetMLModelInput"}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a GetMLModel operation, and provides detailed information
// about a MLModel.
type GetMLModelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The approximate CPU time in milliseconds that Amazon Machine Learning spent
	// processing the MLModel, normalized and scaled on computation resources. ComputeTime
	// is only available if the MLModel is in the COMPLETED state.
	ComputeTime *int64 `type:"long"`

	// The time that the MLModel was created. The time is expressed in epoch time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The AWS user account from which the MLModel was created. The account type
	// can be either an AWS root account or an AWS Identity and Access Management
	// (IAM) user account.
	CreatedByIamUser *string `type:"string"`

	// The current endpoint of the MLModel
	EndpointInfo *RealtimeEndpointInfo `type:"structure"`

	// The epoch time when Amazon Machine Learning marked the MLModel as COMPLETED
	// or FAILED. FinishedAt is only available when the MLModel is in the COMPLETED
	// or FAILED state.
	FinishedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The location of the data file or directory in Amazon Simple Storage Service
	// (Amazon S3).
	InputDataLocationS3 *string `type:"string"`

	// The time of the most recent edit to the MLModel. The time is expressed in
	// epoch time.
	LastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A link to the file that contains logs of the CreateMLModel operation.
	LogUri *string `type:"string"`

	// The MLModel ID, which is same as the MLModelId in the request.
	MLModelId *string `min:"1" type:"string"`

	// Identifies the MLModel category. The following are the available types:
	//
	//    * REGRESSION -- Produces a numeric result. For example, "What price should
	//    a house be listed at?"
	//    * BINARY -- Produces one of two possible results. For example, "Is this
	//    an e-commerce website?"
	//    * MULTICLASS -- Produces one of several possible results. For example,
	//    "Is this a HIGH, LOW or MEDIUM risk trade?"
	MLModelType MLModelType `type:"string" enum:"true"`

	// A description of the most recent details about accessing the MLModel.
	Message *string `type:"string"`

	// A user-supplied name or description of the MLModel.
	Name *string `type:"string"`

	// The recipe to use when training the MLModel. The Recipe provides detailed
	// information about the observation data to use during training, and manipulations
	// to perform on the observation data during training.
	//
	// NoteThis parameter is provided as part of the verbose format.
	Recipe *string `type:"string"`

	// The schema used by all of the data files referenced by the DataSource.
	//
	// NoteThis parameter is provided as part of the verbose format.
	Schema *string `type:"string"`

	// The scoring threshold is used in binary classification MLModelmodels. It
	// marks the boundary between a positive prediction and a negative prediction.
	//
	// Output values greater than or equal to the threshold receive a positive result
	// from the MLModel, such as true. Output values less than the threshold receive
	// a negative response from the MLModel, such as false.
	ScoreThreshold *float64 `type:"float"`

	// The time of the most recent edit to the ScoreThreshold. The time is expressed
	// in epoch time.
	ScoreThresholdLastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Long integer type that is a 64-bit signed number.
	SizeInBytes *int64 `type:"long"`

	// The epoch time when Amazon Machine Learning marked the MLModel as INPROGRESS.
	// StartedAt isn't available if the MLModel is in the PENDING state.
	StartedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The current status of the MLModel. This element can have one of the following
	// values:
	//
	//    * PENDING - Amazon Machine Learning (Amazon ML) submitted a request to
	//    describe a MLModel.
	//    * INPROGRESS - The request is processing.
	//    * FAILED - The request did not run to completion. The ML model isn't usable.
	//
	//    * COMPLETED - The request completed successfully.
	//    * DELETED - The MLModel is marked as deleted. It isn't usable.
	Status EntityStatus `type:"string" enum:"true"`

	// The ID of the training DataSource.
	TrainingDataSourceId *string `min:"1" type:"string"`

	// A list of the training parameters in the MLModel. The list is implemented
	// as a map of key-value pairs.
	//
	// The following is the current set of training parameters:
	//
	//    * sgd.maxMLModelSizeInBytes - The maximum allowed size of the model. Depending
	//    on the input data, the size of the model might affect its performance.
	//
	//  The value is an integer that ranges from 100000 to 2147483648. The default
	//    value is 33554432.
	//
	//    * sgd.maxPasses - The number of times that the training process traverses
	//    the observations to build the MLModel. The value is an integer that ranges
	//    from 1 to 10000. The default value is 10.
	//
	//    * sgd.shuffleType - Whether Amazon ML shuffles the training data. Shuffling
	//    data improves a model's ability to find the optimal solution for a variety
	//    of data types. The valid values are auto and none. The default value is
	//    none. We strongly recommend that you shuffle your data.
	//
	//    * sgd.l1RegularizationAmount - The coefficient regularization L1 norm.
	//    It controls overfitting the data by penalizing large coefficients. This
	//    tends to drive coefficients to zero, resulting in a sparse feature set.
	//    If you use this parameter, start by specifying a small value, such as
	//    1.0E-08.
	//
	// The value is a double that ranges from 0 to MAX_DOUBLE. The default is to
	//    not use L1 normalization. This parameter can't be used when L2 is specified.
	//    Use this parameter sparingly.
	//
	//    * sgd.l2RegularizationAmount - The coefficient regularization L2 norm.
	//    It controls overfitting the data by penalizing large coefficients. This
	//    tends to drive coefficients to small, nonzero values. If you use this
	//    parameter, start by specifying a small value, such as 1.0E-08.
	//
	// The value is a double that ranges from 0 to MAX_DOUBLE. The default is to
	//    not use L2 normalization. This parameter can't be used when L1 is specified.
	//    Use this parameter sparingly.
	TrainingParameters map[string]string `type:"map"`
}

// String returns the string representation
func (s GetMLModelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMLModelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetMLModelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the output of a GetMLModel operation.
//
// The content consists of the detailed metadata and the current status of the
// MLModel.
type MLModel struct {
	_ struct{} `type:"structure"`

	// The algorithm used to train the MLModel. The following algorithm is supported:
	//
	//    * SGD -- Stochastic gradient descent. The goal of SGD is to minimize the
	//    gradient of the loss function.
	Algorithm Algorithm `type:"string" enum:"true"`

	// Long integer type that is a 64-bit signed number.
	ComputeTime *int64 `type:"long"`

	// The time that the MLModel was created. The time is expressed in epoch time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The AWS user account from which the MLModel was created. The account type
	// can be either an AWS root account or an AWS Identity and Access Management
	// (IAM) user account.
	CreatedByIamUser *string `type:"string"`

	// The current endpoint of the MLModel.
	EndpointInfo *RealtimeEndpointInfo `type:"structure"`

	// A timestamp represented in epoch time.
	FinishedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The location of the data file or directory in Amazon Simple Storage Service
	// (Amazon S3).
	InputDataLocationS3 *string `type:"string"`

	// The time of the most recent edit to the MLModel. The time is expressed in
	// epoch time.
	LastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The ID assigned to the MLModel at creation.
	MLModelId *string `min:"1" type:"string"`

	// Identifies the MLModel category. The following are the available types:
	//
	//    * REGRESSION - Produces a numeric result. For example, "What price should
	//    a house be listed at?"
	//    * BINARY - Produces one of two possible results. For example, "Is this
	//    a child-friendly web site?".
	//    * MULTICLASS - Produces one of several possible results. For example,
	//    "Is this a HIGH-, LOW-, or MEDIUM-risk trade?".
	MLModelType MLModelType `type:"string" enum:"true"`

	// A description of the most recent details about accessing the MLModel.
	Message *string `type:"string"`

	// A user-supplied name or description of the MLModel.
	Name *string `type:"string"`

	ScoreThreshold *float64 `type:"float"`

	// The time of the most recent edit to the ScoreThreshold. The time is expressed
	// in epoch time.
	ScoreThresholdLastUpdatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Long integer type that is a 64-bit signed number.
	SizeInBytes *int64 `type:"long"`

	// A timestamp represented in epoch time.
	StartedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The current status of an MLModel. This element can have one of the following
	// values:
	//
	//    * PENDING - Amazon Machine Learning (Amazon ML) submitted a request to
	//    create an MLModel.
	//    * INPROGRESS - The creation process is underway.
	//    * FAILED - The request to create an MLModel didn't run to completion.
	//    The model isn't usable.
	//    * COMPLETED - The creation process completed successfully.
	//    * DELETED - The MLModel is marked as deleted. It isn't usable.
	Status EntityStatus `type:"string" enum:"true"`

	// The ID of the training DataSource. The CreateMLModel operation uses the TrainingDataSourceId.
	TrainingDataSourceId *string `min:"1" type:"string"`

	// A list of the training parameters in the MLModel. The list is implemented
	// as a map of key-value pairs.
	//
	// The following is the current set of training parameters:
	//
	//    * sgd.maxMLModelSizeInBytes - The maximum allowed size of the model. Depending
	//    on the input data, the size of the model might affect its performance.
	//
	//  The value is an integer that ranges from 100000 to 2147483648. The default
	//    value is 33554432.
	//
	//    * sgd.maxPasses - The number of times that the training process traverses
	//    the observations to build the MLModel. The value is an integer that ranges
	//    from 1 to 10000. The default value is 10.
	//
	//    * sgd.shuffleType - Whether Amazon ML shuffles the training data. Shuffling
	//    the data improves a model's ability to find the optimal solution for a
	//    variety of data types. The valid values are auto and none. The default
	//    value is none.
	//
	//    * sgd.l1RegularizationAmount - The coefficient regularization L1 norm,
	//    which controls overfitting the data by penalizing large coefficients.
	//    This parameter tends to drive coefficients to zero, resulting in sparse
	//    feature set. If you use this parameter, start by specifying a small value,
	//    such as 1.0E-08.
	//
	// The value is a double that ranges from 0 to MAX_DOUBLE. The default is to
	//    not use L1 normalization. This parameter can't be used when L2 is specified.
	//    Use this parameter sparingly.
	//
	//    * sgd.l2RegularizationAmount - The coefficient regularization L2 norm,
	//    which controls overfitting the data by penalizing large coefficients.
	//    This tends to drive coefficients to small, nonzero values. If you use
	//    this parameter, start by specifying a small value, such as 1.0E-08.
	//
	// The value is a double that ranges from 0 to MAX_DOUBLE. The default is to
	//    not use L2 normalization. This parameter can't be used when L1 is specified.
	//    Use this parameter sparingly.
	TrainingParameters map[string]string `type:"map"`
}

// String returns the string representation
func (s MLModel) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MLModel) GoString() string {
	return s.String()
}

// Measurements of how well the MLModel performed on known observations. One
// of the following metrics is returned, based on the type of the MLModel:
//
//    * BinaryAUC: The binary MLModel uses the Area Under the Curve (AUC) technique
//    to measure performance.
//
//    * RegressionRMSE: The regression MLModel uses the Root Mean Square Error
//    (RMSE) technique to measure performance. RMSE measures the difference
//    between predicted and actual values for a single variable.
//
//    * MulticlassAvgFScore: The multiclass MLModel uses the F1 score technique
//    to measure performance.
//
// For more information about performance metrics, please see the Amazon Machine
// Learning Developer Guide (http://docs.aws.amazon.com/machine-learning/latest/dg).
type PerformanceMetrics struct {
	_ struct{} `type:"structure"`

	Properties map[string]string `type:"map"`
}

// String returns the string representation
func (s PerformanceMetrics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PerformanceMetrics) GoString() string {
	return s.String()
}

type PredictInput struct {
	_ struct{} `type:"structure"`

	// A unique identifier of the MLModel.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`

	// PredictEndpoint is a required field
	PredictEndpoint *string `type:"string" required:"true"`

	// A map of variable name-value pairs that represent an observation.
	//
	// Record is a required field
	Record map[string]string `type:"map" required:"true"`
}

// String returns the string representation
func (s PredictInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PredictInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PredictInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PredictInput"}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}

	if s.PredictEndpoint == nil {
		invalidParams.Add(aws.NewErrParamRequired("PredictEndpoint"))
	}

	if s.Record == nil {
		invalidParams.Add(aws.NewErrParamRequired("Record"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type PredictOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The output from a Predict operation:
	//
	//    * Details - Contains the following attributes: DetailsAttributes.PREDICTIVE_MODEL_TYPE
	//    - REGRESSION | BINARY | MULTICLASSDetailsAttributes.ALGORITHM - SGD
	//
	//    * PredictedLabel - Present for either a BINARY or MULTICLASSMLModel request.
	//
	//
	//    * PredictedScores - Contains the raw classification score corresponding
	//    to each label.
	//
	//    * PredictedValue - Present for a REGRESSIONMLModel request.
	Prediction *Prediction `type:"structure"`
}

// String returns the string representation
func (s PredictOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PredictOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PredictOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// The output from a Predict operation:
//
//    * Details - Contains the following attributes: DetailsAttributes.PREDICTIVE_MODEL_TYPE
//    - REGRESSION | BINARY | MULTICLASSDetailsAttributes.ALGORITHM - SGD
//
//    * PredictedLabel - Present for either a BINARY or MULTICLASSMLModel request.
//
//
//    * PredictedScores - Contains the raw classification score corresponding
//    to each label.
//
//    * PredictedValue - Present for a REGRESSIONMLModel request.
type Prediction struct {
	_ struct{} `type:"structure"`

	// Provides any additional details regarding the prediction.
	Details map[string]string `locationName:"details" type:"map"`

	// The prediction label for either a BINARY or MULTICLASSMLModel.
	PredictedLabel *string `locationName:"predictedLabel" min:"1" type:"string"`

	// Provides the raw classification score corresponding to each label.
	PredictedScores map[string]float64 `locationName:"predictedScores" type:"map"`

	// The prediction value for REGRESSIONMLModel
	PredictedValue *float64 `locationName:"predictedValue" type:"float"`
}

// String returns the string representation
func (s Prediction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Prediction) GoString() string {
	return s.String()
}

// The data specification of an Amazon Relational Database Service (Amazon RDS)
// DataSource.
type RDSDataSpec struct {
	_ struct{} `type:"structure"`

	// A JSON string that represents the splitting and rearrangement processing
	// to be applied to a DataSource. If the DataRearrangement parameter is not
	// provided, all of the input data is used to create the Datasource.
	//
	// There are multiple parameters that control what data is used to create a
	// datasource:
	//
	//    * percentBegin
	//
	// Use percentBegin to indicate the beginning of the range of the data used
	//    to create the Datasource. If you do not include percentBegin and percentEnd,
	//    Amazon ML includes all of the data when creating the datasource.
	//
	//    * percentEnd
	//
	// Use percentEnd to indicate the end of the range of the data used to create
	//    the Datasource. If you do not include percentBegin and percentEnd, Amazon
	//    ML includes all of the data when creating the datasource.
	//
	//    * complement
	//
	// The complement parameter instructs Amazon ML to use the data that is not
	//    included in the range of percentBegin to percentEnd to create a datasource.
	//    The complement parameter is useful if you need to create complementary
	//    datasources for training and evaluation. To create a complementary datasource,
	//    use the same values for percentBegin and percentEnd, along with the complement
	//    parameter.
	//
	// For example, the following two datasources do not share any data, and can
	//    be used to train and evaluate a model. The first datasource has 25 percent
	//    of the data, and the second one has 75 percent of the data.
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":0, "percentEnd":25}}
	//
	// Datasource for training: {"splitting":{"percentBegin":0, "percentEnd":25,
	//    "complement":"true"}}
	//
	//    * strategy
	//
	// To change how Amazon ML splits the data for a datasource, use the strategy
	//    parameter.
	//
	// The default value for the strategy parameter is sequential, meaning that
	//    Amazon ML takes all of the data records between the percentBegin and percentEnd
	//    parameters for the datasource, in the order that the records appear in
	//    the input data.
	//
	// The following two DataRearrangement lines are examples of sequentially ordered
	//    training and evaluation datasources:
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"sequential"}}
	//
	// Datasource for training: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"sequential", "complement":"true"}}
	//
	// To randomly split the input data into the proportions indicated by the percentBegin
	//    and percentEnd parameters, set the strategy parameter to random and provide
	//    a string that is used as the seed value for the random data splitting
	//    (for example, you can use the S3 path to your data as the random seed
	//    string). If you choose the random split strategy, Amazon ML assigns each
	//    row of data a pseudo-random number between 0 and 100, and then selects
	//    the rows that have an assigned number between percentBegin and percentEnd.
	//    Pseudo-random numbers are assigned using both the input seed string value
	//    and the byte offset as a seed, so changing the data results in a different
	//    split. Any existing ordering is preserved. The random splitting strategy
	//    ensures that variables in the training and evaluation data are distributed
	//    similarly. It is useful in the cases where the input data may have an
	//    implicit sort order, which would otherwise result in training and evaluation
	//    datasources containing non-similar data records.
	//
	// The following two DataRearrangement lines are examples of non-sequentially
	//    ordered training and evaluation datasources:
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"random", "randomSeed"="s3://my_s3_path/bucket/file.csv"}}
	//
	// Datasource for training: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"random", "randomSeed"="s3://my_s3_path/bucket/file.csv", "complement":"true"}}
	DataRearrangement *string `type:"string"`

	// A JSON string that represents the schema for an Amazon RDS DataSource. The
	// DataSchema defines the structure of the observation data in the data file(s)
	// referenced in the DataSource.
	//
	// A DataSchema is not required if you specify a DataSchemaUri
	//
	// Define your DataSchema as a series of key-value pairs. attributes and excludedVariableNames
	// have an array of key-value pairs for their value. Use the following format
	// to define your DataSchema.
	//
	// { "version": "1.0",
	//
	// "recordAnnotationFieldName": "F1",
	//
	// "recordWeightFieldName": "F2",
	//
	// "targetFieldName": "F3",
	//
	// "dataFormat": "CSV",
	//
	// "dataFileContainsHeader": true,
	//
	// "attributes": [
	//
	// { "fieldName": "F1", "fieldType": "TEXT" }, { "fieldName": "F2", "fieldType":
	// "NUMERIC" }, { "fieldName": "F3", "fieldType": "CATEGORICAL" }, { "fieldName":
	// "F4", "fieldType": "NUMERIC" }, { "fieldName": "F5", "fieldType": "CATEGORICAL"
	// }, { "fieldName": "F6", "fieldType": "TEXT" }, { "fieldName": "F7", "fieldType":
	// "WEIGHTED_INT_SEQUENCE" }, { "fieldName": "F8", "fieldType": "WEIGHTED_STRING_SEQUENCE"
	// } ],
	//
	// "excludedVariableNames": [ "F6" ] }
	DataSchema *string `type:"string"`

	// The Amazon S3 location of the DataSchema.
	DataSchemaUri *string `type:"string"`

	// The AWS Identity and Access Management (IAM) credentials that are used connect
	// to the Amazon RDS database.
	//
	// DatabaseCredentials is a required field
	DatabaseCredentials *RDSDatabaseCredentials `type:"structure" required:"true"`

	// Describes the DatabaseName and InstanceIdentifier of an Amazon RDS database.
	//
	// DatabaseInformation is a required field
	DatabaseInformation *RDSDatabase `type:"structure" required:"true"`

	// The role (DataPipelineDefaultResourceRole) assumed by an Amazon Elastic Compute
	// Cloud (Amazon EC2) instance to carry out the copy operation from Amazon RDS
	// to an Amazon S3 task. For more information, see Role templates (http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-iam-roles.html)
	// for data pipelines.
	//
	// ResourceRole is a required field
	ResourceRole *string `min:"1" type:"string" required:"true"`

	// The Amazon S3 location for staging Amazon RDS data. The data retrieved from
	// Amazon RDS using SelectSqlQuery is stored in this location.
	//
	// S3StagingLocation is a required field
	S3StagingLocation *string `type:"string" required:"true"`

	// The security group IDs to be used to access a VPC-based RDS DB instance.
	// Ensure that there are appropriate ingress rules set up to allow access to
	// the RDS DB instance. This attribute is used by Data Pipeline to carry out
	// the copy operation from Amazon RDS to an Amazon S3 task.
	//
	// SecurityGroupIds is a required field
	SecurityGroupIds []string `type:"list" required:"true"`

	// The query that is used to retrieve the observation data for the DataSource.
	//
	// SelectSqlQuery is a required field
	SelectSqlQuery *string `min:"1" type:"string" required:"true"`

	// The role (DataPipelineDefaultRole) assumed by AWS Data Pipeline service to
	// monitor the progress of the copy task from Amazon RDS to Amazon S3. For more
	// information, see Role templates (http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-iam-roles.html)
	// for data pipelines.
	//
	// ServiceRole is a required field
	ServiceRole *string `min:"1" type:"string" required:"true"`

	// The subnet ID to be used to access a VPC-based RDS DB instance. This attribute
	// is used by Data Pipeline to carry out the copy task from Amazon RDS to Amazon
	// S3.
	//
	// SubnetId is a required field
	SubnetId *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RDSDataSpec) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RDSDataSpec) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RDSDataSpec) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RDSDataSpec"}

	if s.DatabaseCredentials == nil {
		invalidParams.Add(aws.NewErrParamRequired("DatabaseCredentials"))
	}

	if s.DatabaseInformation == nil {
		invalidParams.Add(aws.NewErrParamRequired("DatabaseInformation"))
	}

	if s.ResourceRole == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceRole"))
	}
	if s.ResourceRole != nil && len(*s.ResourceRole) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceRole", 1))
	}

	if s.S3StagingLocation == nil {
		invalidParams.Add(aws.NewErrParamRequired("S3StagingLocation"))
	}

	if s.SecurityGroupIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("SecurityGroupIds"))
	}

	if s.SelectSqlQuery == nil {
		invalidParams.Add(aws.NewErrParamRequired("SelectSqlQuery"))
	}
	if s.SelectSqlQuery != nil && len(*s.SelectSqlQuery) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SelectSqlQuery", 1))
	}

	if s.ServiceRole == nil {
		invalidParams.Add(aws.NewErrParamRequired("ServiceRole"))
	}
	if s.ServiceRole != nil && len(*s.ServiceRole) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ServiceRole", 1))
	}

	if s.SubnetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("SubnetId"))
	}
	if s.SubnetId != nil && len(*s.SubnetId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SubnetId", 1))
	}
	if s.DatabaseCredentials != nil {
		if err := s.DatabaseCredentials.Validate(); err != nil {
			invalidParams.AddNested("DatabaseCredentials", err.(aws.ErrInvalidParams))
		}
	}
	if s.DatabaseInformation != nil {
		if err := s.DatabaseInformation.Validate(); err != nil {
			invalidParams.AddNested("DatabaseInformation", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// The database details of an Amazon RDS database.
type RDSDatabase struct {
	_ struct{} `type:"structure"`

	// The name of a database hosted on an RDS DB instance.
	//
	// DatabaseName is a required field
	DatabaseName *string `min:"1" type:"string" required:"true"`

	// The ID of an RDS DB instance.
	//
	// InstanceIdentifier is a required field
	InstanceIdentifier *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RDSDatabase) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RDSDatabase) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RDSDatabase) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RDSDatabase"}

	if s.DatabaseName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DatabaseName"))
	}
	if s.DatabaseName != nil && len(*s.DatabaseName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DatabaseName", 1))
	}

	if s.InstanceIdentifier == nil {
		invalidParams.Add(aws.NewErrParamRequired("InstanceIdentifier"))
	}
	if s.InstanceIdentifier != nil && len(*s.InstanceIdentifier) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("InstanceIdentifier", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// The database credentials to connect to a database on an RDS DB instance.
type RDSDatabaseCredentials struct {
	_ struct{} `type:"structure"`

	// The password to be used by Amazon ML to connect to a database on an RDS DB
	// instance. The password should have sufficient permissions to execute the
	// RDSSelectQuery query.
	//
	// Password is a required field
	Password *string `min:"8" type:"string" required:"true"`

	// The username to be used by Amazon ML to connect to database on an Amazon
	// RDS instance. The username should have sufficient permissions to execute
	// an RDSSelectSqlQuery query.
	//
	// Username is a required field
	Username *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RDSDatabaseCredentials) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RDSDatabaseCredentials) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RDSDatabaseCredentials) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RDSDatabaseCredentials"}

	if s.Password == nil {
		invalidParams.Add(aws.NewErrParamRequired("Password"))
	}
	if s.Password != nil && len(*s.Password) < 8 {
		invalidParams.Add(aws.NewErrParamMinLen("Password", 8))
	}

	if s.Username == nil {
		invalidParams.Add(aws.NewErrParamRequired("Username"))
	}
	if s.Username != nil && len(*s.Username) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Username", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// The datasource details that are specific to Amazon RDS.
type RDSMetadata struct {
	_ struct{} `type:"structure"`

	// The ID of the Data Pipeline instance that is used to carry to copy data from
	// Amazon RDS to Amazon S3. You can use the ID to find details about the instance
	// in the Data Pipeline console.
	DataPipelineId *string `min:"1" type:"string"`

	// The database details required to connect to an Amazon RDS.
	Database *RDSDatabase `type:"structure"`

	// The username to be used by Amazon ML to connect to database on an Amazon
	// RDS instance. The username should have sufficient permissions to execute
	// an RDSSelectSqlQuery query.
	DatabaseUserName *string `min:"1" type:"string"`

	// The role (DataPipelineDefaultResourceRole) assumed by an Amazon EC2 instance
	// to carry out the copy task from Amazon RDS to Amazon S3. For more information,
	// see Role templates (http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-iam-roles.html)
	// for data pipelines.
	ResourceRole *string `min:"1" type:"string"`

	// The SQL query that is supplied during CreateDataSourceFromRDS. Returns only
	// if Verbose is true in GetDataSourceInput.
	SelectSqlQuery *string `min:"1" type:"string"`

	// The role (DataPipelineDefaultRole) assumed by the Data Pipeline service to
	// monitor the progress of the copy task from Amazon RDS to Amazon S3. For more
	// information, see Role templates (http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-iam-roles.html)
	// for data pipelines.
	ServiceRole *string `min:"1" type:"string"`
}

// String returns the string representation
func (s RDSMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RDSMetadata) GoString() string {
	return s.String()
}

// Describes the real-time endpoint information for an MLModel.
type RealtimeEndpointInfo struct {
	_ struct{} `type:"structure"`

	// The time that the request to create the real-time endpoint for the MLModel
	// was received. The time is expressed in epoch time.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The current status of the real-time endpoint for the MLModel. This element
	// can have one of the following values:
	//
	//    * NONE - Endpoint does not exist or was previously deleted.
	//    * READY - Endpoint is ready to be used for real-time predictions.
	//    * UPDATING - Updating/creating the endpoint.
	EndpointStatus RealtimeEndpointStatus `type:"string" enum:"true"`

	// The URI that specifies where to send real-time prediction requests for the
	// MLModel.
	//
	// NoteThe application must wait until the real-time endpoint is ready before
	// using this URI.
	EndpointUrl *string `type:"string"`

	// The maximum processing rate for the real-time endpoint for MLModel, measured
	// in incoming requests per second.
	PeakRequestsPerSecond *int64 `type:"integer"`
}

// String returns the string representation
func (s RealtimeEndpointInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RealtimeEndpointInfo) GoString() string {
	return s.String()
}

// Describes the data specification of an Amazon Redshift DataSource.
type RedshiftDataSpec struct {
	_ struct{} `type:"structure"`

	// A JSON string that represents the splitting and rearrangement processing
	// to be applied to a DataSource. If the DataRearrangement parameter is not
	// provided, all of the input data is used to create the Datasource.
	//
	// There are multiple parameters that control what data is used to create a
	// datasource:
	//
	//    * percentBegin
	//
	// Use percentBegin to indicate the beginning of the range of the data used
	//    to create the Datasource. If you do not include percentBegin and percentEnd,
	//    Amazon ML includes all of the data when creating the datasource.
	//
	//    * percentEnd
	//
	// Use percentEnd to indicate the end of the range of the data used to create
	//    the Datasource. If you do not include percentBegin and percentEnd, Amazon
	//    ML includes all of the data when creating the datasource.
	//
	//    * complement
	//
	// The complement parameter instructs Amazon ML to use the data that is not
	//    included in the range of percentBegin to percentEnd to create a datasource.
	//    The complement parameter is useful if you need to create complementary
	//    datasources for training and evaluation. To create a complementary datasource,
	//    use the same values for percentBegin and percentEnd, along with the complement
	//    parameter.
	//
	// For example, the following two datasources do not share any data, and can
	//    be used to train and evaluate a model. The first datasource has 25 percent
	//    of the data, and the second one has 75 percent of the data.
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":0, "percentEnd":25}}
	//
	// Datasource for training: {"splitting":{"percentBegin":0, "percentEnd":25,
	//    "complement":"true"}}
	//
	//    * strategy
	//
	// To change how Amazon ML splits the data for a datasource, use the strategy
	//    parameter.
	//
	// The default value for the strategy parameter is sequential, meaning that
	//    Amazon ML takes all of the data records between the percentBegin and percentEnd
	//    parameters for the datasource, in the order that the records appear in
	//    the input data.
	//
	// The following two DataRearrangement lines are examples of sequentially ordered
	//    training and evaluation datasources:
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"sequential"}}
	//
	// Datasource for training: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"sequential", "complement":"true"}}
	//
	// To randomly split the input data into the proportions indicated by the percentBegin
	//    and percentEnd parameters, set the strategy parameter to random and provide
	//    a string that is used as the seed value for the random data splitting
	//    (for example, you can use the S3 path to your data as the random seed
	//    string). If you choose the random split strategy, Amazon ML assigns each
	//    row of data a pseudo-random number between 0 and 100, and then selects
	//    the rows that have an assigned number between percentBegin and percentEnd.
	//    Pseudo-random numbers are assigned using both the input seed string value
	//    and the byte offset as a seed, so changing the data results in a different
	//    split. Any existing ordering is preserved. The random splitting strategy
	//    ensures that variables in the training and evaluation data are distributed
	//    similarly. It is useful in the cases where the input data may have an
	//    implicit sort order, which would otherwise result in training and evaluation
	//    datasources containing non-similar data records.
	//
	// The following two DataRearrangement lines are examples of non-sequentially
	//    ordered training and evaluation datasources:
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"random", "randomSeed"="s3://my_s3_path/bucket/file.csv"}}
	//
	// Datasource for training: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"random", "randomSeed"="s3://my_s3_path/bucket/file.csv", "complement":"true"}}
	DataRearrangement *string `type:"string"`

	// A JSON string that represents the schema for an Amazon Redshift DataSource.
	// The DataSchema defines the structure of the observation data in the data
	// file(s) referenced in the DataSource.
	//
	// A DataSchema is not required if you specify a DataSchemaUri.
	//
	// Define your DataSchema as a series of key-value pairs. attributes and excludedVariableNames
	// have an array of key-value pairs for their value. Use the following format
	// to define your DataSchema.
	//
	// { "version": "1.0",
	//
	// "recordAnnotationFieldName": "F1",
	//
	// "recordWeightFieldName": "F2",
	//
	// "targetFieldName": "F3",
	//
	// "dataFormat": "CSV",
	//
	// "dataFileContainsHeader": true,
	//
	// "attributes": [
	//
	// { "fieldName": "F1", "fieldType": "TEXT" }, { "fieldName": "F2", "fieldType":
	// "NUMERIC" }, { "fieldName": "F3", "fieldType": "CATEGORICAL" }, { "fieldName":
	// "F4", "fieldType": "NUMERIC" }, { "fieldName": "F5", "fieldType": "CATEGORICAL"
	// }, { "fieldName": "F6", "fieldType": "TEXT" }, { "fieldName": "F7", "fieldType":
	// "WEIGHTED_INT_SEQUENCE" }, { "fieldName": "F8", "fieldType": "WEIGHTED_STRING_SEQUENCE"
	// } ],
	//
	// "excludedVariableNames": [ "F6" ] }
	DataSchema *string `type:"string"`

	// Describes the schema location for an Amazon Redshift DataSource.
	DataSchemaUri *string `type:"string"`

	// Describes AWS Identity and Access Management (IAM) credentials that are used
	// connect to the Amazon Redshift database.
	//
	// DatabaseCredentials is a required field
	DatabaseCredentials *RedshiftDatabaseCredentials `type:"structure" required:"true"`

	// Describes the DatabaseName and ClusterIdentifier for an Amazon Redshift DataSource.
	//
	// DatabaseInformation is a required field
	DatabaseInformation *RedshiftDatabase `type:"structure" required:"true"`

	// Describes an Amazon S3 location to store the result set of the SelectSqlQuery
	// query.
	//
	// S3StagingLocation is a required field
	S3StagingLocation *string `type:"string" required:"true"`

	// Describes the SQL Query to execute on an Amazon Redshift database for an
	// Amazon Redshift DataSource.
	//
	// SelectSqlQuery is a required field
	SelectSqlQuery *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RedshiftDataSpec) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RedshiftDataSpec) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RedshiftDataSpec) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RedshiftDataSpec"}

	if s.DatabaseCredentials == nil {
		invalidParams.Add(aws.NewErrParamRequired("DatabaseCredentials"))
	}

	if s.DatabaseInformation == nil {
		invalidParams.Add(aws.NewErrParamRequired("DatabaseInformation"))
	}

	if s.S3StagingLocation == nil {
		invalidParams.Add(aws.NewErrParamRequired("S3StagingLocation"))
	}

	if s.SelectSqlQuery == nil {
		invalidParams.Add(aws.NewErrParamRequired("SelectSqlQuery"))
	}
	if s.SelectSqlQuery != nil && len(*s.SelectSqlQuery) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SelectSqlQuery", 1))
	}
	if s.DatabaseCredentials != nil {
		if err := s.DatabaseCredentials.Validate(); err != nil {
			invalidParams.AddNested("DatabaseCredentials", err.(aws.ErrInvalidParams))
		}
	}
	if s.DatabaseInformation != nil {
		if err := s.DatabaseInformation.Validate(); err != nil {
			invalidParams.AddNested("DatabaseInformation", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Describes the database details required to connect to an Amazon Redshift
// database.
type RedshiftDatabase struct {
	_ struct{} `type:"structure"`

	// The ID of an Amazon Redshift cluster.
	//
	// ClusterIdentifier is a required field
	ClusterIdentifier *string `min:"1" type:"string" required:"true"`

	// The name of a database hosted on an Amazon Redshift cluster.
	//
	// DatabaseName is a required field
	DatabaseName *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RedshiftDatabase) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RedshiftDatabase) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RedshiftDatabase) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RedshiftDatabase"}

	if s.ClusterIdentifier == nil {
		invalidParams.Add(aws.NewErrParamRequired("ClusterIdentifier"))
	}
	if s.ClusterIdentifier != nil && len(*s.ClusterIdentifier) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ClusterIdentifier", 1))
	}

	if s.DatabaseName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DatabaseName"))
	}
	if s.DatabaseName != nil && len(*s.DatabaseName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DatabaseName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Describes the database credentials for connecting to a database on an Amazon
// Redshift cluster.
type RedshiftDatabaseCredentials struct {
	_ struct{} `type:"structure"`

	// A password to be used by Amazon ML to connect to a database on an Amazon
	// Redshift cluster. The password should have sufficient permissions to execute
	// a RedshiftSelectSqlQuery query. The password should be valid for an Amazon
	// Redshift USER (http://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html).
	//
	// Password is a required field
	Password *string `min:"8" type:"string" required:"true"`

	// A username to be used by Amazon Machine Learning (Amazon ML)to connect to
	// a database on an Amazon Redshift cluster. The username should have sufficient
	// permissions to execute the RedshiftSelectSqlQuery query. The username should
	// be valid for an Amazon Redshift USER (http://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html).
	//
	// Username is a required field
	Username *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s RedshiftDatabaseCredentials) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RedshiftDatabaseCredentials) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RedshiftDatabaseCredentials) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RedshiftDatabaseCredentials"}

	if s.Password == nil {
		invalidParams.Add(aws.NewErrParamRequired("Password"))
	}
	if s.Password != nil && len(*s.Password) < 8 {
		invalidParams.Add(aws.NewErrParamMinLen("Password", 8))
	}

	if s.Username == nil {
		invalidParams.Add(aws.NewErrParamRequired("Username"))
	}
	if s.Username != nil && len(*s.Username) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Username", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Describes the DataSource details specific to Amazon Redshift.
type RedshiftMetadata struct {
	_ struct{} `type:"structure"`

	// A username to be used by Amazon Machine Learning (Amazon ML)to connect to
	// a database on an Amazon Redshift cluster. The username should have sufficient
	// permissions to execute the RedshiftSelectSqlQuery query. The username should
	// be valid for an Amazon Redshift USER (http://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html).
	DatabaseUserName *string `min:"1" type:"string"`

	// Describes the database details required to connect to an Amazon Redshift
	// database.
	RedshiftDatabase *RedshiftDatabase `type:"structure"`

	// The SQL query that is specified during CreateDataSourceFromRedshift. Returns
	// only if Verbose is true in GetDataSourceInput.
	SelectSqlQuery *string `min:"1" type:"string"`
}

// String returns the string representation
func (s RedshiftMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RedshiftMetadata) GoString() string {
	return s.String()
}

// Describes the data specification of a DataSource.
type S3DataSpec struct {
	_ struct{} `type:"structure"`

	// The location of the data file(s) used by a DataSource. The URI specifies
	// a data file or an Amazon Simple Storage Service (Amazon S3) directory or
	// bucket containing data files.
	//
	// DataLocationS3 is a required field
	DataLocationS3 *string `type:"string" required:"true"`

	// A JSON string that represents the splitting and rearrangement processing
	// to be applied to a DataSource. If the DataRearrangement parameter is not
	// provided, all of the input data is used to create the Datasource.
	//
	// There are multiple parameters that control what data is used to create a
	// datasource:
	//
	//    * percentBegin
	//
	// Use percentBegin to indicate the beginning of the range of the data used
	//    to create the Datasource. If you do not include percentBegin and percentEnd,
	//    Amazon ML includes all of the data when creating the datasource.
	//
	//    * percentEnd
	//
	// Use percentEnd to indicate the end of the range of the data used to create
	//    the Datasource. If you do not include percentBegin and percentEnd, Amazon
	//    ML includes all of the data when creating the datasource.
	//
	//    * complement
	//
	// The complement parameter instructs Amazon ML to use the data that is not
	//    included in the range of percentBegin to percentEnd to create a datasource.
	//    The complement parameter is useful if you need to create complementary
	//    datasources for training and evaluation. To create a complementary datasource,
	//    use the same values for percentBegin and percentEnd, along with the complement
	//    parameter.
	//
	// For example, the following two datasources do not share any data, and can
	//    be used to train and evaluate a model. The first datasource has 25 percent
	//    of the data, and the second one has 75 percent of the data.
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":0, "percentEnd":25}}
	//
	// Datasource for training: {"splitting":{"percentBegin":0, "percentEnd":25,
	//    "complement":"true"}}
	//
	//    * strategy
	//
	// To change how Amazon ML splits the data for a datasource, use the strategy
	//    parameter.
	//
	// The default value for the strategy parameter is sequential, meaning that
	//    Amazon ML takes all of the data records between the percentBegin and percentEnd
	//    parameters for the datasource, in the order that the records appear in
	//    the input data.
	//
	// The following two DataRearrangement lines are examples of sequentially ordered
	//    training and evaluation datasources:
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"sequential"}}
	//
	// Datasource for training: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"sequential", "complement":"true"}}
	//
	// To randomly split the input data into the proportions indicated by the percentBegin
	//    and percentEnd parameters, set the strategy parameter to random and provide
	//    a string that is used as the seed value for the random data splitting
	//    (for example, you can use the S3 path to your data as the random seed
	//    string). If you choose the random split strategy, Amazon ML assigns each
	//    row of data a pseudo-random number between 0 and 100, and then selects
	//    the rows that have an assigned number between percentBegin and percentEnd.
	//    Pseudo-random numbers are assigned using both the input seed string value
	//    and the byte offset as a seed, so changing the data results in a different
	//    split. Any existing ordering is preserved. The random splitting strategy
	//    ensures that variables in the training and evaluation data are distributed
	//    similarly. It is useful in the cases where the input data may have an
	//    implicit sort order, which would otherwise result in training and evaluation
	//    datasources containing non-similar data records.
	//
	// The following two DataRearrangement lines are examples of non-sequentially
	//    ordered training and evaluation datasources:
	//
	// Datasource for evaluation: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"random", "randomSeed"="s3://my_s3_path/bucket/file.csv"}}
	//
	// Datasource for training: {"splitting":{"percentBegin":70, "percentEnd":100,
	//    "strategy":"random", "randomSeed"="s3://my_s3_path/bucket/file.csv", "complement":"true"}}
	DataRearrangement *string `type:"string"`

	// A JSON string that represents the schema for an Amazon S3 DataSource. The
	// DataSchema defines the structure of the observation data in the data file(s)
	// referenced in the DataSource.
	//
	// You must provide either the DataSchema or the DataSchemaLocationS3.
	//
	// Define your DataSchema as a series of key-value pairs. attributes and excludedVariableNames
	// have an array of key-value pairs for their value. Use the following format
	// to define your DataSchema.
	//
	// { "version": "1.0",
	//
	// "recordAnnotationFieldName": "F1",
	//
	// "recordWeightFieldName": "F2",
	//
	// "targetFieldName": "F3",
	//
	// "dataFormat": "CSV",
	//
	// "dataFileContainsHeader": true,
	//
	// "attributes": [
	//
	// { "fieldName": "F1", "fieldType": "TEXT" }, { "fieldName": "F2", "fieldType":
	// "NUMERIC" }, { "fieldName": "F3", "fieldType": "CATEGORICAL" }, { "fieldName":
	// "F4", "fieldType": "NUMERIC" }, { "fieldName": "F5", "fieldType": "CATEGORICAL"
	// }, { "fieldName": "F6", "fieldType": "TEXT" }, { "fieldName": "F7", "fieldType":
	// "WEIGHTED_INT_SEQUENCE" }, { "fieldName": "F8", "fieldType": "WEIGHTED_STRING_SEQUENCE"
	// } ],
	//
	// "excludedVariableNames": [ "F6" ] }
	DataSchema *string `type:"string"`

	// Describes the schema location in Amazon S3. You must provide either the DataSchema
	// or the DataSchemaLocationS3.
	DataSchemaLocationS3 *string `type:"string"`
}

// String returns the string representation
func (s S3DataSpec) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s S3DataSpec) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3DataSpec) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3DataSpec"}

	if s.DataLocationS3 == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataLocationS3"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// A custom key-value pair associated with an ML object, such as an ML model.
type Tag struct {
	_ struct{} `type:"structure"`

	// A unique identifier for the tag. Valid characters include Unicode letters,
	// digits, white space, _, ., /, =, +, -, %, and @.
	Key *string `min:"1" type:"string"`

	// An optional string, typically used to describe or define the tag. Valid characters
	// include Unicode letters, digits, white space, _, ., /, =, +, -, %, and @.
	Value *string `type:"string"`
}

// String returns the string representation
func (s Tag) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Tag) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Tag) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Tag"}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type UpdateBatchPredictionInput struct {
	_ struct{} `type:"structure"`

	// The ID assigned to the BatchPrediction during creation.
	//
	// BatchPredictionId is a required field
	BatchPredictionId *string `min:"1" type:"string" required:"true"`

	// A new user-supplied name or description of the BatchPrediction.
	//
	// BatchPredictionName is a required field
	BatchPredictionName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateBatchPredictionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBatchPredictionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateBatchPredictionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateBatchPredictionInput"}

	if s.BatchPredictionId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BatchPredictionId"))
	}
	if s.BatchPredictionId != nil && len(*s.BatchPredictionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("BatchPredictionId", 1))
	}

	if s.BatchPredictionName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BatchPredictionName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of an UpdateBatchPrediction operation.
//
// You can see the updated content by using the GetBatchPrediction operation.
type UpdateBatchPredictionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID assigned to the BatchPrediction during creation. This value should
	// be identical to the value of the BatchPredictionId in the request.
	BatchPredictionId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateBatchPredictionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBatchPredictionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateBatchPredictionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type UpdateDataSourceInput struct {
	_ struct{} `type:"structure"`

	// The ID assigned to the DataSource during creation.
	//
	// DataSourceId is a required field
	DataSourceId *string `min:"1" type:"string" required:"true"`

	// A new user-supplied name or description of the DataSource that will replace
	// the current description.
	//
	// DataSourceName is a required field
	DataSourceName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateDataSourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDataSourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDataSourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateDataSourceInput"}

	if s.DataSourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceId"))
	}
	if s.DataSourceId != nil && len(*s.DataSourceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DataSourceId", 1))
	}

	if s.DataSourceName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DataSourceName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of an UpdateDataSource operation.
//
// You can see the updated content by using the GetBatchPrediction operation.
type UpdateDataSourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID assigned to the DataSource during creation. This value should be identical
	// to the value of the DataSourceID in the request.
	DataSourceId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateDataSourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDataSourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateDataSourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type UpdateEvaluationInput struct {
	_ struct{} `type:"structure"`

	// The ID assigned to the Evaluation during creation.
	//
	// EvaluationId is a required field
	EvaluationId *string `min:"1" type:"string" required:"true"`

	// A new user-supplied name or description of the Evaluation that will replace
	// the current content.
	//
	// EvaluationName is a required field
	EvaluationName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateEvaluationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateEvaluationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateEvaluationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateEvaluationInput"}

	if s.EvaluationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("EvaluationId"))
	}
	if s.EvaluationId != nil && len(*s.EvaluationId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("EvaluationId", 1))
	}

	if s.EvaluationName == nil {
		invalidParams.Add(aws.NewErrParamRequired("EvaluationName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of an UpdateEvaluation operation.
//
// You can see the updated content by using the GetEvaluation operation.
type UpdateEvaluationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID assigned to the Evaluation during creation. This value should be identical
	// to the value of the Evaluation in the request.
	EvaluationId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateEvaluationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateEvaluationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateEvaluationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

type UpdateMLModelInput struct {
	_ struct{} `type:"structure"`

	// The ID assigned to the MLModel during creation.
	//
	// MLModelId is a required field
	MLModelId *string `min:"1" type:"string" required:"true"`

	// A user-supplied name or description of the MLModel.
	MLModelName *string `type:"string"`

	// The ScoreThreshold used in binary classification MLModel that marks the boundary
	// between a positive prediction and a negative prediction.
	//
	// Output values greater than or equal to the ScoreThreshold receive a positive
	// result from the MLModel, such as true. Output values less than the ScoreThreshold
	// receive a negative response from the MLModel, such as false.
	ScoreThreshold *float64 `type:"float"`
}

// String returns the string representation
func (s UpdateMLModelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateMLModelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateMLModelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateMLModelInput"}

	if s.MLModelId == nil {
		invalidParams.Add(aws.NewErrParamRequired("MLModelId"))
	}
	if s.MLModelId != nil && len(*s.MLModelId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("MLModelId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of an UpdateMLModel operation.
//
// You can see the updated content by using the GetMLModel operation.
type UpdateMLModelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID assigned to the MLModel during creation. This value should be identical
	// to the value of the MLModelID in the request.
	MLModelId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateMLModelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateMLModelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateMLModelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// The function used to train an MLModel. Training choices supported by Amazon
// ML include the following:
//
//    * SGD - Stochastic Gradient Descent.
//    * RandomForest - Random forest of decision trees.
type Algorithm string

// Enum values for Algorithm
const (
	AlgorithmSgd Algorithm = "sgd"
)

func (enum Algorithm) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Algorithm) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// A list of the variables to use in searching or filtering BatchPrediction.
//
//    * CreatedAt - Sets the search criteria to BatchPrediction creation date.
//
//    * Status - Sets the search criteria to BatchPrediction status.
//    * Name - Sets the search criteria to the contents of BatchPredictionName.
//
//    * IAMUser - Sets the search criteria to the user account that invoked
//    the BatchPrediction creation.
//    * MLModelId - Sets the search criteria to the MLModel used in the BatchPrediction.
//
//    * DataSourceId - Sets the search criteria to the DataSource used in the
//    BatchPrediction.
//    * DataURI - Sets the search criteria to the data file(s) used in the BatchPrediction.
//    The URL can identify either a file or an Amazon Simple Storage Service
//    (Amazon S3) bucket or directory.
type BatchPredictionFilterVariable string

// Enum values for BatchPredictionFilterVariable
const (
	BatchPredictionFilterVariableCreatedAt     BatchPredictionFilterVariable = "CreatedAt"
	BatchPredictionFilterVariableLastUpdatedAt BatchPredictionFilterVariable = "LastUpdatedAt"
	BatchPredictionFilterVariableStatus        BatchPredictionFilterVariable = "Status"
	BatchPredictionFilterVariableName          BatchPredictionFilterVariable = "Name"
	BatchPredictionFilterVariableIamuser       BatchPredictionFilterVariable = "IAMUser"
	BatchPredictionFilterVariableMlmodelId     BatchPredictionFilterVariable = "MLModelId"
	BatchPredictionFilterVariableDataSourceId  BatchPredictionFilterVariable = "DataSourceId"
	BatchPredictionFilterVariableDataUri       BatchPredictionFilterVariable = "DataURI"
)

func (enum BatchPredictionFilterVariable) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BatchPredictionFilterVariable) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// A list of the variables to use in searching or filtering DataSource.
//
//    * CreatedAt - Sets the search criteria to DataSource creation date.
//    * Status - Sets the search criteria to DataSource status.
//    * Name - Sets the search criteria to the contents of DataSourceName.
//    * DataUri - Sets the search criteria to the URI of data files used to
//    create the DataSource. The URI can identify either a file or an Amazon
//    Simple Storage Service (Amazon S3) bucket or directory.
//    * IAMUser - Sets the search criteria to the user account that invoked
//    the DataSource creation.
// NoteThe variable names should match the variable names in the DataSource.
type DataSourceFilterVariable string

// Enum values for DataSourceFilterVariable
const (
	DataSourceFilterVariableCreatedAt      DataSourceFilterVariable = "CreatedAt"
	DataSourceFilterVariableLastUpdatedAt  DataSourceFilterVariable = "LastUpdatedAt"
	DataSourceFilterVariableStatus         DataSourceFilterVariable = "Status"
	DataSourceFilterVariableName           DataSourceFilterVariable = "Name"
	DataSourceFilterVariableDataLocationS3 DataSourceFilterVariable = "DataLocationS3"
	DataSourceFilterVariableIamuser        DataSourceFilterVariable = "IAMUser"
)

func (enum DataSourceFilterVariable) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DataSourceFilterVariable) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// Contains the key values of DetailsMap: PredictiveModelType- Indicates the type of the MLModel. Algorithm- Indicates the algorithm that was used for the MLModel
type DetailsAttributes string

// Enum values for DetailsAttributes
const (
	DetailsAttributesPredictiveModelType DetailsAttributes = "PredictiveModelType"
	DetailsAttributesAlgorithm           DetailsAttributes = "Algorithm"
)

func (enum DetailsAttributes) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DetailsAttributes) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// Object status with the following possible values:
//
//    * PENDING
//    * INPROGRESS
//    * FAILED
//    * COMPLETED
//    * DELETED
type EntityStatus string

// Enum values for EntityStatus
const (
	EntityStatusPending    EntityStatus = "PENDING"
	EntityStatusInprogress EntityStatus = "INPROGRESS"
	EntityStatusFailed     EntityStatus = "FAILED"
	EntityStatusCompleted  EntityStatus = "COMPLETED"
	EntityStatusDeleted    EntityStatus = "DELETED"
)

func (enum EntityStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EntityStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// A list of the variables to use in searching or filtering Evaluation.
//
//    * CreatedAt - Sets the search criteria to Evaluation creation date.
//    * Status - Sets the search criteria to Evaluation status.
//    * Name - Sets the search criteria to the contents of EvaluationName.
//    * IAMUser - Sets the search criteria to the user account that invoked
//    an evaluation.
//    * MLModelId - Sets the search criteria to the Predictor that was evaluated.
//
//    * DataSourceId - Sets the search criteria to the DataSource used in evaluation.
//
//    * DataUri - Sets the search criteria to the data file(s) used in evaluation.
//    The URL can identify either a file or an Amazon Simple Storage Service
//    (Amazon S3) bucket or directory.
type EvaluationFilterVariable string

// Enum values for EvaluationFilterVariable
const (
	EvaluationFilterVariableCreatedAt     EvaluationFilterVariable = "CreatedAt"
	EvaluationFilterVariableLastUpdatedAt EvaluationFilterVariable = "LastUpdatedAt"
	EvaluationFilterVariableStatus        EvaluationFilterVariable = "Status"
	EvaluationFilterVariableName          EvaluationFilterVariable = "Name"
	EvaluationFilterVariableIamuser       EvaluationFilterVariable = "IAMUser"
	EvaluationFilterVariableMlmodelId     EvaluationFilterVariable = "MLModelId"
	EvaluationFilterVariableDataSourceId  EvaluationFilterVariable = "DataSourceId"
	EvaluationFilterVariableDataUri       EvaluationFilterVariable = "DataURI"
)

func (enum EvaluationFilterVariable) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EvaluationFilterVariable) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type MLModelFilterVariable string

// Enum values for MLModelFilterVariable
const (
	MLModelFilterVariableCreatedAt              MLModelFilterVariable = "CreatedAt"
	MLModelFilterVariableLastUpdatedAt          MLModelFilterVariable = "LastUpdatedAt"
	MLModelFilterVariableStatus                 MLModelFilterVariable = "Status"
	MLModelFilterVariableName                   MLModelFilterVariable = "Name"
	MLModelFilterVariableIamuser                MLModelFilterVariable = "IAMUser"
	MLModelFilterVariableTrainingDataSourceId   MLModelFilterVariable = "TrainingDataSourceId"
	MLModelFilterVariableRealtimeEndpointStatus MLModelFilterVariable = "RealtimeEndpointStatus"
	MLModelFilterVariableMlmodelType            MLModelFilterVariable = "MLModelType"
	MLModelFilterVariableAlgorithm              MLModelFilterVariable = "Algorithm"
	MLModelFilterVariableTrainingDataUri        MLModelFilterVariable = "TrainingDataURI"
)

func (enum MLModelFilterVariable) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum MLModelFilterVariable) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type MLModelType string

// Enum values for MLModelType
const (
	MLModelTypeRegression MLModelType = "REGRESSION"
	MLModelTypeBinary     MLModelType = "BINARY"
	MLModelTypeMulticlass MLModelType = "MULTICLASS"
)

func (enum MLModelType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum MLModelType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RealtimeEndpointStatus string

// Enum values for RealtimeEndpointStatus
const (
	RealtimeEndpointStatusNone     RealtimeEndpointStatus = "NONE"
	RealtimeEndpointStatusReady    RealtimeEndpointStatus = "READY"
	RealtimeEndpointStatusUpdating RealtimeEndpointStatus = "UPDATING"
	RealtimeEndpointStatusFailed   RealtimeEndpointStatus = "FAILED"
)

func (enum RealtimeEndpointStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RealtimeEndpointStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The sort order specified in a listing condition. Possible values include
// the following:
//
//    * asc - Present the information in ascending order (from A-Z).
//    * dsc - Present the information in descending order (from Z-A).
type SortOrder string

// Enum values for SortOrder
const (
	SortOrderAsc SortOrder = "asc"
	SortOrderDsc SortOrder = "dsc"
)

func (enum SortOrder) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SortOrder) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type TaggableResourceType string

// Enum values for TaggableResourceType
const (
	TaggableResourceTypeBatchPrediction TaggableResourceType = "BatchPrediction"
	TaggableResourceTypeDataSource      TaggableResourceType = "DataSource"
	TaggableResourceTypeEvaluation      TaggableResourceType = "Evaluation"
	TaggableResourceTypeMlmodel         TaggableResourceType = "MLModel"
)

func (enum TaggableResourceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum TaggableResourceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
