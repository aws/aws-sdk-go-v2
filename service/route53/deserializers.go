// Code generated by smithy-go-codegen DO NOT EDIT.

package route53

import (
	"bytes"
	"context"
	"encoding/xml"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/route53/types"
	smithy "github.com/awslabs/smithy-go"
	smithyio "github.com/awslabs/smithy-go/io"
	"github.com/awslabs/smithy-go/middleware"
	"github.com/awslabs/smithy-go/ptr"
	smithytime "github.com/awslabs/smithy-go/time"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	smithyxml "github.com/awslabs/smithy-go/xml"
	"io"
	"strconv"
	"strings"
)

type awsRestxml_deserializeOpAssociateVPCWithHostedZone struct {
}

func (*awsRestxml_deserializeOpAssociateVPCWithHostedZone) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpAssociateVPCWithHostedZone) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorAssociateVPCWithHostedZone(response)
	}
	output := &AssociateVPCWithHostedZoneOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentAssociateVPCWithHostedZoneOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorAssociateVPCWithHostedZone(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConflictingDomainExists", errorCode):
		return awsRestxml_deserializeErrorConflictingDomainExists(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidVPCId", errorCode):
		return awsRestxml_deserializeErrorInvalidVPCId(response, errorBody)

	case strings.EqualFold("LimitsExceeded", errorCode):
		return awsRestxml_deserializeErrorLimitsExceeded(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("NotAuthorizedException", errorCode):
		return awsRestxml_deserializeErrorNotAuthorizedException(response, errorBody)

	case strings.EqualFold("PriorRequestNotComplete", errorCode):
		return awsRestxml_deserializeErrorPriorRequestNotComplete(response, errorBody)

	case strings.EqualFold("PublicZoneVPCAssociation", errorCode):
		return awsRestxml_deserializeErrorPublicZoneVPCAssociation(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentAssociateVPCWithHostedZoneOutput(v **AssociateVPCWithHostedZoneOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *AssociateVPCWithHostedZoneOutput
	if *v == nil {
		sv = &AssociateVPCWithHostedZoneOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ChangeInfo", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentChangeInfo(&sv.ChangeInfo, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpChangeResourceRecordSets struct {
}

func (*awsRestxml_deserializeOpChangeResourceRecordSets) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpChangeResourceRecordSets) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorChangeResourceRecordSets(response)
	}
	output := &ChangeResourceRecordSetsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentChangeResourceRecordSetsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorChangeResourceRecordSets(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidChangeBatch", errorCode):
		return awsRestxml_deserializeErrorInvalidChangeBatch(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("PriorRequestNotComplete", errorCode):
		return awsRestxml_deserializeErrorPriorRequestNotComplete(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentChangeResourceRecordSetsOutput(v **ChangeResourceRecordSetsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ChangeResourceRecordSetsOutput
	if *v == nil {
		sv = &ChangeResourceRecordSetsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ChangeInfo", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentChangeInfo(&sv.ChangeInfo, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpChangeTagsForResource struct {
}

func (*awsRestxml_deserializeOpChangeTagsForResource) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpChangeTagsForResource) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorChangeTagsForResource(response)
	}
	output := &ChangeTagsForResourceOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorChangeTagsForResource(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("PriorRequestNotComplete", errorCode):
		return awsRestxml_deserializeErrorPriorRequestNotComplete(response, errorBody)

	case strings.EqualFold("ThrottlingException", errorCode):
		return awsRestxml_deserializeErrorThrottlingException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpCreateHealthCheck struct {
}

func (*awsRestxml_deserializeOpCreateHealthCheck) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpCreateHealthCheck) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorCreateHealthCheck(response)
	}
	output := &CreateHealthCheckOutput{}
	out.Result = output

	err = awsRestxml_deserializeOpHttpBindingsCreateHealthCheckOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentCreateHealthCheckOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorCreateHealthCheck(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("HealthCheckAlreadyExists", errorCode):
		return awsRestxml_deserializeErrorHealthCheckAlreadyExists(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("TooManyHealthChecks", errorCode):
		return awsRestxml_deserializeErrorTooManyHealthChecks(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpHttpBindingsCreateHealthCheckOutput(v *CreateHealthCheckOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Location"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Location = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeOpDocumentCreateHealthCheckOutput(v **CreateHealthCheckOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateHealthCheckOutput
	if *v == nil {
		sv = &CreateHealthCheckOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthCheck", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHealthCheck(&sv.HealthCheck, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpCreateHostedZone struct {
}

func (*awsRestxml_deserializeOpCreateHostedZone) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpCreateHostedZone) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorCreateHostedZone(response)
	}
	output := &CreateHostedZoneOutput{}
	out.Result = output

	err = awsRestxml_deserializeOpHttpBindingsCreateHostedZoneOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentCreateHostedZoneOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorCreateHostedZone(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConflictingDomainExists", errorCode):
		return awsRestxml_deserializeErrorConflictingDomainExists(response, errorBody)

	case strings.EqualFold("DelegationSetNotAvailable", errorCode):
		return awsRestxml_deserializeErrorDelegationSetNotAvailable(response, errorBody)

	case strings.EqualFold("DelegationSetNotReusable", errorCode):
		return awsRestxml_deserializeErrorDelegationSetNotReusable(response, errorBody)

	case strings.EqualFold("HostedZoneAlreadyExists", errorCode):
		return awsRestxml_deserializeErrorHostedZoneAlreadyExists(response, errorBody)

	case strings.EqualFold("InvalidDomainName", errorCode):
		return awsRestxml_deserializeErrorInvalidDomainName(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidVPCId", errorCode):
		return awsRestxml_deserializeErrorInvalidVPCId(response, errorBody)

	case strings.EqualFold("NoSuchDelegationSet", errorCode):
		return awsRestxml_deserializeErrorNoSuchDelegationSet(response, errorBody)

	case strings.EqualFold("TooManyHostedZones", errorCode):
		return awsRestxml_deserializeErrorTooManyHostedZones(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpHttpBindingsCreateHostedZoneOutput(v *CreateHostedZoneOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Location"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Location = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeOpDocumentCreateHostedZoneOutput(v **CreateHostedZoneOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateHostedZoneOutput
	if *v == nil {
		sv = &CreateHostedZoneOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ChangeInfo", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentChangeInfo(&sv.ChangeInfo, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("DelegationSet", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentDelegationSet(&sv.DelegationSet, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("HostedZone", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZone(&sv.HostedZone, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("VPC", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentVPC(&sv.VPC, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpCreateQueryLoggingConfig struct {
}

func (*awsRestxml_deserializeOpCreateQueryLoggingConfig) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpCreateQueryLoggingConfig) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorCreateQueryLoggingConfig(response)
	}
	output := &CreateQueryLoggingConfigOutput{}
	out.Result = output

	err = awsRestxml_deserializeOpHttpBindingsCreateQueryLoggingConfigOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentCreateQueryLoggingConfigOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorCreateQueryLoggingConfig(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConcurrentModification", errorCode):
		return awsRestxml_deserializeErrorConcurrentModification(response, errorBody)

	case strings.EqualFold("InsufficientCloudWatchLogsResourcePolicy", errorCode):
		return awsRestxml_deserializeErrorInsufficientCloudWatchLogsResourcePolicy(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchCloudWatchLogsLogGroup", errorCode):
		return awsRestxml_deserializeErrorNoSuchCloudWatchLogsLogGroup(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("QueryLoggingConfigAlreadyExists", errorCode):
		return awsRestxml_deserializeErrorQueryLoggingConfigAlreadyExists(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpHttpBindingsCreateQueryLoggingConfigOutput(v *CreateQueryLoggingConfigOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Location"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Location = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeOpDocumentCreateQueryLoggingConfigOutput(v **CreateQueryLoggingConfigOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateQueryLoggingConfigOutput
	if *v == nil {
		sv = &CreateQueryLoggingConfigOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("QueryLoggingConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentQueryLoggingConfig(&sv.QueryLoggingConfig, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpCreateReusableDelegationSet struct {
}

func (*awsRestxml_deserializeOpCreateReusableDelegationSet) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpCreateReusableDelegationSet) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorCreateReusableDelegationSet(response)
	}
	output := &CreateReusableDelegationSetOutput{}
	out.Result = output

	err = awsRestxml_deserializeOpHttpBindingsCreateReusableDelegationSetOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentCreateReusableDelegationSetOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorCreateReusableDelegationSet(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("DelegationSetAlreadyCreated", errorCode):
		return awsRestxml_deserializeErrorDelegationSetAlreadyCreated(response, errorBody)

	case strings.EqualFold("DelegationSetAlreadyReusable", errorCode):
		return awsRestxml_deserializeErrorDelegationSetAlreadyReusable(response, errorBody)

	case strings.EqualFold("DelegationSetNotAvailable", errorCode):
		return awsRestxml_deserializeErrorDelegationSetNotAvailable(response, errorBody)

	case strings.EqualFold("HostedZoneNotFound", errorCode):
		return awsRestxml_deserializeErrorHostedZoneNotFound(response, errorBody)

	case strings.EqualFold("InvalidArgument", errorCode):
		return awsRestxml_deserializeErrorInvalidArgument(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("LimitsExceeded", errorCode):
		return awsRestxml_deserializeErrorLimitsExceeded(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpHttpBindingsCreateReusableDelegationSetOutput(v *CreateReusableDelegationSetOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Location"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Location = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeOpDocumentCreateReusableDelegationSetOutput(v **CreateReusableDelegationSetOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateReusableDelegationSetOutput
	if *v == nil {
		sv = &CreateReusableDelegationSetOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("DelegationSet", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentDelegationSet(&sv.DelegationSet, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpCreateTrafficPolicy struct {
}

func (*awsRestxml_deserializeOpCreateTrafficPolicy) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpCreateTrafficPolicy) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorCreateTrafficPolicy(response)
	}
	output := &CreateTrafficPolicyOutput{}
	out.Result = output

	err = awsRestxml_deserializeOpHttpBindingsCreateTrafficPolicyOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentCreateTrafficPolicyOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorCreateTrafficPolicy(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidTrafficPolicyDocument", errorCode):
		return awsRestxml_deserializeErrorInvalidTrafficPolicyDocument(response, errorBody)

	case strings.EqualFold("TooManyTrafficPolicies", errorCode):
		return awsRestxml_deserializeErrorTooManyTrafficPolicies(response, errorBody)

	case strings.EqualFold("TrafficPolicyAlreadyExists", errorCode):
		return awsRestxml_deserializeErrorTrafficPolicyAlreadyExists(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpHttpBindingsCreateTrafficPolicyOutput(v *CreateTrafficPolicyOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Location"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Location = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeOpDocumentCreateTrafficPolicyOutput(v **CreateTrafficPolicyOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateTrafficPolicyOutput
	if *v == nil {
		sv = &CreateTrafficPolicyOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TrafficPolicy", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicy(&sv.TrafficPolicy, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpCreateTrafficPolicyInstance struct {
}

func (*awsRestxml_deserializeOpCreateTrafficPolicyInstance) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpCreateTrafficPolicyInstance) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorCreateTrafficPolicyInstance(response)
	}
	output := &CreateTrafficPolicyInstanceOutput{}
	out.Result = output

	err = awsRestxml_deserializeOpHttpBindingsCreateTrafficPolicyInstanceOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentCreateTrafficPolicyInstanceOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorCreateTrafficPolicyInstance(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicy", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicy(response, errorBody)

	case strings.EqualFold("TooManyTrafficPolicyInstances", errorCode):
		return awsRestxml_deserializeErrorTooManyTrafficPolicyInstances(response, errorBody)

	case strings.EqualFold("TrafficPolicyInstanceAlreadyExists", errorCode):
		return awsRestxml_deserializeErrorTrafficPolicyInstanceAlreadyExists(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpHttpBindingsCreateTrafficPolicyInstanceOutput(v *CreateTrafficPolicyInstanceOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Location"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Location = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeOpDocumentCreateTrafficPolicyInstanceOutput(v **CreateTrafficPolicyInstanceOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateTrafficPolicyInstanceOutput
	if *v == nil {
		sv = &CreateTrafficPolicyInstanceOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TrafficPolicyInstance", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicyInstance(&sv.TrafficPolicyInstance, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpCreateTrafficPolicyVersion struct {
}

func (*awsRestxml_deserializeOpCreateTrafficPolicyVersion) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpCreateTrafficPolicyVersion) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorCreateTrafficPolicyVersion(response)
	}
	output := &CreateTrafficPolicyVersionOutput{}
	out.Result = output

	err = awsRestxml_deserializeOpHttpBindingsCreateTrafficPolicyVersionOutput(output, response)
	if err != nil {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("failed to decode response with invalid Http bindings, %w", err)}
	}

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentCreateTrafficPolicyVersionOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorCreateTrafficPolicyVersion(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConcurrentModification", errorCode):
		return awsRestxml_deserializeErrorConcurrentModification(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidTrafficPolicyDocument", errorCode):
		return awsRestxml_deserializeErrorInvalidTrafficPolicyDocument(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicy", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicy(response, errorBody)

	case strings.EqualFold("TooManyTrafficPolicyVersionsForCurrentPolicy", errorCode):
		return awsRestxml_deserializeErrorTooManyTrafficPolicyVersionsForCurrentPolicy(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpHttpBindingsCreateTrafficPolicyVersionOutput(v *CreateTrafficPolicyVersionOutput, response *smithyhttp.Response) error {
	if v == nil {
		return fmt.Errorf("unsupported deserialization for nil %T", v)
	}

	if headerValues := response.Header.Values("Location"); len(headerValues) != 0 {
		headerValues[0] = strings.TrimSpace(headerValues[0])
		v.Location = ptr.String(headerValues[0])
	}

	return nil
}
func awsRestxml_deserializeOpDocumentCreateTrafficPolicyVersionOutput(v **CreateTrafficPolicyVersionOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateTrafficPolicyVersionOutput
	if *v == nil {
		sv = &CreateTrafficPolicyVersionOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TrafficPolicy", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicy(&sv.TrafficPolicy, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpCreateVPCAssociationAuthorization struct {
}

func (*awsRestxml_deserializeOpCreateVPCAssociationAuthorization) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpCreateVPCAssociationAuthorization) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorCreateVPCAssociationAuthorization(response)
	}
	output := &CreateVPCAssociationAuthorizationOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentCreateVPCAssociationAuthorizationOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorCreateVPCAssociationAuthorization(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConcurrentModification", errorCode):
		return awsRestxml_deserializeErrorConcurrentModification(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidVPCId", errorCode):
		return awsRestxml_deserializeErrorInvalidVPCId(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("TooManyVPCAssociationAuthorizations", errorCode):
		return awsRestxml_deserializeErrorTooManyVPCAssociationAuthorizations(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentCreateVPCAssociationAuthorizationOutput(v **CreateVPCAssociationAuthorizationOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *CreateVPCAssociationAuthorizationOutput
	if *v == nil {
		sv = &CreateVPCAssociationAuthorizationOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneId = &xtv
			}

		case strings.EqualFold("VPC", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentVPC(&sv.VPC, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpDeleteHealthCheck struct {
}

func (*awsRestxml_deserializeOpDeleteHealthCheck) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpDeleteHealthCheck) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorDeleteHealthCheck(response)
	}
	output := &DeleteHealthCheckOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorDeleteHealthCheck(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("HealthCheckInUse", errorCode):
		return awsRestxml_deserializeErrorHealthCheckInUse(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpDeleteHostedZone struct {
}

func (*awsRestxml_deserializeOpDeleteHostedZone) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpDeleteHostedZone) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorDeleteHostedZone(response)
	}
	output := &DeleteHostedZoneOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentDeleteHostedZoneOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorDeleteHostedZone(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("HostedZoneNotEmpty", errorCode):
		return awsRestxml_deserializeErrorHostedZoneNotEmpty(response, errorBody)

	case strings.EqualFold("InvalidDomainName", errorCode):
		return awsRestxml_deserializeErrorInvalidDomainName(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("PriorRequestNotComplete", errorCode):
		return awsRestxml_deserializeErrorPriorRequestNotComplete(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentDeleteHostedZoneOutput(v **DeleteHostedZoneOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DeleteHostedZoneOutput
	if *v == nil {
		sv = &DeleteHostedZoneOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ChangeInfo", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentChangeInfo(&sv.ChangeInfo, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpDeleteQueryLoggingConfig struct {
}

func (*awsRestxml_deserializeOpDeleteQueryLoggingConfig) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpDeleteQueryLoggingConfig) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorDeleteQueryLoggingConfig(response)
	}
	output := &DeleteQueryLoggingConfigOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorDeleteQueryLoggingConfig(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConcurrentModification", errorCode):
		return awsRestxml_deserializeErrorConcurrentModification(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchQueryLoggingConfig", errorCode):
		return awsRestxml_deserializeErrorNoSuchQueryLoggingConfig(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpDeleteReusableDelegationSet struct {
}

func (*awsRestxml_deserializeOpDeleteReusableDelegationSet) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpDeleteReusableDelegationSet) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorDeleteReusableDelegationSet(response)
	}
	output := &DeleteReusableDelegationSetOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorDeleteReusableDelegationSet(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("DelegationSetInUse", errorCode):
		return awsRestxml_deserializeErrorDelegationSetInUse(response, errorBody)

	case strings.EqualFold("DelegationSetNotReusable", errorCode):
		return awsRestxml_deserializeErrorDelegationSetNotReusable(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchDelegationSet", errorCode):
		return awsRestxml_deserializeErrorNoSuchDelegationSet(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpDeleteTrafficPolicy struct {
}

func (*awsRestxml_deserializeOpDeleteTrafficPolicy) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpDeleteTrafficPolicy) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorDeleteTrafficPolicy(response)
	}
	output := &DeleteTrafficPolicyOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorDeleteTrafficPolicy(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConcurrentModification", errorCode):
		return awsRestxml_deserializeErrorConcurrentModification(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicy", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicy(response, errorBody)

	case strings.EqualFold("TrafficPolicyInUse", errorCode):
		return awsRestxml_deserializeErrorTrafficPolicyInUse(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpDeleteTrafficPolicyInstance struct {
}

func (*awsRestxml_deserializeOpDeleteTrafficPolicyInstance) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpDeleteTrafficPolicyInstance) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorDeleteTrafficPolicyInstance(response)
	}
	output := &DeleteTrafficPolicyInstanceOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorDeleteTrafficPolicyInstance(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicyInstance", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicyInstance(response, errorBody)

	case strings.EqualFold("PriorRequestNotComplete", errorCode):
		return awsRestxml_deserializeErrorPriorRequestNotComplete(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpDeleteVPCAssociationAuthorization struct {
}

func (*awsRestxml_deserializeOpDeleteVPCAssociationAuthorization) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpDeleteVPCAssociationAuthorization) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorDeleteVPCAssociationAuthorization(response)
	}
	output := &DeleteVPCAssociationAuthorizationOutput{}
	out.Result = output

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorDeleteVPCAssociationAuthorization(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConcurrentModification", errorCode):
		return awsRestxml_deserializeErrorConcurrentModification(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidVPCId", errorCode):
		return awsRestxml_deserializeErrorInvalidVPCId(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("VPCAssociationAuthorizationNotFound", errorCode):
		return awsRestxml_deserializeErrorVPCAssociationAuthorizationNotFound(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

type awsRestxml_deserializeOpDisassociateVPCFromHostedZone struct {
}

func (*awsRestxml_deserializeOpDisassociateVPCFromHostedZone) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpDisassociateVPCFromHostedZone) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorDisassociateVPCFromHostedZone(response)
	}
	output := &DisassociateVPCFromHostedZoneOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentDisassociateVPCFromHostedZoneOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorDisassociateVPCFromHostedZone(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidVPCId", errorCode):
		return awsRestxml_deserializeErrorInvalidVPCId(response, errorBody)

	case strings.EqualFold("LastVPCAssociation", errorCode):
		return awsRestxml_deserializeErrorLastVPCAssociation(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("VPCAssociationNotFound", errorCode):
		return awsRestxml_deserializeErrorVPCAssociationNotFound(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentDisassociateVPCFromHostedZoneOutput(v **DisassociateVPCFromHostedZoneOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *DisassociateVPCFromHostedZoneOutput
	if *v == nil {
		sv = &DisassociateVPCFromHostedZoneOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ChangeInfo", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentChangeInfo(&sv.ChangeInfo, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetAccountLimit struct {
}

func (*awsRestxml_deserializeOpGetAccountLimit) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetAccountLimit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetAccountLimit(response)
	}
	output := &GetAccountLimitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetAccountLimitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetAccountLimit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetAccountLimitOutput(v **GetAccountLimitOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetAccountLimitOutput
	if *v == nil {
		sv = &GetAccountLimitOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Count", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Count = &i64
			}

		case strings.EqualFold("Limit", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentAccountLimit(&sv.Limit, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetChange struct {
}

func (*awsRestxml_deserializeOpGetChange) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetChange) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetChange(response)
	}
	output := &GetChangeOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetChangeOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetChange(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchChange", errorCode):
		return awsRestxml_deserializeErrorNoSuchChange(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetChangeOutput(v **GetChangeOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetChangeOutput
	if *v == nil {
		sv = &GetChangeOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ChangeInfo", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentChangeInfo(&sv.ChangeInfo, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetCheckerIpRanges struct {
}

func (*awsRestxml_deserializeOpGetCheckerIpRanges) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetCheckerIpRanges) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetCheckerIpRanges(response)
	}
	output := &GetCheckerIpRangesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetCheckerIpRangesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetCheckerIpRanges(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetCheckerIpRangesOutput(v **GetCheckerIpRangesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetCheckerIpRangesOutput
	if *v == nil {
		sv = &GetCheckerIpRangesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("CheckerIpRanges", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentCheckerIpRanges(&sv.CheckerIpRanges, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetGeoLocation struct {
}

func (*awsRestxml_deserializeOpGetGeoLocation) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetGeoLocation) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetGeoLocation(response)
	}
	output := &GetGeoLocationOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetGeoLocationOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetGeoLocation(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchGeoLocation", errorCode):
		return awsRestxml_deserializeErrorNoSuchGeoLocation(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetGeoLocationOutput(v **GetGeoLocationOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetGeoLocationOutput
	if *v == nil {
		sv = &GetGeoLocationOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("GeoLocationDetails", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentGeoLocationDetails(&sv.GeoLocationDetails, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetHealthCheck struct {
}

func (*awsRestxml_deserializeOpGetHealthCheck) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetHealthCheck) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetHealthCheck(response)
	}
	output := &GetHealthCheckOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetHealthCheckOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetHealthCheck(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("IncompatibleVersion", errorCode):
		return awsRestxml_deserializeErrorIncompatibleVersion(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetHealthCheckOutput(v **GetHealthCheckOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetHealthCheckOutput
	if *v == nil {
		sv = &GetHealthCheckOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthCheck", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHealthCheck(&sv.HealthCheck, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetHealthCheckCount struct {
}

func (*awsRestxml_deserializeOpGetHealthCheckCount) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetHealthCheckCount) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetHealthCheckCount(response)
	}
	output := &GetHealthCheckCountOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetHealthCheckCountOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetHealthCheckCount(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetHealthCheckCountOutput(v **GetHealthCheckCountOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetHealthCheckCountOutput
	if *v == nil {
		sv = &GetHealthCheckCountOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthCheckCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.HealthCheckCount = &i64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetHealthCheckLastFailureReason struct {
}

func (*awsRestxml_deserializeOpGetHealthCheckLastFailureReason) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetHealthCheckLastFailureReason) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetHealthCheckLastFailureReason(response)
	}
	output := &GetHealthCheckLastFailureReasonOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetHealthCheckLastFailureReasonOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetHealthCheckLastFailureReason(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetHealthCheckLastFailureReasonOutput(v **GetHealthCheckLastFailureReasonOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetHealthCheckLastFailureReasonOutput
	if *v == nil {
		sv = &GetHealthCheckLastFailureReasonOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthCheckObservations", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHealthCheckObservations(&sv.HealthCheckObservations, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetHealthCheckStatus struct {
}

func (*awsRestxml_deserializeOpGetHealthCheckStatus) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetHealthCheckStatus) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetHealthCheckStatus(response)
	}
	output := &GetHealthCheckStatusOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetHealthCheckStatusOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetHealthCheckStatus(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetHealthCheckStatusOutput(v **GetHealthCheckStatusOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetHealthCheckStatusOutput
	if *v == nil {
		sv = &GetHealthCheckStatusOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthCheckObservations", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHealthCheckObservations(&sv.HealthCheckObservations, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetHostedZone struct {
}

func (*awsRestxml_deserializeOpGetHostedZone) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetHostedZone) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetHostedZone(response)
	}
	output := &GetHostedZoneOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetHostedZoneOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetHostedZone(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetHostedZoneOutput(v **GetHostedZoneOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetHostedZoneOutput
	if *v == nil {
		sv = &GetHostedZoneOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("DelegationSet", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentDelegationSet(&sv.DelegationSet, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("HostedZone", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZone(&sv.HostedZone, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("VPCs", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentVPCs(&sv.VPCs, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetHostedZoneCount struct {
}

func (*awsRestxml_deserializeOpGetHostedZoneCount) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetHostedZoneCount) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetHostedZoneCount(response)
	}
	output := &GetHostedZoneCountOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetHostedZoneCountOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetHostedZoneCount(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetHostedZoneCountOutput(v **GetHostedZoneCountOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetHostedZoneCountOutput
	if *v == nil {
		sv = &GetHostedZoneCountOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZoneCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.HostedZoneCount = &i64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetHostedZoneLimit struct {
}

func (*awsRestxml_deserializeOpGetHostedZoneLimit) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetHostedZoneLimit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetHostedZoneLimit(response)
	}
	output := &GetHostedZoneLimitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetHostedZoneLimitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetHostedZoneLimit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("HostedZoneNotPrivate", errorCode):
		return awsRestxml_deserializeErrorHostedZoneNotPrivate(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetHostedZoneLimitOutput(v **GetHostedZoneLimitOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetHostedZoneLimitOutput
	if *v == nil {
		sv = &GetHostedZoneLimitOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Count", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Count = &i64
			}

		case strings.EqualFold("Limit", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZoneLimit(&sv.Limit, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetQueryLoggingConfig struct {
}

func (*awsRestxml_deserializeOpGetQueryLoggingConfig) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetQueryLoggingConfig) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetQueryLoggingConfig(response)
	}
	output := &GetQueryLoggingConfigOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetQueryLoggingConfigOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetQueryLoggingConfig(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchQueryLoggingConfig", errorCode):
		return awsRestxml_deserializeErrorNoSuchQueryLoggingConfig(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetQueryLoggingConfigOutput(v **GetQueryLoggingConfigOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetQueryLoggingConfigOutput
	if *v == nil {
		sv = &GetQueryLoggingConfigOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("QueryLoggingConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentQueryLoggingConfig(&sv.QueryLoggingConfig, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetReusableDelegationSet struct {
}

func (*awsRestxml_deserializeOpGetReusableDelegationSet) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetReusableDelegationSet) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetReusableDelegationSet(response)
	}
	output := &GetReusableDelegationSetOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetReusableDelegationSetOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetReusableDelegationSet(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("DelegationSetNotReusable", errorCode):
		return awsRestxml_deserializeErrorDelegationSetNotReusable(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchDelegationSet", errorCode):
		return awsRestxml_deserializeErrorNoSuchDelegationSet(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetReusableDelegationSetOutput(v **GetReusableDelegationSetOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetReusableDelegationSetOutput
	if *v == nil {
		sv = &GetReusableDelegationSetOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("DelegationSet", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentDelegationSet(&sv.DelegationSet, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetReusableDelegationSetLimit struct {
}

func (*awsRestxml_deserializeOpGetReusableDelegationSetLimit) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetReusableDelegationSetLimit) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetReusableDelegationSetLimit(response)
	}
	output := &GetReusableDelegationSetLimitOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetReusableDelegationSetLimitOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetReusableDelegationSetLimit(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchDelegationSet", errorCode):
		return awsRestxml_deserializeErrorNoSuchDelegationSet(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetReusableDelegationSetLimitOutput(v **GetReusableDelegationSetLimitOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetReusableDelegationSetLimitOutput
	if *v == nil {
		sv = &GetReusableDelegationSetLimitOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Count", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Count = &i64
			}

		case strings.EqualFold("Limit", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentReusableDelegationSetLimit(&sv.Limit, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetTrafficPolicy struct {
}

func (*awsRestxml_deserializeOpGetTrafficPolicy) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetTrafficPolicy) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetTrafficPolicy(response)
	}
	output := &GetTrafficPolicyOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetTrafficPolicyOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetTrafficPolicy(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicy", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicy(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetTrafficPolicyOutput(v **GetTrafficPolicyOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetTrafficPolicyOutput
	if *v == nil {
		sv = &GetTrafficPolicyOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TrafficPolicy", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicy(&sv.TrafficPolicy, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetTrafficPolicyInstance struct {
}

func (*awsRestxml_deserializeOpGetTrafficPolicyInstance) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetTrafficPolicyInstance) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetTrafficPolicyInstance(response)
	}
	output := &GetTrafficPolicyInstanceOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetTrafficPolicyInstanceOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetTrafficPolicyInstance(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicyInstance", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicyInstance(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetTrafficPolicyInstanceOutput(v **GetTrafficPolicyInstanceOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetTrafficPolicyInstanceOutput
	if *v == nil {
		sv = &GetTrafficPolicyInstanceOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TrafficPolicyInstance", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicyInstance(&sv.TrafficPolicyInstance, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpGetTrafficPolicyInstanceCount struct {
}

func (*awsRestxml_deserializeOpGetTrafficPolicyInstanceCount) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpGetTrafficPolicyInstanceCount) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorGetTrafficPolicyInstanceCount(response)
	}
	output := &GetTrafficPolicyInstanceCountOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentGetTrafficPolicyInstanceCountOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorGetTrafficPolicyInstanceCount(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentGetTrafficPolicyInstanceCountOutput(v **GetTrafficPolicyInstanceCountOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetTrafficPolicyInstanceCountOutput
	if *v == nil {
		sv = &GetTrafficPolicyInstanceCountOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TrafficPolicyInstanceCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.TrafficPolicyInstanceCount = ptr.Int32(int32(i64))
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListGeoLocations struct {
}

func (*awsRestxml_deserializeOpListGeoLocations) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListGeoLocations) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListGeoLocations(response)
	}
	output := &ListGeoLocationsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListGeoLocationsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListGeoLocations(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListGeoLocationsOutput(v **ListGeoLocationsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListGeoLocationsOutput
	if *v == nil {
		sv = &ListGeoLocationsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("GeoLocationDetailsList", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentGeoLocationDetailsList(&sv.GeoLocationDetailsList, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("NextContinentCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextContinentCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextContinentCode = &xtv
			}

		case strings.EqualFold("NextCountryCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextCountryCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextCountryCode = &xtv
			}

		case strings.EqualFold("NextSubdivisionCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextSubdivisionCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextSubdivisionCode = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListHealthChecks struct {
}

func (*awsRestxml_deserializeOpListHealthChecks) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListHealthChecks) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListHealthChecks(response)
	}
	output := &ListHealthChecksOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListHealthChecksOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListHealthChecks(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("IncompatibleVersion", errorCode):
		return awsRestxml_deserializeErrorIncompatibleVersion(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListHealthChecksOutput(v **ListHealthChecksOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListHealthChecksOutput
	if *v == nil {
		sv = &ListHealthChecksOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthChecks", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHealthChecks(&sv.HealthChecks, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("Marker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Marker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Marker = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListHostedZones struct {
}

func (*awsRestxml_deserializeOpListHostedZones) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListHostedZones) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListHostedZones(response)
	}
	output := &ListHostedZonesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListHostedZonesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListHostedZones(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("DelegationSetNotReusable", errorCode):
		return awsRestxml_deserializeErrorDelegationSetNotReusable(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchDelegationSet", errorCode):
		return awsRestxml_deserializeErrorNoSuchDelegationSet(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListHostedZonesOutput(v **ListHostedZonesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListHostedZonesOutput
	if *v == nil {
		sv = &ListHostedZonesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZones", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZones(&sv.HostedZones, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("Marker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Marker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Marker = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListHostedZonesByName struct {
}

func (*awsRestxml_deserializeOpListHostedZonesByName) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListHostedZonesByName) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListHostedZonesByName(response)
	}
	output := &ListHostedZonesByNameOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListHostedZonesByNameOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListHostedZonesByName(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidDomainName", errorCode):
		return awsRestxml_deserializeErrorInvalidDomainName(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListHostedZonesByNameOutput(v **ListHostedZonesByNameOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListHostedZonesByNameOutput
	if *v == nil {
		sv = &ListHostedZonesByNameOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("DNSName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.DNSName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DNSName = &xtv
			}

		case strings.EqualFold("HostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneId = &xtv
			}

		case strings.EqualFold("HostedZones", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZones(&sv.HostedZones, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("NextDNSName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextDNSName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextDNSName = &xtv
			}

		case strings.EqualFold("NextHostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextHostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextHostedZoneId = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListHostedZonesByVPC struct {
}

func (*awsRestxml_deserializeOpListHostedZonesByVPC) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListHostedZonesByVPC) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListHostedZonesByVPC(response)
	}
	output := &ListHostedZonesByVPCOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListHostedZonesByVPCOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListHostedZonesByVPC(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidPaginationToken", errorCode):
		return awsRestxml_deserializeErrorInvalidPaginationToken(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListHostedZonesByVPCOutput(v **ListHostedZonesByVPCOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListHostedZonesByVPCOutput
	if *v == nil {
		sv = &ListHostedZonesByVPCOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZoneSummaries", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZoneSummaries(&sv.HostedZoneSummaries, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("NextToken", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextToken = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextToken = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListQueryLoggingConfigs struct {
}

func (*awsRestxml_deserializeOpListQueryLoggingConfigs) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListQueryLoggingConfigs) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListQueryLoggingConfigs(response)
	}
	output := &ListQueryLoggingConfigsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListQueryLoggingConfigsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListQueryLoggingConfigs(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidPaginationToken", errorCode):
		return awsRestxml_deserializeErrorInvalidPaginationToken(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListQueryLoggingConfigsOutput(v **ListQueryLoggingConfigsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListQueryLoggingConfigsOutput
	if *v == nil {
		sv = &ListQueryLoggingConfigsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("NextToken", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextToken = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextToken = &xtv
			}

		case strings.EqualFold("QueryLoggingConfigs", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentQueryLoggingConfigs(&sv.QueryLoggingConfigs, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListResourceRecordSets struct {
}

func (*awsRestxml_deserializeOpListResourceRecordSets) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListResourceRecordSets) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListResourceRecordSets(response)
	}
	output := &ListResourceRecordSetsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListResourceRecordSetsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListResourceRecordSets(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListResourceRecordSetsOutput(v **ListResourceRecordSetsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListResourceRecordSetsOutput
	if *v == nil {
		sv = &ListResourceRecordSetsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("NextRecordIdentifier", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextRecordIdentifier = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextRecordIdentifier = &xtv
			}

		case strings.EqualFold("NextRecordName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextRecordName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextRecordName = &xtv
			}

		case strings.EqualFold("NextRecordType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextRecordType = types.RRType(xtv)
			}

		case strings.EqualFold("ResourceRecordSets", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentResourceRecordSets(&sv.ResourceRecordSets, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListReusableDelegationSets struct {
}

func (*awsRestxml_deserializeOpListReusableDelegationSets) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListReusableDelegationSets) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListReusableDelegationSets(response)
	}
	output := &ListReusableDelegationSetsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListReusableDelegationSetsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListReusableDelegationSets(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListReusableDelegationSetsOutput(v **ListReusableDelegationSetsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListReusableDelegationSetsOutput
	if *v == nil {
		sv = &ListReusableDelegationSetsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("DelegationSets", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentDelegationSets(&sv.DelegationSets, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("Marker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Marker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Marker = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("NextMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextMarker = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListTagsForResource struct {
}

func (*awsRestxml_deserializeOpListTagsForResource) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListTagsForResource) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListTagsForResource(response)
	}
	output := &ListTagsForResourceOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListTagsForResourceOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListTagsForResource(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("PriorRequestNotComplete", errorCode):
		return awsRestxml_deserializeErrorPriorRequestNotComplete(response, errorBody)

	case strings.EqualFold("ThrottlingException", errorCode):
		return awsRestxml_deserializeErrorThrottlingException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListTagsForResourceOutput(v **ListTagsForResourceOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListTagsForResourceOutput
	if *v == nil {
		sv = &ListTagsForResourceOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ResourceTagSet", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentResourceTagSet(&sv.ResourceTagSet, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListTagsForResources struct {
}

func (*awsRestxml_deserializeOpListTagsForResources) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListTagsForResources) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListTagsForResources(response)
	}
	output := &ListTagsForResourcesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListTagsForResourcesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListTagsForResources(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("PriorRequestNotComplete", errorCode):
		return awsRestxml_deserializeErrorPriorRequestNotComplete(response, errorBody)

	case strings.EqualFold("ThrottlingException", errorCode):
		return awsRestxml_deserializeErrorThrottlingException(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListTagsForResourcesOutput(v **ListTagsForResourcesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListTagsForResourcesOutput
	if *v == nil {
		sv = &ListTagsForResourcesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ResourceTagSets", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentResourceTagSetList(&sv.ResourceTagSets, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListTrafficPolicies struct {
}

func (*awsRestxml_deserializeOpListTrafficPolicies) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListTrafficPolicies) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListTrafficPolicies(response)
	}
	output := &ListTrafficPoliciesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListTrafficPoliciesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListTrafficPolicies(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListTrafficPoliciesOutput(v **ListTrafficPoliciesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListTrafficPoliciesOutput
	if *v == nil {
		sv = &ListTrafficPoliciesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("TrafficPolicyIdMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TrafficPolicyIdMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyIdMarker = &xtv
			}

		case strings.EqualFold("TrafficPolicySummaries", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicySummaries(&sv.TrafficPolicySummaries, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListTrafficPolicyInstances struct {
}

func (*awsRestxml_deserializeOpListTrafficPolicyInstances) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListTrafficPolicyInstances) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListTrafficPolicyInstances(response)
	}
	output := &ListTrafficPolicyInstancesOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListTrafficPolicyInstancesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListTrafficPolicyInstances(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicyInstance", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicyInstance(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListTrafficPolicyInstancesOutput(v **ListTrafficPolicyInstancesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListTrafficPolicyInstancesOutput
	if *v == nil {
		sv = &ListTrafficPolicyInstancesOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZoneIdMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneIdMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneIdMarker = &xtv
			}

		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("TrafficPolicyInstanceNameMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TrafficPolicyInstanceNameMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyInstanceNameMarker = &xtv
			}

		case strings.EqualFold("TrafficPolicyInstances", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicyInstances(&sv.TrafficPolicyInstances, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TrafficPolicyInstanceTypeMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyInstanceTypeMarker = types.RRType(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListTrafficPolicyInstancesByHostedZone struct {
}

func (*awsRestxml_deserializeOpListTrafficPolicyInstancesByHostedZone) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListTrafficPolicyInstancesByHostedZone) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListTrafficPolicyInstancesByHostedZone(response)
	}
	output := &ListTrafficPolicyInstancesByHostedZoneOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListTrafficPolicyInstancesByHostedZoneOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListTrafficPolicyInstancesByHostedZone(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicyInstance", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicyInstance(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListTrafficPolicyInstancesByHostedZoneOutput(v **ListTrafficPolicyInstancesByHostedZoneOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListTrafficPolicyInstancesByHostedZoneOutput
	if *v == nil {
		sv = &ListTrafficPolicyInstancesByHostedZoneOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("TrafficPolicyInstanceNameMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TrafficPolicyInstanceNameMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyInstanceNameMarker = &xtv
			}

		case strings.EqualFold("TrafficPolicyInstances", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicyInstances(&sv.TrafficPolicyInstances, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TrafficPolicyInstanceTypeMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyInstanceTypeMarker = types.RRType(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListTrafficPolicyInstancesByPolicy struct {
}

func (*awsRestxml_deserializeOpListTrafficPolicyInstancesByPolicy) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListTrafficPolicyInstancesByPolicy) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListTrafficPolicyInstancesByPolicy(response)
	}
	output := &ListTrafficPolicyInstancesByPolicyOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListTrafficPolicyInstancesByPolicyOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListTrafficPolicyInstancesByPolicy(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicy", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicy(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicyInstance", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicyInstance(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListTrafficPolicyInstancesByPolicyOutput(v **ListTrafficPolicyInstancesByPolicyOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListTrafficPolicyInstancesByPolicyOutput
	if *v == nil {
		sv = &ListTrafficPolicyInstancesByPolicyOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZoneIdMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneIdMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneIdMarker = &xtv
			}

		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("TrafficPolicyInstanceNameMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TrafficPolicyInstanceNameMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyInstanceNameMarker = &xtv
			}

		case strings.EqualFold("TrafficPolicyInstances", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicyInstances(&sv.TrafficPolicyInstances, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TrafficPolicyInstanceTypeMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyInstanceTypeMarker = types.RRType(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListTrafficPolicyVersions struct {
}

func (*awsRestxml_deserializeOpListTrafficPolicyVersions) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListTrafficPolicyVersions) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListTrafficPolicyVersions(response)
	}
	output := &ListTrafficPolicyVersionsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListTrafficPolicyVersionsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListTrafficPolicyVersions(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicy", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicy(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListTrafficPolicyVersionsOutput(v **ListTrafficPolicyVersionsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListTrafficPolicyVersionsOutput
	if *v == nil {
		sv = &ListTrafficPolicyVersionsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("IsTruncated", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected PageTruncated to be of type *bool, got %T instead", val)
				}
				sv.IsTruncated = &xtv
			}

		case strings.EqualFold("MaxItems", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MaxItems = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MaxItems = &xtv
			}

		case strings.EqualFold("TrafficPolicies", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicies(&sv.TrafficPolicies, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("TrafficPolicyVersionMarker", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TrafficPolicyVersionMarker = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyVersionMarker = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpListVPCAssociationAuthorizations struct {
}

func (*awsRestxml_deserializeOpListVPCAssociationAuthorizations) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpListVPCAssociationAuthorizations) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorListVPCAssociationAuthorizations(response)
	}
	output := &ListVPCAssociationAuthorizationsOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentListVPCAssociationAuthorizationsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorListVPCAssociationAuthorizations(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("InvalidPaginationToken", errorCode):
		return awsRestxml_deserializeErrorInvalidPaginationToken(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentListVPCAssociationAuthorizationsOutput(v **ListVPCAssociationAuthorizationsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListVPCAssociationAuthorizationsOutput
	if *v == nil {
		sv = &ListVPCAssociationAuthorizationsOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneId = &xtv
			}

		case strings.EqualFold("NextToken", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.NextToken = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.NextToken = &xtv
			}

		case strings.EqualFold("VPCs", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentVPCs(&sv.VPCs, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpTestDNSAnswer struct {
}

func (*awsRestxml_deserializeOpTestDNSAnswer) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpTestDNSAnswer) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorTestDNSAnswer(response)
	}
	output := &TestDNSAnswerOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentTestDNSAnswerOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorTestDNSAnswer(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentTestDNSAnswerOutput(v **TestDNSAnswerOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *TestDNSAnswerOutput
	if *v == nil {
		sv = &TestDNSAnswerOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Nameserver", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Nameserver = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Nameserver = &xtv
			}

		case strings.EqualFold("Protocol", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Protocol = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Protocol = &xtv
			}

		case strings.EqualFold("RecordData", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentRecordData(&sv.RecordData, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("RecordName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.RecordName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.RecordName = &xtv
			}

		case strings.EqualFold("RecordType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.RecordType = types.RRType(xtv)
			}

		case strings.EqualFold("ResponseCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ResponseCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ResponseCode = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpUpdateHealthCheck struct {
}

func (*awsRestxml_deserializeOpUpdateHealthCheck) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpUpdateHealthCheck) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorUpdateHealthCheck(response)
	}
	output := &UpdateHealthCheckOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentUpdateHealthCheckOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorUpdateHealthCheck(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("HealthCheckVersionMismatch", errorCode):
		return awsRestxml_deserializeErrorHealthCheckVersionMismatch(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHealthCheck", errorCode):
		return awsRestxml_deserializeErrorNoSuchHealthCheck(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentUpdateHealthCheckOutput(v **UpdateHealthCheckOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *UpdateHealthCheckOutput
	if *v == nil {
		sv = &UpdateHealthCheckOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HealthCheck", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHealthCheck(&sv.HealthCheck, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpUpdateHostedZoneComment struct {
}

func (*awsRestxml_deserializeOpUpdateHostedZoneComment) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpUpdateHostedZoneComment) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorUpdateHostedZoneComment(response)
	}
	output := &UpdateHostedZoneCommentOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentUpdateHostedZoneCommentOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorUpdateHostedZoneComment(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchHostedZone", errorCode):
		return awsRestxml_deserializeErrorNoSuchHostedZone(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentUpdateHostedZoneCommentOutput(v **UpdateHostedZoneCommentOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *UpdateHostedZoneCommentOutput
	if *v == nil {
		sv = &UpdateHostedZoneCommentOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZone", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZone(&sv.HostedZone, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpUpdateTrafficPolicyComment struct {
}

func (*awsRestxml_deserializeOpUpdateTrafficPolicyComment) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpUpdateTrafficPolicyComment) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorUpdateTrafficPolicyComment(response)
	}
	output := &UpdateTrafficPolicyCommentOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentUpdateTrafficPolicyCommentOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorUpdateTrafficPolicyComment(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConcurrentModification", errorCode):
		return awsRestxml_deserializeErrorConcurrentModification(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicy", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicy(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentUpdateTrafficPolicyCommentOutput(v **UpdateTrafficPolicyCommentOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *UpdateTrafficPolicyCommentOutput
	if *v == nil {
		sv = &UpdateTrafficPolicyCommentOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TrafficPolicy", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicy(&sv.TrafficPolicy, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

type awsRestxml_deserializeOpUpdateTrafficPolicyInstance struct {
}

func (*awsRestxml_deserializeOpUpdateTrafficPolicyInstance) ID() string {
	return "OperationDeserializer"
}

func (m *awsRestxml_deserializeOpUpdateTrafficPolicyInstance) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil {
		return out, metadata, err
	}

	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}

	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsRestxml_deserializeOpErrorUpdateTrafficPolicyInstance(response)
	}
	output := &UpdateTrafficPolicyInstanceOutput{}
	out.Result = output

	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return out, metadata, nil
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeOpDocumentUpdateTrafficPolicyInstanceOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return out, metadata, err
}

func awsRestxml_deserializeOpErrorUpdateTrafficPolicyInstance(response *smithyhttp.Response) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())

	errorCode := "UnknownError"
	errorMessage := errorCode

	errorCode, err := smithyxml.GetResponseErrorCode(errorBody, false)
	if err != nil {
		return err
	}
	errorBody.Seek(0, io.SeekStart)
	switch {
	case strings.EqualFold("ConflictingTypes", errorCode):
		return awsRestxml_deserializeErrorConflictingTypes(response, errorBody)

	case strings.EqualFold("InvalidInput", errorCode):
		return awsRestxml_deserializeErrorInvalidInput(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicy", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicy(response, errorBody)

	case strings.EqualFold("NoSuchTrafficPolicyInstance", errorCode):
		return awsRestxml_deserializeErrorNoSuchTrafficPolicyInstance(response, errorBody)

	case strings.EqualFold("PriorRequestNotComplete", errorCode):
		return awsRestxml_deserializeErrorPriorRequestNotComplete(response, errorBody)

	default:
		genericError := &smithy.GenericAPIError{
			Code:    errorCode,
			Message: errorMessage,
		}
		return genericError

	}
}

func awsRestxml_deserializeOpDocumentUpdateTrafficPolicyInstanceOutput(v **UpdateTrafficPolicyInstanceOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *UpdateTrafficPolicyInstanceOutput
	if *v == nil {
		sv = &UpdateTrafficPolicyInstanceOutput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("TrafficPolicyInstance", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTrafficPolicyInstance(&sv.TrafficPolicyInstance, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeErrorConcurrentModification(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ConcurrentModification{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentConcurrentModification(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorConflictingDomainExists(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ConflictingDomainExists{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentConflictingDomainExists(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorConflictingTypes(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ConflictingTypes{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentConflictingTypes(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorDelegationSetAlreadyCreated(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DelegationSetAlreadyCreated{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentDelegationSetAlreadyCreated(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorDelegationSetAlreadyReusable(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DelegationSetAlreadyReusable{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentDelegationSetAlreadyReusable(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorDelegationSetInUse(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DelegationSetInUse{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentDelegationSetInUse(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorDelegationSetNotAvailable(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DelegationSetNotAvailable{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentDelegationSetNotAvailable(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorDelegationSetNotReusable(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.DelegationSetNotReusable{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentDelegationSetNotReusable(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorHealthCheckAlreadyExists(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.HealthCheckAlreadyExists{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentHealthCheckAlreadyExists(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorHealthCheckInUse(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.HealthCheckInUse{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentHealthCheckInUse(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorHealthCheckVersionMismatch(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.HealthCheckVersionMismatch{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentHealthCheckVersionMismatch(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorHostedZoneAlreadyExists(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.HostedZoneAlreadyExists{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentHostedZoneAlreadyExists(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorHostedZoneNotEmpty(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.HostedZoneNotEmpty{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentHostedZoneNotEmpty(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorHostedZoneNotFound(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.HostedZoneNotFound{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentHostedZoneNotFound(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorHostedZoneNotPrivate(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.HostedZoneNotPrivate{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentHostedZoneNotPrivate(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorIncompatibleVersion(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.IncompatibleVersion{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentIncompatibleVersion(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInsufficientCloudWatchLogsResourcePolicy(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InsufficientCloudWatchLogsResourcePolicy{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInsufficientCloudWatchLogsResourcePolicy(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInvalidArgument(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidArgument{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInvalidArgument(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInvalidChangeBatch(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidChangeBatch{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInvalidChangeBatch(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInvalidDomainName(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidDomainName{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInvalidDomainName(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInvalidInput(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidInput{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInvalidInput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInvalidPaginationToken(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidPaginationToken{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInvalidPaginationToken(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInvalidTrafficPolicyDocument(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidTrafficPolicyDocument{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInvalidTrafficPolicyDocument(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorInvalidVPCId(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.InvalidVPCId{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentInvalidVPCId(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorLastVPCAssociation(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.LastVPCAssociation{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentLastVPCAssociation(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorLimitsExceeded(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.LimitsExceeded{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentLimitsExceeded(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchChange(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchChange{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchChange(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchCloudWatchLogsLogGroup(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchCloudWatchLogsLogGroup{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchCloudWatchLogsLogGroup(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchDelegationSet(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchDelegationSet{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchDelegationSet(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchGeoLocation(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchGeoLocation{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchGeoLocation(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchHealthCheck(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchHealthCheck{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchHealthCheck(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchHostedZone(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchHostedZone{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchHostedZone(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchQueryLoggingConfig(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchQueryLoggingConfig{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchQueryLoggingConfig(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchTrafficPolicy(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchTrafficPolicy{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchTrafficPolicy(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNoSuchTrafficPolicyInstance(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NoSuchTrafficPolicyInstance{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNoSuchTrafficPolicyInstance(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorNotAuthorizedException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.NotAuthorizedException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentNotAuthorizedException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorPriorRequestNotComplete(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.PriorRequestNotComplete{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentPriorRequestNotComplete(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorPublicZoneVPCAssociation(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.PublicZoneVPCAssociation{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentPublicZoneVPCAssociation(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorQueryLoggingConfigAlreadyExists(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.QueryLoggingConfigAlreadyExists{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentQueryLoggingConfigAlreadyExists(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorThrottlingException(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.ThrottlingException{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentThrottlingException(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTooManyHealthChecks(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyHealthChecks{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTooManyHealthChecks(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTooManyHostedZones(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyHostedZones{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTooManyHostedZones(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTooManyTrafficPolicies(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyTrafficPolicies{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTooManyTrafficPolicies(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTooManyTrafficPolicyInstances(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyTrafficPolicyInstances{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTooManyTrafficPolicyInstances(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTooManyTrafficPolicyVersionsForCurrentPolicy(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyTrafficPolicyVersionsForCurrentPolicy{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTooManyTrafficPolicyVersionsForCurrentPolicy(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTooManyVPCAssociationAuthorizations(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TooManyVPCAssociationAuthorizations{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTooManyVPCAssociationAuthorizations(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTrafficPolicyAlreadyExists(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TrafficPolicyAlreadyExists{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTrafficPolicyAlreadyExists(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTrafficPolicyInstanceAlreadyExists(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TrafficPolicyInstanceAlreadyExists{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTrafficPolicyInstanceAlreadyExists(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorTrafficPolicyInUse(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.TrafficPolicyInUse{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentTrafficPolicyInUse(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorVPCAssociationAuthorizationNotFound(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.VPCAssociationAuthorizationNotFound{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentVPCAssociationAuthorizationNotFound(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeErrorVPCAssociationNotFound(response *smithyhttp.Response, errorBody *bytes.Reader) error {
	output := &types.VPCAssociationNotFound{}
	buff := make([]byte, 1024)
	ringBuffer := smithyio.NewRingBuffer(buff)
	body := io.TeeReader(errorBody, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF {
		return output
	}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	err = awsRestxml_deserializeDocumentVPCAssociationNotFound(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return &smithy.DeserializationError{
			Err:      fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}

	return output
}

func awsRestxml_deserializeDocumentAccountLimit(v **types.AccountLimit, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AccountLimit
	if *v == nil {
		sv = &types.AccountLimit{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.AccountLimitType(xtv)
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Value = &i64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentAlarmIdentifier(v **types.AlarmIdentifier, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AlarmIdentifier
	if *v == nil {
		sv = &types.AlarmIdentifier{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("Region", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Region = types.CloudWatchRegion(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentAliasTarget(v **types.AliasTarget, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.AliasTarget
	if *v == nil {
		sv = &types.AliasTarget{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("DNSName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.DNSName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.DNSName = &xtv
			}

		case strings.EqualFold("EvaluateTargetHealth", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected AliasHealthEnabled to be of type *bool, got %T instead", val)
				}
				sv.EvaluateTargetHealth = &xtv
			}

		case strings.EqualFold("HostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneId = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentChangeInfo(v **types.ChangeInfo, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ChangeInfo
	if *v == nil {
		sv = &types.ChangeInfo{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Comment", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Comment = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Comment = &xtv
			}

		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		case strings.EqualFold("Status", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Status = types.ChangeStatus(xtv)
			}

		case strings.EqualFold("SubmittedAt", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				t, err := smithytime.ParseDateTime(xtv)
				if err != nil {
					return err
				}
				sv.SubmittedAt = &t
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentCheckerIpRanges(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("member", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentCheckerIpRangesUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentChildHealthCheckList(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("ChildHealthCheck", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentChildHealthCheckListUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentCloudWatchAlarmConfiguration(v **types.CloudWatchAlarmConfiguration, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.CloudWatchAlarmConfiguration
	if *v == nil {
		sv = &types.CloudWatchAlarmConfiguration{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ComparisonOperator", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ComparisonOperator = types.ComparisonOperator(xtv)
			}

		case strings.EqualFold("Dimensions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentDimensionList(&sv.Dimensions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("EvaluationPeriods", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.EvaluationPeriods = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("MetricName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.MetricName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.MetricName = &xtv
			}

		case strings.EqualFold("Namespace", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Namespace = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Namespace = &xtv
			}

		case strings.EqualFold("Period", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Period = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("Statistic", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Statistic = types.Statistic(xtv)
			}

		case strings.EqualFold("Threshold", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				f64, err := strconv.ParseFloat(xtv, 64)
				if err != nil {
					return err
				}
				sv.Threshold = &f64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentConcurrentModification(v **types.ConcurrentModification, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ConcurrentModification
	if *v == nil {
		sv = &types.ConcurrentModification{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentConflictingDomainExists(v **types.ConflictingDomainExists, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ConflictingDomainExists
	if *v == nil {
		sv = &types.ConflictingDomainExists{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentConflictingTypes(v **types.ConflictingTypes, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ConflictingTypes
	if *v == nil {
		sv = &types.ConflictingTypes{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSet(v **types.DelegationSet, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DelegationSet
	if *v == nil {
		sv = &types.DelegationSet{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("CallerReference", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CallerReference = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CallerReference = &xtv
			}

		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		case strings.EqualFold("NameServers", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentDelegationSetNameServers(&sv.NameServers, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSetAlreadyCreated(v **types.DelegationSetAlreadyCreated, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DelegationSetAlreadyCreated
	if *v == nil {
		sv = &types.DelegationSetAlreadyCreated{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSetAlreadyReusable(v **types.DelegationSetAlreadyReusable, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DelegationSetAlreadyReusable
	if *v == nil {
		sv = &types.DelegationSetAlreadyReusable{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSetInUse(v **types.DelegationSetInUse, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DelegationSetInUse
	if *v == nil {
		sv = &types.DelegationSetInUse{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSetNameServers(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("NameServer", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSetNameServersUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentDelegationSetNotAvailable(v **types.DelegationSetNotAvailable, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DelegationSetNotAvailable
	if *v == nil {
		sv = &types.DelegationSetNotAvailable{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSetNotReusable(v **types.DelegationSetNotReusable, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DelegationSetNotReusable
	if *v == nil {
		sv = &types.DelegationSetNotReusable{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSets(v *[]*types.DelegationSet, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.DelegationSet
	if *v == nil {
		sv = make([]*types.DelegationSet, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("DelegationSet", t.Name.Local) {
				var col *types.DelegationSet
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentDelegationSet(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDelegationSetsUnwrapped(v *[]*types.DelegationSet, decoder smithyxml.NodeDecoder) error {
	var sv []*types.DelegationSet
	if *v == nil {
		sv = make([]*types.DelegationSet, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.DelegationSet
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentDelegationSet(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentDimension(v **types.Dimension, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Dimension
	if *v == nil {
		sv = &types.Dimension{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Value = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Value = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDimensionList(v *[]*types.Dimension, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Dimension
	if *v == nil {
		sv = make([]*types.Dimension, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("Dimension", t.Name.Local) {
				var col *types.Dimension
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentDimension(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentDimensionListUnwrapped(v *[]*types.Dimension, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Dimension
	if *v == nil {
		sv = make([]*types.Dimension, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Dimension
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentDimension(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentErrorMessages(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("Message", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentErrorMessagesUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentGeoLocation(v **types.GeoLocation, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.GeoLocation
	if *v == nil {
		sv = &types.GeoLocation{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ContinentCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ContinentCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ContinentCode = &xtv
			}

		case strings.EqualFold("CountryCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CountryCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CountryCode = &xtv
			}

		case strings.EqualFold("SubdivisionCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SubdivisionCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SubdivisionCode = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentGeoLocationDetails(v **types.GeoLocationDetails, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.GeoLocationDetails
	if *v == nil {
		sv = &types.GeoLocationDetails{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ContinentCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ContinentCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ContinentCode = &xtv
			}

		case strings.EqualFold("ContinentName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ContinentName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ContinentName = &xtv
			}

		case strings.EqualFold("CountryCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CountryCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CountryCode = &xtv
			}

		case strings.EqualFold("CountryName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CountryName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CountryName = &xtv
			}

		case strings.EqualFold("SubdivisionCode", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SubdivisionCode = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SubdivisionCode = &xtv
			}

		case strings.EqualFold("SubdivisionName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SubdivisionName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SubdivisionName = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentGeoLocationDetailsList(v *[]*types.GeoLocationDetails, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.GeoLocationDetails
	if *v == nil {
		sv = make([]*types.GeoLocationDetails, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("GeoLocationDetails", t.Name.Local) {
				var col *types.GeoLocationDetails
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentGeoLocationDetails(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentGeoLocationDetailsListUnwrapped(v *[]*types.GeoLocationDetails, decoder smithyxml.NodeDecoder) error {
	var sv []*types.GeoLocationDetails
	if *v == nil {
		sv = make([]*types.GeoLocationDetails, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.GeoLocationDetails
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentGeoLocationDetails(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentHealthCheck(v **types.HealthCheck, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HealthCheck
	if *v == nil {
		sv = &types.HealthCheck{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("CallerReference", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CallerReference = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CallerReference = &xtv
			}

		case strings.EqualFold("CloudWatchAlarmConfiguration", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentCloudWatchAlarmConfiguration(&sv.CloudWatchAlarmConfiguration, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("HealthCheckConfig", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHealthCheckConfig(&sv.HealthCheckConfig, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("HealthCheckVersion", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.HealthCheckVersion = &i64
			}

		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		case strings.EqualFold("LinkedService", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentLinkedService(&sv.LinkedService, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHealthCheckAlreadyExists(v **types.HealthCheckAlreadyExists, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HealthCheckAlreadyExists
	if *v == nil {
		sv = &types.HealthCheckAlreadyExists{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHealthCheckConfig(v **types.HealthCheckConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HealthCheckConfig
	if *v == nil {
		sv = &types.HealthCheckConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AlarmIdentifier", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentAlarmIdentifier(&sv.AlarmIdentifier, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("ChildHealthChecks", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentChildHealthCheckList(&sv.ChildHealthChecks, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Disabled", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Disabled to be of type *bool, got %T instead", val)
				}
				sv.Disabled = &xtv
			}

		case strings.EqualFold("EnableSNI", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected EnableSNI to be of type *bool, got %T instead", val)
				}
				sv.EnableSNI = &xtv
			}

		case strings.EqualFold("FailureThreshold", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.FailureThreshold = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("FullyQualifiedDomainName", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.FullyQualifiedDomainName = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.FullyQualifiedDomainName = &xtv
			}

		case strings.EqualFold("HealthThreshold", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.HealthThreshold = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("InsufficientDataHealthStatus", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.InsufficientDataHealthStatus = types.InsufficientDataHealthStatus(xtv)
			}

		case strings.EqualFold("Inverted", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected Inverted to be of type *bool, got %T instead", val)
				}
				sv.Inverted = &xtv
			}

		case strings.EqualFold("IPAddress", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.IPAddress = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.IPAddress = &xtv
			}

		case strings.EqualFold("MeasureLatency", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected MeasureLatency to be of type *bool, got %T instead", val)
				}
				sv.MeasureLatency = &xtv
			}

		case strings.EqualFold("Port", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Port = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("Regions", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHealthCheckRegionList(&sv.Regions, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("RequestInterval", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.RequestInterval = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("ResourcePath", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ResourcePath = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ResourcePath = &xtv
			}

		case strings.EqualFold("SearchString", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SearchString = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SearchString = &xtv
			}

		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.HealthCheckType(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHealthCheckInUse(v **types.HealthCheckInUse, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HealthCheckInUse
	if *v == nil {
		sv = &types.HealthCheckInUse{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHealthCheckObservation(v **types.HealthCheckObservation, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HealthCheckObservation
	if *v == nil {
		sv = &types.HealthCheckObservation{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("IPAddress", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.IPAddress = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.IPAddress = &xtv
			}

		case strings.EqualFold("Region", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Region = types.HealthCheckRegion(xtv)
			}

		case strings.EqualFold("StatusReport", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentStatusReport(&sv.StatusReport, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHealthCheckObservations(v *[]*types.HealthCheckObservation, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.HealthCheckObservation
	if *v == nil {
		sv = make([]*types.HealthCheckObservation, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("HealthCheckObservation", t.Name.Local) {
				var col *types.HealthCheckObservation
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentHealthCheckObservation(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHealthCheckObservationsUnwrapped(v *[]*types.HealthCheckObservation, decoder smithyxml.NodeDecoder) error {
	var sv []*types.HealthCheckObservation
	if *v == nil {
		sv = make([]*types.HealthCheckObservation, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.HealthCheckObservation
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentHealthCheckObservation(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentHealthCheckRegionList(v *[]types.HealthCheckRegion, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []types.HealthCheckRegion
	if *v == nil {
		sv = make([]types.HealthCheckRegion, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("Region", t.Name.Local) {
				var col types.HealthCheckRegion
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					break
				}
				if val != nil {
					xtv := string(val)
					col = types.HealthCheckRegion(xtv)
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHealthCheckRegionListUnwrapped(v *[]types.HealthCheckRegion, decoder smithyxml.NodeDecoder) error {
	var sv []types.HealthCheckRegion
	if *v == nil {
		sv = make([]types.HealthCheckRegion, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv types.HealthCheckRegion
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			break
		}
		if val != nil {
			xtv := string(val)
			mv = types.HealthCheckRegion(xtv)
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentHealthChecks(v *[]*types.HealthCheck, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.HealthCheck
	if *v == nil {
		sv = make([]*types.HealthCheck, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("HealthCheck", t.Name.Local) {
				var col *types.HealthCheck
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentHealthCheck(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHealthChecksUnwrapped(v *[]*types.HealthCheck, decoder smithyxml.NodeDecoder) error {
	var sv []*types.HealthCheck
	if *v == nil {
		sv = make([]*types.HealthCheck, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.HealthCheck
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentHealthCheck(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentHealthCheckVersionMismatch(v **types.HealthCheckVersionMismatch, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HealthCheckVersionMismatch
	if *v == nil {
		sv = &types.HealthCheckVersionMismatch{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZone(v **types.HostedZone, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZone
	if *v == nil {
		sv = &types.HostedZone{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("CallerReference", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CallerReference = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CallerReference = &xtv
			}

		case strings.EqualFold("Config", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZoneConfig(&sv.Config, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		case strings.EqualFold("LinkedService", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentLinkedService(&sv.LinkedService, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("ResourceRecordSetCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.ResourceRecordSetCount = &i64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZoneAlreadyExists(v **types.HostedZoneAlreadyExists, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZoneAlreadyExists
	if *v == nil {
		sv = &types.HostedZoneAlreadyExists{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZoneConfig(v **types.HostedZoneConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZoneConfig
	if *v == nil {
		sv = &types.HostedZoneConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Comment", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Comment = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Comment = &xtv
			}

		case strings.EqualFold("PrivateZone", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected IsPrivateZone to be of type *bool, got %T instead", val)
				}
				sv.PrivateZone = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZoneLimit(v **types.HostedZoneLimit, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZoneLimit
	if *v == nil {
		sv = &types.HostedZoneLimit{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.HostedZoneLimitType(xtv)
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Value = &i64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZoneNotEmpty(v **types.HostedZoneNotEmpty, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZoneNotEmpty
	if *v == nil {
		sv = &types.HostedZoneNotEmpty{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZoneNotFound(v **types.HostedZoneNotFound, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZoneNotFound
	if *v == nil {
		sv = &types.HostedZoneNotFound{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZoneNotPrivate(v **types.HostedZoneNotPrivate, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZoneNotPrivate
	if *v == nil {
		sv = &types.HostedZoneNotPrivate{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZoneOwner(v **types.HostedZoneOwner, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZoneOwner
	if *v == nil {
		sv = &types.HostedZoneOwner{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("OwningAccount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.OwningAccount = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.OwningAccount = &xtv
			}

		case strings.EqualFold("OwningService", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.OwningService = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.OwningService = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZones(v *[]*types.HostedZone, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.HostedZone
	if *v == nil {
		sv = make([]*types.HostedZone, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("HostedZone", t.Name.Local) {
				var col *types.HostedZone
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentHostedZone(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZonesUnwrapped(v *[]*types.HostedZone, decoder smithyxml.NodeDecoder) error {
	var sv []*types.HostedZone
	if *v == nil {
		sv = make([]*types.HostedZone, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.HostedZone
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentHostedZone(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentHostedZoneSummaries(v *[]*types.HostedZoneSummary, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.HostedZoneSummary
	if *v == nil {
		sv = make([]*types.HostedZoneSummary, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("HostedZoneSummary", t.Name.Local) {
				var col *types.HostedZoneSummary
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentHostedZoneSummary(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentHostedZoneSummariesUnwrapped(v *[]*types.HostedZoneSummary, decoder smithyxml.NodeDecoder) error {
	var sv []*types.HostedZoneSummary
	if *v == nil {
		sv = make([]*types.HostedZoneSummary, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.HostedZoneSummary
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentHostedZoneSummary(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentHostedZoneSummary(v **types.HostedZoneSummary, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.HostedZoneSummary
	if *v == nil {
		sv = &types.HostedZoneSummary{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneId = &xtv
			}

		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("Owner", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentHostedZoneOwner(&sv.Owner, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentIncompatibleVersion(v **types.IncompatibleVersion, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.IncompatibleVersion
	if *v == nil {
		sv = &types.IncompatibleVersion{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentInsufficientCloudWatchLogsResourcePolicy(v **types.InsufficientCloudWatchLogsResourcePolicy, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InsufficientCloudWatchLogsResourcePolicy
	if *v == nil {
		sv = &types.InsufficientCloudWatchLogsResourcePolicy{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentInvalidArgument(v **types.InvalidArgument, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidArgument
	if *v == nil {
		sv = &types.InvalidArgument{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentInvalidChangeBatch(v **types.InvalidChangeBatch, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidChangeBatch
	if *v == nil {
		sv = &types.InvalidChangeBatch{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		case strings.EqualFold("messages", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentErrorMessages(&sv.Messages, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentInvalidDomainName(v **types.InvalidDomainName, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidDomainName
	if *v == nil {
		sv = &types.InvalidDomainName{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentInvalidInput(v **types.InvalidInput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidInput
	if *v == nil {
		sv = &types.InvalidInput{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentInvalidPaginationToken(v **types.InvalidPaginationToken, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidPaginationToken
	if *v == nil {
		sv = &types.InvalidPaginationToken{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentInvalidTrafficPolicyDocument(v **types.InvalidTrafficPolicyDocument, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidTrafficPolicyDocument
	if *v == nil {
		sv = &types.InvalidTrafficPolicyDocument{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentInvalidVPCId(v **types.InvalidVPCId, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.InvalidVPCId
	if *v == nil {
		sv = &types.InvalidVPCId{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentLastVPCAssociation(v **types.LastVPCAssociation, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LastVPCAssociation
	if *v == nil {
		sv = &types.LastVPCAssociation{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentLimitsExceeded(v **types.LimitsExceeded, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LimitsExceeded
	if *v == nil {
		sv = &types.LimitsExceeded{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentLinkedService(v **types.LinkedService, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.LinkedService
	if *v == nil {
		sv = &types.LinkedService{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Description", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Description = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Description = &xtv
			}

		case strings.EqualFold("ServicePrincipal", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ServicePrincipal = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ServicePrincipal = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchChange(v **types.NoSuchChange, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchChange
	if *v == nil {
		sv = &types.NoSuchChange{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchCloudWatchLogsLogGroup(v **types.NoSuchCloudWatchLogsLogGroup, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchCloudWatchLogsLogGroup
	if *v == nil {
		sv = &types.NoSuchCloudWatchLogsLogGroup{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchDelegationSet(v **types.NoSuchDelegationSet, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchDelegationSet
	if *v == nil {
		sv = &types.NoSuchDelegationSet{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchGeoLocation(v **types.NoSuchGeoLocation, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchGeoLocation
	if *v == nil {
		sv = &types.NoSuchGeoLocation{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchHealthCheck(v **types.NoSuchHealthCheck, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchHealthCheck
	if *v == nil {
		sv = &types.NoSuchHealthCheck{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchHostedZone(v **types.NoSuchHostedZone, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchHostedZone
	if *v == nil {
		sv = &types.NoSuchHostedZone{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchQueryLoggingConfig(v **types.NoSuchQueryLoggingConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchQueryLoggingConfig
	if *v == nil {
		sv = &types.NoSuchQueryLoggingConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchTrafficPolicy(v **types.NoSuchTrafficPolicy, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchTrafficPolicy
	if *v == nil {
		sv = &types.NoSuchTrafficPolicy{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNoSuchTrafficPolicyInstance(v **types.NoSuchTrafficPolicyInstance, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NoSuchTrafficPolicyInstance
	if *v == nil {
		sv = &types.NoSuchTrafficPolicyInstance{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentNotAuthorizedException(v **types.NotAuthorizedException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.NotAuthorizedException
	if *v == nil {
		sv = &types.NotAuthorizedException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentPriorRequestNotComplete(v **types.PriorRequestNotComplete, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.PriorRequestNotComplete
	if *v == nil {
		sv = &types.PriorRequestNotComplete{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentPublicZoneVPCAssociation(v **types.PublicZoneVPCAssociation, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.PublicZoneVPCAssociation
	if *v == nil {
		sv = &types.PublicZoneVPCAssociation{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentQueryLoggingConfig(v **types.QueryLoggingConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.QueryLoggingConfig
	if *v == nil {
		sv = &types.QueryLoggingConfig{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("CloudWatchLogsLogGroupArn", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.CloudWatchLogsLogGroupArn = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.CloudWatchLogsLogGroupArn = &xtv
			}

		case strings.EqualFold("HostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneId = &xtv
			}

		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentQueryLoggingConfigAlreadyExists(v **types.QueryLoggingConfigAlreadyExists, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.QueryLoggingConfigAlreadyExists
	if *v == nil {
		sv = &types.QueryLoggingConfigAlreadyExists{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentQueryLoggingConfigs(v *[]*types.QueryLoggingConfig, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.QueryLoggingConfig
	if *v == nil {
		sv = make([]*types.QueryLoggingConfig, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("QueryLoggingConfig", t.Name.Local) {
				var col *types.QueryLoggingConfig
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentQueryLoggingConfig(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentQueryLoggingConfigsUnwrapped(v *[]*types.QueryLoggingConfig, decoder smithyxml.NodeDecoder) error {
	var sv []*types.QueryLoggingConfig
	if *v == nil {
		sv = make([]*types.QueryLoggingConfig, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.QueryLoggingConfig
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentQueryLoggingConfig(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentRecordData(v *[]*string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		for {
			if strings.EqualFold("RecordDataEntry", t.Name.Local) {
				var col *string
				val, done, err := decoder.Value()
				if err != nil {
					return err
				}
				if done {
					if val == nil {
						col = ptr.String("")
					}
					break
				}
				if val != nil {
					xtv := string(val)
					col = &xtv
				}
				sv = append(sv, col)
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentRecordDataUnwrapped(v *[]*string, decoder smithyxml.NodeDecoder) error {
	var sv []*string
	if *v == nil {
		sv = make([]*string, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *string
		t := decoder.StartEl
		_ = t
		val, done, err := decoder.Value()
		if err != nil {
			return err
		}
		if done {
			if val == nil {
				mv = ptr.String("")
			}
			break
		}
		if val != nil {
			xtv := string(val)
			mv = &xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentResourceRecord(v **types.ResourceRecord, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ResourceRecord
	if *v == nil {
		sv = &types.ResourceRecord{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Value = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Value = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentResourceRecords(v *[]*types.ResourceRecord, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.ResourceRecord
	if *v == nil {
		sv = make([]*types.ResourceRecord, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("ResourceRecord", t.Name.Local) {
				var col *types.ResourceRecord
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentResourceRecord(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentResourceRecordsUnwrapped(v *[]*types.ResourceRecord, decoder smithyxml.NodeDecoder) error {
	var sv []*types.ResourceRecord
	if *v == nil {
		sv = make([]*types.ResourceRecord, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.ResourceRecord
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentResourceRecord(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentResourceRecordSet(v **types.ResourceRecordSet, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ResourceRecordSet
	if *v == nil {
		sv = &types.ResourceRecordSet{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("AliasTarget", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentAliasTarget(&sv.AliasTarget, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("Failover", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Failover = types.ResourceRecordSetFailover(xtv)
			}

		case strings.EqualFold("GeoLocation", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentGeoLocation(&sv.GeoLocation, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("HealthCheckId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HealthCheckId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HealthCheckId = &xtv
			}

		case strings.EqualFold("MultiValueAnswer", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv, err := strconv.ParseBool(string(val))
				if err != nil {
					return fmt.Errorf("expected ResourceRecordSetMultiValueAnswer to be of type *bool, got %T instead", val)
				}
				sv.MultiValueAnswer = &xtv
			}

		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("Region", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Region = types.ResourceRecordSetRegion(xtv)
			}

		case strings.EqualFold("ResourceRecords", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentResourceRecords(&sv.ResourceRecords, nodeDecoder); err != nil {
				return err
			}

		case strings.EqualFold("SetIdentifier", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.SetIdentifier = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.SetIdentifier = &xtv
			}

		case strings.EqualFold("TrafficPolicyInstanceId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TrafficPolicyInstanceId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyInstanceId = &xtv
			}

		case strings.EqualFold("TTL", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.TTL = &i64
			}

		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.RRType(xtv)
			}

		case strings.EqualFold("Weight", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Weight = &i64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentResourceRecordSets(v *[]*types.ResourceRecordSet, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.ResourceRecordSet
	if *v == nil {
		sv = make([]*types.ResourceRecordSet, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("ResourceRecordSet", t.Name.Local) {
				var col *types.ResourceRecordSet
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentResourceRecordSet(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentResourceRecordSetsUnwrapped(v *[]*types.ResourceRecordSet, decoder smithyxml.NodeDecoder) error {
	var sv []*types.ResourceRecordSet
	if *v == nil {
		sv = make([]*types.ResourceRecordSet, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.ResourceRecordSet
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentResourceRecordSet(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentResourceTagSet(v **types.ResourceTagSet, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ResourceTagSet
	if *v == nil {
		sv = &types.ResourceTagSet{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("ResourceId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.ResourceId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ResourceId = &xtv
			}

		case strings.EqualFold("ResourceType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.ResourceType = types.TagResourceType(xtv)
			}

		case strings.EqualFold("Tags", t.Name.Local):
			nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
			if err := awsRestxml_deserializeDocumentTagList(&sv.Tags, nodeDecoder); err != nil {
				return err
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentResourceTagSetList(v *[]*types.ResourceTagSet, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.ResourceTagSet
	if *v == nil {
		sv = make([]*types.ResourceTagSet, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("ResourceTagSet", t.Name.Local) {
				var col *types.ResourceTagSet
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentResourceTagSet(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentResourceTagSetListUnwrapped(v *[]*types.ResourceTagSet, decoder smithyxml.NodeDecoder) error {
	var sv []*types.ResourceTagSet
	if *v == nil {
		sv = make([]*types.ResourceTagSet, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.ResourceTagSet
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentResourceTagSet(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentReusableDelegationSetLimit(v **types.ReusableDelegationSetLimit, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ReusableDelegationSetLimit
	if *v == nil {
		sv = &types.ReusableDelegationSetLimit{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.ReusableDelegationSetLimitType(xtv)
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Value = &i64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentStatusReport(v **types.StatusReport, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.StatusReport
	if *v == nil {
		sv = &types.StatusReport{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("CheckedTime", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				t, err := smithytime.ParseDateTime(xtv)
				if err != nil {
					return err
				}
				sv.CheckedTime = &t
			}

		case strings.EqualFold("Status", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Status = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Status = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTag(v **types.Tag, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Tag
	if *v == nil {
		sv = &types.Tag{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Key", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Key = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Key = &xtv
			}

		case strings.EqualFold("Value", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Value = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Value = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTagList(v *[]*types.Tag, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.Tag
	if *v == nil {
		sv = make([]*types.Tag, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("Tag", t.Name.Local) {
				var col *types.Tag
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentTag(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTagListUnwrapped(v *[]*types.Tag, decoder smithyxml.NodeDecoder) error {
	var sv []*types.Tag
	if *v == nil {
		sv = make([]*types.Tag, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.Tag
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentTag(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentThrottlingException(v **types.ThrottlingException, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ThrottlingException
	if *v == nil {
		sv = &types.ThrottlingException{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTooManyHealthChecks(v **types.TooManyHealthChecks, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyHealthChecks
	if *v == nil {
		sv = &types.TooManyHealthChecks{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTooManyHostedZones(v **types.TooManyHostedZones, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyHostedZones
	if *v == nil {
		sv = &types.TooManyHostedZones{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTooManyTrafficPolicies(v **types.TooManyTrafficPolicies, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyTrafficPolicies
	if *v == nil {
		sv = &types.TooManyTrafficPolicies{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTooManyTrafficPolicyInstances(v **types.TooManyTrafficPolicyInstances, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyTrafficPolicyInstances
	if *v == nil {
		sv = &types.TooManyTrafficPolicyInstances{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTooManyTrafficPolicyVersionsForCurrentPolicy(v **types.TooManyTrafficPolicyVersionsForCurrentPolicy, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyTrafficPolicyVersionsForCurrentPolicy
	if *v == nil {
		sv = &types.TooManyTrafficPolicyVersionsForCurrentPolicy{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTooManyVPCAssociationAuthorizations(v **types.TooManyVPCAssociationAuthorizations, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TooManyVPCAssociationAuthorizations
	if *v == nil {
		sv = &types.TooManyVPCAssociationAuthorizations{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPolicies(v *[]*types.TrafficPolicy, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.TrafficPolicy
	if *v == nil {
		sv = make([]*types.TrafficPolicy, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("TrafficPolicy", t.Name.Local) {
				var col *types.TrafficPolicy
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentTrafficPolicy(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPoliciesUnwrapped(v *[]*types.TrafficPolicy, decoder smithyxml.NodeDecoder) error {
	var sv []*types.TrafficPolicy
	if *v == nil {
		sv = make([]*types.TrafficPolicy, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.TrafficPolicy
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentTrafficPolicy(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentTrafficPolicy(v **types.TrafficPolicy, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TrafficPolicy
	if *v == nil {
		sv = &types.TrafficPolicy{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Comment", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Comment = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Comment = &xtv
			}

		case strings.EqualFold("Document", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Document = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Document = &xtv
			}

		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.RRType(xtv)
			}

		case strings.EqualFold("Version", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.Version = ptr.Int32(int32(i64))
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPolicyAlreadyExists(v **types.TrafficPolicyAlreadyExists, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TrafficPolicyAlreadyExists
	if *v == nil {
		sv = &types.TrafficPolicyAlreadyExists{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPolicyInstance(v **types.TrafficPolicyInstance, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TrafficPolicyInstance
	if *v == nil {
		sv = &types.TrafficPolicyInstance{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("HostedZoneId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.HostedZoneId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.HostedZoneId = &xtv
			}

		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		case strings.EqualFold("Message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("State", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.State = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.State = &xtv
			}

		case strings.EqualFold("TrafficPolicyId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.TrafficPolicyId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyId = &xtv
			}

		case strings.EqualFold("TrafficPolicyType", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.TrafficPolicyType = types.RRType(xtv)
			}

		case strings.EqualFold("TrafficPolicyVersion", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.TrafficPolicyVersion = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("TTL", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.TTL = &i64
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPolicyInstanceAlreadyExists(v **types.TrafficPolicyInstanceAlreadyExists, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TrafficPolicyInstanceAlreadyExists
	if *v == nil {
		sv = &types.TrafficPolicyInstanceAlreadyExists{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPolicyInstances(v *[]*types.TrafficPolicyInstance, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.TrafficPolicyInstance
	if *v == nil {
		sv = make([]*types.TrafficPolicyInstance, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("TrafficPolicyInstance", t.Name.Local) {
				var col *types.TrafficPolicyInstance
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentTrafficPolicyInstance(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPolicyInstancesUnwrapped(v *[]*types.TrafficPolicyInstance, decoder smithyxml.NodeDecoder) error {
	var sv []*types.TrafficPolicyInstance
	if *v == nil {
		sv = make([]*types.TrafficPolicyInstance, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.TrafficPolicyInstance
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentTrafficPolicyInstance(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentTrafficPolicyInUse(v **types.TrafficPolicyInUse, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TrafficPolicyInUse
	if *v == nil {
		sv = &types.TrafficPolicyInUse{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPolicySummaries(v *[]*types.TrafficPolicySummary, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.TrafficPolicySummary
	if *v == nil {
		sv = make([]*types.TrafficPolicySummary, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("TrafficPolicySummary", t.Name.Local) {
				var col *types.TrafficPolicySummary
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentTrafficPolicySummary(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentTrafficPolicySummariesUnwrapped(v *[]*types.TrafficPolicySummary, decoder smithyxml.NodeDecoder) error {
	var sv []*types.TrafficPolicySummary
	if *v == nil {
		sv = make([]*types.TrafficPolicySummary, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.TrafficPolicySummary
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentTrafficPolicySummary(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsRestxml_deserializeDocumentTrafficPolicySummary(v **types.TrafficPolicySummary, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.TrafficPolicySummary
	if *v == nil {
		sv = &types.TrafficPolicySummary{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("Id", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Id = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Id = &xtv
			}

		case strings.EqualFold("LatestVersion", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.LatestVersion = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("Name", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Name = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Name = &xtv
			}

		case strings.EqualFold("TrafficPolicyCount", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				i64, err := strconv.ParseInt(xtv, 10, 64)
				if err != nil {
					return err
				}
				sv.TrafficPolicyCount = ptr.Int32(int32(i64))
			}

		case strings.EqualFold("Type", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Type = types.RRType(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentVPC(v **types.VPC, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.VPC
	if *v == nil {
		sv = &types.VPC{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("VPCId", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.VPCId = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.VPCId = &xtv
			}

		case strings.EqualFold("VPCRegion", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				break
			}
			if val != nil {
				xtv := string(val)
				sv.VPCRegion = types.VPCRegion(xtv)
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentVPCAssociationAuthorizationNotFound(v **types.VPCAssociationAuthorizationNotFound, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.VPCAssociationAuthorizationNotFound
	if *v == nil {
		sv = &types.VPCAssociationAuthorizationNotFound{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentVPCAssociationNotFound(v **types.VPCAssociationNotFound, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.VPCAssociationNotFound
	if *v == nil {
		sv = &types.VPCAssociationNotFound{}
	} else {
		sv = *v
	}

	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
		case strings.EqualFold("message", t.Name.Local):
			val, done, err := decoder.Value()
			if err != nil {
				return err
			}
			if done {
				if val == nil {
					sv.Message = ptr.String("")
				}
				break
			}
			if val != nil {
				xtv := string(val)
				sv.Message = &xtv
			}

		default:
			// Do nothing and ignore the unexpected tag element

		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentVPCs(v *[]*types.VPC, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []*types.VPC
	if *v == nil {
		sv = make([]*types.VPC, 0)
	} else {
		sv = *v
	}

	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil {
			return err
		}
		if done {
			break
		}
		for {
			if strings.EqualFold("VPC", t.Name.Local) {
				var col *types.VPC
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsRestxml_deserializeDocumentVPC(&col, nodeDecoder); err != nil {
					return err
				}
				sv = append(sv, col)
				break
			} else {
				break
			}
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsRestxml_deserializeDocumentVPCsUnwrapped(v *[]*types.VPC, decoder smithyxml.NodeDecoder) error {
	var sv []*types.VPC
	if *v == nil {
		sv = make([]*types.VPC, 0)
	} else {
		sv = *v
	}

	switch {
	default:
		var mv *types.VPC
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		if err := awsRestxml_deserializeDocumentVPC(&mv, nodeDecoder); err != nil {
			return err
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
