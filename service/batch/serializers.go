// Code generated by smithy-go-codegen DO NOT EDIT.

package batch

import (
	"bytes"
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/batch/types"
	smithy "github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/httpbinding"
	smithyjson "github.com/awslabs/smithy-go/json"
	"github.com/awslabs/smithy-go/middleware"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
)

type awsRestjson1_serializeOpCancelJob struct {
}

func (*awsRestjson1_serializeOpCancelJob) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCancelJob) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CancelJobInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/canceljob")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentCancelJobInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsCancelJobInput(v *CancelJobInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentCancelJobInput(v *CancelJobInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.JobId != nil {
		ok := object.Key("jobId")
		ok.String(*v.JobId)
	}

	if v.Reason != nil {
		ok := object.Key("reason")
		ok.String(*v.Reason)
	}

	return nil
}

type awsRestjson1_serializeOpCreateComputeEnvironment struct {
}

func (*awsRestjson1_serializeOpCreateComputeEnvironment) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateComputeEnvironment) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateComputeEnvironmentInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/createcomputeenvironment")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentCreateComputeEnvironmentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsCreateComputeEnvironmentInput(v *CreateComputeEnvironmentInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentCreateComputeEnvironmentInput(v *CreateComputeEnvironmentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ComputeEnvironmentName != nil {
		ok := object.Key("computeEnvironmentName")
		ok.String(*v.ComputeEnvironmentName)
	}

	if v.ComputeResources != nil {
		ok := object.Key("computeResources")
		if err := awsRestjson1_serializeDocumentComputeResource(v.ComputeResources, ok); err != nil {
			return err
		}
	}

	if v.ServiceRole != nil {
		ok := object.Key("serviceRole")
		ok.String(*v.ServiceRole)
	}

	if len(v.State) > 0 {
		ok := object.Key("state")
		ok.String(string(v.State))
	}

	if len(v.Type) > 0 {
		ok := object.Key("type")
		ok.String(string(v.Type))
	}

	return nil
}

type awsRestjson1_serializeOpCreateJobQueue struct {
}

func (*awsRestjson1_serializeOpCreateJobQueue) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpCreateJobQueue) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateJobQueueInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/createjobqueue")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentCreateJobQueueInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsCreateJobQueueInput(v *CreateJobQueueInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentCreateJobQueueInput(v *CreateJobQueueInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ComputeEnvironmentOrder != nil {
		ok := object.Key("computeEnvironmentOrder")
		if err := awsRestjson1_serializeDocumentComputeEnvironmentOrders(v.ComputeEnvironmentOrder, ok); err != nil {
			return err
		}
	}

	if v.JobQueueName != nil {
		ok := object.Key("jobQueueName")
		ok.String(*v.JobQueueName)
	}

	if v.Priority != nil {
		ok := object.Key("priority")
		ok.Integer(*v.Priority)
	}

	if len(v.State) > 0 {
		ok := object.Key("state")
		ok.String(string(v.State))
	}

	return nil
}

type awsRestjson1_serializeOpDeleteComputeEnvironment struct {
}

func (*awsRestjson1_serializeOpDeleteComputeEnvironment) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteComputeEnvironment) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteComputeEnvironmentInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/deletecomputeenvironment")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDeleteComputeEnvironmentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDeleteComputeEnvironmentInput(v *DeleteComputeEnvironmentInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDeleteComputeEnvironmentInput(v *DeleteComputeEnvironmentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ComputeEnvironment != nil {
		ok := object.Key("computeEnvironment")
		ok.String(*v.ComputeEnvironment)
	}

	return nil
}

type awsRestjson1_serializeOpDeleteJobQueue struct {
}

func (*awsRestjson1_serializeOpDeleteJobQueue) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeleteJobQueue) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteJobQueueInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/deletejobqueue")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDeleteJobQueueInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDeleteJobQueueInput(v *DeleteJobQueueInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDeleteJobQueueInput(v *DeleteJobQueueInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.JobQueue != nil {
		ok := object.Key("jobQueue")
		ok.String(*v.JobQueue)
	}

	return nil
}

type awsRestjson1_serializeOpDeregisterJobDefinition struct {
}

func (*awsRestjson1_serializeOpDeregisterJobDefinition) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDeregisterJobDefinition) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeregisterJobDefinitionInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/deregisterjobdefinition")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDeregisterJobDefinitionInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDeregisterJobDefinitionInput(v *DeregisterJobDefinitionInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDeregisterJobDefinitionInput(v *DeregisterJobDefinitionInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.JobDefinition != nil {
		ok := object.Key("jobDefinition")
		ok.String(*v.JobDefinition)
	}

	return nil
}

type awsRestjson1_serializeOpDescribeComputeEnvironments struct {
}

func (*awsRestjson1_serializeOpDescribeComputeEnvironments) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeComputeEnvironments) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeComputeEnvironmentsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/describecomputeenvironments")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDescribeComputeEnvironmentsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeComputeEnvironmentsInput(v *DescribeComputeEnvironmentsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDescribeComputeEnvironmentsInput(v *DescribeComputeEnvironmentsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ComputeEnvironments != nil {
		ok := object.Key("computeEnvironments")
		if err := awsRestjson1_serializeDocumentStringList(v.ComputeEnvironments, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpDescribeJobDefinitions struct {
}

func (*awsRestjson1_serializeOpDescribeJobDefinitions) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeJobDefinitions) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeJobDefinitionsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/describejobdefinitions")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDescribeJobDefinitionsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeJobDefinitionsInput(v *DescribeJobDefinitionsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDescribeJobDefinitionsInput(v *DescribeJobDefinitionsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.JobDefinitionName != nil {
		ok := object.Key("jobDefinitionName")
		ok.String(*v.JobDefinitionName)
	}

	if v.JobDefinitions != nil {
		ok := object.Key("jobDefinitions")
		if err := awsRestjson1_serializeDocumentStringList(v.JobDefinitions, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	if v.Status != nil {
		ok := object.Key("status")
		ok.String(*v.Status)
	}

	return nil
}

type awsRestjson1_serializeOpDescribeJobQueues struct {
}

func (*awsRestjson1_serializeOpDescribeJobQueues) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeJobQueues) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeJobQueuesInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/describejobqueues")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDescribeJobQueuesInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeJobQueuesInput(v *DescribeJobQueuesInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDescribeJobQueuesInput(v *DescribeJobQueuesInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.JobQueues != nil {
		ok := object.Key("jobQueues")
		if err := awsRestjson1_serializeDocumentStringList(v.JobQueues, ok); err != nil {
			return err
		}
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpDescribeJobs struct {
}

func (*awsRestjson1_serializeOpDescribeJobs) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpDescribeJobs) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeJobsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/describejobs")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentDescribeJobsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsDescribeJobsInput(v *DescribeJobsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentDescribeJobsInput(v *DescribeJobsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Jobs != nil {
		ok := object.Key("jobs")
		if err := awsRestjson1_serializeDocumentStringList(v.Jobs, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpListJobs struct {
}

func (*awsRestjson1_serializeOpListJobs) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpListJobs) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListJobsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/listjobs")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentListJobsInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsListJobsInput(v *ListJobsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentListJobsInput(v *ListJobsInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ArrayJobId != nil {
		ok := object.Key("arrayJobId")
		ok.String(*v.ArrayJobId)
	}

	if v.JobQueue != nil {
		ok := object.Key("jobQueue")
		ok.String(*v.JobQueue)
	}

	if len(v.JobStatus) > 0 {
		ok := object.Key("jobStatus")
		ok.String(string(v.JobStatus))
	}

	if v.MaxResults != nil {
		ok := object.Key("maxResults")
		ok.Integer(*v.MaxResults)
	}

	if v.MultiNodeJobId != nil {
		ok := object.Key("multiNodeJobId")
		ok.String(*v.MultiNodeJobId)
	}

	if v.NextToken != nil {
		ok := object.Key("nextToken")
		ok.String(*v.NextToken)
	}

	return nil
}

type awsRestjson1_serializeOpRegisterJobDefinition struct {
}

func (*awsRestjson1_serializeOpRegisterJobDefinition) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpRegisterJobDefinition) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*RegisterJobDefinitionInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/registerjobdefinition")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentRegisterJobDefinitionInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsRegisterJobDefinitionInput(v *RegisterJobDefinitionInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentRegisterJobDefinitionInput(v *RegisterJobDefinitionInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ContainerProperties != nil {
		ok := object.Key("containerProperties")
		if err := awsRestjson1_serializeDocumentContainerProperties(v.ContainerProperties, ok); err != nil {
			return err
		}
	}

	if v.JobDefinitionName != nil {
		ok := object.Key("jobDefinitionName")
		ok.String(*v.JobDefinitionName)
	}

	if v.NodeProperties != nil {
		ok := object.Key("nodeProperties")
		if err := awsRestjson1_serializeDocumentNodeProperties(v.NodeProperties, ok); err != nil {
			return err
		}
	}

	if v.Parameters != nil {
		ok := object.Key("parameters")
		if err := awsRestjson1_serializeDocumentParametersMap(v.Parameters, ok); err != nil {
			return err
		}
	}

	if v.RetryStrategy != nil {
		ok := object.Key("retryStrategy")
		if err := awsRestjson1_serializeDocumentRetryStrategy(v.RetryStrategy, ok); err != nil {
			return err
		}
	}

	if v.Timeout != nil {
		ok := object.Key("timeout")
		if err := awsRestjson1_serializeDocumentJobTimeout(v.Timeout, ok); err != nil {
			return err
		}
	}

	if len(v.Type) > 0 {
		ok := object.Key("type")
		ok.String(string(v.Type))
	}

	return nil
}

type awsRestjson1_serializeOpSubmitJob struct {
}

func (*awsRestjson1_serializeOpSubmitJob) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpSubmitJob) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*SubmitJobInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/submitjob")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentSubmitJobInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsSubmitJobInput(v *SubmitJobInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentSubmitJobInput(v *SubmitJobInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ArrayProperties != nil {
		ok := object.Key("arrayProperties")
		if err := awsRestjson1_serializeDocumentArrayProperties(v.ArrayProperties, ok); err != nil {
			return err
		}
	}

	if v.ContainerOverrides != nil {
		ok := object.Key("containerOverrides")
		if err := awsRestjson1_serializeDocumentContainerOverrides(v.ContainerOverrides, ok); err != nil {
			return err
		}
	}

	if v.DependsOn != nil {
		ok := object.Key("dependsOn")
		if err := awsRestjson1_serializeDocumentJobDependencyList(v.DependsOn, ok); err != nil {
			return err
		}
	}

	if v.JobDefinition != nil {
		ok := object.Key("jobDefinition")
		ok.String(*v.JobDefinition)
	}

	if v.JobName != nil {
		ok := object.Key("jobName")
		ok.String(*v.JobName)
	}

	if v.JobQueue != nil {
		ok := object.Key("jobQueue")
		ok.String(*v.JobQueue)
	}

	if v.NodeOverrides != nil {
		ok := object.Key("nodeOverrides")
		if err := awsRestjson1_serializeDocumentNodeOverrides(v.NodeOverrides, ok); err != nil {
			return err
		}
	}

	if v.Parameters != nil {
		ok := object.Key("parameters")
		if err := awsRestjson1_serializeDocumentParametersMap(v.Parameters, ok); err != nil {
			return err
		}
	}

	if v.RetryStrategy != nil {
		ok := object.Key("retryStrategy")
		if err := awsRestjson1_serializeDocumentRetryStrategy(v.RetryStrategy, ok); err != nil {
			return err
		}
	}

	if v.Timeout != nil {
		ok := object.Key("timeout")
		if err := awsRestjson1_serializeDocumentJobTimeout(v.Timeout, ok); err != nil {
			return err
		}
	}

	return nil
}

type awsRestjson1_serializeOpTerminateJob struct {
}

func (*awsRestjson1_serializeOpTerminateJob) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpTerminateJob) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*TerminateJobInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/terminatejob")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentTerminateJobInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsTerminateJobInput(v *TerminateJobInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentTerminateJobInput(v *TerminateJobInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.JobId != nil {
		ok := object.Key("jobId")
		ok.String(*v.JobId)
	}

	if v.Reason != nil {
		ok := object.Key("reason")
		ok.String(*v.Reason)
	}

	return nil
}

type awsRestjson1_serializeOpUpdateComputeEnvironment struct {
}

func (*awsRestjson1_serializeOpUpdateComputeEnvironment) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateComputeEnvironment) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateComputeEnvironmentInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/updatecomputeenvironment")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentUpdateComputeEnvironmentInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsUpdateComputeEnvironmentInput(v *UpdateComputeEnvironmentInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentUpdateComputeEnvironmentInput(v *UpdateComputeEnvironmentInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ComputeEnvironment != nil {
		ok := object.Key("computeEnvironment")
		ok.String(*v.ComputeEnvironment)
	}

	if v.ComputeResources != nil {
		ok := object.Key("computeResources")
		if err := awsRestjson1_serializeDocumentComputeResourceUpdate(v.ComputeResources, ok); err != nil {
			return err
		}
	}

	if v.ServiceRole != nil {
		ok := object.Key("serviceRole")
		ok.String(*v.ServiceRole)
	}

	if len(v.State) > 0 {
		ok := object.Key("state")
		ok.String(string(v.State))
	}

	return nil
}

type awsRestjson1_serializeOpUpdateJobQueue struct {
}

func (*awsRestjson1_serializeOpUpdateJobQueue) ID() string {
	return "OperationSerializer"
}

func (m *awsRestjson1_serializeOpUpdateJobQueue) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateJobQueueInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v1/updatejobqueue")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/json")

	jsonEncoder := smithyjson.NewEncoder()
	if err := awsRestjson1_serializeDocumentUpdateJobQueueInput(input, jsonEncoder.Value); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request, err = request.SetStream(bytes.NewReader(jsonEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestjson1_serializeHttpBindingsUpdateJobQueueInput(v *UpdateJobQueueInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	return nil
}

func awsRestjson1_serializeDocumentUpdateJobQueueInput(v *UpdateJobQueueInput, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ComputeEnvironmentOrder != nil {
		ok := object.Key("computeEnvironmentOrder")
		if err := awsRestjson1_serializeDocumentComputeEnvironmentOrders(v.ComputeEnvironmentOrder, ok); err != nil {
			return err
		}
	}

	if v.JobQueue != nil {
		ok := object.Key("jobQueue")
		ok.String(*v.JobQueue)
	}

	if v.Priority != nil {
		ok := object.Key("priority")
		ok.Integer(*v.Priority)
	}

	if len(v.State) > 0 {
		ok := object.Key("state")
		ok.String(string(v.State))
	}

	return nil
}

func awsRestjson1_serializeDocumentArrayProperties(v *types.ArrayProperties, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Size != nil {
		ok := object.Key("size")
		ok.Integer(*v.Size)
	}

	return nil
}

func awsRestjson1_serializeDocumentComputeEnvironmentOrder(v *types.ComputeEnvironmentOrder, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ComputeEnvironment != nil {
		ok := object.Key("computeEnvironment")
		ok.String(*v.ComputeEnvironment)
	}

	if v.Order != nil {
		ok := object.Key("order")
		ok.Integer(*v.Order)
	}

	return nil
}

func awsRestjson1_serializeDocumentComputeEnvironmentOrders(v []*types.ComputeEnvironmentOrder, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentComputeEnvironmentOrder(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentComputeResource(v *types.ComputeResource, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.AllocationStrategy) > 0 {
		ok := object.Key("allocationStrategy")
		ok.String(string(v.AllocationStrategy))
	}

	if v.BidPercentage != nil {
		ok := object.Key("bidPercentage")
		ok.Integer(*v.BidPercentage)
	}

	if v.DesiredvCpus != nil {
		ok := object.Key("desiredvCpus")
		ok.Integer(*v.DesiredvCpus)
	}

	if v.Ec2KeyPair != nil {
		ok := object.Key("ec2KeyPair")
		ok.String(*v.Ec2KeyPair)
	}

	if v.ImageId != nil {
		ok := object.Key("imageId")
		ok.String(*v.ImageId)
	}

	if v.InstanceRole != nil {
		ok := object.Key("instanceRole")
		ok.String(*v.InstanceRole)
	}

	if v.InstanceTypes != nil {
		ok := object.Key("instanceTypes")
		if err := awsRestjson1_serializeDocumentStringList(v.InstanceTypes, ok); err != nil {
			return err
		}
	}

	if v.LaunchTemplate != nil {
		ok := object.Key("launchTemplate")
		if err := awsRestjson1_serializeDocumentLaunchTemplateSpecification(v.LaunchTemplate, ok); err != nil {
			return err
		}
	}

	if v.MaxvCpus != nil {
		ok := object.Key("maxvCpus")
		ok.Integer(*v.MaxvCpus)
	}

	if v.MinvCpus != nil {
		ok := object.Key("minvCpus")
		ok.Integer(*v.MinvCpus)
	}

	if v.PlacementGroup != nil {
		ok := object.Key("placementGroup")
		ok.String(*v.PlacementGroup)
	}

	if v.SecurityGroupIds != nil {
		ok := object.Key("securityGroupIds")
		if err := awsRestjson1_serializeDocumentStringList(v.SecurityGroupIds, ok); err != nil {
			return err
		}
	}

	if v.SpotIamFleetRole != nil {
		ok := object.Key("spotIamFleetRole")
		ok.String(*v.SpotIamFleetRole)
	}

	if v.Subnets != nil {
		ok := object.Key("subnets")
		if err := awsRestjson1_serializeDocumentStringList(v.Subnets, ok); err != nil {
			return err
		}
	}

	if v.Tags != nil {
		ok := object.Key("tags")
		if err := awsRestjson1_serializeDocumentTagsMap(v.Tags, ok); err != nil {
			return err
		}
	}

	if len(v.Type) > 0 {
		ok := object.Key("type")
		ok.String(string(v.Type))
	}

	return nil
}

func awsRestjson1_serializeDocumentComputeResourceUpdate(v *types.ComputeResourceUpdate, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.DesiredvCpus != nil {
		ok := object.Key("desiredvCpus")
		ok.Integer(*v.DesiredvCpus)
	}

	if v.MaxvCpus != nil {
		ok := object.Key("maxvCpus")
		ok.Integer(*v.MaxvCpus)
	}

	if v.MinvCpus != nil {
		ok := object.Key("minvCpus")
		ok.Integer(*v.MinvCpus)
	}

	return nil
}

func awsRestjson1_serializeDocumentContainerOverrides(v *types.ContainerOverrides, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Command != nil {
		ok := object.Key("command")
		if err := awsRestjson1_serializeDocumentStringList(v.Command, ok); err != nil {
			return err
		}
	}

	if v.Environment != nil {
		ok := object.Key("environment")
		if err := awsRestjson1_serializeDocumentEnvironmentVariables(v.Environment, ok); err != nil {
			return err
		}
	}

	if v.InstanceType != nil {
		ok := object.Key("instanceType")
		ok.String(*v.InstanceType)
	}

	if v.Memory != nil {
		ok := object.Key("memory")
		ok.Integer(*v.Memory)
	}

	if v.ResourceRequirements != nil {
		ok := object.Key("resourceRequirements")
		if err := awsRestjson1_serializeDocumentResourceRequirements(v.ResourceRequirements, ok); err != nil {
			return err
		}
	}

	if v.Vcpus != nil {
		ok := object.Key("vcpus")
		ok.Integer(*v.Vcpus)
	}

	return nil
}

func awsRestjson1_serializeDocumentContainerProperties(v *types.ContainerProperties, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Command != nil {
		ok := object.Key("command")
		if err := awsRestjson1_serializeDocumentStringList(v.Command, ok); err != nil {
			return err
		}
	}

	if v.Environment != nil {
		ok := object.Key("environment")
		if err := awsRestjson1_serializeDocumentEnvironmentVariables(v.Environment, ok); err != nil {
			return err
		}
	}

	if v.Image != nil {
		ok := object.Key("image")
		ok.String(*v.Image)
	}

	if v.InstanceType != nil {
		ok := object.Key("instanceType")
		ok.String(*v.InstanceType)
	}

	if v.JobRoleArn != nil {
		ok := object.Key("jobRoleArn")
		ok.String(*v.JobRoleArn)
	}

	if v.LinuxParameters != nil {
		ok := object.Key("linuxParameters")
		if err := awsRestjson1_serializeDocumentLinuxParameters(v.LinuxParameters, ok); err != nil {
			return err
		}
	}

	if v.Memory != nil {
		ok := object.Key("memory")
		ok.Integer(*v.Memory)
	}

	if v.MountPoints != nil {
		ok := object.Key("mountPoints")
		if err := awsRestjson1_serializeDocumentMountPoints(v.MountPoints, ok); err != nil {
			return err
		}
	}

	if v.Privileged != nil {
		ok := object.Key("privileged")
		ok.Boolean(*v.Privileged)
	}

	if v.ReadonlyRootFilesystem != nil {
		ok := object.Key("readonlyRootFilesystem")
		ok.Boolean(*v.ReadonlyRootFilesystem)
	}

	if v.ResourceRequirements != nil {
		ok := object.Key("resourceRequirements")
		if err := awsRestjson1_serializeDocumentResourceRequirements(v.ResourceRequirements, ok); err != nil {
			return err
		}
	}

	if v.Ulimits != nil {
		ok := object.Key("ulimits")
		if err := awsRestjson1_serializeDocumentUlimits(v.Ulimits, ok); err != nil {
			return err
		}
	}

	if v.User != nil {
		ok := object.Key("user")
		ok.String(*v.User)
	}

	if v.Vcpus != nil {
		ok := object.Key("vcpus")
		ok.Integer(*v.Vcpus)
	}

	if v.Volumes != nil {
		ok := object.Key("volumes")
		if err := awsRestjson1_serializeDocumentVolumes(v.Volumes, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentDevice(v *types.Device, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ContainerPath != nil {
		ok := object.Key("containerPath")
		ok.String(*v.ContainerPath)
	}

	if v.HostPath != nil {
		ok := object.Key("hostPath")
		ok.String(*v.HostPath)
	}

	if v.Permissions != nil {
		ok := object.Key("permissions")
		if err := awsRestjson1_serializeDocumentDeviceCgroupPermissions(v.Permissions, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentDeviceCgroupPermissions(v []types.DeviceCgroupPermission, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		av.String(string(v[i]))
	}
	return nil
}

func awsRestjson1_serializeDocumentDevicesList(v []*types.Device, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentDevice(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentEnvironmentVariables(v []*types.KeyValuePair, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentKeyValuePair(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentHost(v *types.Host, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.SourcePath != nil {
		ok := object.Key("sourcePath")
		ok.String(*v.SourcePath)
	}

	return nil
}

func awsRestjson1_serializeDocumentJobDependency(v *types.JobDependency, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.JobId != nil {
		ok := object.Key("jobId")
		ok.String(*v.JobId)
	}

	if len(v.Type) > 0 {
		ok := object.Key("type")
		ok.String(string(v.Type))
	}

	return nil
}

func awsRestjson1_serializeDocumentJobDependencyList(v []*types.JobDependency, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentJobDependency(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentJobTimeout(v *types.JobTimeout, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.AttemptDurationSeconds != nil {
		ok := object.Key("attemptDurationSeconds")
		ok.Integer(*v.AttemptDurationSeconds)
	}

	return nil
}

func awsRestjson1_serializeDocumentKeyValuePair(v *types.KeyValuePair, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Name != nil {
		ok := object.Key("name")
		ok.String(*v.Name)
	}

	if v.Value != nil {
		ok := object.Key("value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentLaunchTemplateSpecification(v *types.LaunchTemplateSpecification, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.LaunchTemplateId != nil {
		ok := object.Key("launchTemplateId")
		ok.String(*v.LaunchTemplateId)
	}

	if v.LaunchTemplateName != nil {
		ok := object.Key("launchTemplateName")
		ok.String(*v.LaunchTemplateName)
	}

	if v.Version != nil {
		ok := object.Key("version")
		ok.String(*v.Version)
	}

	return nil
}

func awsRestjson1_serializeDocumentLinuxParameters(v *types.LinuxParameters, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Devices != nil {
		ok := object.Key("devices")
		if err := awsRestjson1_serializeDocumentDevicesList(v.Devices, ok); err != nil {
			return err
		}
	}

	return nil
}

func awsRestjson1_serializeDocumentMountPoint(v *types.MountPoint, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ContainerPath != nil {
		ok := object.Key("containerPath")
		ok.String(*v.ContainerPath)
	}

	if v.ReadOnly != nil {
		ok := object.Key("readOnly")
		ok.Boolean(*v.ReadOnly)
	}

	if v.SourceVolume != nil {
		ok := object.Key("sourceVolume")
		ok.String(*v.SourceVolume)
	}

	return nil
}

func awsRestjson1_serializeDocumentMountPoints(v []*types.MountPoint, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentMountPoint(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentNodeOverrides(v *types.NodeOverrides, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.NodePropertyOverrides != nil {
		ok := object.Key("nodePropertyOverrides")
		if err := awsRestjson1_serializeDocumentNodePropertyOverrides(v.NodePropertyOverrides, ok); err != nil {
			return err
		}
	}

	if v.NumNodes != nil {
		ok := object.Key("numNodes")
		ok.Integer(*v.NumNodes)
	}

	return nil
}

func awsRestjson1_serializeDocumentNodeProperties(v *types.NodeProperties, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.MainNode != nil {
		ok := object.Key("mainNode")
		ok.Integer(*v.MainNode)
	}

	if v.NodeRangeProperties != nil {
		ok := object.Key("nodeRangeProperties")
		if err := awsRestjson1_serializeDocumentNodeRangeProperties(v.NodeRangeProperties, ok); err != nil {
			return err
		}
	}

	if v.NumNodes != nil {
		ok := object.Key("numNodes")
		ok.Integer(*v.NumNodes)
	}

	return nil
}

func awsRestjson1_serializeDocumentNodePropertyOverride(v *types.NodePropertyOverride, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.ContainerOverrides != nil {
		ok := object.Key("containerOverrides")
		if err := awsRestjson1_serializeDocumentContainerOverrides(v.ContainerOverrides, ok); err != nil {
			return err
		}
	}

	if v.TargetNodes != nil {
		ok := object.Key("targetNodes")
		ok.String(*v.TargetNodes)
	}

	return nil
}

func awsRestjson1_serializeDocumentNodePropertyOverrides(v []*types.NodePropertyOverride, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentNodePropertyOverride(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentNodeRangeProperties(v []*types.NodeRangeProperty, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentNodeRangeProperty(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentNodeRangeProperty(v *types.NodeRangeProperty, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Container != nil {
		ok := object.Key("container")
		if err := awsRestjson1_serializeDocumentContainerProperties(v.Container, ok); err != nil {
			return err
		}
	}

	if v.TargetNodes != nil {
		ok := object.Key("targetNodes")
		ok.String(*v.TargetNodes)
	}

	return nil
}

func awsRestjson1_serializeDocumentParametersMap(v map[string]*string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		if vv := v[key]; vv == nil {
			om.Null()
			continue
		}
		om.String(*v[key])
	}
	return nil
}

func awsRestjson1_serializeDocumentResourceRequirement(v *types.ResourceRequirement, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if len(v.Type) > 0 {
		ok := object.Key("type")
		ok.String(string(v.Type))
	}

	if v.Value != nil {
		ok := object.Key("value")
		ok.String(*v.Value)
	}

	return nil
}

func awsRestjson1_serializeDocumentResourceRequirements(v []*types.ResourceRequirement, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentResourceRequirement(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentRetryStrategy(v *types.RetryStrategy, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Attempts != nil {
		ok := object.Key("attempts")
		ok.Integer(*v.Attempts)
	}

	return nil
}

func awsRestjson1_serializeDocumentStringList(v []*string, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		av.String(*v[i])
	}
	return nil
}

func awsRestjson1_serializeDocumentTagsMap(v map[string]*string, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	for key := range v {
		om := object.Key(key)
		if vv := v[key]; vv == nil {
			om.Null()
			continue
		}
		om.String(*v[key])
	}
	return nil
}

func awsRestjson1_serializeDocumentUlimit(v *types.Ulimit, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.HardLimit != nil {
		ok := object.Key("hardLimit")
		ok.Integer(*v.HardLimit)
	}

	if v.Name != nil {
		ok := object.Key("name")
		ok.String(*v.Name)
	}

	if v.SoftLimit != nil {
		ok := object.Key("softLimit")
		ok.Integer(*v.SoftLimit)
	}

	return nil
}

func awsRestjson1_serializeDocumentUlimits(v []*types.Ulimit, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentUlimit(v[i], av); err != nil {
			return err
		}
	}
	return nil
}

func awsRestjson1_serializeDocumentVolume(v *types.Volume, value smithyjson.Value) error {
	object := value.Object()
	defer object.Close()

	if v.Host != nil {
		ok := object.Key("host")
		if err := awsRestjson1_serializeDocumentHost(v.Host, ok); err != nil {
			return err
		}
	}

	if v.Name != nil {
		ok := object.Key("name")
		ok.String(*v.Name)
	}

	return nil
}

func awsRestjson1_serializeDocumentVolumes(v []*types.Volume, value smithyjson.Value) error {
	array := value.Array()
	defer array.Close()

	for i := range v {
		av := array.Value()
		if vv := v[i]; vv == nil {
			av.Null()
			continue
		}
		if err := awsRestjson1_serializeDocumentVolume(v[i], av); err != nil {
			return err
		}
	}
	return nil
}
