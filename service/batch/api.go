// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package batch

import (
	"fmt"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

const opCancelJob = "CancelJob"

// CancelJobRequest is a API request type for the CancelJob API operation.
type CancelJobRequest struct {
	*aws.Request
	Input *CancelJobInput
	Copy  func(*CancelJobInput) CancelJobRequest
}

// Send marshals and sends the CancelJob API request.
func (r CancelJobRequest) Send() (*CancelJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CancelJobOutput), nil
}

// CancelJobRequest returns a request value for making API operation for
// AWS Batch.
//
// Cancels a job in an AWS Batch job queue. Jobs that are in the SUBMITTED,
// PENDING, or RUNNABLE state are cancelled. Jobs that have progressed to STARTING
// or RUNNING are not cancelled (but the API operation still succeeds, even
// if no job is cancelled); these jobs must be terminated with the TerminateJob
// operation.
//
//    // Example sending a request using the CancelJobRequest method.
//    req := client.CancelJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CancelJob
func (c *Batch) CancelJobRequest(input *CancelJobInput) CancelJobRequest {
	op := &aws.Operation{
		Name:       opCancelJob,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/canceljob",
	}

	if input == nil {
		input = &CancelJobInput{}
	}

	output := &CancelJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CancelJobRequest{Request: req, Input: input, Copy: c.CancelJobRequest}
}

const opCreateComputeEnvironment = "CreateComputeEnvironment"

// CreateComputeEnvironmentRequest is a API request type for the CreateComputeEnvironment API operation.
type CreateComputeEnvironmentRequest struct {
	*aws.Request
	Input *CreateComputeEnvironmentInput
	Copy  func(*CreateComputeEnvironmentInput) CreateComputeEnvironmentRequest
}

// Send marshals and sends the CreateComputeEnvironment API request.
func (r CreateComputeEnvironmentRequest) Send() (*CreateComputeEnvironmentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateComputeEnvironmentOutput), nil
}

// CreateComputeEnvironmentRequest returns a request value for making API operation for
// AWS Batch.
//
// Creates an AWS Batch compute environment. You can create MANAGED or UNMANAGED
// compute environments.
//
// In a managed compute environment, AWS Batch manages the compute resources
// within the environment, based on the compute resources that you specify.
// Instances launched into a managed compute environment use a recent, approved
// version of the Amazon ECS-optimized AMI. You can choose to use Amazon EC2
// On-Demand Instances in your managed compute environment, or you can use Amazon
// EC2 Spot Instances that only launch when the Spot bid price is below a specified
// percentage of the On-Demand price.
//
// In an unmanaged compute environment, you can manage your own compute resources.
// This provides more compute resource configuration options, such as using
// a custom AMI, but you must ensure that your AMI meets the Amazon ECS container
// instance AMI specification. For more information, see Container Instance
// AMIs (http://docs.aws.amazon.com/AmazonECS/latest/developerguide/container_instance_AMIs.html)
// in the Amazon Elastic Container Service Developer Guide. After you have created
// your unmanaged compute environment, you can use the DescribeComputeEnvironments
// operation to find the Amazon ECS cluster that is associated with it and then
// manually launch your container instances into that Amazon ECS cluster. For
// more information, see Launching an Amazon ECS Container Instance (http://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html)
// in the Amazon Elastic Container Service Developer Guide.
//
//    // Example sending a request using the CreateComputeEnvironmentRequest method.
//    req := client.CreateComputeEnvironmentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CreateComputeEnvironment
func (c *Batch) CreateComputeEnvironmentRequest(input *CreateComputeEnvironmentInput) CreateComputeEnvironmentRequest {
	op := &aws.Operation{
		Name:       opCreateComputeEnvironment,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/createcomputeenvironment",
	}

	if input == nil {
		input = &CreateComputeEnvironmentInput{}
	}

	output := &CreateComputeEnvironmentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateComputeEnvironmentRequest{Request: req, Input: input, Copy: c.CreateComputeEnvironmentRequest}
}

const opCreateJobQueue = "CreateJobQueue"

// CreateJobQueueRequest is a API request type for the CreateJobQueue API operation.
type CreateJobQueueRequest struct {
	*aws.Request
	Input *CreateJobQueueInput
	Copy  func(*CreateJobQueueInput) CreateJobQueueRequest
}

// Send marshals and sends the CreateJobQueue API request.
func (r CreateJobQueueRequest) Send() (*CreateJobQueueOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateJobQueueOutput), nil
}

// CreateJobQueueRequest returns a request value for making API operation for
// AWS Batch.
//
// Creates an AWS Batch job queue. When you create a job queue, you associate
// one or more compute environments to the queue and assign an order of preference
// for the compute environments.
//
// You also set a priority to the job queue that determines the order in which
// the AWS Batch scheduler places jobs onto its associated compute environments.
// For example, if a compute environment is associated with more than one job
// queue, the job queue with a higher priority is given preference for scheduling
// jobs to that compute environment.
//
//    // Example sending a request using the CreateJobQueueRequest method.
//    req := client.CreateJobQueueRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CreateJobQueue
func (c *Batch) CreateJobQueueRequest(input *CreateJobQueueInput) CreateJobQueueRequest {
	op := &aws.Operation{
		Name:       opCreateJobQueue,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/createjobqueue",
	}

	if input == nil {
		input = &CreateJobQueueInput{}
	}

	output := &CreateJobQueueOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateJobQueueRequest{Request: req, Input: input, Copy: c.CreateJobQueueRequest}
}

const opDeleteComputeEnvironment = "DeleteComputeEnvironment"

// DeleteComputeEnvironmentRequest is a API request type for the DeleteComputeEnvironment API operation.
type DeleteComputeEnvironmentRequest struct {
	*aws.Request
	Input *DeleteComputeEnvironmentInput
	Copy  func(*DeleteComputeEnvironmentInput) DeleteComputeEnvironmentRequest
}

// Send marshals and sends the DeleteComputeEnvironment API request.
func (r DeleteComputeEnvironmentRequest) Send() (*DeleteComputeEnvironmentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteComputeEnvironmentOutput), nil
}

// DeleteComputeEnvironmentRequest returns a request value for making API operation for
// AWS Batch.
//
// Deletes an AWS Batch compute environment.
//
// Before you can delete a compute environment, you must set its state to DISABLED
// with the UpdateComputeEnvironment API operation and disassociate it from
// any job queues with the UpdateJobQueue API operation.
//
//    // Example sending a request using the DeleteComputeEnvironmentRequest method.
//    req := client.DeleteComputeEnvironmentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeleteComputeEnvironment
func (c *Batch) DeleteComputeEnvironmentRequest(input *DeleteComputeEnvironmentInput) DeleteComputeEnvironmentRequest {
	op := &aws.Operation{
		Name:       opDeleteComputeEnvironment,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/deletecomputeenvironment",
	}

	if input == nil {
		input = &DeleteComputeEnvironmentInput{}
	}

	output := &DeleteComputeEnvironmentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteComputeEnvironmentRequest{Request: req, Input: input, Copy: c.DeleteComputeEnvironmentRequest}
}

const opDeleteJobQueue = "DeleteJobQueue"

// DeleteJobQueueRequest is a API request type for the DeleteJobQueue API operation.
type DeleteJobQueueRequest struct {
	*aws.Request
	Input *DeleteJobQueueInput
	Copy  func(*DeleteJobQueueInput) DeleteJobQueueRequest
}

// Send marshals and sends the DeleteJobQueue API request.
func (r DeleteJobQueueRequest) Send() (*DeleteJobQueueOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteJobQueueOutput), nil
}

// DeleteJobQueueRequest returns a request value for making API operation for
// AWS Batch.
//
// Deletes the specified job queue. You must first disable submissions for a
// queue with the UpdateJobQueue operation. All jobs in the queue are terminated
// when you delete a job queue.
//
// It is not necessary to disassociate compute environments from a queue before
// submitting a DeleteJobQueue request.
//
//    // Example sending a request using the DeleteJobQueueRequest method.
//    req := client.DeleteJobQueueRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeleteJobQueue
func (c *Batch) DeleteJobQueueRequest(input *DeleteJobQueueInput) DeleteJobQueueRequest {
	op := &aws.Operation{
		Name:       opDeleteJobQueue,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/deletejobqueue",
	}

	if input == nil {
		input = &DeleteJobQueueInput{}
	}

	output := &DeleteJobQueueOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteJobQueueRequest{Request: req, Input: input, Copy: c.DeleteJobQueueRequest}
}

const opDeregisterJobDefinition = "DeregisterJobDefinition"

// DeregisterJobDefinitionRequest is a API request type for the DeregisterJobDefinition API operation.
type DeregisterJobDefinitionRequest struct {
	*aws.Request
	Input *DeregisterJobDefinitionInput
	Copy  func(*DeregisterJobDefinitionInput) DeregisterJobDefinitionRequest
}

// Send marshals and sends the DeregisterJobDefinition API request.
func (r DeregisterJobDefinitionRequest) Send() (*DeregisterJobDefinitionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeregisterJobDefinitionOutput), nil
}

// DeregisterJobDefinitionRequest returns a request value for making API operation for
// AWS Batch.
//
// Deregisters an AWS Batch job definition.
//
//    // Example sending a request using the DeregisterJobDefinitionRequest method.
//    req := client.DeregisterJobDefinitionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeregisterJobDefinition
func (c *Batch) DeregisterJobDefinitionRequest(input *DeregisterJobDefinitionInput) DeregisterJobDefinitionRequest {
	op := &aws.Operation{
		Name:       opDeregisterJobDefinition,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/deregisterjobdefinition",
	}

	if input == nil {
		input = &DeregisterJobDefinitionInput{}
	}

	output := &DeregisterJobDefinitionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeregisterJobDefinitionRequest{Request: req, Input: input, Copy: c.DeregisterJobDefinitionRequest}
}

const opDescribeComputeEnvironments = "DescribeComputeEnvironments"

// DescribeComputeEnvironmentsRequest is a API request type for the DescribeComputeEnvironments API operation.
type DescribeComputeEnvironmentsRequest struct {
	*aws.Request
	Input *DescribeComputeEnvironmentsInput
	Copy  func(*DescribeComputeEnvironmentsInput) DescribeComputeEnvironmentsRequest
}

// Send marshals and sends the DescribeComputeEnvironments API request.
func (r DescribeComputeEnvironmentsRequest) Send() (*DescribeComputeEnvironmentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeComputeEnvironmentsOutput), nil
}

// DescribeComputeEnvironmentsRequest returns a request value for making API operation for
// AWS Batch.
//
// Describes one or more of your compute environments.
//
// If you are using an unmanaged compute environment, you can use the DescribeComputeEnvironment
// operation to determine the ecsClusterArn that you should launch your Amazon
// ECS container instances into.
//
//    // Example sending a request using the DescribeComputeEnvironmentsRequest method.
//    req := client.DescribeComputeEnvironmentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeComputeEnvironments
func (c *Batch) DescribeComputeEnvironmentsRequest(input *DescribeComputeEnvironmentsInput) DescribeComputeEnvironmentsRequest {
	op := &aws.Operation{
		Name:       opDescribeComputeEnvironments,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/describecomputeenvironments",
	}

	if input == nil {
		input = &DescribeComputeEnvironmentsInput{}
	}

	output := &DescribeComputeEnvironmentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeComputeEnvironmentsRequest{Request: req, Input: input, Copy: c.DescribeComputeEnvironmentsRequest}
}

const opDescribeJobDefinitions = "DescribeJobDefinitions"

// DescribeJobDefinitionsRequest is a API request type for the DescribeJobDefinitions API operation.
type DescribeJobDefinitionsRequest struct {
	*aws.Request
	Input *DescribeJobDefinitionsInput
	Copy  func(*DescribeJobDefinitionsInput) DescribeJobDefinitionsRequest
}

// Send marshals and sends the DescribeJobDefinitions API request.
func (r DescribeJobDefinitionsRequest) Send() (*DescribeJobDefinitionsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeJobDefinitionsOutput), nil
}

// DescribeJobDefinitionsRequest returns a request value for making API operation for
// AWS Batch.
//
// Describes a list of job definitions. You can specify a status (such as ACTIVE)
// to only return job definitions that match that status.
//
//    // Example sending a request using the DescribeJobDefinitionsRequest method.
//    req := client.DescribeJobDefinitionsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobDefinitions
func (c *Batch) DescribeJobDefinitionsRequest(input *DescribeJobDefinitionsInput) DescribeJobDefinitionsRequest {
	op := &aws.Operation{
		Name:       opDescribeJobDefinitions,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/describejobdefinitions",
	}

	if input == nil {
		input = &DescribeJobDefinitionsInput{}
	}

	output := &DescribeJobDefinitionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeJobDefinitionsRequest{Request: req, Input: input, Copy: c.DescribeJobDefinitionsRequest}
}

const opDescribeJobQueues = "DescribeJobQueues"

// DescribeJobQueuesRequest is a API request type for the DescribeJobQueues API operation.
type DescribeJobQueuesRequest struct {
	*aws.Request
	Input *DescribeJobQueuesInput
	Copy  func(*DescribeJobQueuesInput) DescribeJobQueuesRequest
}

// Send marshals and sends the DescribeJobQueues API request.
func (r DescribeJobQueuesRequest) Send() (*DescribeJobQueuesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeJobQueuesOutput), nil
}

// DescribeJobQueuesRequest returns a request value for making API operation for
// AWS Batch.
//
// Describes one or more of your job queues.
//
//    // Example sending a request using the DescribeJobQueuesRequest method.
//    req := client.DescribeJobQueuesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobQueues
func (c *Batch) DescribeJobQueuesRequest(input *DescribeJobQueuesInput) DescribeJobQueuesRequest {
	op := &aws.Operation{
		Name:       opDescribeJobQueues,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/describejobqueues",
	}

	if input == nil {
		input = &DescribeJobQueuesInput{}
	}

	output := &DescribeJobQueuesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeJobQueuesRequest{Request: req, Input: input, Copy: c.DescribeJobQueuesRequest}
}

const opDescribeJobs = "DescribeJobs"

// DescribeJobsRequest is a API request type for the DescribeJobs API operation.
type DescribeJobsRequest struct {
	*aws.Request
	Input *DescribeJobsInput
	Copy  func(*DescribeJobsInput) DescribeJobsRequest
}

// Send marshals and sends the DescribeJobs API request.
func (r DescribeJobsRequest) Send() (*DescribeJobsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeJobsOutput), nil
}

// DescribeJobsRequest returns a request value for making API operation for
// AWS Batch.
//
// Describes a list of AWS Batch jobs.
//
//    // Example sending a request using the DescribeJobsRequest method.
//    req := client.DescribeJobsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobs
func (c *Batch) DescribeJobsRequest(input *DescribeJobsInput) DescribeJobsRequest {
	op := &aws.Operation{
		Name:       opDescribeJobs,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/describejobs",
	}

	if input == nil {
		input = &DescribeJobsInput{}
	}

	output := &DescribeJobsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeJobsRequest{Request: req, Input: input, Copy: c.DescribeJobsRequest}
}

const opListJobs = "ListJobs"

// ListJobsRequest is a API request type for the ListJobs API operation.
type ListJobsRequest struct {
	*aws.Request
	Input *ListJobsInput
	Copy  func(*ListJobsInput) ListJobsRequest
}

// Send marshals and sends the ListJobs API request.
func (r ListJobsRequest) Send() (*ListJobsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListJobsOutput), nil
}

// ListJobsRequest returns a request value for making API operation for
// AWS Batch.
//
// Returns a list of task jobs for a specified job queue. You can filter the
// results by job status with the jobStatus parameter. If you do not specify
// a status, only RUNNING jobs are returned.
//
//    // Example sending a request using the ListJobsRequest method.
//    req := client.ListJobsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ListJobs
func (c *Batch) ListJobsRequest(input *ListJobsInput) ListJobsRequest {
	op := &aws.Operation{
		Name:       opListJobs,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/listjobs",
	}

	if input == nil {
		input = &ListJobsInput{}
	}

	output := &ListJobsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListJobsRequest{Request: req, Input: input, Copy: c.ListJobsRequest}
}

const opRegisterJobDefinition = "RegisterJobDefinition"

// RegisterJobDefinitionRequest is a API request type for the RegisterJobDefinition API operation.
type RegisterJobDefinitionRequest struct {
	*aws.Request
	Input *RegisterJobDefinitionInput
	Copy  func(*RegisterJobDefinitionInput) RegisterJobDefinitionRequest
}

// Send marshals and sends the RegisterJobDefinition API request.
func (r RegisterJobDefinitionRequest) Send() (*RegisterJobDefinitionOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RegisterJobDefinitionOutput), nil
}

// RegisterJobDefinitionRequest returns a request value for making API operation for
// AWS Batch.
//
// Registers an AWS Batch job definition.
//
//    // Example sending a request using the RegisterJobDefinitionRequest method.
//    req := client.RegisterJobDefinitionRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/RegisterJobDefinition
func (c *Batch) RegisterJobDefinitionRequest(input *RegisterJobDefinitionInput) RegisterJobDefinitionRequest {
	op := &aws.Operation{
		Name:       opRegisterJobDefinition,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/registerjobdefinition",
	}

	if input == nil {
		input = &RegisterJobDefinitionInput{}
	}

	output := &RegisterJobDefinitionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RegisterJobDefinitionRequest{Request: req, Input: input, Copy: c.RegisterJobDefinitionRequest}
}

const opSubmitJob = "SubmitJob"

// SubmitJobRequest is a API request type for the SubmitJob API operation.
type SubmitJobRequest struct {
	*aws.Request
	Input *SubmitJobInput
	Copy  func(*SubmitJobInput) SubmitJobRequest
}

// Send marshals and sends the SubmitJob API request.
func (r SubmitJobRequest) Send() (*SubmitJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*SubmitJobOutput), nil
}

// SubmitJobRequest returns a request value for making API operation for
// AWS Batch.
//
// Submits an AWS Batch job from a job definition. Parameters specified during
// SubmitJob override parameters defined in the job definition.
//
//    // Example sending a request using the SubmitJobRequest method.
//    req := client.SubmitJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/SubmitJob
func (c *Batch) SubmitJobRequest(input *SubmitJobInput) SubmitJobRequest {
	op := &aws.Operation{
		Name:       opSubmitJob,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/submitjob",
	}

	if input == nil {
		input = &SubmitJobInput{}
	}

	output := &SubmitJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return SubmitJobRequest{Request: req, Input: input, Copy: c.SubmitJobRequest}
}

const opTerminateJob = "TerminateJob"

// TerminateJobRequest is a API request type for the TerminateJob API operation.
type TerminateJobRequest struct {
	*aws.Request
	Input *TerminateJobInput
	Copy  func(*TerminateJobInput) TerminateJobRequest
}

// Send marshals and sends the TerminateJob API request.
func (r TerminateJobRequest) Send() (*TerminateJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TerminateJobOutput), nil
}

// TerminateJobRequest returns a request value for making API operation for
// AWS Batch.
//
// Terminates a job in a job queue. Jobs that are in the STARTING or RUNNING
// state are terminated, which causes them to transition to FAILED. Jobs that
// have not progressed to the STARTING state are cancelled.
//
//    // Example sending a request using the TerminateJobRequest method.
//    req := client.TerminateJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/TerminateJob
func (c *Batch) TerminateJobRequest(input *TerminateJobInput) TerminateJobRequest {
	op := &aws.Operation{
		Name:       opTerminateJob,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/terminatejob",
	}

	if input == nil {
		input = &TerminateJobInput{}
	}

	output := &TerminateJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TerminateJobRequest{Request: req, Input: input, Copy: c.TerminateJobRequest}
}

const opUpdateComputeEnvironment = "UpdateComputeEnvironment"

// UpdateComputeEnvironmentRequest is a API request type for the UpdateComputeEnvironment API operation.
type UpdateComputeEnvironmentRequest struct {
	*aws.Request
	Input *UpdateComputeEnvironmentInput
	Copy  func(*UpdateComputeEnvironmentInput) UpdateComputeEnvironmentRequest
}

// Send marshals and sends the UpdateComputeEnvironment API request.
func (r UpdateComputeEnvironmentRequest) Send() (*UpdateComputeEnvironmentOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateComputeEnvironmentOutput), nil
}

// UpdateComputeEnvironmentRequest returns a request value for making API operation for
// AWS Batch.
//
// Updates an AWS Batch compute environment.
//
//    // Example sending a request using the UpdateComputeEnvironmentRequest method.
//    req := client.UpdateComputeEnvironmentRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/UpdateComputeEnvironment
func (c *Batch) UpdateComputeEnvironmentRequest(input *UpdateComputeEnvironmentInput) UpdateComputeEnvironmentRequest {
	op := &aws.Operation{
		Name:       opUpdateComputeEnvironment,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/updatecomputeenvironment",
	}

	if input == nil {
		input = &UpdateComputeEnvironmentInput{}
	}

	output := &UpdateComputeEnvironmentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateComputeEnvironmentRequest{Request: req, Input: input, Copy: c.UpdateComputeEnvironmentRequest}
}

const opUpdateJobQueue = "UpdateJobQueue"

// UpdateJobQueueRequest is a API request type for the UpdateJobQueue API operation.
type UpdateJobQueueRequest struct {
	*aws.Request
	Input *UpdateJobQueueInput
	Copy  func(*UpdateJobQueueInput) UpdateJobQueueRequest
}

// Send marshals and sends the UpdateJobQueue API request.
func (r UpdateJobQueueRequest) Send() (*UpdateJobQueueOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateJobQueueOutput), nil
}

// UpdateJobQueueRequest returns a request value for making API operation for
// AWS Batch.
//
// Updates a job queue.
//
//    // Example sending a request using the UpdateJobQueueRequest method.
//    req := client.UpdateJobQueueRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/UpdateJobQueue
func (c *Batch) UpdateJobQueueRequest(input *UpdateJobQueueInput) UpdateJobQueueRequest {
	op := &aws.Operation{
		Name:       opUpdateJobQueue,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/updatejobqueue",
	}

	if input == nil {
		input = &UpdateJobQueueInput{}
	}

	output := &UpdateJobQueueOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateJobQueueRequest{Request: req, Input: input, Copy: c.UpdateJobQueueRequest}
}

// An object representing an AWS Batch array job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ArrayProperties
type ArrayProperties struct {
	_ struct{} `type:"structure"`

	// The size of the array job.
	Size *int64 `locationName:"size" type:"integer"`
}

// String returns the string representation
func (s ArrayProperties) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ArrayProperties) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ArrayProperties) MarshalFields(e protocol.FieldEncoder) error {
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "size", protocol.Int64Value(v), metadata)
	}
	return nil
}

// An object representing the array properties of a job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ArrayPropertiesDetail
type ArrayPropertiesDetail struct {
	_ struct{} `type:"structure"`

	// The job index within the array that is associated with this job. This parameter
	// is returned for array job children.
	Index *int64 `locationName:"index" type:"integer"`

	// The size of the array job. This parameter is returned for parent array jobs.
	Size *int64 `locationName:"size" type:"integer"`

	// A summary of the number of array job children in each available job status.
	// This parameter is returned for parent array jobs.
	StatusSummary map[string]int64 `locationName:"statusSummary" type:"map"`
}

// String returns the string representation
func (s ArrayPropertiesDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ArrayPropertiesDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ArrayPropertiesDetail) MarshalFields(e protocol.FieldEncoder) error {
	if s.Index != nil {
		v := *s.Index

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "index", protocol.Int64Value(v), metadata)
	}
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "size", protocol.Int64Value(v), metadata)
	}
	if len(s.StatusSummary) > 0 {
		v := s.StatusSummary

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "statusSummary", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.Int64Value(v1))
		}
		ms0.End()

	}
	return nil
}

// An object representing the array properties of a job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ArrayPropertiesSummary
type ArrayPropertiesSummary struct {
	_ struct{} `type:"structure"`

	// The job index within the array that is associated with this job. This parameter
	// is returned for children of array jobs.
	Index *int64 `locationName:"index" type:"integer"`

	// The size of the array job. This parameter is returned for parent array jobs.
	Size *int64 `locationName:"size" type:"integer"`
}

// String returns the string representation
func (s ArrayPropertiesSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ArrayPropertiesSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ArrayPropertiesSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.Index != nil {
		v := *s.Index

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "index", protocol.Int64Value(v), metadata)
	}
	if s.Size != nil {
		v := *s.Size

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "size", protocol.Int64Value(v), metadata)
	}
	return nil
}

// An object representing the details of a container that is part of a job attempt.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/AttemptContainerDetail
type AttemptContainerDetail struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the Amazon ECS container instance that
	// hosts the job attempt.
	ContainerInstanceArn *string `locationName:"containerInstanceArn" type:"string"`

	// The exit code for the job attempt. A non-zero exit code is considered a failure.
	ExitCode *int64 `locationName:"exitCode" type:"integer"`

	// The name of the CloudWatch Logs log stream associated with the container.
	// The log group for AWS Batch jobs is /aws/batch/job. Each container attempt
	// receives a log stream name when they reach the RUNNING status.
	LogStreamName *string `locationName:"logStreamName" type:"string"`

	// A short (255 max characters) human-readable string to provide additional
	// details about a running or stopped container.
	Reason *string `locationName:"reason" type:"string"`

	// The Amazon Resource Name (ARN) of the Amazon ECS task that is associated
	// with the job attempt. Each container attempt receives a task ARN when they
	// reach the STARTING status.
	TaskArn *string `locationName:"taskArn" type:"string"`
}

// String returns the string representation
func (s AttemptContainerDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttemptContainerDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttemptContainerDetail) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContainerInstanceArn != nil {
		v := *s.ContainerInstanceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "containerInstanceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ExitCode != nil {
		v := *s.ExitCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "exitCode", protocol.Int64Value(v), metadata)
	}
	if s.LogStreamName != nil {
		v := *s.LogStreamName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "logStreamName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Reason != nil {
		v := *s.Reason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "reason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TaskArn != nil {
		v := *s.TaskArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "taskArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// An object representing a job attempt.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/AttemptDetail
type AttemptDetail struct {
	_ struct{} `type:"structure"`

	// Details about the container in this job attempt.
	Container *AttemptContainerDetail `locationName:"container" type:"structure"`

	// The Unix time stamp (in seconds and milliseconds) for when the attempt was
	// started (when the attempt transitioned from the STARTING state to the RUNNING
	// state).
	StartedAt *int64 `locationName:"startedAt" type:"long"`

	// A short, human-readable string to provide additional details about the current
	// status of the job attempt.
	StatusReason *string `locationName:"statusReason" type:"string"`

	// The Unix time stamp (in seconds and milliseconds) for when the attempt was
	// stopped (when the attempt transitioned from the RUNNING state to a terminal
	// state, such as SUCCEEDED or FAILED).
	StoppedAt *int64 `locationName:"stoppedAt" type:"long"`
}

// String returns the string representation
func (s AttemptDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttemptDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AttemptDetail) MarshalFields(e protocol.FieldEncoder) error {
	if s.Container != nil {
		v := s.Container

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "container", v, metadata)
	}
	if s.StartedAt != nil {
		v := *s.StartedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startedAt", protocol.Int64Value(v), metadata)
	}
	if s.StatusReason != nil {
		v := *s.StatusReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StoppedAt != nil {
		v := *s.StoppedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stoppedAt", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CancelJobRequest
type CancelJobInput struct {
	_ struct{} `type:"structure"`

	// The AWS Batch job ID of the job to cancel.
	//
	// JobId is a required field
	JobId *string `locationName:"jobId" type:"string" required:"true"`

	// A message to attach to the job that explains the reason for canceling it.
	// This message is returned by future DescribeJobs operations on the job. This
	// message is also recorded in the AWS Batch activity logs.
	//
	// Reason is a required field
	Reason *string `locationName:"reason" type:"string" required:"true"`
}

// String returns the string representation
func (s CancelJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CancelJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CancelJobInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}

	if s.Reason == nil {
		invalidParams.Add(aws.NewErrParamRequired("Reason"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Reason != nil {
		v := *s.Reason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "reason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CancelJobResponse
type CancelJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CancelJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CancelJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// An object representing an AWS Batch compute environment.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ComputeEnvironmentDetail
type ComputeEnvironmentDetail struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the compute environment.
	//
	// ComputeEnvironmentArn is a required field
	ComputeEnvironmentArn *string `locationName:"computeEnvironmentArn" type:"string" required:"true"`

	// The name of the compute environment.
	//
	// ComputeEnvironmentName is a required field
	ComputeEnvironmentName *string `locationName:"computeEnvironmentName" type:"string" required:"true"`

	// The compute resources defined for the compute environment.
	ComputeResources *ComputeResource `locationName:"computeResources" type:"structure"`

	// The Amazon Resource Name (ARN) of the underlying Amazon ECS cluster used
	// by the compute environment.
	//
	// EcsClusterArn is a required field
	EcsClusterArn *string `locationName:"ecsClusterArn" type:"string" required:"true"`

	// The service role associated with the compute environment that allows AWS
	// Batch to make calls to AWS API operations on your behalf.
	ServiceRole *string `locationName:"serviceRole" type:"string"`

	// The state of the compute environment. The valid values are ENABLED or DISABLED.
	// An ENABLED state indicates that you can register instances with the compute
	// environment and that the associated instances can accept jobs.
	State CEState `locationName:"state" type:"string" enum:"true"`

	// The current status of the compute environment (for example, CREATING or VALID).
	Status CEStatus `locationName:"status" type:"string" enum:"true"`

	// A short, human-readable string to provide additional details about the current
	// status of the compute environment.
	StatusReason *string `locationName:"statusReason" type:"string"`

	// The type of the compute environment.
	Type CEType `locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s ComputeEnvironmentDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ComputeEnvironmentDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ComputeEnvironmentDetail) MarshalFields(e protocol.FieldEncoder) error {
	if s.ComputeEnvironmentArn != nil {
		v := *s.ComputeEnvironmentArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironmentArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ComputeEnvironmentName != nil {
		v := *s.ComputeEnvironmentName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironmentName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ComputeResources != nil {
		v := s.ComputeResources

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "computeResources", v, metadata)
	}
	if s.EcsClusterArn != nil {
		v := *s.EcsClusterArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ecsClusterArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ServiceRole != nil {
		v := *s.ServiceRole

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "serviceRole", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "state", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusReason != nil {
		v := *s.StatusReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The order in which compute environments are tried for job placement within
// a queue. Compute environments are tried in ascending order. For example,
// if two compute environments are associated with a job queue, the compute
// environment with a lower order integer value is tried for job placement first.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ComputeEnvironmentOrder
type ComputeEnvironmentOrder struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the compute environment.
	//
	// ComputeEnvironment is a required field
	ComputeEnvironment *string `locationName:"computeEnvironment" type:"string" required:"true"`

	// The order of the compute environment.
	//
	// Order is a required field
	Order *int64 `locationName:"order" type:"integer" required:"true"`
}

// String returns the string representation
func (s ComputeEnvironmentOrder) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ComputeEnvironmentOrder) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ComputeEnvironmentOrder) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ComputeEnvironmentOrder"}

	if s.ComputeEnvironment == nil {
		invalidParams.Add(aws.NewErrParamRequired("ComputeEnvironment"))
	}

	if s.Order == nil {
		invalidParams.Add(aws.NewErrParamRequired("Order"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ComputeEnvironmentOrder) MarshalFields(e protocol.FieldEncoder) error {
	if s.ComputeEnvironment != nil {
		v := *s.ComputeEnvironment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironment", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Order != nil {
		v := *s.Order

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "order", protocol.Int64Value(v), metadata)
	}
	return nil
}

// An object representing an AWS Batch compute resource.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ComputeResource
type ComputeResource struct {
	_ struct{} `type:"structure"`

	// The minimum percentage that a Spot Instance price must be when compared with
	// the On-Demand price for that instance type before instances are launched.
	// For example, if your bid percentage is 20%, then the Spot price must be below
	// 20% of the current On-Demand price for that EC2 instance.
	BidPercentage *int64 `locationName:"bidPercentage" type:"integer"`

	// The desired number of EC2 vCPUS in the compute environment.
	DesiredvCpus *int64 `locationName:"desiredvCpus" type:"integer"`

	// The EC2 key pair that is used for instances launched in the compute environment.
	Ec2KeyPair *string `locationName:"ec2KeyPair" type:"string"`

	// The Amazon Machine Image (AMI) ID used for instances launched in the compute
	// environment.
	ImageId *string `locationName:"imageId" type:"string"`

	// The Amazon ECS instance profile applied to Amazon EC2 instances in a compute
	// environment. You can specify the short name or full Amazon Resource Name
	// (ARN) of an instance profile. For example, ecsInstanceRole or arn:aws:iam::<aws_account_id>:instance-profile/ecsInstanceRole.
	// For more information, see Amazon ECS Instance Role (http://docs.aws.amazon.com/batch/latest/userguide/instance_IAM_role.html)
	// in the AWS Batch User Guide.
	//
	// InstanceRole is a required field
	InstanceRole *string `locationName:"instanceRole" type:"string" required:"true"`

	// The instances types that may be launched. You can specify instance families
	// to launch any instance type within those families (for example, c4 or p3),
	// or you can specify specific sizes within a family (such as c4.8xlarge). You
	// can also choose optimal to pick instance types (from the latest C, M, and
	// R instance families) on the fly that match the demand of your job queues.
	//
	// InstanceTypes is a required field
	InstanceTypes []string `locationName:"instanceTypes" type:"list" required:"true"`

	// The maximum number of EC2 vCPUs that an environment can reach.
	//
	// MaxvCpus is a required field
	MaxvCpus *int64 `locationName:"maxvCpus" type:"integer" required:"true"`

	// The minimum number of EC2 vCPUs that an environment should maintain.
	//
	// MinvCpus is a required field
	MinvCpus *int64 `locationName:"minvCpus" type:"integer" required:"true"`

	// The EC2 security group that is associated with instances launched in the
	// compute environment.
	//
	// SecurityGroupIds is a required field
	SecurityGroupIds []string `locationName:"securityGroupIds" type:"list" required:"true"`

	// The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied
	// to a SPOT compute environment.
	SpotIamFleetRole *string `locationName:"spotIamFleetRole" type:"string"`

	// The VPC subnets into which the compute resources are launched.
	//
	// Subnets is a required field
	Subnets []string `locationName:"subnets" type:"list" required:"true"`

	// Key-value pair tags to be applied to resources that are launched in the compute
	// environment.
	Tags map[string]string `locationName:"tags" type:"map"`

	// The type of compute environment.
	//
	// Type is a required field
	Type CRType `locationName:"type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s ComputeResource) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ComputeResource) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ComputeResource) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ComputeResource"}

	if s.InstanceRole == nil {
		invalidParams.Add(aws.NewErrParamRequired("InstanceRole"))
	}

	if s.InstanceTypes == nil {
		invalidParams.Add(aws.NewErrParamRequired("InstanceTypes"))
	}

	if s.MaxvCpus == nil {
		invalidParams.Add(aws.NewErrParamRequired("MaxvCpus"))
	}

	if s.MinvCpus == nil {
		invalidParams.Add(aws.NewErrParamRequired("MinvCpus"))
	}

	if s.SecurityGroupIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("SecurityGroupIds"))
	}

	if s.Subnets == nil {
		invalidParams.Add(aws.NewErrParamRequired("Subnets"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ComputeResource) MarshalFields(e protocol.FieldEncoder) error {
	if s.BidPercentage != nil {
		v := *s.BidPercentage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "bidPercentage", protocol.Int64Value(v), metadata)
	}
	if s.DesiredvCpus != nil {
		v := *s.DesiredvCpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "desiredvCpus", protocol.Int64Value(v), metadata)
	}
	if s.Ec2KeyPair != nil {
		v := *s.Ec2KeyPair

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ec2KeyPair", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ImageId != nil {
		v := *s.ImageId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "imageId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.InstanceRole != nil {
		v := *s.InstanceRole

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "instanceRole", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.InstanceTypes) > 0 {
		v := s.InstanceTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "instanceTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.MaxvCpus != nil {
		v := *s.MaxvCpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxvCpus", protocol.Int64Value(v), metadata)
	}
	if s.MinvCpus != nil {
		v := *s.MinvCpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "minvCpus", protocol.Int64Value(v), metadata)
	}
	if len(s.SecurityGroupIds) > 0 {
		v := s.SecurityGroupIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "securityGroupIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.SpotIamFleetRole != nil {
		v := *s.SpotIamFleetRole

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "spotIamFleetRole", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Subnets) > 0 {
		v := s.Subnets

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "subnets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// An object representing the attributes of a compute environment that can be
// updated.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ComputeResourceUpdate
type ComputeResourceUpdate struct {
	_ struct{} `type:"structure"`

	// The desired number of EC2 vCPUS in the compute environment.
	DesiredvCpus *int64 `locationName:"desiredvCpus" type:"integer"`

	// The maximum number of EC2 vCPUs that an environment can reach.
	MaxvCpus *int64 `locationName:"maxvCpus" type:"integer"`

	// The minimum number of EC2 vCPUs that an environment should maintain.
	MinvCpus *int64 `locationName:"minvCpus" type:"integer"`
}

// String returns the string representation
func (s ComputeResourceUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ComputeResourceUpdate) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ComputeResourceUpdate) MarshalFields(e protocol.FieldEncoder) error {
	if s.DesiredvCpus != nil {
		v := *s.DesiredvCpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "desiredvCpus", protocol.Int64Value(v), metadata)
	}
	if s.MaxvCpus != nil {
		v := *s.MaxvCpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxvCpus", protocol.Int64Value(v), metadata)
	}
	if s.MinvCpus != nil {
		v := *s.MinvCpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "minvCpus", protocol.Int64Value(v), metadata)
	}
	return nil
}

// An object representing the details of a container that is part of a job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ContainerDetail
type ContainerDetail struct {
	_ struct{} `type:"structure"`

	// The command that is passed to the container.
	Command []string `locationName:"command" type:"list"`

	// The Amazon Resource Name (ARN) of the container instance on which the container
	// is running.
	ContainerInstanceArn *string `locationName:"containerInstanceArn" type:"string"`

	// The environment variables to pass to a container.
	//
	// Environment variables must not start with AWS_BATCH; this naming convention
	// is reserved for variables that are set by the AWS Batch service.
	Environment []KeyValuePair `locationName:"environment" type:"list"`

	// The exit code to return upon completion.
	ExitCode *int64 `locationName:"exitCode" type:"integer"`

	// The image used to start the container.
	Image *string `locationName:"image" type:"string"`

	// The Amazon Resource Name (ARN) associated with the job upon execution.
	JobRoleArn *string `locationName:"jobRoleArn" type:"string"`

	// The name of the CloudWatch Logs log stream associated with the container.
	// The log group for AWS Batch jobs is /aws/batch/job. Each container attempt
	// receives a log stream name when they reach the RUNNING status.
	LogStreamName *string `locationName:"logStreamName" type:"string"`

	// The number of MiB of memory reserved for the job.
	Memory *int64 `locationName:"memory" type:"integer"`

	// The mount points for data volumes in your container.
	MountPoints []MountPoint `locationName:"mountPoints" type:"list"`

	// When this parameter is true, the container is given elevated privileges on
	// the host container instance (similar to the root user).
	Privileged *bool `locationName:"privileged" type:"boolean"`

	// When this parameter is true, the container is given read-only access to its
	// root file system.
	ReadonlyRootFilesystem *bool `locationName:"readonlyRootFilesystem" type:"boolean"`

	// A short (255 max characters) human-readable string to provide additional
	// details about a running or stopped container.
	Reason *string `locationName:"reason" type:"string"`

	// The Amazon Resource Name (ARN) of the Amazon ECS task that is associated
	// with the container job. Each container attempt receives a task ARN when they
	// reach the STARTING status.
	TaskArn *string `locationName:"taskArn" type:"string"`

	// A list of ulimit values to set in the container.
	Ulimits []Ulimit `locationName:"ulimits" type:"list"`

	// The user name to use inside the container.
	User *string `locationName:"user" type:"string"`

	// The number of VCPUs allocated for the job.
	Vcpus *int64 `locationName:"vcpus" type:"integer"`

	// A list of volumes associated with the job.
	Volumes []Volume `locationName:"volumes" type:"list"`
}

// String returns the string representation
func (s ContainerDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContainerDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ContainerDetail) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Command) > 0 {
		v := s.Command

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "command", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ContainerInstanceArn != nil {
		v := *s.ContainerInstanceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "containerInstanceArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Environment) > 0 {
		v := s.Environment

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "environment", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ExitCode != nil {
		v := *s.ExitCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "exitCode", protocol.Int64Value(v), metadata)
	}
	if s.Image != nil {
		v := *s.Image

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "image", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobRoleArn != nil {
		v := *s.JobRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LogStreamName != nil {
		v := *s.LogStreamName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "logStreamName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Memory != nil {
		v := *s.Memory

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "memory", protocol.Int64Value(v), metadata)
	}
	if len(s.MountPoints) > 0 {
		v := s.MountPoints

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "mountPoints", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Privileged != nil {
		v := *s.Privileged

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "privileged", protocol.BoolValue(v), metadata)
	}
	if s.ReadonlyRootFilesystem != nil {
		v := *s.ReadonlyRootFilesystem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "readonlyRootFilesystem", protocol.BoolValue(v), metadata)
	}
	if s.Reason != nil {
		v := *s.Reason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "reason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TaskArn != nil {
		v := *s.TaskArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "taskArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Ulimits) > 0 {
		v := s.Ulimits

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ulimits", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.User != nil {
		v := *s.User

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "user", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Vcpus != nil {
		v := *s.Vcpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "vcpus", protocol.Int64Value(v), metadata)
	}
	if len(s.Volumes) > 0 {
		v := s.Volumes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "volumes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The overrides that should be sent to a container.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ContainerOverrides
type ContainerOverrides struct {
	_ struct{} `type:"structure"`

	// The command to send to the container that overrides the default command from
	// the Docker image or the job definition.
	Command []string `locationName:"command" type:"list"`

	// The environment variables to send to the container. You can add new environment
	// variables, which are added to the container at launch, or you can override
	// the existing environment variables from the Docker image or the job definition.
	//
	// Environment variables must not start with AWS_BATCH; this naming convention
	// is reserved for variables that are set by the AWS Batch service.
	Environment []KeyValuePair `locationName:"environment" type:"list"`

	// The number of MiB of memory reserved for the job. This value overrides the
	// value set in the job definition.
	Memory *int64 `locationName:"memory" type:"integer"`

	// The number of vCPUs to reserve for the container. This value overrides the
	// value set in the job definition.
	Vcpus *int64 `locationName:"vcpus" type:"integer"`
}

// String returns the string representation
func (s ContainerOverrides) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContainerOverrides) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ContainerOverrides) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Command) > 0 {
		v := s.Command

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "command", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Environment) > 0 {
		v := s.Environment

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "environment", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Memory != nil {
		v := *s.Memory

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "memory", protocol.Int64Value(v), metadata)
	}
	if s.Vcpus != nil {
		v := *s.Vcpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "vcpus", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Container properties are used in job definitions to describe the container
// that is launched as part of a job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ContainerProperties
type ContainerProperties struct {
	_ struct{} `type:"structure"`

	// The command that is passed to the container. This parameter maps to Cmd in
	// the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the COMMAND parameter to docker run (https://docs.docker.com/engine/reference/run/).
	// For more information, see https://docs.docker.com/engine/reference/builder/#cmd
	// (https://docs.docker.com/engine/reference/builder/#cmd).
	Command []string `locationName:"command" type:"list"`

	// The environment variables to pass to a container. This parameter maps to
	// Env in the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the --env option to docker run (https://docs.docker.com/engine/reference/run/).
	//
	// We do not recommend using plaintext environment variables for sensitive information,
	// such as credential data.
	//
	// Environment variables must not start with AWS_BATCH; this naming convention
	// is reserved for variables that are set by the AWS Batch service.
	Environment []KeyValuePair `locationName:"environment" type:"list"`

	// The image used to start a container. This string is passed directly to the
	// Docker daemon. Images in the Docker Hub registry are available by default.
	// Other repositories are specified with repository-url/image:tag. Up to 255
	// letters (uppercase and lowercase), numbers, hyphens, underscores, colons,
	// periods, forward slashes, and number signs are allowed. This parameter maps
	// to Image in the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the IMAGE parameter of docker run (https://docs.docker.com/engine/reference/run/).
	//
	//    * Images in Amazon ECR repositories use the full registry and repository
	//    URI (for example, 012345678910.dkr.ecr.<region-name>.amazonaws.com/<repository-name>).
	//
	//
	//    * Images in official repositories on Docker Hub use a single name (for
	//    example, ubuntu or mongo).
	//
	//    * Images in other repositories on Docker Hub are qualified with an organization
	//    name (for example, amazon/amazon-ecs-agent).
	//
	//    * Images in other online repositories are qualified further by a domain
	//    name (for example, quay.io/assemblyline/ubuntu).
	//
	// Image is a required field
	Image *string `locationName:"image" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) of the IAM role that the container can assume
	// for AWS permissions.
	JobRoleArn *string `locationName:"jobRoleArn" type:"string"`

	// The hard limit (in MiB) of memory to present to the container. If your container
	// attempts to exceed the memory specified here, the container is killed. This
	// parameter maps to Memory in the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the --memory option to docker run (https://docs.docker.com/engine/reference/run/).
	// You must specify at least 4 MiB of memory for a job.
	//
	// If you are trying to maximize your resource utilization by providing your
	// jobs as much memory as possible for a particular instance type, see Memory
	// Management (http://docs.aws.amazon.com/batch/latest/userguide/memory-management.html)
	// in the AWS Batch User Guide.
	//
	// Memory is a required field
	Memory *int64 `locationName:"memory" type:"integer" required:"true"`

	// The mount points for data volumes in your container. This parameter maps
	// to Volumes in the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the --volume option to docker run (https://docs.docker.com/engine/reference/run/).
	MountPoints []MountPoint `locationName:"mountPoints" type:"list"`

	// When this parameter is true, the container is given elevated privileges on
	// the host container instance (similar to the root user). This parameter maps
	// to Privileged in the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the --privileged option to docker run (https://docs.docker.com/engine/reference/run/).
	Privileged *bool `locationName:"privileged" type:"boolean"`

	// When this parameter is true, the container is given read-only access to its
	// root file system. This parameter maps to ReadonlyRootfs in the Create a container
	// (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the --read-only option to docker run.
	ReadonlyRootFilesystem *bool `locationName:"readonlyRootFilesystem" type:"boolean"`

	// A list of ulimits to set in the container. This parameter maps to Ulimits
	// in the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the --ulimit option to docker run (https://docs.docker.com/engine/reference/run/).
	Ulimits []Ulimit `locationName:"ulimits" type:"list"`

	// The user name to use inside the container. This parameter maps to User in
	// the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the --user option to docker run (https://docs.docker.com/engine/reference/run/).
	User *string `locationName:"user" type:"string"`

	// The number of vCPUs reserved for the container. This parameter maps to CpuShares
	// in the Create a container (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/#create-a-container)
	// section of the Docker Remote API (https://docs.docker.com/engine/reference/api/docker_remote_api_v1.23/)
	// and the --cpu-shares option to docker run (https://docs.docker.com/engine/reference/run/).
	// Each vCPU is equivalent to 1,024 CPU shares. You must specify at least one
	// vCPU.
	//
	// Vcpus is a required field
	Vcpus *int64 `locationName:"vcpus" type:"integer" required:"true"`

	// A list of data volumes used in a job.
	Volumes []Volume `locationName:"volumes" type:"list"`
}

// String returns the string representation
func (s ContainerProperties) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContainerProperties) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ContainerProperties) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ContainerProperties"}

	if s.Image == nil {
		invalidParams.Add(aws.NewErrParamRequired("Image"))
	}

	if s.Memory == nil {
		invalidParams.Add(aws.NewErrParamRequired("Memory"))
	}

	if s.Vcpus == nil {
		invalidParams.Add(aws.NewErrParamRequired("Vcpus"))
	}
	if s.Ulimits != nil {
		for i, v := range s.Ulimits {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Ulimits", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ContainerProperties) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Command) > 0 {
		v := s.Command

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "command", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Environment) > 0 {
		v := s.Environment

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "environment", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Image != nil {
		v := *s.Image

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "image", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobRoleArn != nil {
		v := *s.JobRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Memory != nil {
		v := *s.Memory

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "memory", protocol.Int64Value(v), metadata)
	}
	if len(s.MountPoints) > 0 {
		v := s.MountPoints

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "mountPoints", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Privileged != nil {
		v := *s.Privileged

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "privileged", protocol.BoolValue(v), metadata)
	}
	if s.ReadonlyRootFilesystem != nil {
		v := *s.ReadonlyRootFilesystem

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "readonlyRootFilesystem", protocol.BoolValue(v), metadata)
	}
	if len(s.Ulimits) > 0 {
		v := s.Ulimits

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ulimits", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.User != nil {
		v := *s.User

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "user", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Vcpus != nil {
		v := *s.Vcpus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "vcpus", protocol.Int64Value(v), metadata)
	}
	if len(s.Volumes) > 0 {
		v := s.Volumes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "volumes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// An object representing summary details of a container within a job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ContainerSummary
type ContainerSummary struct {
	_ struct{} `type:"structure"`

	// The exit code to return upon completion.
	ExitCode *int64 `locationName:"exitCode" type:"integer"`

	// A short (255 max characters) human-readable string to provide additional
	// details about a running or stopped container.
	Reason *string `locationName:"reason" type:"string"`
}

// String returns the string representation
func (s ContainerSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContainerSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ContainerSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.ExitCode != nil {
		v := *s.ExitCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "exitCode", protocol.Int64Value(v), metadata)
	}
	if s.Reason != nil {
		v := *s.Reason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "reason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CreateComputeEnvironmentRequest
type CreateComputeEnvironmentInput struct {
	_ struct{} `type:"structure"`

	// The name for your compute environment. Up to 128 letters (uppercase and lowercase),
	// numbers, hyphens, and underscores are allowed.
	//
	// ComputeEnvironmentName is a required field
	ComputeEnvironmentName *string `locationName:"computeEnvironmentName" type:"string" required:"true"`

	// Details of the compute resources managed by the compute environment. This
	// parameter is required for managed compute environments.
	ComputeResources *ComputeResource `locationName:"computeResources" type:"structure"`

	// The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch
	// to make calls to other AWS services on your behalf.
	//
	// If your specified role has a path other than /, then you must either specify
	// the full role ARN (this is recommended) or prefix the role name with the
	// path.
	//
	// Depending on how you created your AWS Batch service role, its ARN may contain
	// the service-role path prefix. When you only specify the name of the service
	// role, AWS Batch assumes that your ARN does not use the service-role path
	// prefix. Because of this, we recommend that you specify the full ARN of your
	// service role when you create compute environments.
	//
	// ServiceRole is a required field
	ServiceRole *string `locationName:"serviceRole" type:"string" required:"true"`

	// The state of the compute environment. If the state is ENABLED, then the compute
	// environment accepts jobs from a queue and can scale out automatically based
	// on queues.
	State CEState `locationName:"state" type:"string" enum:"true"`

	// The type of the compute environment.
	//
	// Type is a required field
	Type CEType `locationName:"type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s CreateComputeEnvironmentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateComputeEnvironmentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateComputeEnvironmentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateComputeEnvironmentInput"}

	if s.ComputeEnvironmentName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ComputeEnvironmentName"))
	}

	if s.ServiceRole == nil {
		invalidParams.Add(aws.NewErrParamRequired("ServiceRole"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}
	if s.ComputeResources != nil {
		if err := s.ComputeResources.Validate(); err != nil {
			invalidParams.AddNested("ComputeResources", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateComputeEnvironmentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ComputeEnvironmentName != nil {
		v := *s.ComputeEnvironmentName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironmentName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ComputeResources != nil {
		v := s.ComputeResources

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "computeResources", v, metadata)
	}
	if s.ServiceRole != nil {
		v := *s.ServiceRole

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "serviceRole", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "state", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CreateComputeEnvironmentResponse
type CreateComputeEnvironmentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) of the compute environment.
	ComputeEnvironmentArn *string `locationName:"computeEnvironmentArn" type:"string"`

	// The name of the compute environment.
	ComputeEnvironmentName *string `locationName:"computeEnvironmentName" type:"string"`
}

// String returns the string representation
func (s CreateComputeEnvironmentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateComputeEnvironmentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateComputeEnvironmentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateComputeEnvironmentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ComputeEnvironmentArn != nil {
		v := *s.ComputeEnvironmentArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironmentArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ComputeEnvironmentName != nil {
		v := *s.ComputeEnvironmentName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironmentName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CreateJobQueueRequest
type CreateJobQueueInput struct {
	_ struct{} `type:"structure"`

	// The set of compute environments mapped to a job queue and their order relative
	// to each other. The job scheduler uses this parameter to determine which compute
	// environment should execute a given job. Compute environments must be in the
	// VALID state before you can associate them with a job queue. You can associate
	// up to three compute environments with a job queue.
	//
	// ComputeEnvironmentOrder is a required field
	ComputeEnvironmentOrder []ComputeEnvironmentOrder `locationName:"computeEnvironmentOrder" type:"list" required:"true"`

	// The name of the job queue.
	//
	// JobQueueName is a required field
	JobQueueName *string `locationName:"jobQueueName" type:"string" required:"true"`

	// The priority of the job queue. Job queues with a higher priority (or a higher
	// integer value for the priority parameter) are evaluated first when associated
	// with same compute environment. Priority is determined in descending order,
	// for example, a job queue with a priority value of 10 is given scheduling
	// preference over a job queue with a priority value of 1.
	//
	// Priority is a required field
	Priority *int64 `locationName:"priority" type:"integer" required:"true"`

	// The state of the job queue. If the job queue state is ENABLED, it is able
	// to accept jobs.
	State JQState `locationName:"state" type:"string" enum:"true"`
}

// String returns the string representation
func (s CreateJobQueueInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateJobQueueInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateJobQueueInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateJobQueueInput"}

	if s.ComputeEnvironmentOrder == nil {
		invalidParams.Add(aws.NewErrParamRequired("ComputeEnvironmentOrder"))
	}

	if s.JobQueueName == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobQueueName"))
	}

	if s.Priority == nil {
		invalidParams.Add(aws.NewErrParamRequired("Priority"))
	}
	if s.ComputeEnvironmentOrder != nil {
		for i, v := range s.ComputeEnvironmentOrder {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ComputeEnvironmentOrder", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateJobQueueInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.ComputeEnvironmentOrder) > 0 {
		v := s.ComputeEnvironmentOrder

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "computeEnvironmentOrder", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.JobQueueName != nil {
		v := *s.JobQueueName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueueName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "priority", protocol.Int64Value(v), metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "state", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/CreateJobQueueResponse
type CreateJobQueueOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) of the job queue.
	//
	// JobQueueArn is a required field
	JobQueueArn *string `locationName:"jobQueueArn" type:"string" required:"true"`

	// The name of the job queue.
	//
	// JobQueueName is a required field
	JobQueueName *string `locationName:"jobQueueName" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateJobQueueOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateJobQueueOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateJobQueueOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateJobQueueOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobQueueArn != nil {
		v := *s.JobQueueArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueueArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobQueueName != nil {
		v := *s.JobQueueName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueueName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeleteComputeEnvironmentRequest
type DeleteComputeEnvironmentInput struct {
	_ struct{} `type:"structure"`

	// The name or Amazon Resource Name (ARN) of the compute environment to delete.
	//
	// ComputeEnvironment is a required field
	ComputeEnvironment *string `locationName:"computeEnvironment" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteComputeEnvironmentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteComputeEnvironmentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteComputeEnvironmentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteComputeEnvironmentInput"}

	if s.ComputeEnvironment == nil {
		invalidParams.Add(aws.NewErrParamRequired("ComputeEnvironment"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteComputeEnvironmentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ComputeEnvironment != nil {
		v := *s.ComputeEnvironment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironment", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeleteComputeEnvironmentResponse
type DeleteComputeEnvironmentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteComputeEnvironmentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteComputeEnvironmentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteComputeEnvironmentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteComputeEnvironmentOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeleteJobQueueRequest
type DeleteJobQueueInput struct {
	_ struct{} `type:"structure"`

	// The short name or full Amazon Resource Name (ARN) of the queue to delete.
	//
	// JobQueue is a required field
	JobQueue *string `locationName:"jobQueue" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteJobQueueInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteJobQueueInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteJobQueueInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteJobQueueInput"}

	if s.JobQueue == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobQueue"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteJobQueueInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.JobQueue != nil {
		v := *s.JobQueue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeleteJobQueueResponse
type DeleteJobQueueOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteJobQueueOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteJobQueueOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteJobQueueOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteJobQueueOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeregisterJobDefinitionRequest
type DeregisterJobDefinitionInput struct {
	_ struct{} `type:"structure"`

	// The name and revision (name:revision) or full Amazon Resource Name (ARN)
	// of the job definition to deregister.
	//
	// JobDefinition is a required field
	JobDefinition *string `locationName:"jobDefinition" type:"string" required:"true"`
}

// String returns the string representation
func (s DeregisterJobDefinitionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeregisterJobDefinitionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeregisterJobDefinitionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeregisterJobDefinitionInput"}

	if s.JobDefinition == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobDefinition"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeregisterJobDefinitionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.JobDefinition != nil {
		v := *s.JobDefinition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DeregisterJobDefinitionResponse
type DeregisterJobDefinitionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeregisterJobDefinitionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeregisterJobDefinitionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeregisterJobDefinitionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeregisterJobDefinitionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeComputeEnvironmentsRequest
type DescribeComputeEnvironmentsInput struct {
	_ struct{} `type:"structure"`

	// A list of up to 100 compute environment names or full Amazon Resource Name
	// (ARN) entries.
	ComputeEnvironments []string `locationName:"computeEnvironments" type:"list"`

	// The maximum number of cluster results returned by DescribeComputeEnvironments
	// in paginated output. When this parameter is used, DescribeComputeEnvironments
	// only returns maxResults results in a single page along with a nextToken response
	// element. The remaining results of the initial request can be seen by sending
	// another DescribeComputeEnvironments request with the returned nextToken value.
	// This value can be between 1 and 100. If this parameter is not used, then
	// DescribeComputeEnvironments returns up to 100 results and a nextToken value
	// if applicable.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// The nextToken value returned from a previous paginated DescribeComputeEnvironments
	// request where maxResults was used and the results exceeded the value of that
	// parameter. Pagination continues from the end of the previous results that
	// returned the nextToken value. This value is null when there are no more results
	// to return.
	//
	// This token should be treated as an opaque identifier that is only used to
	// retrieve the next items in a list and not for other programmatic purposes.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s DescribeComputeEnvironmentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeComputeEnvironmentsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeComputeEnvironmentsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.ComputeEnvironments) > 0 {
		v := s.ComputeEnvironments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "computeEnvironments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeComputeEnvironmentsResponse
type DescribeComputeEnvironmentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The list of compute environments.
	ComputeEnvironments []ComputeEnvironmentDetail `locationName:"computeEnvironments" type:"list"`

	// The nextToken value to include in a future DescribeComputeEnvironments request.
	// When the results of a DescribeJobDefinitions request exceed maxResults, this
	// value can be used to retrieve the next page of results. This value is null
	// when there are no more results to return.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s DescribeComputeEnvironmentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeComputeEnvironmentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeComputeEnvironmentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeComputeEnvironmentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ComputeEnvironments) > 0 {
		v := s.ComputeEnvironments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "computeEnvironments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobDefinitionsRequest
type DescribeJobDefinitionsInput struct {
	_ struct{} `type:"structure"`

	// The name of the job definition to describe.
	JobDefinitionName *string `locationName:"jobDefinitionName" type:"string"`

	// A space-separated list of up to 100 job definition names or full Amazon Resource
	// Name (ARN) entries.
	JobDefinitions []string `locationName:"jobDefinitions" type:"list"`

	// The maximum number of results returned by DescribeJobDefinitions in paginated
	// output. When this parameter is used, DescribeJobDefinitions only returns
	// maxResults results in a single page along with a nextToken response element.
	// The remaining results of the initial request can be seen by sending another
	// DescribeJobDefinitions request with the returned nextToken value. This value
	// can be between 1 and 100. If this parameter is not used, then DescribeJobDefinitions
	// returns up to 100 results and a nextToken value if applicable.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// The nextToken value returned from a previous paginated DescribeJobDefinitions
	// request where maxResults was used and the results exceeded the value of that
	// parameter. Pagination continues from the end of the previous results that
	// returned the nextToken value. This value is null when there are no more results
	// to return.
	//
	// This token should be treated as an opaque identifier that is only used to
	// retrieve the next items in a list and not for other programmatic purposes.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The status with which to filter job definitions.
	Status *string `locationName:"status" type:"string"`
}

// String returns the string representation
func (s DescribeJobDefinitionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobDefinitionsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobDefinitionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.JobDefinitionName != nil {
		v := *s.JobDefinitionName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinitionName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.JobDefinitions) > 0 {
		v := s.JobDefinitions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobDefinitions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Status != nil {
		v := *s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobDefinitionsResponse
type DescribeJobDefinitionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The list of job definitions.
	JobDefinitions []JobDefinition `locationName:"jobDefinitions" type:"list"`

	// The nextToken value to include in a future DescribeJobDefinitions request.
	// When the results of a DescribeJobDefinitions request exceed maxResults, this
	// value can be used to retrieve the next page of results. This value is null
	// when there are no more results to return.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s DescribeJobDefinitionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobDefinitionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeJobDefinitionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobDefinitionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.JobDefinitions) > 0 {
		v := s.JobDefinitions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobDefinitions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobQueuesRequest
type DescribeJobQueuesInput struct {
	_ struct{} `type:"structure"`

	// A list of up to 100 queue names or full queue Amazon Resource Name (ARN)
	// entries.
	JobQueues []string `locationName:"jobQueues" type:"list"`

	// The maximum number of results returned by DescribeJobQueues in paginated
	// output. When this parameter is used, DescribeJobQueues only returns maxResults
	// results in a single page along with a nextToken response element. The remaining
	// results of the initial request can be seen by sending another DescribeJobQueues
	// request with the returned nextToken value. This value can be between 1 and
	// 100. If this parameter is not used, then DescribeJobQueues returns up to
	// 100 results and a nextToken value if applicable.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// The nextToken value returned from a previous paginated DescribeJobQueues
	// request where maxResults was used and the results exceeded the value of that
	// parameter. Pagination continues from the end of the previous results that
	// returned the nextToken value. This value is null when there are no more results
	// to return.
	//
	// This token should be treated as an opaque identifier that is only used to
	// retrieve the next items in a list and not for other programmatic purposes.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s DescribeJobQueuesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobQueuesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobQueuesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.JobQueues) > 0 {
		v := s.JobQueues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobQueues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobQueuesResponse
type DescribeJobQueuesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The list of job queues.
	JobQueues []JobQueueDetail `locationName:"jobQueues" type:"list"`

	// The nextToken value to include in a future DescribeJobQueues request. When
	// the results of a DescribeJobQueues request exceed maxResults, this value
	// can be used to retrieve the next page of results. This value is null when
	// there are no more results to return.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s DescribeJobQueuesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobQueuesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeJobQueuesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobQueuesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.JobQueues) > 0 {
		v := s.JobQueues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobQueues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobsRequest
type DescribeJobsInput struct {
	_ struct{} `type:"structure"`

	// A space-separated list of up to 100 job IDs.
	//
	// Jobs is a required field
	Jobs []string `locationName:"jobs" type:"list" required:"true"`
}

// String returns the string representation
func (s DescribeJobsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeJobsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeJobsInput"}

	if s.Jobs == nil {
		invalidParams.Add(aws.NewErrParamRequired("Jobs"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.Jobs) > 0 {
		v := s.Jobs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/DescribeJobsResponse
type DescribeJobsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The list of jobs.
	Jobs []JobDetail `locationName:"jobs" type:"list"`
}

// String returns the string representation
func (s DescribeJobsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeJobsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeJobsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeJobsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Jobs) > 0 {
		v := s.Jobs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The contents of the host parameter determine whether your data volume persists
// on the host container instance and where it is stored. If the host parameter
// is empty, then the Docker daemon assigns a host path for your data volume,
// but the data is not guaranteed to persist after the containers associated
// with it stop running.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/Host
type Host struct {
	_ struct{} `type:"structure"`

	// The path on the host container instance that is presented to the container.
	// If this parameter is empty, then the Docker daemon has assigned a host path
	// for you. If the host parameter contains a sourcePath file location, then
	// the data volume persists at the specified location on the host container
	// instance until you delete it manually. If the sourcePath value does not exist
	// on the host container instance, the Docker daemon creates it. If the location
	// does exist, the contents of the source path folder are exported.
	SourcePath *string `locationName:"sourcePath" type:"string"`
}

// String returns the string representation
func (s Host) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Host) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Host) MarshalFields(e protocol.FieldEncoder) error {
	if s.SourcePath != nil {
		v := *s.SourcePath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "sourcePath", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// An object representing an AWS Batch job definition.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/JobDefinition
type JobDefinition struct {
	_ struct{} `type:"structure"`

	// An object with various properties specific to container-based jobs.
	ContainerProperties *ContainerProperties `locationName:"containerProperties" type:"structure"`

	// The Amazon Resource Name (ARN) for the job definition.
	//
	// JobDefinitionArn is a required field
	JobDefinitionArn *string `locationName:"jobDefinitionArn" type:"string" required:"true"`

	// The name of the job definition.
	//
	// JobDefinitionName is a required field
	JobDefinitionName *string `locationName:"jobDefinitionName" type:"string" required:"true"`

	// Default parameters or parameter substitution placeholders that are set in
	// the job definition. Parameters are specified as a key-value pair mapping.
	// Parameters in a SubmitJob request override any corresponding parameter defaults
	// from the job definition.
	Parameters map[string]string `locationName:"parameters" type:"map"`

	// The retry strategy to use for failed jobs that are submitted with this job
	// definition.
	RetryStrategy *RetryStrategy `locationName:"retryStrategy" type:"structure"`

	// The revision of the job definition.
	//
	// Revision is a required field
	Revision *int64 `locationName:"revision" type:"integer" required:"true"`

	// The status of the job definition.
	Status *string `locationName:"status" type:"string"`

	// The timeout configuration for jobs that are submitted with this job definition.
	// You can specify a timeout duration after which AWS Batch terminates your
	// jobs if they have not finished.
	Timeout *JobTimeout `locationName:"timeout" type:"structure"`

	// The type of job definition.
	//
	// Type is a required field
	Type *string `locationName:"type" type:"string" required:"true"`
}

// String returns the string representation
func (s JobDefinition) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobDefinition) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobDefinition) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContainerProperties != nil {
		v := s.ContainerProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "containerProperties", v, metadata)
	}
	if s.JobDefinitionArn != nil {
		v := *s.JobDefinitionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinitionArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobDefinitionName != nil {
		v := *s.JobDefinitionName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinitionName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RetryStrategy != nil {
		v := s.RetryStrategy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "retryStrategy", v, metadata)
	}
	if s.Revision != nil {
		v := *s.Revision

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "revision", protocol.Int64Value(v), metadata)
	}
	if s.Status != nil {
		v := *s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Timeout != nil {
		v := s.Timeout

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "timeout", v, metadata)
	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// An object representing an AWS Batch job dependency.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/JobDependency
type JobDependency struct {
	_ struct{} `type:"structure"`

	// The job ID of the AWS Batch job associated with this dependency.
	JobId *string `locationName:"jobId" type:"string"`

	// The type of the job dependency.
	Type ArrayJobDependency `locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s JobDependency) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobDependency) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobDependency) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// An object representing an AWS Batch job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/JobDetail
type JobDetail struct {
	_ struct{} `type:"structure"`

	// The array properties of the job, if it is an array job.
	ArrayProperties *ArrayPropertiesDetail `locationName:"arrayProperties" type:"structure"`

	// A list of job attempts associated with this job.
	Attempts []AttemptDetail `locationName:"attempts" type:"list"`

	// An object representing the details of the container that is associated with
	// the job.
	Container *ContainerDetail `locationName:"container" type:"structure"`

	// The Unix time stamp (in seconds and milliseconds) for when the job was created.
	// For non-array jobs and parent array jobs, this is when the job entered the
	// SUBMITTED state (at the time SubmitJob was called). For array child jobs,
	// this is when the child job was spawned by its parent and entered the PENDING
	// state.
	CreatedAt *int64 `locationName:"createdAt" type:"long"`

	// A list of job names or IDs on which this job depends.
	DependsOn []JobDependency `locationName:"dependsOn" type:"list"`

	// The job definition that is used by this job.
	//
	// JobDefinition is a required field
	JobDefinition *string `locationName:"jobDefinition" type:"string" required:"true"`

	// The ID for the job.
	//
	// JobId is a required field
	JobId *string `locationName:"jobId" type:"string" required:"true"`

	// The name of the job.
	//
	// JobName is a required field
	JobName *string `locationName:"jobName" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) of the job queue with which the job is associated.
	//
	// JobQueue is a required field
	JobQueue *string `locationName:"jobQueue" type:"string" required:"true"`

	// Additional parameters passed to the job that replace parameter substitution
	// placeholders or override any corresponding parameter defaults from the job
	// definition.
	Parameters map[string]string `locationName:"parameters" type:"map"`

	// The retry strategy to use for this job if an attempt fails.
	RetryStrategy *RetryStrategy `locationName:"retryStrategy" type:"structure"`

	// The Unix time stamp (in seconds and milliseconds) for when the job was started
	// (when the job transitioned from the STARTING state to the RUNNING state).
	//
	// StartedAt is a required field
	StartedAt *int64 `locationName:"startedAt" type:"long" required:"true"`

	// The current status for the job.
	//
	// Status is a required field
	Status JobStatus `locationName:"status" type:"string" required:"true" enum:"true"`

	// A short, human-readable string to provide additional details about the current
	// status of the job.
	StatusReason *string `locationName:"statusReason" type:"string"`

	// The Unix time stamp (in seconds and milliseconds) for when the job was stopped
	// (when the job transitioned from the RUNNING state to a terminal state, such
	// as SUCCEEDED or FAILED).
	StoppedAt *int64 `locationName:"stoppedAt" type:"long"`

	// The timeout configuration for the job.
	Timeout *JobTimeout `locationName:"timeout" type:"structure"`
}

// String returns the string representation
func (s JobDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobDetail) MarshalFields(e protocol.FieldEncoder) error {
	if s.ArrayProperties != nil {
		v := s.ArrayProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "arrayProperties", v, metadata)
	}
	if len(s.Attempts) > 0 {
		v := s.Attempts

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "attempts", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Container != nil {
		v := s.Container

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "container", v, metadata)
	}
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.Int64Value(v), metadata)
	}
	if len(s.DependsOn) > 0 {
		v := s.DependsOn

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "dependsOn", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.JobDefinition != nil {
		v := *s.JobDefinition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobName != nil {
		v := *s.JobName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobQueue != nil {
		v := *s.JobQueue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RetryStrategy != nil {
		v := s.RetryStrategy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "retryStrategy", v, metadata)
	}
	if s.StartedAt != nil {
		v := *s.StartedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startedAt", protocol.Int64Value(v), metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusReason != nil {
		v := *s.StatusReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StoppedAt != nil {
		v := *s.StoppedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stoppedAt", protocol.Int64Value(v), metadata)
	}
	if s.Timeout != nil {
		v := s.Timeout

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "timeout", v, metadata)
	}
	return nil
}

// An object representing the details of an AWS Batch job queue.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/JobQueueDetail
type JobQueueDetail struct {
	_ struct{} `type:"structure"`

	// The compute environments that are attached to the job queue and the order
	// in which job placement is preferred. Compute environments are selected for
	// job placement in ascending order.
	//
	// ComputeEnvironmentOrder is a required field
	ComputeEnvironmentOrder []ComputeEnvironmentOrder `locationName:"computeEnvironmentOrder" type:"list" required:"true"`

	// The Amazon Resource Name (ARN) of the job queue.
	//
	// JobQueueArn is a required field
	JobQueueArn *string `locationName:"jobQueueArn" type:"string" required:"true"`

	// The name of the job queue.
	//
	// JobQueueName is a required field
	JobQueueName *string `locationName:"jobQueueName" type:"string" required:"true"`

	// The priority of the job queue.
	//
	// Priority is a required field
	Priority *int64 `locationName:"priority" type:"integer" required:"true"`

	// Describes the ability of the queue to accept new jobs.
	//
	// State is a required field
	State JQState `locationName:"state" type:"string" required:"true" enum:"true"`

	// The status of the job queue (for example, CREATING or VALID).
	Status JQStatus `locationName:"status" type:"string" enum:"true"`

	// A short, human-readable string to provide additional details about the current
	// status of the job queue.
	StatusReason *string `locationName:"statusReason" type:"string"`
}

// String returns the string representation
func (s JobQueueDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobQueueDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobQueueDetail) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ComputeEnvironmentOrder) > 0 {
		v := s.ComputeEnvironmentOrder

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "computeEnvironmentOrder", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.JobQueueArn != nil {
		v := *s.JobQueueArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueueArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobQueueName != nil {
		v := *s.JobQueueName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueueName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "priority", protocol.Int64Value(v), metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "state", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusReason != nil {
		v := *s.StatusReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// An object representing summary details of a job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/JobSummary
type JobSummary struct {
	_ struct{} `type:"structure"`

	// The array properties of the job, if it is an array job.
	ArrayProperties *ArrayPropertiesSummary `locationName:"arrayProperties" type:"structure"`

	// An object representing the details of the container that is associated with
	// the job.
	Container *ContainerSummary `locationName:"container" type:"structure"`

	// The Unix time stamp for when the job was created. For non-array jobs and
	// parent array jobs, this is when the job entered the SUBMITTED state (at the
	// time SubmitJob was called). For array child jobs, this is when the child
	// job was spawned by its parent and entered the PENDING state.
	CreatedAt *int64 `locationName:"createdAt" type:"long"`

	// The ID of the job.
	//
	// JobId is a required field
	JobId *string `locationName:"jobId" type:"string" required:"true"`

	// The name of the job.
	//
	// JobName is a required field
	JobName *string `locationName:"jobName" type:"string" required:"true"`

	// The Unix time stamp for when the job was started (when the job transitioned
	// from the STARTING state to the RUNNING state).
	StartedAt *int64 `locationName:"startedAt" type:"long"`

	// The current status for the job.
	Status JobStatus `locationName:"status" type:"string" enum:"true"`

	// A short, human-readable string to provide additional details about the current
	// status of the job.
	StatusReason *string `locationName:"statusReason" type:"string"`

	// The Unix time stamp for when the job was stopped (when the job transitioned
	// from the RUNNING state to a terminal state, such as SUCCEEDED or FAILED).
	StoppedAt *int64 `locationName:"stoppedAt" type:"long"`
}

// String returns the string representation
func (s JobSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.ArrayProperties != nil {
		v := s.ArrayProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "arrayProperties", v, metadata)
	}
	if s.Container != nil {
		v := s.Container

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "container", v, metadata)
	}
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.Int64Value(v), metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobName != nil {
		v := *s.JobName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartedAt != nil {
		v := *s.StartedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startedAt", protocol.Int64Value(v), metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusReason != nil {
		v := *s.StatusReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StoppedAt != nil {
		v := *s.StoppedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stoppedAt", protocol.Int64Value(v), metadata)
	}
	return nil
}

// An object representing a job timeout configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/JobTimeout
type JobTimeout struct {
	_ struct{} `type:"structure"`

	// The time duration in seconds (measured from the job attempt's startedAt timestamp)
	// after which AWS Batch terminates your jobs if they have not finished.
	AttemptDurationSeconds *int64 `locationName:"attemptDurationSeconds" type:"integer"`
}

// String returns the string representation
func (s JobTimeout) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s JobTimeout) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobTimeout) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttemptDurationSeconds != nil {
		v := *s.AttemptDurationSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "attemptDurationSeconds", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A key-value pair object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/KeyValuePair
type KeyValuePair struct {
	_ struct{} `type:"structure"`

	// The name of the key-value pair. For environment variables, this is the name
	// of the environment variable.
	Name *string `locationName:"name" type:"string"`

	// The value of the key-value pair. For environment variables, this is the value
	// of the environment variable.
	Value *string `locationName:"value" type:"string"`
}

// String returns the string representation
func (s KeyValuePair) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s KeyValuePair) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s KeyValuePair) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ListJobsRequest
type ListJobsInput struct {
	_ struct{} `type:"structure"`

	// The job ID for an array job. Specifying an array job ID with this parameter
	// lists all child jobs from within the specified array.
	ArrayJobId *string `locationName:"arrayJobId" type:"string"`

	// The name or full Amazon Resource Name (ARN) of the job queue with which to
	// list jobs.
	JobQueue *string `locationName:"jobQueue" type:"string"`

	// The job status with which to filter jobs in the specified queue. If you do
	// not specify a status, only RUNNING jobs are returned.
	JobStatus JobStatus `locationName:"jobStatus" type:"string" enum:"true"`

	// The maximum number of results returned by ListJobs in paginated output. When
	// this parameter is used, ListJobs only returns maxResults results in a single
	// page along with a nextToken response element. The remaining results of the
	// initial request can be seen by sending another ListJobs request with the
	// returned nextToken value. This value can be between 1 and 100. If this parameter
	// is not used, then ListJobs returns up to 100 results and a nextToken value
	// if applicable.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// The nextToken value returned from a previous paginated ListJobs request where
	// maxResults was used and the results exceeded the value of that parameter.
	// Pagination continues from the end of the previous results that returned the
	// nextToken value. This value is null when there are no more results to return.
	//
	// This token should be treated as an opaque identifier that is only used to
	// retrieve the next items in a list and not for other programmatic purposes.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListJobsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ArrayJobId != nil {
		v := *s.ArrayJobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arrayJobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobQueue != nil {
		v := *s.JobQueue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.JobStatus) > 0 {
		v := s.JobStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/ListJobsResponse
type ListJobsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of job summaries that match the request.
	//
	// JobSummaryList is a required field
	JobSummaryList []JobSummary `locationName:"jobSummaryList" type:"list" required:"true"`

	// The nextToken value to include in a future ListJobs request. When the results
	// of a ListJobs request exceed maxResults, this value can be used to retrieve
	// the next page of results. This value is null when there are no more results
	// to return.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListJobsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListJobsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListJobsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListJobsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.JobSummaryList) > 0 {
		v := s.JobSummaryList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobSummaryList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Details on a Docker volume mount point that is used in a job's container
// properties.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/MountPoint
type MountPoint struct {
	_ struct{} `type:"structure"`

	// The path on the container at which to mount the host volume.
	ContainerPath *string `locationName:"containerPath" type:"string"`

	// If this value is true, the container has read-only access to the volume;
	// otherwise, the container can write to the volume. The default value is false.
	ReadOnly *bool `locationName:"readOnly" type:"boolean"`

	// The name of the volume to mount.
	SourceVolume *string `locationName:"sourceVolume" type:"string"`
}

// String returns the string representation
func (s MountPoint) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MountPoint) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MountPoint) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContainerPath != nil {
		v := *s.ContainerPath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "containerPath", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ReadOnly != nil {
		v := *s.ReadOnly

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "readOnly", protocol.BoolValue(v), metadata)
	}
	if s.SourceVolume != nil {
		v := *s.SourceVolume

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "sourceVolume", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/RegisterJobDefinitionRequest
type RegisterJobDefinitionInput struct {
	_ struct{} `type:"structure"`

	// An object with various properties specific for container-based jobs. This
	// parameter is required if the type parameter is container.
	ContainerProperties *ContainerProperties `locationName:"containerProperties" type:"structure"`

	// The name of the job definition to register. Up to 128 letters (uppercase
	// and lowercase), numbers, hyphens, and underscores are allowed.
	//
	// JobDefinitionName is a required field
	JobDefinitionName *string `locationName:"jobDefinitionName" type:"string" required:"true"`

	// Default parameter substitution placeholders to set in the job definition.
	// Parameters are specified as a key-value pair mapping. Parameters in a SubmitJob
	// request override any corresponding parameter defaults from the job definition.
	Parameters map[string]string `locationName:"parameters" type:"map"`

	// The retry strategy to use for failed jobs that are submitted with this job
	// definition. Any retry strategy that is specified during a SubmitJob operation
	// overrides the retry strategy defined here. If a job is terminated due to
	// a timeout, it is not retried.
	RetryStrategy *RetryStrategy `locationName:"retryStrategy" type:"structure"`

	// The timeout configuration for jobs that are submitted with this job definition,
	// after which AWS Batch terminates your jobs if they have not finished. If
	// a job is terminated due to a timeout, it is not retried. The minimum value
	// for the timeout is 60 seconds. Any timeout configuration that is specified
	// during a SubmitJob operation overrides the timeout configuration defined
	// here. For more information, see Job Timeouts (http://docs.aws.amazon.com/AmazonECS/latest/developerguide/job_timeouts.html)
	// in the Amazon Elastic Container Service Developer Guide.
	Timeout *JobTimeout `locationName:"timeout" type:"structure"`

	// The type of job definition.
	//
	// Type is a required field
	Type JobDefinitionType `locationName:"type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s RegisterJobDefinitionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterJobDefinitionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RegisterJobDefinitionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RegisterJobDefinitionInput"}

	if s.JobDefinitionName == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobDefinitionName"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}
	if s.ContainerProperties != nil {
		if err := s.ContainerProperties.Validate(); err != nil {
			invalidParams.AddNested("ContainerProperties", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegisterJobDefinitionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ContainerProperties != nil {
		v := s.ContainerProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "containerProperties", v, metadata)
	}
	if s.JobDefinitionName != nil {
		v := *s.JobDefinitionName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinitionName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RetryStrategy != nil {
		v := s.RetryStrategy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "retryStrategy", v, metadata)
	}
	if s.Timeout != nil {
		v := s.Timeout

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "timeout", v, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/RegisterJobDefinitionResponse
type RegisterJobDefinitionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) of the job definition.
	//
	// JobDefinitionArn is a required field
	JobDefinitionArn *string `locationName:"jobDefinitionArn" type:"string" required:"true"`

	// The name of the job definition.
	//
	// JobDefinitionName is a required field
	JobDefinitionName *string `locationName:"jobDefinitionName" type:"string" required:"true"`

	// The revision of the job definition.
	//
	// Revision is a required field
	Revision *int64 `locationName:"revision" type:"integer" required:"true"`
}

// String returns the string representation
func (s RegisterJobDefinitionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterJobDefinitionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RegisterJobDefinitionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RegisterJobDefinitionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobDefinitionArn != nil {
		v := *s.JobDefinitionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinitionArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobDefinitionName != nil {
		v := *s.JobDefinitionName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinitionName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Revision != nil {
		v := *s.Revision

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "revision", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The retry strategy associated with a job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/RetryStrategy
type RetryStrategy struct {
	_ struct{} `type:"structure"`

	// The number of times to move a job to the RUNNABLE status. You may specify
	// between 1 and 10 attempts. If the value of attempts is greater than one,
	// the job is retried if it fails until it has moved to RUNNABLE that many times.
	Attempts *int64 `locationName:"attempts" type:"integer"`
}

// String returns the string representation
func (s RetryStrategy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RetryStrategy) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RetryStrategy) MarshalFields(e protocol.FieldEncoder) error {
	if s.Attempts != nil {
		v := *s.Attempts

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "attempts", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/SubmitJobRequest
type SubmitJobInput struct {
	_ struct{} `type:"structure"`

	// The array properties for the submitted job, such as the size of the array.
	// The array size can be between 2 and 10,000. If you specify array properties
	// for a job, it becomes an array job. For more information, see Array Jobs
	// (http://docs.aws.amazon.com/batch/latest/userguide/array_jobs.html) in the
	// AWS Batch User Guide.
	ArrayProperties *ArrayProperties `locationName:"arrayProperties" type:"structure"`

	// A list of container overrides in JSON format that specify the name of a container
	// in the specified job definition and the overrides it should receive. You
	// can override the default command for a container (that is specified in the
	// job definition or the Docker image) with a command override. You can also
	// override existing environment variables (that are specified in the job definition
	// or Docker image) on a container or add new environment variables to it with
	// an environment override.
	ContainerOverrides *ContainerOverrides `locationName:"containerOverrides" type:"structure"`

	// A list of dependencies for the job. A job can depend upon a maximum of 20
	// jobs. You can specify a SEQUENTIAL type dependency without specifying a job
	// ID for array jobs so that each child array job completes sequentially, starting
	// at index 0. You can also specify an N_TO_N type dependency with a job ID
	// for array jobs so that each index child of this job must wait for the corresponding
	// index child of each dependency to complete before it can begin.
	DependsOn []JobDependency `locationName:"dependsOn" type:"list"`

	// The job definition used by this job. This value can be either a name:revision
	// or the Amazon Resource Name (ARN) for the job definition.
	//
	// JobDefinition is a required field
	JobDefinition *string `locationName:"jobDefinition" type:"string" required:"true"`

	// The name of the job. The first character must be alphanumeric, and up to
	// 128 letters (uppercase and lowercase), numbers, hyphens, and underscores
	// are allowed.
	//
	// JobName is a required field
	JobName *string `locationName:"jobName" type:"string" required:"true"`

	// The job queue into which the job is submitted. You can specify either the
	// name or the Amazon Resource Name (ARN) of the queue.
	//
	// JobQueue is a required field
	JobQueue *string `locationName:"jobQueue" type:"string" required:"true"`

	// Additional parameters passed to the job that replace parameter substitution
	// placeholders that are set in the job definition. Parameters are specified
	// as a key and value pair mapping. Parameters in a SubmitJob request override
	// any corresponding parameter defaults from the job definition.
	Parameters map[string]string `locationName:"parameters" type:"map"`

	// The retry strategy to use for failed jobs from this SubmitJob operation.
	// When a retry strategy is specified here, it overrides the retry strategy
	// defined in the job definition.
	RetryStrategy *RetryStrategy `locationName:"retryStrategy" type:"structure"`

	// The timeout configuration for this SubmitJob operation. You can specify a
	// timeout duration after which AWS Batch terminates your jobs if they have
	// not finished. If a job is terminated due to a timeout, it is not retried.
	// The minimum value for the timeout is 60 seconds. This configuration overrides
	// any timeout configuration specified in the job definition. For array jobs,
	// child jobs have the same timeout configuration as the parent job. For more
	// information, see Job Timeouts (http://docs.aws.amazon.com/AmazonECS/latest/developerguide/job_timeouts.html)
	// in the Amazon Elastic Container Service Developer Guide.
	Timeout *JobTimeout `locationName:"timeout" type:"structure"`
}

// String returns the string representation
func (s SubmitJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SubmitJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SubmitJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SubmitJobInput"}

	if s.JobDefinition == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobDefinition"))
	}

	if s.JobName == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobName"))
	}

	if s.JobQueue == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobQueue"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SubmitJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ArrayProperties != nil {
		v := s.ArrayProperties

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "arrayProperties", v, metadata)
	}
	if s.ContainerOverrides != nil {
		v := s.ContainerOverrides

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "containerOverrides", v, metadata)
	}
	if len(s.DependsOn) > 0 {
		v := s.DependsOn

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "dependsOn", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.JobDefinition != nil {
		v := *s.JobDefinition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobDefinition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobName != nil {
		v := *s.JobName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobQueue != nil {
		v := *s.JobQueue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RetryStrategy != nil {
		v := s.RetryStrategy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "retryStrategy", v, metadata)
	}
	if s.Timeout != nil {
		v := s.Timeout

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "timeout", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/SubmitJobResponse
type SubmitJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The unique identifier for the job.
	//
	// JobId is a required field
	JobId *string `locationName:"jobId" type:"string" required:"true"`

	// The name of the job.
	//
	// JobName is a required field
	JobName *string `locationName:"jobName" type:"string" required:"true"`
}

// String returns the string representation
func (s SubmitJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SubmitJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s SubmitJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SubmitJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobName != nil {
		v := *s.JobName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/TerminateJobRequest
type TerminateJobInput struct {
	_ struct{} `type:"structure"`

	// The AWS Batch job ID of the job to terminate.
	//
	// JobId is a required field
	JobId *string `locationName:"jobId" type:"string" required:"true"`

	// A message to attach to the job that explains the reason for canceling it.
	// This message is returned by future DescribeJobs operations on the job. This
	// message is also recorded in the AWS Batch activity logs.
	//
	// Reason is a required field
	Reason *string `locationName:"reason" type:"string" required:"true"`
}

// String returns the string representation
func (s TerminateJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TerminateJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TerminateJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TerminateJobInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}

	if s.Reason == nil {
		invalidParams.Add(aws.NewErrParamRequired("Reason"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TerminateJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Reason != nil {
		v := *s.Reason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "reason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/TerminateJobResponse
type TerminateJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s TerminateJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TerminateJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TerminateJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TerminateJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The ulimit settings to pass to the container.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/Ulimit
type Ulimit struct {
	_ struct{} `type:"structure"`

	// The hard limit for the ulimit type.
	//
	// HardLimit is a required field
	HardLimit *int64 `locationName:"hardLimit" type:"integer" required:"true"`

	// The type of the ulimit.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// The soft limit for the ulimit type.
	//
	// SoftLimit is a required field
	SoftLimit *int64 `locationName:"softLimit" type:"integer" required:"true"`
}

// String returns the string representation
func (s Ulimit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Ulimit) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Ulimit) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Ulimit"}

	if s.HardLimit == nil {
		invalidParams.Add(aws.NewErrParamRequired("HardLimit"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.SoftLimit == nil {
		invalidParams.Add(aws.NewErrParamRequired("SoftLimit"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Ulimit) MarshalFields(e protocol.FieldEncoder) error {
	if s.HardLimit != nil {
		v := *s.HardLimit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hardLimit", protocol.Int64Value(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SoftLimit != nil {
		v := *s.SoftLimit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "softLimit", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/UpdateComputeEnvironmentRequest
type UpdateComputeEnvironmentInput struct {
	_ struct{} `type:"structure"`

	// The name or full Amazon Resource Name (ARN) of the compute environment to
	// update.
	//
	// ComputeEnvironment is a required field
	ComputeEnvironment *string `locationName:"computeEnvironment" type:"string" required:"true"`

	// Details of the compute resources managed by the compute environment. Required
	// for a managed compute environment.
	ComputeResources *ComputeResourceUpdate `locationName:"computeResources" type:"structure"`

	// The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch
	// to make calls to other AWS services on your behalf.
	//
	// If your specified role has a path other than /, then you must either specify
	// the full role ARN (this is recommended) or prefix the role name with the
	// path.
	//
	// Depending on how you created your AWS Batch service role, its ARN may contain
	// the service-role path prefix. When you only specify the name of the service
	// role, AWS Batch assumes that your ARN does not use the service-role path
	// prefix. Because of this, we recommend that you specify the full ARN of your
	// service role when you create compute environments.
	ServiceRole *string `locationName:"serviceRole" type:"string"`

	// The state of the compute environment. Compute environments in the ENABLED
	// state can accept jobs from a queue and scale in or out automatically based
	// on the workload demand of its associated queues.
	State CEState `locationName:"state" type:"string" enum:"true"`
}

// String returns the string representation
func (s UpdateComputeEnvironmentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateComputeEnvironmentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateComputeEnvironmentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateComputeEnvironmentInput"}

	if s.ComputeEnvironment == nil {
		invalidParams.Add(aws.NewErrParamRequired("ComputeEnvironment"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateComputeEnvironmentInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ComputeEnvironment != nil {
		v := *s.ComputeEnvironment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironment", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ComputeResources != nil {
		v := s.ComputeResources

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "computeResources", v, metadata)
	}
	if s.ServiceRole != nil {
		v := *s.ServiceRole

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "serviceRole", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "state", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/UpdateComputeEnvironmentResponse
type UpdateComputeEnvironmentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) of the compute environment.
	ComputeEnvironmentArn *string `locationName:"computeEnvironmentArn" type:"string"`

	// The name of compute environment.
	ComputeEnvironmentName *string `locationName:"computeEnvironmentName" type:"string"`
}

// String returns the string representation
func (s UpdateComputeEnvironmentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateComputeEnvironmentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateComputeEnvironmentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateComputeEnvironmentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ComputeEnvironmentArn != nil {
		v := *s.ComputeEnvironmentArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironmentArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ComputeEnvironmentName != nil {
		v := *s.ComputeEnvironmentName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "computeEnvironmentName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/UpdateJobQueueRequest
type UpdateJobQueueInput struct {
	_ struct{} `type:"structure"`

	// Details the set of compute environments mapped to a job queue and their order
	// relative to each other. This is one of the parameters used by the job scheduler
	// to determine which compute environment should execute a given job.
	ComputeEnvironmentOrder []ComputeEnvironmentOrder `locationName:"computeEnvironmentOrder" type:"list"`

	// The name or the Amazon Resource Name (ARN) of the job queue.
	//
	// JobQueue is a required field
	JobQueue *string `locationName:"jobQueue" type:"string" required:"true"`

	// The priority of the job queue. Job queues with a higher priority (or a higher
	// integer value for the priority parameter) are evaluated first when associated
	// with same compute environment. Priority is determined in descending order,
	// for example, a job queue with a priority value of 10 is given scheduling
	// preference over a job queue with a priority value of 1.
	Priority *int64 `locationName:"priority" type:"integer"`

	// Describes the queue's ability to accept new jobs.
	State JQState `locationName:"state" type:"string" enum:"true"`
}

// String returns the string representation
func (s UpdateJobQueueInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateJobQueueInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateJobQueueInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateJobQueueInput"}

	if s.JobQueue == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobQueue"))
	}
	if s.ComputeEnvironmentOrder != nil {
		for i, v := range s.ComputeEnvironmentOrder {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ComputeEnvironmentOrder", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateJobQueueInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.ComputeEnvironmentOrder) > 0 {
		v := s.ComputeEnvironmentOrder

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "computeEnvironmentOrder", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.JobQueue != nil {
		v := *s.JobQueue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "priority", protocol.Int64Value(v), metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "state", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/UpdateJobQueueResponse
type UpdateJobQueueOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) of the job queue.
	JobQueueArn *string `locationName:"jobQueueArn" type:"string"`

	// The name of the job queue.
	JobQueueName *string `locationName:"jobQueueName" type:"string"`
}

// String returns the string representation
func (s UpdateJobQueueOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateJobQueueOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateJobQueueOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateJobQueueOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobQueueArn != nil {
		v := *s.JobQueueArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueueArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.JobQueueName != nil {
		v := *s.JobQueueName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobQueueName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A data volume used in a job's container properties.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/batch-2016-08-10/Volume
type Volume struct {
	_ struct{} `type:"structure"`

	// The contents of the host parameter determine whether your data volume persists
	// on the host container instance and where it is stored. If the host parameter
	// is empty, then the Docker daemon assigns a host path for your data volume.
	// However, the data is not guaranteed to persist after the containers associated
	// with it stop running.
	Host *Host `locationName:"host" type:"structure"`

	// The name of the volume. Up to 255 letters (uppercase and lowercase), numbers,
	// hyphens, and underscores are allowed. This name is referenced in the sourceVolume
	// parameter of container definition mountPoints.
	Name *string `locationName:"name" type:"string"`
}

// String returns the string representation
func (s Volume) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Volume) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Volume) MarshalFields(e protocol.FieldEncoder) error {
	if s.Host != nil {
		v := s.Host

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "host", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type ArrayJobDependency string

// Enum values for ArrayJobDependency
const (
	ArrayJobDependencyNToN       ArrayJobDependency = "N_TO_N"
	ArrayJobDependencySequential ArrayJobDependency = "SEQUENTIAL"
)

func (enum ArrayJobDependency) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ArrayJobDependency) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CEState string

// Enum values for CEState
const (
	CEStateEnabled  CEState = "ENABLED"
	CEStateDisabled CEState = "DISABLED"
)

func (enum CEState) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CEState) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CEStatus string

// Enum values for CEStatus
const (
	CEStatusCreating CEStatus = "CREATING"
	CEStatusUpdating CEStatus = "UPDATING"
	CEStatusDeleting CEStatus = "DELETING"
	CEStatusDeleted  CEStatus = "DELETED"
	CEStatusValid    CEStatus = "VALID"
	CEStatusInvalid  CEStatus = "INVALID"
)

func (enum CEStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CEStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CEType string

// Enum values for CEType
const (
	CETypeManaged   CEType = "MANAGED"
	CETypeUnmanaged CEType = "UNMANAGED"
)

func (enum CEType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CEType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CRType string

// Enum values for CRType
const (
	CRTypeEc2  CRType = "EC2"
	CRTypeSpot CRType = "SPOT"
)

func (enum CRType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CRType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type JQState string

// Enum values for JQState
const (
	JQStateEnabled  JQState = "ENABLED"
	JQStateDisabled JQState = "DISABLED"
)

func (enum JQState) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum JQState) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type JQStatus string

// Enum values for JQStatus
const (
	JQStatusCreating JQStatus = "CREATING"
	JQStatusUpdating JQStatus = "UPDATING"
	JQStatusDeleting JQStatus = "DELETING"
	JQStatusDeleted  JQStatus = "DELETED"
	JQStatusValid    JQStatus = "VALID"
	JQStatusInvalid  JQStatus = "INVALID"
)

func (enum JQStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum JQStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type JobDefinitionType string

// Enum values for JobDefinitionType
const (
	JobDefinitionTypeContainer JobDefinitionType = "container"
)

func (enum JobDefinitionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum JobDefinitionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type JobStatus string

// Enum values for JobStatus
const (
	JobStatusSubmitted JobStatus = "SUBMITTED"
	JobStatusPending   JobStatus = "PENDING"
	JobStatusRunnable  JobStatus = "RUNNABLE"
	JobStatusStarting  JobStatus = "STARTING"
	JobStatusRunning   JobStatus = "RUNNING"
	JobStatusSucceeded JobStatus = "SUCCEEDED"
	JobStatusFailed    JobStatus = "FAILED"
)

func (enum JobStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum JobStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
