// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package signer

import (
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opCancelSigningProfile = "CancelSigningProfile"

// CancelSigningProfileRequest is a API request type for the CancelSigningProfile API operation.
type CancelSigningProfileRequest struct {
	*aws.Request
	Input *CancelSigningProfileInput
	Copy  func(*CancelSigningProfileInput) CancelSigningProfileRequest
}

// Send marshals and sends the CancelSigningProfile API request.
func (r CancelSigningProfileRequest) Send() (*CancelSigningProfileOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CancelSigningProfileOutput), nil
}

// CancelSigningProfileRequest returns a request value for making API operation for
// AWS Signer.
//
// Changes the state of an ACTIVE signing profile to CANCELED. A canceled profile
// is still viewable with the ListSigningProfiles operation, but it cannot perform
// new signing jobs, and is deleted two years after cancelation.
//
//    // Example sending a request using the CancelSigningProfileRequest method.
//    req := client.CancelSigningProfileRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/CancelSigningProfile
func (c *Signer) CancelSigningProfileRequest(input *CancelSigningProfileInput) CancelSigningProfileRequest {
	op := &aws.Operation{
		Name:       opCancelSigningProfile,
		HTTPMethod: "DELETE",
		HTTPPath:   "/signing-profiles/{profileName}",
	}

	if input == nil {
		input = &CancelSigningProfileInput{}
	}

	output := &CancelSigningProfileOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return CancelSigningProfileRequest{Request: req, Input: input, Copy: c.CancelSigningProfileRequest}
}

const opDescribeSigningJob = "DescribeSigningJob"

// DescribeSigningJobRequest is a API request type for the DescribeSigningJob API operation.
type DescribeSigningJobRequest struct {
	*aws.Request
	Input *DescribeSigningJobInput
	Copy  func(*DescribeSigningJobInput) DescribeSigningJobRequest
}

// Send marshals and sends the DescribeSigningJob API request.
func (r DescribeSigningJobRequest) Send() (*DescribeSigningJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeSigningJobOutput), nil
}

// DescribeSigningJobRequest returns a request value for making API operation for
// AWS Signer.
//
// Returns information about a specific code signing job. You specify the job
// by using the jobId value that is returned by the StartSigningJob operation.
//
//    // Example sending a request using the DescribeSigningJobRequest method.
//    req := client.DescribeSigningJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/DescribeSigningJob
func (c *Signer) DescribeSigningJobRequest(input *DescribeSigningJobInput) DescribeSigningJobRequest {
	op := &aws.Operation{
		Name:       opDescribeSigningJob,
		HTTPMethod: "GET",
		HTTPPath:   "/signing-jobs/{jobId}",
	}

	if input == nil {
		input = &DescribeSigningJobInput{}
	}

	output := &DescribeSigningJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeSigningJobRequest{Request: req, Input: input, Copy: c.DescribeSigningJobRequest}
}

const opGetSigningPlatform = "GetSigningPlatform"

// GetSigningPlatformRequest is a API request type for the GetSigningPlatform API operation.
type GetSigningPlatformRequest struct {
	*aws.Request
	Input *GetSigningPlatformInput
	Copy  func(*GetSigningPlatformInput) GetSigningPlatformRequest
}

// Send marshals and sends the GetSigningPlatform API request.
func (r GetSigningPlatformRequest) Send() (*GetSigningPlatformOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSigningPlatformOutput), nil
}

// GetSigningPlatformRequest returns a request value for making API operation for
// AWS Signer.
//
// Returns information on a specific signing platform.
//
//    // Example sending a request using the GetSigningPlatformRequest method.
//    req := client.GetSigningPlatformRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/GetSigningPlatform
func (c *Signer) GetSigningPlatformRequest(input *GetSigningPlatformInput) GetSigningPlatformRequest {
	op := &aws.Operation{
		Name:       opGetSigningPlatform,
		HTTPMethod: "GET",
		HTTPPath:   "/signing-platforms/{platformId}",
	}

	if input == nil {
		input = &GetSigningPlatformInput{}
	}

	output := &GetSigningPlatformOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSigningPlatformRequest{Request: req, Input: input, Copy: c.GetSigningPlatformRequest}
}

const opGetSigningProfile = "GetSigningProfile"

// GetSigningProfileRequest is a API request type for the GetSigningProfile API operation.
type GetSigningProfileRequest struct {
	*aws.Request
	Input *GetSigningProfileInput
	Copy  func(*GetSigningProfileInput) GetSigningProfileRequest
}

// Send marshals and sends the GetSigningProfile API request.
func (r GetSigningProfileRequest) Send() (*GetSigningProfileOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSigningProfileOutput), nil
}

// GetSigningProfileRequest returns a request value for making API operation for
// AWS Signer.
//
// Returns information on a specific signing profile.
//
//    // Example sending a request using the GetSigningProfileRequest method.
//    req := client.GetSigningProfileRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/GetSigningProfile
func (c *Signer) GetSigningProfileRequest(input *GetSigningProfileInput) GetSigningProfileRequest {
	op := &aws.Operation{
		Name:       opGetSigningProfile,
		HTTPMethod: "GET",
		HTTPPath:   "/signing-profiles/{profileName}",
	}

	if input == nil {
		input = &GetSigningProfileInput{}
	}

	output := &GetSigningProfileOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSigningProfileRequest{Request: req, Input: input, Copy: c.GetSigningProfileRequest}
}

const opListSigningJobs = "ListSigningJobs"

// ListSigningJobsRequest is a API request type for the ListSigningJobs API operation.
type ListSigningJobsRequest struct {
	*aws.Request
	Input *ListSigningJobsInput
	Copy  func(*ListSigningJobsInput) ListSigningJobsRequest
}

// Send marshals and sends the ListSigningJobs API request.
func (r ListSigningJobsRequest) Send() (*ListSigningJobsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListSigningJobsOutput), nil
}

// ListSigningJobsRequest returns a request value for making API operation for
// AWS Signer.
//
// Lists all your signing jobs. You can use the maxResults parameter to limit
// the number of signing jobs that are returned in the response. If additional
// jobs remain to be listed, AWS Signer returns a nextToken value. Use this
// value in subsequent calls to ListSigningJobs to fetch the remaining values.
// You can continue calling ListSigningJobs with your maxResults parameter and
// with new values that AWS Signer returns in the nextToken parameter until
// all of your signing jobs have been returned.
//
//    // Example sending a request using the ListSigningJobsRequest method.
//    req := client.ListSigningJobsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningJobs
func (c *Signer) ListSigningJobsRequest(input *ListSigningJobsInput) ListSigningJobsRequest {
	op := &aws.Operation{
		Name:       opListSigningJobs,
		HTTPMethod: "GET",
		HTTPPath:   "/signing-jobs",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListSigningJobsInput{}
	}

	output := &ListSigningJobsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListSigningJobsRequest{Request: req, Input: input, Copy: c.ListSigningJobsRequest}
}

// Paginate pages iterates over the pages of a ListSigningJobsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListSigningJobs operation.
//		req := client.ListSigningJobsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListSigningJobsRequest) Paginate(opts ...aws.Option) ListSigningJobsPager {
	return ListSigningJobsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListSigningJobsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListSigningJobsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListSigningJobsPager struct {
	aws.Pager
}

func (p *ListSigningJobsPager) CurrentPage() *ListSigningJobsOutput {
	return p.Pager.CurrentPage().(*ListSigningJobsOutput)
}

const opListSigningPlatforms = "ListSigningPlatforms"

// ListSigningPlatformsRequest is a API request type for the ListSigningPlatforms API operation.
type ListSigningPlatformsRequest struct {
	*aws.Request
	Input *ListSigningPlatformsInput
	Copy  func(*ListSigningPlatformsInput) ListSigningPlatformsRequest
}

// Send marshals and sends the ListSigningPlatforms API request.
func (r ListSigningPlatformsRequest) Send() (*ListSigningPlatformsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListSigningPlatformsOutput), nil
}

// ListSigningPlatformsRequest returns a request value for making API operation for
// AWS Signer.
//
// Lists all signing platforms available in AWS Signer that match the request
// parameters. If additional jobs remain to be listed, AWS Signer returns a
// nextToken value. Use this value in subsequent calls to ListSigningJobs to
// fetch the remaining values. You can continue calling ListSigningJobs with
// your maxResults parameter and with new values that AWS Signer returns in
// the nextToken parameter until all of your signing jobs have been returned.
//
//    // Example sending a request using the ListSigningPlatformsRequest method.
//    req := client.ListSigningPlatformsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningPlatforms
func (c *Signer) ListSigningPlatformsRequest(input *ListSigningPlatformsInput) ListSigningPlatformsRequest {
	op := &aws.Operation{
		Name:       opListSigningPlatforms,
		HTTPMethod: "GET",
		HTTPPath:   "/signing-platforms",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListSigningPlatformsInput{}
	}

	output := &ListSigningPlatformsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListSigningPlatformsRequest{Request: req, Input: input, Copy: c.ListSigningPlatformsRequest}
}

// Paginate pages iterates over the pages of a ListSigningPlatformsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListSigningPlatforms operation.
//		req := client.ListSigningPlatformsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListSigningPlatformsRequest) Paginate(opts ...aws.Option) ListSigningPlatformsPager {
	return ListSigningPlatformsPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListSigningPlatformsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListSigningPlatformsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListSigningPlatformsPager struct {
	aws.Pager
}

func (p *ListSigningPlatformsPager) CurrentPage() *ListSigningPlatformsOutput {
	return p.Pager.CurrentPage().(*ListSigningPlatformsOutput)
}

const opListSigningProfiles = "ListSigningProfiles"

// ListSigningProfilesRequest is a API request type for the ListSigningProfiles API operation.
type ListSigningProfilesRequest struct {
	*aws.Request
	Input *ListSigningProfilesInput
	Copy  func(*ListSigningProfilesInput) ListSigningProfilesRequest
}

// Send marshals and sends the ListSigningProfiles API request.
func (r ListSigningProfilesRequest) Send() (*ListSigningProfilesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListSigningProfilesOutput), nil
}

// ListSigningProfilesRequest returns a request value for making API operation for
// AWS Signer.
//
// Lists all available signing profiles in your AWS account. Returns only profiles
// with an ACTIVE status unless the includeCanceled request field is set to
// true. If additional jobs remain to be listed, AWS Signer returns a nextToken
// value. Use this value in subsequent calls to ListSigningJobs to fetch the
// remaining values. You can continue calling ListSigningJobs with your maxResults
// parameter and with new values that AWS Signer returns in the nextToken parameter
// until all of your signing jobs have been returned.
//
//    // Example sending a request using the ListSigningProfilesRequest method.
//    req := client.ListSigningProfilesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningProfiles
func (c *Signer) ListSigningProfilesRequest(input *ListSigningProfilesInput) ListSigningProfilesRequest {
	op := &aws.Operation{
		Name:       opListSigningProfiles,
		HTTPMethod: "GET",
		HTTPPath:   "/signing-profiles",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListSigningProfilesInput{}
	}

	output := &ListSigningProfilesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListSigningProfilesRequest{Request: req, Input: input, Copy: c.ListSigningProfilesRequest}
}

// Paginate pages iterates over the pages of a ListSigningProfilesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListSigningProfiles operation.
//		req := client.ListSigningProfilesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListSigningProfilesRequest) Paginate(opts ...aws.Option) ListSigningProfilesPager {
	return ListSigningProfilesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *ListSigningProfilesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// ListSigningProfilesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListSigningProfilesPager struct {
	aws.Pager
}

func (p *ListSigningProfilesPager) CurrentPage() *ListSigningProfilesOutput {
	return p.Pager.CurrentPage().(*ListSigningProfilesOutput)
}

const opPutSigningProfile = "PutSigningProfile"

// PutSigningProfileRequest is a API request type for the PutSigningProfile API operation.
type PutSigningProfileRequest struct {
	*aws.Request
	Input *PutSigningProfileInput
	Copy  func(*PutSigningProfileInput) PutSigningProfileRequest
}

// Send marshals and sends the PutSigningProfile API request.
func (r PutSigningProfileRequest) Send() (*PutSigningProfileOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutSigningProfileOutput), nil
}

// PutSigningProfileRequest returns a request value for making API operation for
// AWS Signer.
//
// Creates a signing profile. A signing profile is an AWS Signer template that
// can be used to carry out a pre-defined signing job. For more information,
// see http://docs.aws.amazon.com/signer/latest/developerguide/gs-profile.html
// (http://docs.aws.amazon.com/signer/latest/developerguide/gs-profile.html)
//
//    // Example sending a request using the PutSigningProfileRequest method.
//    req := client.PutSigningProfileRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/PutSigningProfile
func (c *Signer) PutSigningProfileRequest(input *PutSigningProfileInput) PutSigningProfileRequest {
	op := &aws.Operation{
		Name:       opPutSigningProfile,
		HTTPMethod: "PUT",
		HTTPPath:   "/signing-profiles/{profileName}",
	}

	if input == nil {
		input = &PutSigningProfileInput{}
	}

	output := &PutSigningProfileOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutSigningProfileRequest{Request: req, Input: input, Copy: c.PutSigningProfileRequest}
}

const opStartSigningJob = "StartSigningJob"

// StartSigningJobRequest is a API request type for the StartSigningJob API operation.
type StartSigningJobRequest struct {
	*aws.Request
	Input *StartSigningJobInput
	Copy  func(*StartSigningJobInput) StartSigningJobRequest
}

// Send marshals and sends the StartSigningJob API request.
func (r StartSigningJobRequest) Send() (*StartSigningJobOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartSigningJobOutput), nil
}

// StartSigningJobRequest returns a request value for making API operation for
// AWS Signer.
//
// Initiates a signing job to be performed on the code provided. Signing jobs
// are viewable by the ListSigningJobs operation for two years after they are
// performed. Note the following requirements:
//
//    *  You must create an Amazon S3 source bucket. For more information, see
//    Create a Bucket (http://docs.aws.amazon.com/AmazonS3/latest/gsg/CreatingABucket.html)
//    in the Amazon S3 Getting Started Guide.
//
//    * Your S3 source bucket must be version enabled.
//
//    * You must create an S3 destination bucket. AWS Signer uses your S3 destination
//    bucket to write your signed code.
//
//    * You specify the name of the source and destination buckets when calling
//    the StartSigningJob operation.
//
//    * You must also specify a request token that identifies your request to
//    AWS Signer.
//
// You can call the DescribeSigningJob and the ListSigningJobs actions after
// you call StartSigningJob.
//
// For a Java example that shows how to use this action, see http://docs.aws.amazon.com/acm/latest/userguide/
// (http://docs.aws.amazon.com/acm/latest/userguide/)
//
//    // Example sending a request using the StartSigningJobRequest method.
//    req := client.StartSigningJobRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/StartSigningJob
func (c *Signer) StartSigningJobRequest(input *StartSigningJobInput) StartSigningJobRequest {
	op := &aws.Operation{
		Name:       opStartSigningJob,
		HTTPMethod: "POST",
		HTTPPath:   "/signing-jobs",
	}

	if input == nil {
		input = &StartSigningJobInput{}
	}

	output := &StartSigningJobOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartSigningJobRequest{Request: req, Input: input, Copy: c.StartSigningJobRequest}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/CancelSigningProfileRequest
type CancelSigningProfileInput struct {
	_ struct{} `type:"structure"`

	// The name of the signing profile to be canceled.
	//
	// ProfileName is a required field
	ProfileName *string `location:"uri" locationName:"profileName" min:"2" type:"string" required:"true"`
}

// String returns the string representation
func (s CancelSigningProfileInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelSigningProfileInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CancelSigningProfileInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CancelSigningProfileInput"}

	if s.ProfileName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ProfileName"))
	}
	if s.ProfileName != nil && len(*s.ProfileName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("ProfileName", 2))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelSigningProfileInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ProfileName != nil {
		v := *s.ProfileName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "profileName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/CancelSigningProfileOutput
type CancelSigningProfileOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CancelSigningProfileOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelSigningProfileOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CancelSigningProfileOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelSigningProfileOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/DescribeSigningJobRequest
type DescribeSigningJobInput struct {
	_ struct{} `type:"structure"`

	// The ID of the signing job on input.
	//
	// JobId is a required field
	JobId *string `location:"uri" locationName:"jobId" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeSigningJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeSigningJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeSigningJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeSigningJobInput"}

	if s.JobId == nil {
		invalidParams.Add(aws.NewErrParamRequired("JobId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeSigningJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/DescribeSigningJobResponse
type DescribeSigningJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Date and time that the signing job was completed.
	CompletedAt *time.Time `locationName:"completedAt" type:"timestamp" timestampFormat:"unix"`

	// Date and time that the signing job was created.
	CreatedAt *time.Time `locationName:"createdAt" type:"timestamp" timestampFormat:"unix"`

	// The ID of the signing job on output.
	JobId *string `locationName:"jobId" type:"string"`

	// A list of any overrides that were applied to the signing operation.
	Overrides *SigningPlatformOverrides `locationName:"overrides" type:"structure"`

	// The microcontroller platform to which your signed code image will be distributed.
	PlatformId *string `locationName:"platformId" type:"string"`

	// The name of the profile that initiated the signing operation.
	ProfileName *string `locationName:"profileName" min:"2" type:"string"`

	// The IAM principal that requested the signing job.
	RequestedBy *string `locationName:"requestedBy" type:"string"`

	// Name of the S3 bucket where the signed code image is saved by AWS Signer.
	SignedObject *SignedObject `locationName:"signedObject" type:"structure"`

	// Amazon Resource Name (ARN) of your code signing certificate.
	SigningMaterial *SigningMaterial `locationName:"signingMaterial" type:"structure"`

	// Map of user-assigned key-value pairs used during signing. These values contain
	// any information that you specified for use in your signing job.
	SigningParameters map[string]string `locationName:"signingParameters" type:"map"`

	// The object that contains the name of your S3 bucket or your raw code.
	Source *Source `locationName:"source" type:"structure"`

	// Status of the signing job.
	Status SigningStatus `locationName:"status" type:"string" enum:"true"`

	// String value that contains the status reason.
	StatusReason *string `locationName:"statusReason" type:"string"`
}

// String returns the string representation
func (s DescribeSigningJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeSigningJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeSigningJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeSigningJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CompletedAt != nil {
		v := *s.CompletedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "completedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Overrides != nil {
		v := s.Overrides

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "overrides", v, metadata)
	}
	if s.PlatformId != nil {
		v := *s.PlatformId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "platformId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProfileName != nil {
		v := *s.ProfileName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "profileName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RequestedBy != nil {
		v := *s.RequestedBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "requestedBy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SignedObject != nil {
		v := s.SignedObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signedObject", v, metadata)
	}
	if s.SigningMaterial != nil {
		v := s.SigningMaterial

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingMaterial", v, metadata)
	}
	if len(s.SigningParameters) > 0 {
		v := s.SigningParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "signingParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Source != nil {
		v := s.Source

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "source", v, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusReason != nil {
		v := *s.StatusReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusReason", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Points to an S3Destination object that contains information about your S3
// bucket.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/Destination
type Destination struct {
	_ struct{} `type:"structure"`

	// The S3Destination object.
	S3 *S3Destination `locationName:"s3" type:"structure"`
}

// String returns the string representation
func (s Destination) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Destination) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Destination) MarshalFields(e protocol.FieldEncoder) error {
	if s.S3 != nil {
		v := s.S3

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "s3", v, metadata)
	}
	return nil
}

// The encryption algorithm options that are available to an AWS Signer job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/EncryptionAlgorithmOptions
type EncryptionAlgorithmOptions struct {
	_ struct{} `type:"structure"`

	// The set of accepted encryption algorithms that are allowed in an AWS Signer
	// job.
	//
	// AllowedValues is a required field
	AllowedValues []EncryptionAlgorithm `locationName:"allowedValues" type:"list" required:"true"`

	// The default encryption algorithm that is used by an AWS Signer job.
	//
	// DefaultValue is a required field
	DefaultValue EncryptionAlgorithm `locationName:"defaultValue" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s EncryptionAlgorithmOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionAlgorithmOptions) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EncryptionAlgorithmOptions) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AllowedValues) > 0 {
		v := s.AllowedValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "allowedValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.DefaultValue) > 0 {
		v := s.DefaultValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultValue", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/GetSigningPlatformRequest
type GetSigningPlatformInput struct {
	_ struct{} `type:"structure"`

	// The ID of the target signing platform.
	//
	// PlatformId is a required field
	PlatformId *string `location:"uri" locationName:"platformId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetSigningPlatformInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSigningPlatformInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSigningPlatformInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSigningPlatformInput"}

	if s.PlatformId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PlatformId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSigningPlatformInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.PlatformId != nil {
		v := *s.PlatformId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "platformId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/GetSigningPlatformResponse
type GetSigningPlatformOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The category type of the target signing platform.
	Category Category `locationName:"category" type:"string" enum:"true"`

	// The display name of the target signing platform.
	DisplayName *string `locationName:"displayName" type:"string"`

	// The maximum size (in MB) of the payload that can be signed by the target
	// platform.
	MaxSizeInMB *int64 `locationName:"maxSizeInMB" type:"integer"`

	// A list of partner entities that use the target signing platform.
	Partner *string `locationName:"partner" type:"string"`

	// The ID of the target signing platform.
	PlatformId *string `locationName:"platformId" type:"string"`

	// A list of configurations applied to the target platform at signing.
	SigningConfiguration *SigningConfiguration `locationName:"signingConfiguration" type:"structure"`

	// The format of the target platform's signing image.
	SigningImageFormat *SigningImageFormat `locationName:"signingImageFormat" type:"structure"`

	// The validation template that is used by the target signing platform.
	Target *string `locationName:"target" type:"string"`
}

// String returns the string representation
func (s GetSigningPlatformOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSigningPlatformOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSigningPlatformOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSigningPlatformOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Category) > 0 {
		v := s.Category

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "category", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DisplayName != nil {
		v := *s.DisplayName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "displayName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxSizeInMB != nil {
		v := *s.MaxSizeInMB

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxSizeInMB", protocol.Int64Value(v), metadata)
	}
	if s.Partner != nil {
		v := *s.Partner

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "partner", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PlatformId != nil {
		v := *s.PlatformId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "platformId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SigningConfiguration != nil {
		v := s.SigningConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingConfiguration", v, metadata)
	}
	if s.SigningImageFormat != nil {
		v := s.SigningImageFormat

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingImageFormat", v, metadata)
	}
	if s.Target != nil {
		v := *s.Target

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "target", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/GetSigningProfileRequest
type GetSigningProfileInput struct {
	_ struct{} `type:"structure"`

	// The name of the target signing profile.
	//
	// ProfileName is a required field
	ProfileName *string `location:"uri" locationName:"profileName" min:"2" type:"string" required:"true"`
}

// String returns the string representation
func (s GetSigningProfileInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSigningProfileInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSigningProfileInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSigningProfileInput"}

	if s.ProfileName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ProfileName"))
	}
	if s.ProfileName != nil && len(*s.ProfileName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("ProfileName", 2))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSigningProfileInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ProfileName != nil {
		v := *s.ProfileName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "profileName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/GetSigningProfileResponse
type GetSigningProfileOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of overrides applied by the target signing profile for signing operations.
	Overrides *SigningPlatformOverrides `locationName:"overrides" type:"structure"`

	// The ID of the platform that is used by the target signing profile.
	PlatformId *string `locationName:"platformId" type:"string"`

	// The name of the target signing profile.
	ProfileName *string `locationName:"profileName" min:"2" type:"string"`

	// The ARN of the certificate that the target profile uses for signing operations.
	SigningMaterial *SigningMaterial `locationName:"signingMaterial" type:"structure"`

	// A map of key-value pairs for signing operations that is attached to the target
	// signing profile.
	SigningParameters map[string]string `locationName:"signingParameters" type:"map"`

	// The status of the target signing profile.
	Status SigningProfileStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s GetSigningProfileOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSigningProfileOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSigningProfileOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSigningProfileOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Overrides != nil {
		v := s.Overrides

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "overrides", v, metadata)
	}
	if s.PlatformId != nil {
		v := *s.PlatformId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "platformId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProfileName != nil {
		v := *s.ProfileName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "profileName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SigningMaterial != nil {
		v := s.SigningMaterial

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingMaterial", v, metadata)
	}
	if len(s.SigningParameters) > 0 {
		v := s.SigningParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "signingParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The hash algorithms that are available to an AWS Signer job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/HashAlgorithmOptions
type HashAlgorithmOptions struct {
	_ struct{} `type:"structure"`

	// The set of accepted hash algorithms allowed in an AWS Signer job.
	//
	// AllowedValues is a required field
	AllowedValues []HashAlgorithm `locationName:"allowedValues" type:"list" required:"true"`

	// The default hash algorithm that is used in an AWS Signer job.
	//
	// DefaultValue is a required field
	DefaultValue HashAlgorithm `locationName:"defaultValue" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s HashAlgorithmOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HashAlgorithmOptions) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HashAlgorithmOptions) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AllowedValues) > 0 {
		v := s.AllowedValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "allowedValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.DefaultValue) > 0 {
		v := s.DefaultValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultValue", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningJobsRequest
type ListSigningJobsInput struct {
	_ struct{} `type:"structure"`

	// Specifies the maximum number of items to return in the response. Use this
	// parameter when paginating results. If additional items exist beyond the number
	// you specify, the nextToken element is set in the response. Use the nextToken
	// value in a subsequent request to retrieve additional items.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// String for specifying the next set of paginated results to return. After
	// you receive a response with truncated results, use this parameter in a subsequent
	// request. Set it to the value of nextToken from the response that you just
	// received.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The ID of microcontroller platform that you specified for the distribution
	// of your code image.
	PlatformId *string `location:"querystring" locationName:"platformId" type:"string"`

	// The IAM principal that requested the signing job.
	RequestedBy *string `location:"querystring" locationName:"requestedBy" type:"string"`

	// A status value with which to filter your results.
	Status SigningStatus `location:"querystring" locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListSigningJobsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListSigningJobsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListSigningJobsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListSigningJobsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListSigningJobsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PlatformId != nil {
		v := *s.PlatformId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "platformId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RequestedBy != nil {
		v := *s.RequestedBy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "requestedBy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningJobsResponse
type ListSigningJobsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of your signing jobs.
	Jobs []SigningJob `locationName:"jobs" type:"list"`

	// String for specifying the next set of paginated results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListSigningJobsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListSigningJobsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListSigningJobsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListSigningJobsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Jobs) > 0 {
		v := s.Jobs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "jobs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningPlatformsRequest
type ListSigningPlatformsInput struct {
	_ struct{} `type:"structure"`

	// The category type of a signing platform.
	Category *string `location:"querystring" locationName:"category" type:"string"`

	// The maximum number of results to be returned by this operation.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// Value for specifying the next set of paginated results to return. After you
	// receive a response with truncated results, use this parameter in a subsequent
	// request. Set it to the value of nextToken from the response that you just
	// received.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// Any partner entities connected to a signing platform.
	Partner *string `location:"querystring" locationName:"partner" type:"string"`

	// The validation template that is used by the target signing platform.
	Target *string `location:"querystring" locationName:"target" type:"string"`
}

// String returns the string representation
func (s ListSigningPlatformsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListSigningPlatformsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListSigningPlatformsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListSigningPlatformsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListSigningPlatformsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Category != nil {
		v := *s.Category

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "category", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Partner != nil {
		v := *s.Partner

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "partner", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Target != nil {
		v := *s.Target

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "target", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningPlatformsResponse
type ListSigningPlatformsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Value for specifying the next set of paginated results to return.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A list of all platforms that match the request parameters.
	Platforms []SigningPlatform `locationName:"platforms" type:"list"`
}

// String returns the string representation
func (s ListSigningPlatformsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListSigningPlatformsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListSigningPlatformsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListSigningPlatformsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Platforms) > 0 {
		v := s.Platforms

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "platforms", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningProfilesRequest
type ListSigningProfilesInput struct {
	_ struct{} `type:"structure"`

	// Designates whether to include profiles with the status of CANCELED.
	IncludeCanceled *bool `location:"querystring" locationName:"includeCanceled" type:"boolean"`

	// The maximum number of profiles to be returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	// Value for specifying the next set of paginated results to return. After you
	// receive a response with truncated results, use this parameter in a subsequent
	// request. Set it to the value of nextToken from the response that you just
	// received.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListSigningProfilesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListSigningProfilesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListSigningProfilesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListSigningProfilesInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListSigningProfilesInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.IncludeCanceled != nil {
		v := *s.IncludeCanceled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "includeCanceled", protocol.BoolValue(v), metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/ListSigningProfilesResponse
type ListSigningProfilesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Value for specifying the next set of paginated results to return.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A list of profiles that are available in the AWS account. This includes profiles
	// with the status of CANCELED if the includeCanceled parameter is set to true.
	Profiles []SigningProfile `locationName:"profiles" type:"list"`
}

// String returns the string representation
func (s ListSigningProfilesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListSigningProfilesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListSigningProfilesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListSigningProfilesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Profiles) > 0 {
		v := s.Profiles

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "profiles", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/PutSigningProfileRequest
type PutSigningProfileInput struct {
	_ struct{} `type:"structure"`

	// A subfield of platform. This specifies any different configuration options
	// that you want to apply to the chosen platform (such as a different hash-algorithm
	// or signing-algorithm).
	Overrides *SigningPlatformOverrides `locationName:"overrides" type:"structure"`

	// The ID of the signing profile to be created.
	//
	// PlatformId is a required field
	PlatformId *string `locationName:"platformId" type:"string" required:"true"`

	// The name of the signing profile to be created.
	//
	// ProfileName is a required field
	ProfileName *string `location:"uri" locationName:"profileName" min:"2" type:"string" required:"true"`

	// The AWS Certificate Manager certificate that will be used to sign code with
	// the new signing profile.
	//
	// SigningMaterial is a required field
	SigningMaterial *SigningMaterial `locationName:"signingMaterial" type:"structure" required:"true"`

	// Map of key-value pairs for signing. These can include any information that
	// you want to use during signing.
	SigningParameters map[string]string `locationName:"signingParameters" type:"map"`
}

// String returns the string representation
func (s PutSigningProfileInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutSigningProfileInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutSigningProfileInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutSigningProfileInput"}

	if s.PlatformId == nil {
		invalidParams.Add(aws.NewErrParamRequired("PlatformId"))
	}

	if s.ProfileName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ProfileName"))
	}
	if s.ProfileName != nil && len(*s.ProfileName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("ProfileName", 2))
	}

	if s.SigningMaterial == nil {
		invalidParams.Add(aws.NewErrParamRequired("SigningMaterial"))
	}
	if s.SigningMaterial != nil {
		if err := s.SigningMaterial.Validate(); err != nil {
			invalidParams.AddNested("SigningMaterial", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutSigningProfileInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Overrides != nil {
		v := s.Overrides

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "overrides", v, metadata)
	}
	if s.PlatformId != nil {
		v := *s.PlatformId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "platformId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SigningMaterial != nil {
		v := s.SigningMaterial

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingMaterial", v, metadata)
	}
	if len(s.SigningParameters) > 0 {
		v := s.SigningParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "signingParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.ProfileName != nil {
		v := *s.ProfileName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "profileName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/PutSigningProfileResponse
type PutSigningProfileOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Resource Name (ARN) of the signing profile created.
	Arn *string `locationName:"arn" type:"string"`
}

// String returns the string representation
func (s PutSigningProfileOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutSigningProfileOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutSigningProfileOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutSigningProfileOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The name and prefix of the S3 bucket where AWS Signer saves your signed objects.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/S3Destination
type S3Destination struct {
	_ struct{} `type:"structure"`

	// Name of the S3 bucket.
	BucketName *string `locationName:"bucketName" type:"string"`

	// An Amazon S3 prefix that you can use to limit responses to those that begin
	// with the specified prefix.
	Prefix *string `locationName:"prefix" type:"string"`
}

// String returns the string representation
func (s S3Destination) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s S3Destination) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Destination) MarshalFields(e protocol.FieldEncoder) error {
	if s.BucketName != nil {
		v := *s.BucketName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "bucketName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "prefix", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The S3 bucket name and key where AWS Signer saved your signed code image.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/S3SignedObject
type S3SignedObject struct {
	_ struct{} `type:"structure"`

	// Name of the S3 bucket.
	BucketName *string `locationName:"bucketName" type:"string"`

	// Key name that uniquely identifies a signed code image in your bucket.
	Key *string `locationName:"key" type:"string"`
}

// String returns the string representation
func (s S3SignedObject) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s S3SignedObject) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3SignedObject) MarshalFields(e protocol.FieldEncoder) error {
	if s.BucketName != nil {
		v := *s.BucketName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "bucketName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about the S3 bucket where you saved your unsigned code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/S3Source
type S3Source struct {
	_ struct{} `type:"structure"`

	// Name of the S3 bucket.
	//
	// BucketName is a required field
	BucketName *string `locationName:"bucketName" type:"string" required:"true"`

	// Key name of the bucket object that contains your unsigned code.
	//
	// Key is a required field
	Key *string `locationName:"key" type:"string" required:"true"`

	// Version of your source image in your version enabled S3 bucket.
	//
	// Version is a required field
	Version *string `locationName:"version" type:"string" required:"true"`
}

// String returns the string representation
func (s S3Source) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s S3Source) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Source) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Source"}

	if s.BucketName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BucketName"))
	}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Source) MarshalFields(e protocol.FieldEncoder) error {
	if s.BucketName != nil {
		v := *s.BucketName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "bucketName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Points to an S3SignedObject object that contains information about your signed
// code image.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SignedObject
type SignedObject struct {
	_ struct{} `type:"structure"`

	// The S3SignedObject.
	S3 *S3SignedObject `locationName:"s3" type:"structure"`
}

// String returns the string representation
func (s SignedObject) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SignedObject) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SignedObject) MarshalFields(e protocol.FieldEncoder) error {
	if s.S3 != nil {
		v := s.S3

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "s3", v, metadata)
	}
	return nil
}

// The configuration of an AWS Signer operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SigningConfiguration
type SigningConfiguration struct {
	_ struct{} `type:"structure"`

	// The encryption algorithm options that are available for an AWS Signer job.
	//
	// EncryptionAlgorithmOptions is a required field
	EncryptionAlgorithmOptions *EncryptionAlgorithmOptions `locationName:"encryptionAlgorithmOptions" type:"structure" required:"true"`

	// The hash algorithm options that are available for an AWS Signer job.
	//
	// HashAlgorithmOptions is a required field
	HashAlgorithmOptions *HashAlgorithmOptions `locationName:"hashAlgorithmOptions" type:"structure" required:"true"`
}

// String returns the string representation
func (s SigningConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SigningConfiguration) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SigningConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.EncryptionAlgorithmOptions != nil {
		v := s.EncryptionAlgorithmOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "encryptionAlgorithmOptions", v, metadata)
	}
	if s.HashAlgorithmOptions != nil {
		v := s.HashAlgorithmOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "hashAlgorithmOptions", v, metadata)
	}
	return nil
}

// A signing configuration that overrides the default encryption or hash algorithm
// of a signing job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SigningConfigurationOverrides
type SigningConfigurationOverrides struct {
	_ struct{} `type:"structure"`

	// A specified override of the default encryption algorithm that is used in
	// an AWS Signer job.
	EncryptionAlgorithm EncryptionAlgorithm `locationName:"encryptionAlgorithm" type:"string" enum:"true"`

	// A specified override of the default hash algorithm that is used in an AWS
	// Signer job.
	HashAlgorithm HashAlgorithm `locationName:"hashAlgorithm" type:"string" enum:"true"`
}

// String returns the string representation
func (s SigningConfigurationOverrides) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SigningConfigurationOverrides) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SigningConfigurationOverrides) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.EncryptionAlgorithm) > 0 {
		v := s.EncryptionAlgorithm

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "encryptionAlgorithm", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.HashAlgorithm) > 0 {
		v := s.HashAlgorithm

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hashAlgorithm", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The image format of an AWS Signer platform or profile.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SigningImageFormat
type SigningImageFormat struct {
	_ struct{} `type:"structure"`

	// The default format of an AWS Signer signing image.
	//
	// DefaultFormat is a required field
	DefaultFormat ImageFormat `locationName:"defaultFormat" type:"string" required:"true" enum:"true"`

	// The supported formats of an AWS Signer signing image.
	//
	// SupportedFormats is a required field
	SupportedFormats []ImageFormat `locationName:"supportedFormats" type:"list" required:"true"`
}

// String returns the string representation
func (s SigningImageFormat) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SigningImageFormat) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SigningImageFormat) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DefaultFormat) > 0 {
		v := s.DefaultFormat

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultFormat", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.SupportedFormats) > 0 {
		v := s.SupportedFormats

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "supportedFormats", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Contains information about a signing job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SigningJob
type SigningJob struct {
	_ struct{} `type:"structure"`

	// The date and time that the signing job was created.
	CreatedAt *time.Time `locationName:"createdAt" type:"timestamp" timestampFormat:"unix"`

	// The ID of the signing job.
	JobId *string `locationName:"jobId" type:"string"`

	// A SignedObject structure that contains information about a signing job's
	// signed code image.
	SignedObject *SignedObject `locationName:"signedObject" type:"structure"`

	// A SigningMaterial object that contains the Amazon Resource Name (ARN) of
	// the certificate used for the signing job.
	SigningMaterial *SigningMaterial `locationName:"signingMaterial" type:"structure"`

	// A Source that contains information about a signing job's code image source.
	Source *Source `locationName:"source" type:"structure"`

	// The status of the signing job.
	Status SigningStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s SigningJob) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SigningJob) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SigningJob) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SignedObject != nil {
		v := s.SignedObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signedObject", v, metadata)
	}
	if s.SigningMaterial != nil {
		v := s.SigningMaterial

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingMaterial", v, metadata)
	}
	if s.Source != nil {
		v := s.Source

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "source", v, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The ACM certificate that is used to sign your code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SigningMaterial
type SigningMaterial struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the certificates that is used to sign your
	// code.
	//
	// CertificateArn is a required field
	CertificateArn *string `locationName:"certificateArn" type:"string" required:"true"`
}

// String returns the string representation
func (s SigningMaterial) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SigningMaterial) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SigningMaterial) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SigningMaterial"}

	if s.CertificateArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("CertificateArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SigningMaterial) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains information about the signing configurations and parameters that
// is used to perform an AWS Signer job.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SigningPlatform
type SigningPlatform struct {
	_ struct{} `type:"structure"`

	// The category of an AWS Signer platform.
	Category Category `locationName:"category" type:"string" enum:"true"`

	// The display name of an AWS Signer platform.
	DisplayName *string `locationName:"displayName" type:"string"`

	// The maximum size (in MB) of code that can be signed by a AWS Signer platform.
	MaxSizeInMB *int64 `locationName:"maxSizeInMB" type:"integer"`

	// Any partner entities linked to an AWS Signer platform.
	Partner *string `locationName:"partner" type:"string"`

	// The ID of an AWS Signer platform.
	PlatformId *string `locationName:"platformId" type:"string"`

	// The configuration of an AWS Signer platform. This includes the designated
	// hash algorithm and encryption algorithm of a signing platform.
	SigningConfiguration *SigningConfiguration `locationName:"signingConfiguration" type:"structure"`

	// The signing image format that is used by an AWS Signer platform.
	SigningImageFormat *SigningImageFormat `locationName:"signingImageFormat" type:"structure"`

	// The types of targets that can be signed by an AWS Signer platform.
	Target *string `locationName:"target" type:"string"`
}

// String returns the string representation
func (s SigningPlatform) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SigningPlatform) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SigningPlatform) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Category) > 0 {
		v := s.Category

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "category", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DisplayName != nil {
		v := *s.DisplayName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "displayName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxSizeInMB != nil {
		v := *s.MaxSizeInMB

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxSizeInMB", protocol.Int64Value(v), metadata)
	}
	if s.Partner != nil {
		v := *s.Partner

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "partner", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PlatformId != nil {
		v := *s.PlatformId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "platformId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SigningConfiguration != nil {
		v := s.SigningConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingConfiguration", v, metadata)
	}
	if s.SigningImageFormat != nil {
		v := s.SigningImageFormat

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingImageFormat", v, metadata)
	}
	if s.Target != nil {
		v := *s.Target

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "target", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Any overrides that are applied to the signing configuration of an AWS Signer
// platform.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SigningPlatformOverrides
type SigningPlatformOverrides struct {
	_ struct{} `type:"structure"`

	// A signing configuration that overrides the default encryption or hash algorithm
	// of a signing job.
	SigningConfiguration *SigningConfigurationOverrides `locationName:"signingConfiguration" type:"structure"`
}

// String returns the string representation
func (s SigningPlatformOverrides) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SigningPlatformOverrides) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SigningPlatformOverrides) MarshalFields(e protocol.FieldEncoder) error {
	if s.SigningConfiguration != nil {
		v := s.SigningConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingConfiguration", v, metadata)
	}
	return nil
}

// Contains information about the ACM certificates and AWS Signer configuration
// parameters that can be used by a given AWS Signer user.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/SigningProfile
type SigningProfile struct {
	_ struct{} `type:"structure"`

	// The ID of a platform that is available for use by a signing profile.
	PlatformId *string `locationName:"platformId" type:"string"`

	// The name of the AWS Signer profile.
	ProfileName *string `locationName:"profileName" min:"2" type:"string"`

	// The ACM certificate that is available for use by a signing profile.
	SigningMaterial *SigningMaterial `locationName:"signingMaterial" type:"structure"`

	// The parameters that are available for use by an AWS Signer user.
	SigningParameters map[string]string `locationName:"signingParameters" type:"map"`

	// The status of an AWS Signer profile.
	Status SigningProfileStatus `locationName:"status" type:"string" enum:"true"`
}

// String returns the string representation
func (s SigningProfile) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SigningProfile) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SigningProfile) MarshalFields(e protocol.FieldEncoder) error {
	if s.PlatformId != nil {
		v := *s.PlatformId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "platformId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProfileName != nil {
		v := *s.ProfileName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "profileName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SigningMaterial != nil {
		v := s.SigningMaterial

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "signingMaterial", v, metadata)
	}
	if len(s.SigningParameters) > 0 {
		v := s.SigningParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "signingParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// An S3Source object that contains information about the S3 bucket where you
// saved your unsigned code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/Source
type Source struct {
	_ struct{} `type:"structure"`

	// The S3Source object.
	S3 *S3Source `locationName:"s3" type:"structure"`
}

// String returns the string representation
func (s Source) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Source) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Source) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Source"}
	if s.S3 != nil {
		if err := s.S3.Validate(); err != nil {
			invalidParams.AddNested("S3", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Source) MarshalFields(e protocol.FieldEncoder) error {
	if s.S3 != nil {
		v := s.S3

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "s3", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/StartSigningJobRequest
type StartSigningJobInput struct {
	_ struct{} `type:"structure"`

	// String that identifies the signing request. All calls after the first that
	// use this token return the same response as the first call.
	//
	// ClientRequestToken is a required field
	ClientRequestToken *string `locationName:"clientRequestToken" type:"string" required:"true" idempotencyToken:"true"`

	// The S3 bucket in which to save your signed object. The destination contains
	// the name of your bucket and an optional prefix.
	//
	// Destination is a required field
	Destination *Destination `locationName:"destination" type:"structure" required:"true"`

	// The name of the signing profile.
	ProfileName *string `locationName:"profileName" min:"2" type:"string"`

	// The S3 bucket that contains the object to sign or a BLOB that contains your
	// raw code.
	//
	// Source is a required field
	Source *Source `locationName:"source" type:"structure" required:"true"`
}

// String returns the string representation
func (s StartSigningJobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartSigningJobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartSigningJobInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartSigningJobInput"}

	if s.ClientRequestToken == nil {
		invalidParams.Add(aws.NewErrParamRequired("ClientRequestToken"))
	}

	if s.Destination == nil {
		invalidParams.Add(aws.NewErrParamRequired("Destination"))
	}
	if s.ProfileName != nil && len(*s.ProfileName) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("ProfileName", 2))
	}

	if s.Source == nil {
		invalidParams.Add(aws.NewErrParamRequired("Source"))
	}
	if s.Source != nil {
		if err := s.Source.Validate(); err != nil {
			invalidParams.AddNested("Source", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartSigningJobInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	var ClientRequestToken string
	if s.ClientRequestToken != nil {
		ClientRequestToken = *s.ClientRequestToken
	} else {
		ClientRequestToken = protocol.GetIdempotencyToken()
	}
	{
		v := ClientRequestToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "clientRequestToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Destination != nil {
		v := s.Destination

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "destination", v, metadata)
	}
	if s.ProfileName != nil {
		v := *s.ProfileName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "profileName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Source != nil {
		v := s.Source

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "source", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/signer-2017-08-25/StartSigningJobResponse
type StartSigningJobOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of your signing job.
	JobId *string `locationName:"jobId" type:"string"`
}

// String returns the string representation
func (s StartSigningJobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartSigningJobOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartSigningJobOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartSigningJobOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "jobId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type Category string

// Enum values for Category
const (
	CategoryAwsioT Category = "AWSIoT"
)

func (enum Category) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Category) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type EncryptionAlgorithm string

// Enum values for EncryptionAlgorithm
const (
	EncryptionAlgorithmRsa   EncryptionAlgorithm = "RSA"
	EncryptionAlgorithmEcdsa EncryptionAlgorithm = "ECDSA"
)

func (enum EncryptionAlgorithm) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EncryptionAlgorithm) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type HashAlgorithm string

// Enum values for HashAlgorithm
const (
	HashAlgorithmSha1   HashAlgorithm = "SHA1"
	HashAlgorithmSha256 HashAlgorithm = "SHA256"
)

func (enum HashAlgorithm) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum HashAlgorithm) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ImageFormat string

// Enum values for ImageFormat
const (
	ImageFormatJson ImageFormat = "JSON"
)

func (enum ImageFormat) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ImageFormat) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SigningProfileStatus string

// Enum values for SigningProfileStatus
const (
	SigningProfileStatusActive   SigningProfileStatus = "Active"
	SigningProfileStatusCanceled SigningProfileStatus = "Canceled"
)

func (enum SigningProfileStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SigningProfileStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SigningStatus string

// Enum values for SigningStatus
const (
	SigningStatusInProgress SigningStatus = "InProgress"
	SigningStatusFailed     SigningStatus = "Failed"
	SigningStatusSucceeded  SigningStatus = "Succeeded"
)

func (enum SigningStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SigningStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
