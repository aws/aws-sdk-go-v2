// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package xray

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

const opBatchGetTraces = "BatchGetTraces"

// BatchGetTracesRequest is a API request type for the BatchGetTraces API operation.
type BatchGetTracesRequest struct {
	*aws.Request
	Input *BatchGetTracesInput
	Copy  func(*BatchGetTracesInput) BatchGetTracesRequest
}

// Send marshals and sends the BatchGetTraces API request.
func (r BatchGetTracesRequest) Send() (*BatchGetTracesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*BatchGetTracesOutput), nil
}

// BatchGetTracesRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves a list of traces specified by ID. Each trace is a collection of
// segment documents that originates from a single request. Use GetTraceSummaries
// to get a list of trace IDs.
//
//    // Example sending a request using the BatchGetTracesRequest method.
//    req := client.BatchGetTracesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/BatchGetTraces
func (c *XRay) BatchGetTracesRequest(input *BatchGetTracesInput) BatchGetTracesRequest {
	op := &aws.Operation{
		Name:       opBatchGetTraces,
		HTTPMethod: "POST",
		HTTPPath:   "/Traces",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &BatchGetTracesInput{}
	}

	output := &BatchGetTracesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return BatchGetTracesRequest{Request: req, Input: input, Copy: c.BatchGetTracesRequest}
}

// Paginate pages iterates over the pages of a BatchGetTracesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a BatchGetTraces operation.
//		req := client.BatchGetTracesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *BatchGetTracesRequest) Paginate(opts ...aws.Option) BatchGetTracesPager {
	return BatchGetTracesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *BatchGetTracesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// BatchGetTracesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type BatchGetTracesPager struct {
	aws.Pager
}

func (p *BatchGetTracesPager) CurrentPage() *BatchGetTracesOutput {
	return p.Pager.CurrentPage().(*BatchGetTracesOutput)
}

const opGetEncryptionConfig = "GetEncryptionConfig"

// GetEncryptionConfigRequest is a API request type for the GetEncryptionConfig API operation.
type GetEncryptionConfigRequest struct {
	*aws.Request
	Input *GetEncryptionConfigInput
	Copy  func(*GetEncryptionConfigInput) GetEncryptionConfigRequest
}

// Send marshals and sends the GetEncryptionConfig API request.
func (r GetEncryptionConfigRequest) Send() (*GetEncryptionConfigOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetEncryptionConfigOutput), nil
}

// GetEncryptionConfigRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves the current encryption configuration for X-Ray data.
//
//    // Example sending a request using the GetEncryptionConfigRequest method.
//    req := client.GetEncryptionConfigRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetEncryptionConfig
func (c *XRay) GetEncryptionConfigRequest(input *GetEncryptionConfigInput) GetEncryptionConfigRequest {
	op := &aws.Operation{
		Name:       opGetEncryptionConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/EncryptionConfig",
	}

	if input == nil {
		input = &GetEncryptionConfigInput{}
	}

	output := &GetEncryptionConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetEncryptionConfigRequest{Request: req, Input: input, Copy: c.GetEncryptionConfigRequest}
}

const opGetServiceGraph = "GetServiceGraph"

// GetServiceGraphRequest is a API request type for the GetServiceGraph API operation.
type GetServiceGraphRequest struct {
	*aws.Request
	Input *GetServiceGraphInput
	Copy  func(*GetServiceGraphInput) GetServiceGraphRequest
}

// Send marshals and sends the GetServiceGraph API request.
func (r GetServiceGraphRequest) Send() (*GetServiceGraphOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetServiceGraphOutput), nil
}

// GetServiceGraphRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves a document that describes services that process incoming requests,
// and downstream services that they call as a result. Root services process
// incoming requests and make calls to downstream services. Root services are
// applications that use the AWS X-Ray SDK. Downstream services can be other
// applications, AWS resources, HTTP web APIs, or SQL databases.
//
//    // Example sending a request using the GetServiceGraphRequest method.
//    req := client.GetServiceGraphRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetServiceGraph
func (c *XRay) GetServiceGraphRequest(input *GetServiceGraphInput) GetServiceGraphRequest {
	op := &aws.Operation{
		Name:       opGetServiceGraph,
		HTTPMethod: "POST",
		HTTPPath:   "/ServiceGraph",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetServiceGraphInput{}
	}

	output := &GetServiceGraphOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetServiceGraphRequest{Request: req, Input: input, Copy: c.GetServiceGraphRequest}
}

// Paginate pages iterates over the pages of a GetServiceGraphRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetServiceGraph operation.
//		req := client.GetServiceGraphRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetServiceGraphRequest) Paginate(opts ...aws.Option) GetServiceGraphPager {
	return GetServiceGraphPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetServiceGraphInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetServiceGraphPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetServiceGraphPager struct {
	aws.Pager
}

func (p *GetServiceGraphPager) CurrentPage() *GetServiceGraphOutput {
	return p.Pager.CurrentPage().(*GetServiceGraphOutput)
}

const opGetTraceGraph = "GetTraceGraph"

// GetTraceGraphRequest is a API request type for the GetTraceGraph API operation.
type GetTraceGraphRequest struct {
	*aws.Request
	Input *GetTraceGraphInput
	Copy  func(*GetTraceGraphInput) GetTraceGraphRequest
}

// Send marshals and sends the GetTraceGraph API request.
func (r GetTraceGraphRequest) Send() (*GetTraceGraphOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTraceGraphOutput), nil
}

// GetTraceGraphRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves a service graph for one or more specific trace IDs.
//
//    // Example sending a request using the GetTraceGraphRequest method.
//    req := client.GetTraceGraphRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceGraph
func (c *XRay) GetTraceGraphRequest(input *GetTraceGraphInput) GetTraceGraphRequest {
	op := &aws.Operation{
		Name:       opGetTraceGraph,
		HTTPMethod: "POST",
		HTTPPath:   "/TraceGraph",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetTraceGraphInput{}
	}

	output := &GetTraceGraphOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTraceGraphRequest{Request: req, Input: input, Copy: c.GetTraceGraphRequest}
}

// Paginate pages iterates over the pages of a GetTraceGraphRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetTraceGraph operation.
//		req := client.GetTraceGraphRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetTraceGraphRequest) Paginate(opts ...aws.Option) GetTraceGraphPager {
	return GetTraceGraphPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetTraceGraphInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetTraceGraphPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetTraceGraphPager struct {
	aws.Pager
}

func (p *GetTraceGraphPager) CurrentPage() *GetTraceGraphOutput {
	return p.Pager.CurrentPage().(*GetTraceGraphOutput)
}

const opGetTraceSummaries = "GetTraceSummaries"

// GetTraceSummariesRequest is a API request type for the GetTraceSummaries API operation.
type GetTraceSummariesRequest struct {
	*aws.Request
	Input *GetTraceSummariesInput
	Copy  func(*GetTraceSummariesInput) GetTraceSummariesRequest
}

// Send marshals and sends the GetTraceSummaries API request.
func (r GetTraceSummariesRequest) Send() (*GetTraceSummariesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTraceSummariesOutput), nil
}

// GetTraceSummariesRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves IDs and metadata for traces available for a specified time frame
// using an optional filter. To get the full traces, pass the trace IDs to BatchGetTraces.
//
// A filter expression can target traced requests that hit specific service
// nodes or edges, have errors, or come from a known user. For example, the
// following filter expression targets traces that pass through api.example.com:
//
// service("api.example.com")
//
// This filter expression finds traces that have an annotation named account
// with the value 12345:
//
// annotation.account = "12345"
//
// For a full list of indexed fields and keywords that you can use in filter
// expressions, see Using Filter Expressions (http://docs.aws.amazon.com/xray/latest/devguide/xray-console-filters.html)
// in the AWS X-Ray Developer Guide.
//
//    // Example sending a request using the GetTraceSummariesRequest method.
//    req := client.GetTraceSummariesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceSummaries
func (c *XRay) GetTraceSummariesRequest(input *GetTraceSummariesInput) GetTraceSummariesRequest {
	op := &aws.Operation{
		Name:       opGetTraceSummaries,
		HTTPMethod: "POST",
		HTTPPath:   "/TraceSummaries",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetTraceSummariesInput{}
	}

	output := &GetTraceSummariesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTraceSummariesRequest{Request: req, Input: input, Copy: c.GetTraceSummariesRequest}
}

// Paginate pages iterates over the pages of a GetTraceSummariesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetTraceSummaries operation.
//		req := client.GetTraceSummariesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetTraceSummariesRequest) Paginate(opts ...aws.Option) GetTraceSummariesPager {
	return GetTraceSummariesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetTraceSummariesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetTraceSummariesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetTraceSummariesPager struct {
	aws.Pager
}

func (p *GetTraceSummariesPager) CurrentPage() *GetTraceSummariesOutput {
	return p.Pager.CurrentPage().(*GetTraceSummariesOutput)
}

const opPutEncryptionConfig = "PutEncryptionConfig"

// PutEncryptionConfigRequest is a API request type for the PutEncryptionConfig API operation.
type PutEncryptionConfigRequest struct {
	*aws.Request
	Input *PutEncryptionConfigInput
	Copy  func(*PutEncryptionConfigInput) PutEncryptionConfigRequest
}

// Send marshals and sends the PutEncryptionConfig API request.
func (r PutEncryptionConfigRequest) Send() (*PutEncryptionConfigOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutEncryptionConfigOutput), nil
}

// PutEncryptionConfigRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Updates the encryption configuration for X-Ray data.
//
//    // Example sending a request using the PutEncryptionConfigRequest method.
//    req := client.PutEncryptionConfigRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutEncryptionConfig
func (c *XRay) PutEncryptionConfigRequest(input *PutEncryptionConfigInput) PutEncryptionConfigRequest {
	op := &aws.Operation{
		Name:       opPutEncryptionConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/PutEncryptionConfig",
	}

	if input == nil {
		input = &PutEncryptionConfigInput{}
	}

	output := &PutEncryptionConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutEncryptionConfigRequest{Request: req, Input: input, Copy: c.PutEncryptionConfigRequest}
}

const opPutTelemetryRecords = "PutTelemetryRecords"

// PutTelemetryRecordsRequest is a API request type for the PutTelemetryRecords API operation.
type PutTelemetryRecordsRequest struct {
	*aws.Request
	Input *PutTelemetryRecordsInput
	Copy  func(*PutTelemetryRecordsInput) PutTelemetryRecordsRequest
}

// Send marshals and sends the PutTelemetryRecords API request.
func (r PutTelemetryRecordsRequest) Send() (*PutTelemetryRecordsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutTelemetryRecordsOutput), nil
}

// PutTelemetryRecordsRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Used by the AWS X-Ray daemon to upload telemetry.
//
//    // Example sending a request using the PutTelemetryRecordsRequest method.
//    req := client.PutTelemetryRecordsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTelemetryRecords
func (c *XRay) PutTelemetryRecordsRequest(input *PutTelemetryRecordsInput) PutTelemetryRecordsRequest {
	op := &aws.Operation{
		Name:       opPutTelemetryRecords,
		HTTPMethod: "POST",
		HTTPPath:   "/TelemetryRecords",
	}

	if input == nil {
		input = &PutTelemetryRecordsInput{}
	}

	output := &PutTelemetryRecordsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutTelemetryRecordsRequest{Request: req, Input: input, Copy: c.PutTelemetryRecordsRequest}
}

const opPutTraceSegments = "PutTraceSegments"

// PutTraceSegmentsRequest is a API request type for the PutTraceSegments API operation.
type PutTraceSegmentsRequest struct {
	*aws.Request
	Input *PutTraceSegmentsInput
	Copy  func(*PutTraceSegmentsInput) PutTraceSegmentsRequest
}

// Send marshals and sends the PutTraceSegments API request.
func (r PutTraceSegmentsRequest) Send() (*PutTraceSegmentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutTraceSegmentsOutput), nil
}

// PutTraceSegmentsRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Uploads segment documents to AWS X-Ray. The X-Ray SDK generates segment documents
// and sends them to the X-Ray daemon, which uploads them in batches. A segment
// document can be a completed segment, an in-progress segment, or an array
// of subsegments.
//
// Segments must include the following fields. For the full segment document
// schema, see AWS X-Ray Segment Documents (https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html)
// in the AWS X-Ray Developer Guide.
//
// Required Segment Document Fields
//
//    * name - The name of the service that handled the request.
//
//    * id - A 64-bit identifier for the segment, unique among segments in the
//    same trace, in 16 hexadecimal digits.
//
//    * trace_id - A unique identifier that connects all segments and subsegments
//    originating from a single client request.
//
//    * start_time - Time the segment or subsegment was created, in floating
//    point seconds in epoch time, accurate to milliseconds. For example, 1480615200.010
//    or 1.480615200010E9.
//
//    * end_time - Time the segment or subsegment was closed. For example, 1480615200.090
//    or 1.480615200090E9. Specify either an end_time or in_progress.
//
//    * in_progress - Set to true instead of specifying an end_time to record
//    that a segment has been started, but is not complete. Send an in progress
//    segment when your application receives a request that will take a long
//    time to serve, to trace the fact that the request was received. When the
//    response is sent, send the complete segment to overwrite the in-progress
//    segment.
//
// A trace_id consists of three numbers separated by hyphens. For example, 1-58406520-a006649127e371903a2de979.
// This includes:
//
// Trace ID Format
//
//    * The version number, i.e. 1.
//
//    * The time of the original request, in Unix epoch time, in 8 hexadecimal
//    digits. For example, 10:00AM December 2nd, 2016 PST in epoch time is 1480615200
//    seconds, or 58406520 in hexadecimal.
//
//    * A 96-bit identifier for the trace, globally unique, in 24 hexadecimal
//    digits.
//
//    // Example sending a request using the PutTraceSegmentsRequest method.
//    req := client.PutTraceSegmentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTraceSegments
func (c *XRay) PutTraceSegmentsRequest(input *PutTraceSegmentsInput) PutTraceSegmentsRequest {
	op := &aws.Operation{
		Name:       opPutTraceSegments,
		HTTPMethod: "POST",
		HTTPPath:   "/TraceSegments",
	}

	if input == nil {
		input = &PutTraceSegmentsInput{}
	}

	output := &PutTraceSegmentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutTraceSegmentsRequest{Request: req, Input: input, Copy: c.PutTraceSegmentsRequest}
}

// An alias for an edge.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Alias
type Alias struct {
	_ struct{} `type:"structure"`

	// The canonical name of the alias.
	Name *string `type:"string"`

	// A list of names for the alias, including the canonical name.
	Names []string `type:"list"`

	// The type of the alias.
	Type *string `type:"string"`
}

// String returns the string representation
func (s Alias) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Alias) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Alias) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Value of a segment annotation. Has one of three value types: Number, Boolean
// or String.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/AnnotationValue
type AnnotationValue struct {
	_ struct{} `type:"structure"`

	// Value for a Boolean annotation.
	BooleanValue *bool `type:"boolean"`

	// Value for a Number annotation.
	NumberValue *float64 `type:"double"`

	// Value for a String annotation.
	StringValue *string `type:"string"`
}

// String returns the string representation
func (s AnnotationValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AnnotationValue) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AnnotationValue) MarshalFields(e protocol.FieldEncoder) error {
	if s.BooleanValue != nil {
		v := *s.BooleanValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BooleanValue", protocol.BoolValue(v), metadata)
	}
	if s.NumberValue != nil {
		v := *s.NumberValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberValue", protocol.Float64Value(v), metadata)
	}
	if s.StringValue != nil {
		v := *s.StringValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StringValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/BackendConnectionErrors
type BackendConnectionErrors struct {
	_ struct{} `type:"structure"`

	ConnectionRefusedCount *int64 `type:"integer"`

	HTTPCode4XXCount *int64 `type:"integer"`

	HTTPCode5XXCount *int64 `type:"integer"`

	OtherCount *int64 `type:"integer"`

	TimeoutCount *int64 `type:"integer"`

	UnknownHostCount *int64 `type:"integer"`
}

// String returns the string representation
func (s BackendConnectionErrors) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BackendConnectionErrors) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BackendConnectionErrors) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConnectionRefusedCount != nil {
		v := *s.ConnectionRefusedCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ConnectionRefusedCount", protocol.Int64Value(v), metadata)
	}
	if s.HTTPCode4XXCount != nil {
		v := *s.HTTPCode4XXCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HTTPCode4XXCount", protocol.Int64Value(v), metadata)
	}
	if s.HTTPCode5XXCount != nil {
		v := *s.HTTPCode5XXCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HTTPCode5XXCount", protocol.Int64Value(v), metadata)
	}
	if s.OtherCount != nil {
		v := *s.OtherCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OtherCount", protocol.Int64Value(v), metadata)
	}
	if s.TimeoutCount != nil {
		v := *s.TimeoutCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TimeoutCount", protocol.Int64Value(v), metadata)
	}
	if s.UnknownHostCount != nil {
		v := *s.UnknownHostCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UnknownHostCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/BatchGetTracesRequest
type BatchGetTracesInput struct {
	_ struct{} `type:"structure"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// Specify the trace IDs of requests for which to retrieve segments.
	//
	// TraceIds is a required field
	TraceIds []string `type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetTracesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetTracesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetTracesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchGetTracesInput"}

	if s.TraceIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("TraceIds"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchGetTracesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TraceIds) > 0 {
		v := s.TraceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TraceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/BatchGetTracesResult
type BatchGetTracesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// Full traces for the specified requests.
	Traces []Trace `type:"list"`

	// Trace IDs of requests that haven't been processed.
	UnprocessedTraceIds []string `type:"list"`
}

// String returns the string representation
func (s BatchGetTracesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetTracesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s BatchGetTracesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchGetTracesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Traces) > 0 {
		v := s.Traces

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Traces", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.UnprocessedTraceIds) > 0 {
		v := s.UnprocessedTraceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UnprocessedTraceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Information about a connection between two services.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Edge
type Edge struct {
	_ struct{} `type:"structure"`

	// Aliases for the edge.
	Aliases []Alias `type:"list"`

	// The end time of the last segment on the edge.
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Identifier of the edge. Unique within a service map.
	ReferenceId *int64 `type:"integer"`

	// A histogram that maps the spread of client response times on an edge.
	ResponseTimeHistogram []HistogramEntry `type:"list"`

	// The start time of the first segment on the edge.
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Response statistics for segments on the edge.
	SummaryStatistics *EdgeStatistics `type:"structure"`
}

// String returns the string representation
func (s Edge) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Edge) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Edge) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Aliases) > 0 {
		v := s.Aliases

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Aliases", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ReferenceId != nil {
		v := *s.ReferenceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReferenceId", protocol.Int64Value(v), metadata)
	}
	if len(s.ResponseTimeHistogram) > 0 {
		v := s.ResponseTimeHistogram

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResponseTimeHistogram", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.SummaryStatistics != nil {
		v := s.SummaryStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SummaryStatistics", v, metadata)
	}
	return nil
}

// Response statistics for an edge.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/EdgeStatistics
type EdgeStatistics struct {
	_ struct{} `type:"structure"`

	// Information about requests that failed with a 4xx Client Error status code.
	ErrorStatistics *ErrorStatistics `type:"structure"`

	// Information about requests that failed with a 5xx Server Error status code.
	FaultStatistics *FaultStatistics `type:"structure"`

	// The number of requests that completed with a 2xx Success status code.
	OkCount *int64 `type:"long"`

	// The total number of completed requests.
	TotalCount *int64 `type:"long"`

	// The aggregate response time of completed requests.
	TotalResponseTime *float64 `type:"double"`
}

// String returns the string representation
func (s EdgeStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EdgeStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EdgeStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorStatistics != nil {
		v := s.ErrorStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ErrorStatistics", v, metadata)
	}
	if s.FaultStatistics != nil {
		v := s.FaultStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FaultStatistics", v, metadata)
	}
	if s.OkCount != nil {
		v := *s.OkCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OkCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalCount != nil {
		v := *s.TotalCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalResponseTime != nil {
		v := *s.TotalResponseTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalResponseTime", protocol.Float64Value(v), metadata)
	}
	return nil
}

// A configuration document that specifies encryption configuration settings.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/EncryptionConfig
type EncryptionConfig struct {
	_ struct{} `type:"structure"`

	// The ID of the customer master key (CMK) used for encryption, if applicable.
	KeyId *string `type:"string"`

	// The encryption status. After modifying encryption configuration with PutEncryptionConfig,
	// the status can be UPDATING for up to one hour before X-Ray starts encrypting
	// data with the new key.
	Status EncryptionStatus `type:"string" enum:"true"`

	// The type of encryption. Set to KMS for encryption with CMKs. Set to NONE
	// for default encryption.
	Type EncryptionType `type:"string" enum:"true"`
}

// String returns the string representation
func (s EncryptionConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionConfig) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EncryptionConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Information about requests that failed with a 4xx Client Error status code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ErrorStatistics
type ErrorStatistics struct {
	_ struct{} `type:"structure"`

	// The number of requests that failed with untracked 4xx Client Error status
	// codes.
	OtherCount *int64 `type:"long"`

	// The number of requests that failed with a 419 throttling status code.
	ThrottleCount *int64 `type:"long"`

	// The total number of requests that failed with a 4xx Client Error status code.
	TotalCount *int64 `type:"long"`
}

// String returns the string representation
func (s ErrorStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ErrorStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ErrorStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.OtherCount != nil {
		v := *s.OtherCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OtherCount", protocol.Int64Value(v), metadata)
	}
	if s.ThrottleCount != nil {
		v := *s.ThrottleCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ThrottleCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalCount != nil {
		v := *s.TotalCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Information about requests that failed with a 5xx Server Error status code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/FaultStatistics
type FaultStatistics struct {
	_ struct{} `type:"structure"`

	// The number of requests that failed with untracked 5xx Server Error status
	// codes.
	OtherCount *int64 `type:"long"`

	// The total number of requests that failed with a 5xx Server Error status code.
	TotalCount *int64 `type:"long"`
}

// String returns the string representation
func (s FaultStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FaultStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FaultStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.OtherCount != nil {
		v := *s.OtherCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OtherCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalCount != nil {
		v := *s.TotalCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetEncryptionConfigRequest
type GetEncryptionConfigInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetEncryptionConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetEncryptionConfigInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetEncryptionConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetEncryptionConfigResult
type GetEncryptionConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The encryption configuration document.
	EncryptionConfig *EncryptionConfig `type:"structure"`
}

// String returns the string representation
func (s GetEncryptionConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetEncryptionConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetEncryptionConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetEncryptionConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.EncryptionConfig != nil {
		v := s.EncryptionConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EncryptionConfig", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetServiceGraphRequest
type GetServiceGraphInput struct {
	_ struct{} `type:"structure"`

	// The end of the time frame for which to generate a graph.
	//
	// EndTime is a required field
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// The start of the time frame for which to generate a graph.
	//
	// StartTime is a required field
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`
}

// String returns the string representation
func (s GetServiceGraphInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetServiceGraphInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetServiceGraphInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetServiceGraphInput"}

	if s.EndTime == nil {
		invalidParams.Add(aws.NewErrParamRequired("EndTime"))
	}

	if s.StartTime == nil {
		invalidParams.Add(aws.NewErrParamRequired("StartTime"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetServiceGraphInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetServiceGraphResult
type GetServiceGraphOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The end of the time frame for which the graph was generated.
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// The services that have processed a traced request during the specified time
	// frame.
	Services []Service `type:"list"`

	// The start of the time frame for which the graph was generated.
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s GetServiceGraphOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetServiceGraphOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetServiceGraphOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetServiceGraphOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Services) > 0 {
		v := s.Services

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Services", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceGraphRequest
type GetTraceGraphInput struct {
	_ struct{} `type:"structure"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// Trace IDs of requests for which to generate a service graph.
	//
	// TraceIds is a required field
	TraceIds []string `type:"list" required:"true"`
}

// String returns the string representation
func (s GetTraceGraphInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTraceGraphInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTraceGraphInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTraceGraphInput"}

	if s.TraceIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("TraceIds"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTraceGraphInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TraceIds) > 0 {
		v := s.TraceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TraceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceGraphResult
type GetTraceGraphOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// The services that have processed one of the specified requests.
	Services []Service `type:"list"`
}

// String returns the string representation
func (s GetTraceGraphOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTraceGraphOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTraceGraphOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTraceGraphOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Services) > 0 {
		v := s.Services

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Services", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceSummariesRequest
type GetTraceSummariesInput struct {
	_ struct{} `type:"structure"`

	// The end of the time frame for which to retrieve traces.
	//
	// EndTime is a required field
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Specify a filter expression to retrieve trace summaries for services or requests
	// that meet certain requirements.
	FilterExpression *string `min:"1" type:"string"`

	// Specify the pagination token returned by a previous request to retrieve the
	// next page of results.
	NextToken *string `type:"string"`

	// Set to true to get summaries for only a subset of available traces.
	Sampling *bool `type:"boolean"`

	// The start of the time frame for which to retrieve traces.
	//
	// StartTime is a required field
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`
}

// String returns the string representation
func (s GetTraceSummariesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTraceSummariesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTraceSummariesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTraceSummariesInput"}

	if s.EndTime == nil {
		invalidParams.Add(aws.NewErrParamRequired("EndTime"))
	}
	if s.FilterExpression != nil && len(*s.FilterExpression) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FilterExpression", 1))
	}

	if s.StartTime == nil {
		invalidParams.Add(aws.NewErrParamRequired("StartTime"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTraceSummariesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.FilterExpression != nil {
		v := *s.FilterExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FilterExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Sampling != nil {
		v := *s.Sampling

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Sampling", protocol.BoolValue(v), metadata)
	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceSummariesResult
type GetTraceSummariesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The start time of this page of results.
	ApproximateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// If the requested time frame contained more than one page of results, you
	// can use this token to retrieve the next page. The first page contains the
	// most most recent results, closest to the end of the time frame.
	NextToken *string `type:"string"`

	// Trace IDs and metadata for traces that were found in the specified time frame.
	TraceSummaries []TraceSummary `type:"list"`

	// The total number of traces processed, including traces that did not match
	// the specified filter expression.
	TracesProcessedCount *int64 `type:"long"`
}

// String returns the string representation
func (s GetTraceSummariesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTraceSummariesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTraceSummariesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTraceSummariesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApproximateTime != nil {
		v := *s.ApproximateTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ApproximateTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TraceSummaries) > 0 {
		v := s.TraceSummaries

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TraceSummaries", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.TracesProcessedCount != nil {
		v := *s.TracesProcessedCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TracesProcessedCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// An entry in a histogram for a statistic. A histogram maps the range of observed
// values on the X axis, and the prevalence of each value on the Y axis.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/HistogramEntry
type HistogramEntry struct {
	_ struct{} `type:"structure"`

	// The prevalence of the entry.
	Count *int64 `type:"integer"`

	// The value of the entry.
	Value *float64 `type:"double"`
}

// String returns the string representation
func (s HistogramEntry) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HistogramEntry) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HistogramEntry) MarshalFields(e protocol.FieldEncoder) error {
	if s.Count != nil {
		v := *s.Count

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Count", protocol.Int64Value(v), metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.Float64Value(v), metadata)
	}
	return nil
}

// Information about an HTTP request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Http
type Http struct {
	_ struct{} `type:"structure"`

	// The IP address of the requestor.
	ClientIp *string `type:"string"`

	// The request method.
	HttpMethod *string `type:"string"`

	// The response status.
	HttpStatus *int64 `type:"integer"`

	// The request URL.
	HttpURL *string `type:"string"`

	// The request's user agent string.
	UserAgent *string `type:"string"`
}

// String returns the string representation
func (s Http) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Http) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Http) MarshalFields(e protocol.FieldEncoder) error {
	if s.ClientIp != nil {
		v := *s.ClientIp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ClientIp", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpMethod", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpStatus != nil {
		v := *s.HttpStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpStatus", protocol.Int64Value(v), metadata)
	}
	if s.HttpURL != nil {
		v := *s.HttpURL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpURL", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserAgent != nil {
		v := *s.UserAgent

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UserAgent", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutEncryptionConfigRequest
type PutEncryptionConfigInput struct {
	_ struct{} `type:"structure"`

	// An AWS KMS customer master key (CMK) in one of the following formats:
	//
	//    * Alias - The name of the key. For example, alias/MyKey.
	//
	//    * Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456.
	//
	//    * ARN - The full Amazon Resource Name of the key ID or alias. For example,
	//    arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456.
	//    Use this format to specify a key in a different account.
	//
	// Omit this key if you set Type to NONE.
	KeyId *string `min:"1" type:"string"`

	// The type of encryption. Set to KMS to use your own key for encryption. Set
	// to NONE for default encryption.
	//
	// Type is a required field
	Type EncryptionType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s PutEncryptionConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutEncryptionConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutEncryptionConfigInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutEncryptionConfigInput"}
	if s.KeyId != nil && len(*s.KeyId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("KeyId", 1))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutEncryptionConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutEncryptionConfigResult
type PutEncryptionConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The new encryption configuration.
	EncryptionConfig *EncryptionConfig `type:"structure"`
}

// String returns the string representation
func (s PutEncryptionConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutEncryptionConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutEncryptionConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutEncryptionConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.EncryptionConfig != nil {
		v := s.EncryptionConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EncryptionConfig", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTelemetryRecordsRequest
type PutTelemetryRecordsInput struct {
	_ struct{} `type:"structure"`

	EC2InstanceId *string `type:"string"`

	Hostname *string `type:"string"`

	ResourceARN *string `type:"string"`

	// TelemetryRecords is a required field
	TelemetryRecords []TelemetryRecord `type:"list" required:"true"`
}

// String returns the string representation
func (s PutTelemetryRecordsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutTelemetryRecordsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutTelemetryRecordsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutTelemetryRecordsInput"}

	if s.TelemetryRecords == nil {
		invalidParams.Add(aws.NewErrParamRequired("TelemetryRecords"))
	}
	if s.TelemetryRecords != nil {
		for i, v := range s.TelemetryRecords {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TelemetryRecords", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutTelemetryRecordsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.EC2InstanceId != nil {
		v := *s.EC2InstanceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EC2InstanceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Hostname != nil {
		v := *s.Hostname

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Hostname", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceARN != nil {
		v := *s.ResourceARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TelemetryRecords) > 0 {
		v := s.TelemetryRecords

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TelemetryRecords", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTelemetryRecordsResult
type PutTelemetryRecordsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s PutTelemetryRecordsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutTelemetryRecordsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutTelemetryRecordsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutTelemetryRecordsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTraceSegmentsRequest
type PutTraceSegmentsInput struct {
	_ struct{} `type:"structure"`

	// A string containing a JSON document defining one or more segments or subsegments.
	//
	// TraceSegmentDocuments is a required field
	TraceSegmentDocuments []string `type:"list" required:"true"`
}

// String returns the string representation
func (s PutTraceSegmentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutTraceSegmentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutTraceSegmentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutTraceSegmentsInput"}

	if s.TraceSegmentDocuments == nil {
		invalidParams.Add(aws.NewErrParamRequired("TraceSegmentDocuments"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutTraceSegmentsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.TraceSegmentDocuments) > 0 {
		v := s.TraceSegmentDocuments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TraceSegmentDocuments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTraceSegmentsResult
type PutTraceSegmentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Segments that failed processing.
	UnprocessedTraceSegments []UnprocessedTraceSegment `type:"list"`
}

// String returns the string representation
func (s PutTraceSegmentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutTraceSegmentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutTraceSegmentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutTraceSegmentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.UnprocessedTraceSegments) > 0 {
		v := s.UnprocessedTraceSegments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UnprocessedTraceSegments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A segment from a trace that has been ingested by the X-Ray service. The segment
// can be compiled from documents uploaded with PutTraceSegments, or an inferred
// segment for a downstream service, generated from a subsegment sent by the
// service that called it.
//
// For the full segment document schema, see AWS X-Ray Segment Documents (https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html)
// in the AWS X-Ray Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Segment
type Segment struct {
	_ struct{} `type:"structure"`

	// The segment document.
	Document *string `min:"1" type:"string"`

	// The segment's ID.
	Id *string `type:"string"`
}

// String returns the string representation
func (s Segment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Segment) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Segment) MarshalFields(e protocol.FieldEncoder) error {
	if s.Document != nil {
		v := *s.Document

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Document", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about an application that processed requests, users that made
// requests, or downstream services, resources and applications that an application
// used.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Service
type Service struct {
	_ struct{} `type:"structure"`

	// Identifier of the AWS account in which the service runs.
	AccountId *string `type:"string"`

	// A histogram that maps the spread of service durations.
	DurationHistogram []HistogramEntry `type:"list"`

	// Connections to downstream services.
	Edges []Edge `type:"list"`

	// The end time of the last segment that the service generated.
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The canonical name of the service.
	Name *string `type:"string"`

	// A list of names for the service, including the canonical name.
	Names []string `type:"list"`

	// Identifier for the service. Unique within the service map.
	ReferenceId *int64 `type:"integer"`

	// A histogram that maps the spread of service response times.
	ResponseTimeHistogram []HistogramEntry `type:"list"`

	// Indicates that the service was the first service to process a request.
	Root *bool `type:"boolean"`

	// The start time of the first segment that the service generated.
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The service's state.
	State *string `type:"string"`

	// Aggregated statistics for the service.
	SummaryStatistics *ServiceStatistics `type:"structure"`

	// The type of service.
	//
	//    * AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance
	//    for a application running on Amazon EC2 or AWS::DynamoDB::Table for an
	//    Amazon DynamoDB table that the application used.
	//
	//    * AWS Service - The type of an AWS service. For example, AWS::DynamoDB
	//    for downstream calls to Amazon DynamoDB that didn't target a specific
	//    table.
	//
	//    * client - Represents the clients that sent requests to a root service.
	//
	//    * remote - A downstream service of indeterminate type.
	Type *string `type:"string"`
}

// String returns the string representation
func (s Service) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Service) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Service) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.DurationHistogram) > 0 {
		v := s.DurationHistogram

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "DurationHistogram", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Edges) > 0 {
		v := s.Edges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Edges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ReferenceId != nil {
		v := *s.ReferenceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReferenceId", protocol.Int64Value(v), metadata)
	}
	if len(s.ResponseTimeHistogram) > 0 {
		v := s.ResponseTimeHistogram

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResponseTimeHistogram", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Root != nil {
		v := *s.Root

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Root", protocol.BoolValue(v), metadata)
	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.State != nil {
		v := *s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SummaryStatistics != nil {
		v := s.SummaryStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SummaryStatistics", v, metadata)
	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ServiceId
type ServiceId struct {
	_ struct{} `type:"structure"`

	AccountId *string `type:"string"`

	Name *string `type:"string"`

	Names []string `type:"list"`

	Type *string `type:"string"`
}

// String returns the string representation
func (s ServiceId) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ServiceId) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ServiceId) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Response statistics for a service.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ServiceStatistics
type ServiceStatistics struct {
	_ struct{} `type:"structure"`

	// Information about requests that failed with a 4xx Client Error status code.
	ErrorStatistics *ErrorStatistics `type:"structure"`

	// Information about requests that failed with a 5xx Server Error status code.
	FaultStatistics *FaultStatistics `type:"structure"`

	// The number of requests that completed with a 2xx Success status code.
	OkCount *int64 `type:"long"`

	// The total number of completed requests.
	TotalCount *int64 `type:"long"`

	// The aggregate response time of completed requests.
	TotalResponseTime *float64 `type:"double"`
}

// String returns the string representation
func (s ServiceStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ServiceStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ServiceStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorStatistics != nil {
		v := s.ErrorStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ErrorStatistics", v, metadata)
	}
	if s.FaultStatistics != nil {
		v := s.FaultStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FaultStatistics", v, metadata)
	}
	if s.OkCount != nil {
		v := *s.OkCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OkCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalCount != nil {
		v := *s.TotalCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalResponseTime != nil {
		v := *s.TotalResponseTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalResponseTime", protocol.Float64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/TelemetryRecord
type TelemetryRecord struct {
	_ struct{} `type:"structure"`

	BackendConnectionErrors *BackendConnectionErrors `type:"structure"`

	SegmentsReceivedCount *int64 `type:"integer"`

	SegmentsRejectedCount *int64 `type:"integer"`

	SegmentsSentCount *int64 `type:"integer"`

	SegmentsSpilloverCount *int64 `type:"integer"`

	// Timestamp is a required field
	Timestamp *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`
}

// String returns the string representation
func (s TelemetryRecord) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TelemetryRecord) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TelemetryRecord) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TelemetryRecord"}

	if s.Timestamp == nil {
		invalidParams.Add(aws.NewErrParamRequired("Timestamp"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TelemetryRecord) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackendConnectionErrors != nil {
		v := s.BackendConnectionErrors

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackendConnectionErrors", v, metadata)
	}
	if s.SegmentsReceivedCount != nil {
		v := *s.SegmentsReceivedCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SegmentsReceivedCount", protocol.Int64Value(v), metadata)
	}
	if s.SegmentsRejectedCount != nil {
		v := *s.SegmentsRejectedCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SegmentsRejectedCount", protocol.Int64Value(v), metadata)
	}
	if s.SegmentsSentCount != nil {
		v := *s.SegmentsSentCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SegmentsSentCount", protocol.Int64Value(v), metadata)
	}
	if s.SegmentsSpilloverCount != nil {
		v := *s.SegmentsSpilloverCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SegmentsSpilloverCount", protocol.Int64Value(v), metadata)
	}
	if s.Timestamp != nil {
		v := *s.Timestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Timestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// A collection of segment documents with matching trace IDs.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Trace
type Trace struct {
	_ struct{} `type:"structure"`

	// The length of time in seconds between the start time of the root segment
	// and the end time of the last segment that completed.
	Duration *float64 `type:"double"`

	// The unique identifier for the request that generated the trace's segments
	// and subsegments.
	Id *string `min:"1" type:"string"`

	// Segment documents for the segments and subsegments that comprise the trace.
	Segments []Segment `type:"list"`
}

// String returns the string representation
func (s Trace) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Trace) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Trace) MarshalFields(e protocol.FieldEncoder) error {
	if s.Duration != nil {
		v := *s.Duration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Duration", protocol.Float64Value(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Segments) > 0 {
		v := s.Segments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Segments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Metadata generated from the segment documents in a trace.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/TraceSummary
type TraceSummary struct {
	_ struct{} `type:"structure"`

	// Annotations from the trace's segment documents.
	Annotations map[string][]ValueWithServiceIds `type:"map"`

	// The length of time in seconds between the start time of the root segment
	// and the end time of the last segment that completed.
	Duration *float64 `type:"double"`

	// One or more of the segment documents has a 400 series error.
	HasError *bool `type:"boolean"`

	// One or more of the segment documents has a 500 series error.
	HasFault *bool `type:"boolean"`

	// One or more of the segment documents has a 429 throttling error.
	HasThrottle *bool `type:"boolean"`

	// Information about the HTTP request served by the trace.
	Http *Http `type:"structure"`

	// The unique identifier for the request that generated the trace's segments
	// and subsegments.
	Id *string `min:"1" type:"string"`

	// One or more of the segment documents is in progress.
	IsPartial *bool `type:"boolean"`

	// The length of time in seconds between the start and end times of the root
	// segment. If the service performs work asynchronously, the response time measures
	// the time before the response is sent to the user, while the duration measures
	// the amount of time before the last traced activity completes.
	ResponseTime *float64 `type:"double"`

	// Service IDs from the trace's segment documents.
	ServiceIds []ServiceId `type:"list"`

	// Users from the trace's segment documents.
	Users []TraceUser `type:"list"`
}

// String returns the string representation
func (s TraceSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TraceSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TraceSummary) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Annotations) > 0 {
		v := s.Annotations

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Annotations", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ls1 := ms0.List(k1)
			ls1.Start()
			for _, v2 := range v1 {
				ls1.ListAddFields(v2)
			}
			ls1.End()
		}
		ms0.End()

	}
	if s.Duration != nil {
		v := *s.Duration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Duration", protocol.Float64Value(v), metadata)
	}
	if s.HasError != nil {
		v := *s.HasError

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HasError", protocol.BoolValue(v), metadata)
	}
	if s.HasFault != nil {
		v := *s.HasFault

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HasFault", protocol.BoolValue(v), metadata)
	}
	if s.HasThrottle != nil {
		v := *s.HasThrottle

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HasThrottle", protocol.BoolValue(v), metadata)
	}
	if s.Http != nil {
		v := s.Http

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Http", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IsPartial != nil {
		v := *s.IsPartial

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsPartial", protocol.BoolValue(v), metadata)
	}
	if s.ResponseTime != nil {
		v := *s.ResponseTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResponseTime", protocol.Float64Value(v), metadata)
	}
	if len(s.ServiceIds) > 0 {
		v := s.ServiceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ServiceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Users) > 0 {
		v := s.Users

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Users", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Information about a user recorded in segment documents.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/TraceUser
type TraceUser struct {
	_ struct{} `type:"structure"`

	// Services that the user's request hit.
	ServiceIds []ServiceId `type:"list"`

	// The user's name.
	UserName *string `type:"string"`
}

// String returns the string representation
func (s TraceUser) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TraceUser) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TraceUser) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ServiceIds) > 0 {
		v := s.ServiceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ServiceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.UserName != nil {
		v := *s.UserName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UserName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about a segment that failed processing.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UnprocessedTraceSegment
type UnprocessedTraceSegment struct {
	_ struct{} `type:"structure"`

	// The error that caused processing to fail.
	ErrorCode *string `type:"string"`

	// The segment's ID.
	Id *string `type:"string"`

	// The error message.
	Message *string `type:"string"`
}

// String returns the string representation
func (s UnprocessedTraceSegment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UnprocessedTraceSegment) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UnprocessedTraceSegment) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorCode != nil {
		v := *s.ErrorCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ErrorCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Message", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about a segment annotation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ValueWithServiceIds
type ValueWithServiceIds struct {
	_ struct{} `type:"structure"`

	// Values of the annotation.
	AnnotationValue *AnnotationValue `type:"structure"`

	// Services to which the annotation applies.
	ServiceIds []ServiceId `type:"list"`
}

// String returns the string representation
func (s ValueWithServiceIds) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ValueWithServiceIds) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ValueWithServiceIds) MarshalFields(e protocol.FieldEncoder) error {
	if s.AnnotationValue != nil {
		v := s.AnnotationValue

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AnnotationValue", v, metadata)
	}
	if len(s.ServiceIds) > 0 {
		v := s.ServiceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ServiceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type EncryptionStatus string

// Enum values for EncryptionStatus
const (
	EncryptionStatusUpdating EncryptionStatus = "UPDATING"
	EncryptionStatusActive   EncryptionStatus = "ACTIVE"
)

func (enum EncryptionStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EncryptionStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type EncryptionType string

// Enum values for EncryptionType
const (
	EncryptionTypeNone EncryptionType = "NONE"
	EncryptionTypeKms  EncryptionType = "KMS"
)

func (enum EncryptionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EncryptionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
