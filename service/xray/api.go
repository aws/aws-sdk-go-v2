// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package xray

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

const opBatchGetTraces = "BatchGetTraces"

// BatchGetTracesRequest is a API request type for the BatchGetTraces API operation.
type BatchGetTracesRequest struct {
	*aws.Request
	Input *BatchGetTracesInput
	Copy  func(*BatchGetTracesInput) BatchGetTracesRequest
}

// Send marshals and sends the BatchGetTraces API request.
func (r BatchGetTracesRequest) Send() (*BatchGetTracesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*BatchGetTracesOutput), nil
}

// BatchGetTracesRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves a list of traces specified by ID. Each trace is a collection of
// segment documents that originates from a single request. Use GetTraceSummaries
// to get a list of trace IDs.
//
//    // Example sending a request using the BatchGetTracesRequest method.
//    req := client.BatchGetTracesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/BatchGetTraces
func (c *XRay) BatchGetTracesRequest(input *BatchGetTracesInput) BatchGetTracesRequest {
	op := &aws.Operation{
		Name:       opBatchGetTraces,
		HTTPMethod: "POST",
		HTTPPath:   "/Traces",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &BatchGetTracesInput{}
	}

	output := &BatchGetTracesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return BatchGetTracesRequest{Request: req, Input: input, Copy: c.BatchGetTracesRequest}
}

// Paginate pages iterates over the pages of a BatchGetTracesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a BatchGetTraces operation.
//		req := client.BatchGetTracesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *BatchGetTracesRequest) Paginate(opts ...aws.Option) BatchGetTracesPager {
	return BatchGetTracesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *BatchGetTracesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// BatchGetTracesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type BatchGetTracesPager struct {
	aws.Pager
}

func (p *BatchGetTracesPager) CurrentPage() *BatchGetTracesOutput {
	return p.Pager.CurrentPage().(*BatchGetTracesOutput)
}

const opCreateGroup = "CreateGroup"

// CreateGroupRequest is a API request type for the CreateGroup API operation.
type CreateGroupRequest struct {
	*aws.Request
	Input *CreateGroupInput
	Copy  func(*CreateGroupInput) CreateGroupRequest
}

// Send marshals and sends the CreateGroup API request.
func (r CreateGroupRequest) Send() (*CreateGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateGroupOutput), nil
}

// CreateGroupRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Creates a group resource with a name and a filter expression.
//
//    // Example sending a request using the CreateGroupRequest method.
//    req := client.CreateGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/CreateGroup
func (c *XRay) CreateGroupRequest(input *CreateGroupInput) CreateGroupRequest {
	op := &aws.Operation{
		Name:       opCreateGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/CreateGroup",
	}

	if input == nil {
		input = &CreateGroupInput{}
	}

	output := &CreateGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateGroupRequest{Request: req, Input: input, Copy: c.CreateGroupRequest}
}

const opCreateSamplingRule = "CreateSamplingRule"

// CreateSamplingRuleRequest is a API request type for the CreateSamplingRule API operation.
type CreateSamplingRuleRequest struct {
	*aws.Request
	Input *CreateSamplingRuleInput
	Copy  func(*CreateSamplingRuleInput) CreateSamplingRuleRequest
}

// Send marshals and sends the CreateSamplingRule API request.
func (r CreateSamplingRuleRequest) Send() (*CreateSamplingRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateSamplingRuleOutput), nil
}

// CreateSamplingRuleRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Creates a rule to control sampling behavior for instrumented applications.
// Services retrieve rules with GetSamplingRules, and evaluate each rule in
// ascending order of priority for each request. If a rule matches, the service
// records a trace, borrowing it from the reservoir size. After 10 seconds,
// the service reports back to X-Ray with GetSamplingTargets to get updated
// versions of each in-use rule. The updated rule contains a trace quota that
// the service can use instead of borrowing from the reservoir.
//
//    // Example sending a request using the CreateSamplingRuleRequest method.
//    req := client.CreateSamplingRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/CreateSamplingRule
func (c *XRay) CreateSamplingRuleRequest(input *CreateSamplingRuleInput) CreateSamplingRuleRequest {
	op := &aws.Operation{
		Name:       opCreateSamplingRule,
		HTTPMethod: "POST",
		HTTPPath:   "/CreateSamplingRule",
	}

	if input == nil {
		input = &CreateSamplingRuleInput{}
	}

	output := &CreateSamplingRuleOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateSamplingRuleRequest{Request: req, Input: input, Copy: c.CreateSamplingRuleRequest}
}

const opDeleteGroup = "DeleteGroup"

// DeleteGroupRequest is a API request type for the DeleteGroup API operation.
type DeleteGroupRequest struct {
	*aws.Request
	Input *DeleteGroupInput
	Copy  func(*DeleteGroupInput) DeleteGroupRequest
}

// Send marshals and sends the DeleteGroup API request.
func (r DeleteGroupRequest) Send() (*DeleteGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteGroupOutput), nil
}

// DeleteGroupRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Deletes a group resource.
//
//    // Example sending a request using the DeleteGroupRequest method.
//    req := client.DeleteGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/DeleteGroup
func (c *XRay) DeleteGroupRequest(input *DeleteGroupInput) DeleteGroupRequest {
	op := &aws.Operation{
		Name:       opDeleteGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/DeleteGroup",
	}

	if input == nil {
		input = &DeleteGroupInput{}
	}

	output := &DeleteGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteGroupRequest{Request: req, Input: input, Copy: c.DeleteGroupRequest}
}

const opDeleteSamplingRule = "DeleteSamplingRule"

// DeleteSamplingRuleRequest is a API request type for the DeleteSamplingRule API operation.
type DeleteSamplingRuleRequest struct {
	*aws.Request
	Input *DeleteSamplingRuleInput
	Copy  func(*DeleteSamplingRuleInput) DeleteSamplingRuleRequest
}

// Send marshals and sends the DeleteSamplingRule API request.
func (r DeleteSamplingRuleRequest) Send() (*DeleteSamplingRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteSamplingRuleOutput), nil
}

// DeleteSamplingRuleRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Deletes a sampling rule.
//
//    // Example sending a request using the DeleteSamplingRuleRequest method.
//    req := client.DeleteSamplingRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/DeleteSamplingRule
func (c *XRay) DeleteSamplingRuleRequest(input *DeleteSamplingRuleInput) DeleteSamplingRuleRequest {
	op := &aws.Operation{
		Name:       opDeleteSamplingRule,
		HTTPMethod: "POST",
		HTTPPath:   "/DeleteSamplingRule",
	}

	if input == nil {
		input = &DeleteSamplingRuleInput{}
	}

	output := &DeleteSamplingRuleOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteSamplingRuleRequest{Request: req, Input: input, Copy: c.DeleteSamplingRuleRequest}
}

const opGetEncryptionConfig = "GetEncryptionConfig"

// GetEncryptionConfigRequest is a API request type for the GetEncryptionConfig API operation.
type GetEncryptionConfigRequest struct {
	*aws.Request
	Input *GetEncryptionConfigInput
	Copy  func(*GetEncryptionConfigInput) GetEncryptionConfigRequest
}

// Send marshals and sends the GetEncryptionConfig API request.
func (r GetEncryptionConfigRequest) Send() (*GetEncryptionConfigOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetEncryptionConfigOutput), nil
}

// GetEncryptionConfigRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves the current encryption configuration for X-Ray data.
//
//    // Example sending a request using the GetEncryptionConfigRequest method.
//    req := client.GetEncryptionConfigRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetEncryptionConfig
func (c *XRay) GetEncryptionConfigRequest(input *GetEncryptionConfigInput) GetEncryptionConfigRequest {
	op := &aws.Operation{
		Name:       opGetEncryptionConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/EncryptionConfig",
	}

	if input == nil {
		input = &GetEncryptionConfigInput{}
	}

	output := &GetEncryptionConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetEncryptionConfigRequest{Request: req, Input: input, Copy: c.GetEncryptionConfigRequest}
}

const opGetGroup = "GetGroup"

// GetGroupRequest is a API request type for the GetGroup API operation.
type GetGroupRequest struct {
	*aws.Request
	Input *GetGroupInput
	Copy  func(*GetGroupInput) GetGroupRequest
}

// Send marshals and sends the GetGroup API request.
func (r GetGroupRequest) Send() (*GetGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetGroupOutput), nil
}

// GetGroupRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves group resource details.
//
//    // Example sending a request using the GetGroupRequest method.
//    req := client.GetGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetGroup
func (c *XRay) GetGroupRequest(input *GetGroupInput) GetGroupRequest {
	op := &aws.Operation{
		Name:       opGetGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/GetGroup",
	}

	if input == nil {
		input = &GetGroupInput{}
	}

	output := &GetGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetGroupRequest{Request: req, Input: input, Copy: c.GetGroupRequest}
}

const opGetGroups = "GetGroups"

// GetGroupsRequest is a API request type for the GetGroups API operation.
type GetGroupsRequest struct {
	*aws.Request
	Input *GetGroupsInput
	Copy  func(*GetGroupsInput) GetGroupsRequest
}

// Send marshals and sends the GetGroups API request.
func (r GetGroupsRequest) Send() (*GetGroupsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetGroupsOutput), nil
}

// GetGroupsRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves all active group details.
//
//    // Example sending a request using the GetGroupsRequest method.
//    req := client.GetGroupsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetGroups
func (c *XRay) GetGroupsRequest(input *GetGroupsInput) GetGroupsRequest {
	op := &aws.Operation{
		Name:       opGetGroups,
		HTTPMethod: "POST",
		HTTPPath:   "/Groups",
	}

	if input == nil {
		input = &GetGroupsInput{}
	}

	output := &GetGroupsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetGroupsRequest{Request: req, Input: input, Copy: c.GetGroupsRequest}
}

const opGetSamplingRules = "GetSamplingRules"

// GetSamplingRulesRequest is a API request type for the GetSamplingRules API operation.
type GetSamplingRulesRequest struct {
	*aws.Request
	Input *GetSamplingRulesInput
	Copy  func(*GetSamplingRulesInput) GetSamplingRulesRequest
}

// Send marshals and sends the GetSamplingRules API request.
func (r GetSamplingRulesRequest) Send() (*GetSamplingRulesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSamplingRulesOutput), nil
}

// GetSamplingRulesRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves all sampling rules.
//
//    // Example sending a request using the GetSamplingRulesRequest method.
//    req := client.GetSamplingRulesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingRules
func (c *XRay) GetSamplingRulesRequest(input *GetSamplingRulesInput) GetSamplingRulesRequest {
	op := &aws.Operation{
		Name:       opGetSamplingRules,
		HTTPMethod: "POST",
		HTTPPath:   "/GetSamplingRules",
	}

	if input == nil {
		input = &GetSamplingRulesInput{}
	}

	output := &GetSamplingRulesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSamplingRulesRequest{Request: req, Input: input, Copy: c.GetSamplingRulesRequest}
}

const opGetSamplingStatisticSummaries = "GetSamplingStatisticSummaries"

// GetSamplingStatisticSummariesRequest is a API request type for the GetSamplingStatisticSummaries API operation.
type GetSamplingStatisticSummariesRequest struct {
	*aws.Request
	Input *GetSamplingStatisticSummariesInput
	Copy  func(*GetSamplingStatisticSummariesInput) GetSamplingStatisticSummariesRequest
}

// Send marshals and sends the GetSamplingStatisticSummaries API request.
func (r GetSamplingStatisticSummariesRequest) Send() (*GetSamplingStatisticSummariesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSamplingStatisticSummariesOutput), nil
}

// GetSamplingStatisticSummariesRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves information about recent sampling results for all sampling rules.
//
//    // Example sending a request using the GetSamplingStatisticSummariesRequest method.
//    req := client.GetSamplingStatisticSummariesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingStatisticSummaries
func (c *XRay) GetSamplingStatisticSummariesRequest(input *GetSamplingStatisticSummariesInput) GetSamplingStatisticSummariesRequest {
	op := &aws.Operation{
		Name:       opGetSamplingStatisticSummaries,
		HTTPMethod: "POST",
		HTTPPath:   "/SamplingStatisticSummaries",
	}

	if input == nil {
		input = &GetSamplingStatisticSummariesInput{}
	}

	output := &GetSamplingStatisticSummariesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSamplingStatisticSummariesRequest{Request: req, Input: input, Copy: c.GetSamplingStatisticSummariesRequest}
}

const opGetSamplingTargets = "GetSamplingTargets"

// GetSamplingTargetsRequest is a API request type for the GetSamplingTargets API operation.
type GetSamplingTargetsRequest struct {
	*aws.Request
	Input *GetSamplingTargetsInput
	Copy  func(*GetSamplingTargetsInput) GetSamplingTargetsRequest
}

// Send marshals and sends the GetSamplingTargets API request.
func (r GetSamplingTargetsRequest) Send() (*GetSamplingTargetsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSamplingTargetsOutput), nil
}

// GetSamplingTargetsRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Requests a sampling quota for rules that the service is using to sample requests.
//
//    // Example sending a request using the GetSamplingTargetsRequest method.
//    req := client.GetSamplingTargetsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingTargets
func (c *XRay) GetSamplingTargetsRequest(input *GetSamplingTargetsInput) GetSamplingTargetsRequest {
	op := &aws.Operation{
		Name:       opGetSamplingTargets,
		HTTPMethod: "POST",
		HTTPPath:   "/SamplingTargets",
	}

	if input == nil {
		input = &GetSamplingTargetsInput{}
	}

	output := &GetSamplingTargetsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSamplingTargetsRequest{Request: req, Input: input, Copy: c.GetSamplingTargetsRequest}
}

const opGetServiceGraph = "GetServiceGraph"

// GetServiceGraphRequest is a API request type for the GetServiceGraph API operation.
type GetServiceGraphRequest struct {
	*aws.Request
	Input *GetServiceGraphInput
	Copy  func(*GetServiceGraphInput) GetServiceGraphRequest
}

// Send marshals and sends the GetServiceGraph API request.
func (r GetServiceGraphRequest) Send() (*GetServiceGraphOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetServiceGraphOutput), nil
}

// GetServiceGraphRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves a document that describes services that process incoming requests,
// and downstream services that they call as a result. Root services process
// incoming requests and make calls to downstream services. Root services are
// applications that use the AWS X-Ray SDK. Downstream services can be other
// applications, AWS resources, HTTP web APIs, or SQL databases.
//
//    // Example sending a request using the GetServiceGraphRequest method.
//    req := client.GetServiceGraphRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetServiceGraph
func (c *XRay) GetServiceGraphRequest(input *GetServiceGraphInput) GetServiceGraphRequest {
	op := &aws.Operation{
		Name:       opGetServiceGraph,
		HTTPMethod: "POST",
		HTTPPath:   "/ServiceGraph",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetServiceGraphInput{}
	}

	output := &GetServiceGraphOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetServiceGraphRequest{Request: req, Input: input, Copy: c.GetServiceGraphRequest}
}

// Paginate pages iterates over the pages of a GetServiceGraphRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetServiceGraph operation.
//		req := client.GetServiceGraphRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetServiceGraphRequest) Paginate(opts ...aws.Option) GetServiceGraphPager {
	return GetServiceGraphPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetServiceGraphInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetServiceGraphPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetServiceGraphPager struct {
	aws.Pager
}

func (p *GetServiceGraphPager) CurrentPage() *GetServiceGraphOutput {
	return p.Pager.CurrentPage().(*GetServiceGraphOutput)
}

const opGetTraceGraph = "GetTraceGraph"

// GetTraceGraphRequest is a API request type for the GetTraceGraph API operation.
type GetTraceGraphRequest struct {
	*aws.Request
	Input *GetTraceGraphInput
	Copy  func(*GetTraceGraphInput) GetTraceGraphRequest
}

// Send marshals and sends the GetTraceGraph API request.
func (r GetTraceGraphRequest) Send() (*GetTraceGraphOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTraceGraphOutput), nil
}

// GetTraceGraphRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves a service graph for one or more specific trace IDs.
//
//    // Example sending a request using the GetTraceGraphRequest method.
//    req := client.GetTraceGraphRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceGraph
func (c *XRay) GetTraceGraphRequest(input *GetTraceGraphInput) GetTraceGraphRequest {
	op := &aws.Operation{
		Name:       opGetTraceGraph,
		HTTPMethod: "POST",
		HTTPPath:   "/TraceGraph",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetTraceGraphInput{}
	}

	output := &GetTraceGraphOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTraceGraphRequest{Request: req, Input: input, Copy: c.GetTraceGraphRequest}
}

// Paginate pages iterates over the pages of a GetTraceGraphRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetTraceGraph operation.
//		req := client.GetTraceGraphRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetTraceGraphRequest) Paginate(opts ...aws.Option) GetTraceGraphPager {
	return GetTraceGraphPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetTraceGraphInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetTraceGraphPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetTraceGraphPager struct {
	aws.Pager
}

func (p *GetTraceGraphPager) CurrentPage() *GetTraceGraphOutput {
	return p.Pager.CurrentPage().(*GetTraceGraphOutput)
}

const opGetTraceSummaries = "GetTraceSummaries"

// GetTraceSummariesRequest is a API request type for the GetTraceSummaries API operation.
type GetTraceSummariesRequest struct {
	*aws.Request
	Input *GetTraceSummariesInput
	Copy  func(*GetTraceSummariesInput) GetTraceSummariesRequest
}

// Send marshals and sends the GetTraceSummaries API request.
func (r GetTraceSummariesRequest) Send() (*GetTraceSummariesOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTraceSummariesOutput), nil
}

// GetTraceSummariesRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Retrieves IDs and metadata for traces available for a specified time frame
// using an optional filter. To get the full traces, pass the trace IDs to BatchGetTraces.
//
// A filter expression can target traced requests that hit specific service
// nodes or edges, have errors, or come from a known user. For example, the
// following filter expression targets traces that pass through api.example.com:
//
// service("api.example.com")
//
// This filter expression finds traces that have an annotation named account
// with the value 12345:
//
// annotation.account = "12345"
//
// For a full list of indexed fields and keywords that you can use in filter
// expressions, see Using Filter Expressions (http://docs.aws.amazon.com/xray/latest/devguide/xray-console-filters.html)
// in the AWS X-Ray Developer Guide.
//
//    // Example sending a request using the GetTraceSummariesRequest method.
//    req := client.GetTraceSummariesRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceSummaries
func (c *XRay) GetTraceSummariesRequest(input *GetTraceSummariesInput) GetTraceSummariesRequest {
	op := &aws.Operation{
		Name:       opGetTraceSummaries,
		HTTPMethod: "POST",
		HTTPPath:   "/TraceSummaries",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetTraceSummariesInput{}
	}

	output := &GetTraceSummariesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTraceSummariesRequest{Request: req, Input: input, Copy: c.GetTraceSummariesRequest}
}

// Paginate pages iterates over the pages of a GetTraceSummariesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetTraceSummaries operation.
//		req := client.GetTraceSummariesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetTraceSummariesRequest) Paginate(opts ...aws.Option) GetTraceSummariesPager {
	return GetTraceSummariesPager{
		Pager: aws.Pager{
			NewRequest: func() (*aws.Request, error) {
				var inCpy *GetTraceSummariesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)

				return req.Request, nil
			},
		},
	}
}

// GetTraceSummariesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetTraceSummariesPager struct {
	aws.Pager
}

func (p *GetTraceSummariesPager) CurrentPage() *GetTraceSummariesOutput {
	return p.Pager.CurrentPage().(*GetTraceSummariesOutput)
}

const opPutEncryptionConfig = "PutEncryptionConfig"

// PutEncryptionConfigRequest is a API request type for the PutEncryptionConfig API operation.
type PutEncryptionConfigRequest struct {
	*aws.Request
	Input *PutEncryptionConfigInput
	Copy  func(*PutEncryptionConfigInput) PutEncryptionConfigRequest
}

// Send marshals and sends the PutEncryptionConfig API request.
func (r PutEncryptionConfigRequest) Send() (*PutEncryptionConfigOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutEncryptionConfigOutput), nil
}

// PutEncryptionConfigRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Updates the encryption configuration for X-Ray data.
//
//    // Example sending a request using the PutEncryptionConfigRequest method.
//    req := client.PutEncryptionConfigRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutEncryptionConfig
func (c *XRay) PutEncryptionConfigRequest(input *PutEncryptionConfigInput) PutEncryptionConfigRequest {
	op := &aws.Operation{
		Name:       opPutEncryptionConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/PutEncryptionConfig",
	}

	if input == nil {
		input = &PutEncryptionConfigInput{}
	}

	output := &PutEncryptionConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutEncryptionConfigRequest{Request: req, Input: input, Copy: c.PutEncryptionConfigRequest}
}

const opPutTelemetryRecords = "PutTelemetryRecords"

// PutTelemetryRecordsRequest is a API request type for the PutTelemetryRecords API operation.
type PutTelemetryRecordsRequest struct {
	*aws.Request
	Input *PutTelemetryRecordsInput
	Copy  func(*PutTelemetryRecordsInput) PutTelemetryRecordsRequest
}

// Send marshals and sends the PutTelemetryRecords API request.
func (r PutTelemetryRecordsRequest) Send() (*PutTelemetryRecordsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutTelemetryRecordsOutput), nil
}

// PutTelemetryRecordsRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Used by the AWS X-Ray daemon to upload telemetry.
//
//    // Example sending a request using the PutTelemetryRecordsRequest method.
//    req := client.PutTelemetryRecordsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTelemetryRecords
func (c *XRay) PutTelemetryRecordsRequest(input *PutTelemetryRecordsInput) PutTelemetryRecordsRequest {
	op := &aws.Operation{
		Name:       opPutTelemetryRecords,
		HTTPMethod: "POST",
		HTTPPath:   "/TelemetryRecords",
	}

	if input == nil {
		input = &PutTelemetryRecordsInput{}
	}

	output := &PutTelemetryRecordsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutTelemetryRecordsRequest{Request: req, Input: input, Copy: c.PutTelemetryRecordsRequest}
}

const opPutTraceSegments = "PutTraceSegments"

// PutTraceSegmentsRequest is a API request type for the PutTraceSegments API operation.
type PutTraceSegmentsRequest struct {
	*aws.Request
	Input *PutTraceSegmentsInput
	Copy  func(*PutTraceSegmentsInput) PutTraceSegmentsRequest
}

// Send marshals and sends the PutTraceSegments API request.
func (r PutTraceSegmentsRequest) Send() (*PutTraceSegmentsOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutTraceSegmentsOutput), nil
}

// PutTraceSegmentsRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Uploads segment documents to AWS X-Ray. The X-Ray SDK generates segment documents
// and sends them to the X-Ray daemon, which uploads them in batches. A segment
// document can be a completed segment, an in-progress segment, or an array
// of subsegments.
//
// Segments must include the following fields. For the full segment document
// schema, see AWS X-Ray Segment Documents (https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html)
// in the AWS X-Ray Developer Guide.
//
// Required Segment Document Fields
//
//    * name - The name of the service that handled the request.
//
//    * id - A 64-bit identifier for the segment, unique among segments in the
//    same trace, in 16 hexadecimal digits.
//
//    * trace_id - A unique identifier that connects all segments and subsegments
//    originating from a single client request.
//
//    * start_time - Time the segment or subsegment was created, in floating
//    point seconds in epoch time, accurate to milliseconds. For example, 1480615200.010
//    or 1.480615200010E9.
//
//    * end_time - Time the segment or subsegment was closed. For example, 1480615200.090
//    or 1.480615200090E9. Specify either an end_time or in_progress.
//
//    * in_progress - Set to true instead of specifying an end_time to record
//    that a segment has been started, but is not complete. Send an in progress
//    segment when your application receives a request that will take a long
//    time to serve, to trace the fact that the request was received. When the
//    response is sent, send the complete segment to overwrite the in-progress
//    segment.
//
// A trace_id consists of three numbers separated by hyphens. For example, 1-58406520-a006649127e371903a2de979.
// This includes:
//
// Trace ID Format
//
//    * The version number, i.e. 1.
//
//    * The time of the original request, in Unix epoch time, in 8 hexadecimal
//    digits. For example, 10:00AM December 2nd, 2016 PST in epoch time is 1480615200
//    seconds, or 58406520 in hexadecimal.
//
//    * A 96-bit identifier for the trace, globally unique, in 24 hexadecimal
//    digits.
//
//    // Example sending a request using the PutTraceSegmentsRequest method.
//    req := client.PutTraceSegmentsRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTraceSegments
func (c *XRay) PutTraceSegmentsRequest(input *PutTraceSegmentsInput) PutTraceSegmentsRequest {
	op := &aws.Operation{
		Name:       opPutTraceSegments,
		HTTPMethod: "POST",
		HTTPPath:   "/TraceSegments",
	}

	if input == nil {
		input = &PutTraceSegmentsInput{}
	}

	output := &PutTraceSegmentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutTraceSegmentsRequest{Request: req, Input: input, Copy: c.PutTraceSegmentsRequest}
}

const opUpdateGroup = "UpdateGroup"

// UpdateGroupRequest is a API request type for the UpdateGroup API operation.
type UpdateGroupRequest struct {
	*aws.Request
	Input *UpdateGroupInput
	Copy  func(*UpdateGroupInput) UpdateGroupRequest
}

// Send marshals and sends the UpdateGroup API request.
func (r UpdateGroupRequest) Send() (*UpdateGroupOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGroupOutput), nil
}

// UpdateGroupRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Updates a group resource.
//
//    // Example sending a request using the UpdateGroupRequest method.
//    req := client.UpdateGroupRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UpdateGroup
func (c *XRay) UpdateGroupRequest(input *UpdateGroupInput) UpdateGroupRequest {
	op := &aws.Operation{
		Name:       opUpdateGroup,
		HTTPMethod: "POST",
		HTTPPath:   "/UpdateGroup",
	}

	if input == nil {
		input = &UpdateGroupInput{}
	}

	output := &UpdateGroupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateGroupRequest{Request: req, Input: input, Copy: c.UpdateGroupRequest}
}

const opUpdateSamplingRule = "UpdateSamplingRule"

// UpdateSamplingRuleRequest is a API request type for the UpdateSamplingRule API operation.
type UpdateSamplingRuleRequest struct {
	*aws.Request
	Input *UpdateSamplingRuleInput
	Copy  func(*UpdateSamplingRuleInput) UpdateSamplingRuleRequest
}

// Send marshals and sends the UpdateSamplingRule API request.
func (r UpdateSamplingRuleRequest) Send() (*UpdateSamplingRuleOutput, error) {
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateSamplingRuleOutput), nil
}

// UpdateSamplingRuleRequest returns a request value for making API operation for
// AWS X-Ray.
//
// Modifies a sampling rule's configuration.
//
//    // Example sending a request using the UpdateSamplingRuleRequest method.
//    req := client.UpdateSamplingRuleRequest(params)
//    resp, err := req.Send()
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UpdateSamplingRule
func (c *XRay) UpdateSamplingRuleRequest(input *UpdateSamplingRuleInput) UpdateSamplingRuleRequest {
	op := &aws.Operation{
		Name:       opUpdateSamplingRule,
		HTTPMethod: "POST",
		HTTPPath:   "/UpdateSamplingRule",
	}

	if input == nil {
		input = &UpdateSamplingRuleInput{}
	}

	output := &UpdateSamplingRuleOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateSamplingRuleRequest{Request: req, Input: input, Copy: c.UpdateSamplingRuleRequest}
}

// An alias for an edge.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Alias
type Alias struct {
	_ struct{} `type:"structure"`

	// The canonical name of the alias.
	Name *string `type:"string"`

	// A list of names for the alias, including the canonical name.
	Names []string `type:"list"`

	// The type of the alias.
	Type *string `type:"string"`
}

// String returns the string representation
func (s Alias) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Alias) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Alias) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Value of a segment annotation. Has one of three value types: Number, Boolean
// or String.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/AnnotationValue
type AnnotationValue struct {
	_ struct{} `type:"structure"`

	// Value for a Boolean annotation.
	BooleanValue *bool `type:"boolean"`

	// Value for a Number annotation.
	NumberValue *float64 `type:"double"`

	// Value for a String annotation.
	StringValue *string `type:"string"`
}

// String returns the string representation
func (s AnnotationValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AnnotationValue) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AnnotationValue) MarshalFields(e protocol.FieldEncoder) error {
	if s.BooleanValue != nil {
		v := *s.BooleanValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BooleanValue", protocol.BoolValue(v), metadata)
	}
	if s.NumberValue != nil {
		v := *s.NumberValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberValue", protocol.Float64Value(v), metadata)
	}
	if s.StringValue != nil {
		v := *s.StringValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StringValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A list of availability zones corresponding to the segments in a trace.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/AvailabilityZoneDetail
type AvailabilityZoneDetail struct {
	_ struct{} `type:"structure"`

	// The name of a corresponding availability zone.
	Name *string `type:"string"`
}

// String returns the string representation
func (s AvailabilityZoneDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AvailabilityZoneDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AvailabilityZoneDetail) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/BackendConnectionErrors
type BackendConnectionErrors struct {
	_ struct{} `type:"structure"`

	ConnectionRefusedCount *int64 `type:"integer"`

	HTTPCode4XXCount *int64 `type:"integer"`

	HTTPCode5XXCount *int64 `type:"integer"`

	OtherCount *int64 `type:"integer"`

	TimeoutCount *int64 `type:"integer"`

	UnknownHostCount *int64 `type:"integer"`
}

// String returns the string representation
func (s BackendConnectionErrors) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BackendConnectionErrors) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BackendConnectionErrors) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConnectionRefusedCount != nil {
		v := *s.ConnectionRefusedCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ConnectionRefusedCount", protocol.Int64Value(v), metadata)
	}
	if s.HTTPCode4XXCount != nil {
		v := *s.HTTPCode4XXCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HTTPCode4XXCount", protocol.Int64Value(v), metadata)
	}
	if s.HTTPCode5XXCount != nil {
		v := *s.HTTPCode5XXCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HTTPCode5XXCount", protocol.Int64Value(v), metadata)
	}
	if s.OtherCount != nil {
		v := *s.OtherCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OtherCount", protocol.Int64Value(v), metadata)
	}
	if s.TimeoutCount != nil {
		v := *s.TimeoutCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TimeoutCount", protocol.Int64Value(v), metadata)
	}
	if s.UnknownHostCount != nil {
		v := *s.UnknownHostCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UnknownHostCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/BatchGetTracesRequest
type BatchGetTracesInput struct {
	_ struct{} `type:"structure"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// Specify the trace IDs of requests for which to retrieve segments.
	//
	// TraceIds is a required field
	TraceIds []string `type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetTracesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetTracesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetTracesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchGetTracesInput"}

	if s.TraceIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("TraceIds"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchGetTracesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TraceIds) > 0 {
		v := s.TraceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TraceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/BatchGetTracesResult
type BatchGetTracesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// Full traces for the specified requests.
	Traces []Trace `type:"list"`

	// Trace IDs of requests that haven't been processed.
	UnprocessedTraceIds []string `type:"list"`
}

// String returns the string representation
func (s BatchGetTracesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetTracesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s BatchGetTracesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BatchGetTracesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Traces) > 0 {
		v := s.Traces

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Traces", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.UnprocessedTraceIds) > 0 {
		v := s.UnprocessedTraceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UnprocessedTraceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/CreateGroupRequest
type CreateGroupInput struct {
	_ struct{} `type:"structure"`

	// The filter expression defining criteria by which to group traces.
	FilterExpression *string `min:"1" type:"string"`

	// The case-sensitive name of the new group. Default is a reserved name and
	// names must be unique.
	//
	// GroupName is a required field
	GroupName *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateGroupInput"}
	if s.FilterExpression != nil && len(*s.FilterExpression) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FilterExpression", 1))
	}

	if s.GroupName == nil {
		invalidParams.Add(aws.NewErrParamRequired("GroupName"))
	}
	if s.GroupName != nil && len(*s.GroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.FilterExpression != nil {
		v := *s.FilterExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FilterExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupName != nil {
		v := *s.GroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/CreateGroupResult
type CreateGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The group that was created. Contains the name of the group that was created,
	// the ARN of the group that was generated based on the group name, and the
	// filter expression that was assigned to the group.
	Group *Group `type:"structure"`
}

// String returns the string representation
func (s CreateGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Group != nil {
		v := s.Group

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Group", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/CreateSamplingRuleRequest
type CreateSamplingRuleInput struct {
	_ struct{} `type:"structure"`

	// The rule definition.
	//
	// SamplingRule is a required field
	SamplingRule *SamplingRule `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateSamplingRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateSamplingRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateSamplingRuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateSamplingRuleInput"}

	if s.SamplingRule == nil {
		invalidParams.Add(aws.NewErrParamRequired("SamplingRule"))
	}
	if s.SamplingRule != nil {
		if err := s.SamplingRule.Validate(); err != nil {
			invalidParams.AddNested("SamplingRule", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateSamplingRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.SamplingRule != nil {
		v := s.SamplingRule

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SamplingRule", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/CreateSamplingRuleResult
type CreateSamplingRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The saved rule definition and metadata.
	SamplingRuleRecord *SamplingRuleRecord `type:"structure"`
}

// String returns the string representation
func (s CreateSamplingRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateSamplingRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateSamplingRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateSamplingRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.SamplingRuleRecord != nil {
		v := s.SamplingRuleRecord

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SamplingRuleRecord", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/DeleteGroupRequest
type DeleteGroupInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the group that was generated on creation.
	GroupARN *string `min:"1" type:"string"`

	// The case-sensitive name of the group.
	GroupName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s DeleteGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteGroupInput"}
	if s.GroupARN != nil && len(*s.GroupARN) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupARN", 1))
	}
	if s.GroupName != nil && len(*s.GroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.GroupARN != nil {
		v := *s.GroupARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupName != nil {
		v := *s.GroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/DeleteGroupResult
type DeleteGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/DeleteSamplingRuleRequest
type DeleteSamplingRuleInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the sampling rule. Specify a rule by either name or ARN, but not
	// both.
	RuleARN *string `type:"string"`

	// The name of the sampling rule. Specify a rule by either name or ARN, but
	// not both.
	RuleName *string `type:"string"`
}

// String returns the string representation
func (s DeleteSamplingRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSamplingRuleInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteSamplingRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RuleARN != nil {
		v := *s.RuleARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/DeleteSamplingRuleResult
type DeleteSamplingRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The deleted rule definition and metadata.
	SamplingRuleRecord *SamplingRuleRecord `type:"structure"`
}

// String returns the string representation
func (s DeleteSamplingRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSamplingRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteSamplingRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteSamplingRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.SamplingRuleRecord != nil {
		v := s.SamplingRuleRecord

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SamplingRuleRecord", v, metadata)
	}
	return nil
}

// Information about a connection between two services.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Edge
type Edge struct {
	_ struct{} `type:"structure"`

	// Aliases for the edge.
	Aliases []Alias `type:"list"`

	// The end time of the last segment on the edge.
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Identifier of the edge. Unique within a service map.
	ReferenceId *int64 `type:"integer"`

	// A histogram that maps the spread of client response times on an edge.
	ResponseTimeHistogram []HistogramEntry `type:"list"`

	// The start time of the first segment on the edge.
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Response statistics for segments on the edge.
	SummaryStatistics *EdgeStatistics `type:"structure"`
}

// String returns the string representation
func (s Edge) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Edge) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Edge) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Aliases) > 0 {
		v := s.Aliases

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Aliases", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ReferenceId != nil {
		v := *s.ReferenceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReferenceId", protocol.Int64Value(v), metadata)
	}
	if len(s.ResponseTimeHistogram) > 0 {
		v := s.ResponseTimeHistogram

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResponseTimeHistogram", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.SummaryStatistics != nil {
		v := s.SummaryStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SummaryStatistics", v, metadata)
	}
	return nil
}

// Response statistics for an edge.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/EdgeStatistics
type EdgeStatistics struct {
	_ struct{} `type:"structure"`

	// Information about requests that failed with a 4xx Client Error status code.
	ErrorStatistics *ErrorStatistics `type:"structure"`

	// Information about requests that failed with a 5xx Server Error status code.
	FaultStatistics *FaultStatistics `type:"structure"`

	// The number of requests that completed with a 2xx Success status code.
	OkCount *int64 `type:"long"`

	// The total number of completed requests.
	TotalCount *int64 `type:"long"`

	// The aggregate response time of completed requests.
	TotalResponseTime *float64 `type:"double"`
}

// String returns the string representation
func (s EdgeStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EdgeStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EdgeStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorStatistics != nil {
		v := s.ErrorStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ErrorStatistics", v, metadata)
	}
	if s.FaultStatistics != nil {
		v := s.FaultStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FaultStatistics", v, metadata)
	}
	if s.OkCount != nil {
		v := *s.OkCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OkCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalCount != nil {
		v := *s.TotalCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalResponseTime != nil {
		v := *s.TotalResponseTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalResponseTime", protocol.Float64Value(v), metadata)
	}
	return nil
}

// A configuration document that specifies encryption configuration settings.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/EncryptionConfig
type EncryptionConfig struct {
	_ struct{} `type:"structure"`

	// The ID of the customer master key (CMK) used for encryption, if applicable.
	KeyId *string `type:"string"`

	// The encryption status. While the status is UPDATING, X-Ray may encrypt data
	// with a combination of the new and old settings.
	Status EncryptionStatus `type:"string" enum:"true"`

	// The type of encryption. Set to KMS for encryption with CMKs. Set to NONE
	// for default encryption.
	Type EncryptionType `type:"string" enum:"true"`
}

// String returns the string representation
func (s EncryptionConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionConfig) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EncryptionConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The root cause of a trace summary error.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ErrorRootCause
type ErrorRootCause struct {
	_ struct{} `type:"structure"`

	// A list of services corresponding to an error. A service identifies a segment
	// and it contains a name, account ID, type, and inferred flag.
	Services []ErrorRootCauseService `type:"list"`
}

// String returns the string representation
func (s ErrorRootCause) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ErrorRootCause) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ErrorRootCause) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Services) > 0 {
		v := s.Services

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Services", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A collection of segments and corresponding subsegments associated to a trace
// summary error.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ErrorRootCauseEntity
type ErrorRootCauseEntity struct {
	_ struct{} `type:"structure"`

	// The types and messages of the exceptions.
	Exceptions []RootCauseException `type:"list"`

	// The name of the entity.
	Name *string `type:"string"`

	// A flag that denotes a remote subsegment.
	Remote *bool `type:"boolean"`
}

// String returns the string representation
func (s ErrorRootCauseEntity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ErrorRootCauseEntity) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ErrorRootCauseEntity) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Exceptions) > 0 {
		v := s.Exceptions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Exceptions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Remote != nil {
		v := *s.Remote

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Remote", protocol.BoolValue(v), metadata)
	}
	return nil
}

// A collection of fields identifying the services in a trace summary error.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ErrorRootCauseService
type ErrorRootCauseService struct {
	_ struct{} `type:"structure"`

	// The account ID associated to the service.
	AccountId *string `type:"string"`

	// The path of root cause entities found on the service.
	EntityPath []ErrorRootCauseEntity `type:"list"`

	// A Boolean value indicating if the service is inferred from the trace.
	Inferred *bool `type:"boolean"`

	// The service name.
	Name *string `type:"string"`

	// A collection of associated service names.
	Names []string `type:"list"`

	// The type associated to the service.
	Type *string `type:"string"`
}

// String returns the string representation
func (s ErrorRootCauseService) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ErrorRootCauseService) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ErrorRootCauseService) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EntityPath) > 0 {
		v := s.EntityPath

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "EntityPath", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Inferred != nil {
		v := *s.Inferred

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Inferred", protocol.BoolValue(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about requests that failed with a 4xx Client Error status code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ErrorStatistics
type ErrorStatistics struct {
	_ struct{} `type:"structure"`

	// The number of requests that failed with untracked 4xx Client Error status
	// codes.
	OtherCount *int64 `type:"long"`

	// The number of requests that failed with a 419 throttling status code.
	ThrottleCount *int64 `type:"long"`

	// The total number of requests that failed with a 4xx Client Error status code.
	TotalCount *int64 `type:"long"`
}

// String returns the string representation
func (s ErrorStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ErrorStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ErrorStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.OtherCount != nil {
		v := *s.OtherCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OtherCount", protocol.Int64Value(v), metadata)
	}
	if s.ThrottleCount != nil {
		v := *s.ThrottleCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ThrottleCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalCount != nil {
		v := *s.TotalCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The root cause information for a trace summary fault.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/FaultRootCause
type FaultRootCause struct {
	_ struct{} `type:"structure"`

	// A list of corresponding services. A service identifies a segment and it contains
	// a name, account ID, type, and inferred flag.
	Services []FaultRootCauseService `type:"list"`
}

// String returns the string representation
func (s FaultRootCause) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FaultRootCause) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FaultRootCause) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Services) > 0 {
		v := s.Services

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Services", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A collection of segments and corresponding subsegments associated to a trace
// summary fault error.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/FaultRootCauseEntity
type FaultRootCauseEntity struct {
	_ struct{} `type:"structure"`

	// The types and messages of the exceptions.
	Exceptions []RootCauseException `type:"list"`

	// The name of the entity.
	Name *string `type:"string"`

	// A flag that denotes a remote subsegment.
	Remote *bool `type:"boolean"`
}

// String returns the string representation
func (s FaultRootCauseEntity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FaultRootCauseEntity) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FaultRootCauseEntity) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Exceptions) > 0 {
		v := s.Exceptions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Exceptions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Remote != nil {
		v := *s.Remote

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Remote", protocol.BoolValue(v), metadata)
	}
	return nil
}

// A collection of fields identifying the services in a trace summary fault.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/FaultRootCauseService
type FaultRootCauseService struct {
	_ struct{} `type:"structure"`

	// The account ID associated to the service.
	AccountId *string `type:"string"`

	// The path of root cause entities found on the service.
	EntityPath []FaultRootCauseEntity `type:"list"`

	// A Boolean value indicating if the service is inferred from the trace.
	Inferred *bool `type:"boolean"`

	// The service name.
	Name *string `type:"string"`

	// A collection of associated service names.
	Names []string `type:"list"`

	// The type associated to the service.
	Type *string `type:"string"`
}

// String returns the string representation
func (s FaultRootCauseService) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FaultRootCauseService) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FaultRootCauseService) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EntityPath) > 0 {
		v := s.EntityPath

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "EntityPath", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Inferred != nil {
		v := *s.Inferred

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Inferred", protocol.BoolValue(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about requests that failed with a 5xx Server Error status code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/FaultStatistics
type FaultStatistics struct {
	_ struct{} `type:"structure"`

	// The number of requests that failed with untracked 5xx Server Error status
	// codes.
	OtherCount *int64 `type:"long"`

	// The total number of requests that failed with a 5xx Server Error status code.
	TotalCount *int64 `type:"long"`
}

// String returns the string representation
func (s FaultStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FaultStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FaultStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.OtherCount != nil {
		v := *s.OtherCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OtherCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalCount != nil {
		v := *s.TotalCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetEncryptionConfigRequest
type GetEncryptionConfigInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetEncryptionConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetEncryptionConfigInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetEncryptionConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetEncryptionConfigResult
type GetEncryptionConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The encryption configuration document.
	EncryptionConfig *EncryptionConfig `type:"structure"`
}

// String returns the string representation
func (s GetEncryptionConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetEncryptionConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetEncryptionConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetEncryptionConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.EncryptionConfig != nil {
		v := s.EncryptionConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EncryptionConfig", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetGroupRequest
type GetGroupInput struct {
	_ struct{} `type:"structure"`

	// The ARN of the group that was generated on creation.
	GroupARN *string `min:"1" type:"string"`

	// The case-sensitive name of the group.
	GroupName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s GetGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetGroupInput"}
	if s.GroupARN != nil && len(*s.GroupARN) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupARN", 1))
	}
	if s.GroupName != nil && len(*s.GroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.GroupARN != nil {
		v := *s.GroupARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupName != nil {
		v := *s.GroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetGroupResult
type GetGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The group that was requested. Contains the name of the group, the ARN of
	// the group, and the filter expression that assigned to the group.
	Group *Group `type:"structure"`
}

// String returns the string representation
func (s GetGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Group != nil {
		v := s.Group

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Group", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetGroupsRequest
type GetGroupsInput struct {
	_ struct{} `type:"structure"`

	// Pagination token. Not used.
	NextToken *string `min:"1" type:"string"`
}

// String returns the string representation
func (s GetGroupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGroupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetGroupsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetGroupsInput"}
	if s.NextToken != nil && len(*s.NextToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NextToken", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGroupsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetGroupsResult
type GetGroupsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The collection of all active groups.
	Groups []GroupSummary `type:"list"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s GetGroupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGroupsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetGroupsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGroupsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Groups) > 0 {
		v := s.Groups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Groups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingRulesRequest
type GetSamplingRulesInput struct {
	_ struct{} `type:"structure"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s GetSamplingRulesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSamplingRulesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSamplingRulesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingRulesResult
type GetSamplingRulesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// Rule definitions and metadata.
	SamplingRuleRecords []SamplingRuleRecord `type:"list"`
}

// String returns the string representation
func (s GetSamplingRulesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSamplingRulesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSamplingRulesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSamplingRulesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SamplingRuleRecords) > 0 {
		v := s.SamplingRuleRecords

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SamplingRuleRecords", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingStatisticSummariesRequest
type GetSamplingStatisticSummariesInput struct {
	_ struct{} `type:"structure"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s GetSamplingStatisticSummariesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSamplingStatisticSummariesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSamplingStatisticSummariesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingStatisticSummariesResult
type GetSamplingStatisticSummariesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// Information about the number of requests instrumented for each sampling rule.
	SamplingStatisticSummaries []SamplingStatisticSummary `type:"list"`
}

// String returns the string representation
func (s GetSamplingStatisticSummariesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSamplingStatisticSummariesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSamplingStatisticSummariesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSamplingStatisticSummariesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.SamplingStatisticSummaries) > 0 {
		v := s.SamplingStatisticSummaries

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SamplingStatisticSummaries", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingTargetsRequest
type GetSamplingTargetsInput struct {
	_ struct{} `type:"structure"`

	// Information about rules that the service is using to sample requests.
	//
	// SamplingStatisticsDocuments is a required field
	SamplingStatisticsDocuments []SamplingStatisticsDocument `type:"list" required:"true"`
}

// String returns the string representation
func (s GetSamplingTargetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSamplingTargetsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSamplingTargetsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSamplingTargetsInput"}

	if s.SamplingStatisticsDocuments == nil {
		invalidParams.Add(aws.NewErrParamRequired("SamplingStatisticsDocuments"))
	}
	if s.SamplingStatisticsDocuments != nil {
		for i, v := range s.SamplingStatisticsDocuments {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "SamplingStatisticsDocuments", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSamplingTargetsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.SamplingStatisticsDocuments) > 0 {
		v := s.SamplingStatisticsDocuments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SamplingStatisticsDocuments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetSamplingTargetsResult
type GetSamplingTargetsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The last time a user changed the sampling rule configuration. If the sampling
	// rule configuration changed since the service last retrieved it, the service
	// should call GetSamplingRules to get the latest version.
	LastRuleModification *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Updated rules that the service should use to sample requests.
	SamplingTargetDocuments []SamplingTargetDocument `type:"list"`

	// Information about SamplingStatisticsDocument that X-Ray could not process.
	UnprocessedStatistics []UnprocessedStatistics `type:"list"`
}

// String returns the string representation
func (s GetSamplingTargetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSamplingTargetsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSamplingTargetsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSamplingTargetsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.LastRuleModification != nil {
		v := *s.LastRuleModification

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LastRuleModification", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.SamplingTargetDocuments) > 0 {
		v := s.SamplingTargetDocuments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SamplingTargetDocuments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.UnprocessedStatistics) > 0 {
		v := s.UnprocessedStatistics

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UnprocessedStatistics", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetServiceGraphRequest
type GetServiceGraphInput struct {
	_ struct{} `type:"structure"`

	// The end of the timeframe for which to generate a graph.
	//
	// EndTime is a required field
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// The ARN of a group to generate a graph based on.
	GroupARN *string `min:"1" type:"string"`

	// The name of a group to generate a graph based on.
	GroupName *string `min:"1" type:"string"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// The start of the time frame for which to generate a graph.
	//
	// StartTime is a required field
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`
}

// String returns the string representation
func (s GetServiceGraphInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetServiceGraphInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetServiceGraphInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetServiceGraphInput"}

	if s.EndTime == nil {
		invalidParams.Add(aws.NewErrParamRequired("EndTime"))
	}
	if s.GroupARN != nil && len(*s.GroupARN) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupARN", 1))
	}
	if s.GroupName != nil && len(*s.GroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupName", 1))
	}

	if s.StartTime == nil {
		invalidParams.Add(aws.NewErrParamRequired("StartTime"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetServiceGraphInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.GroupARN != nil {
		v := *s.GroupARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupName != nil {
		v := *s.GroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetServiceGraphResult
type GetServiceGraphOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A flag indicating whether the group's filter expression has been consistent,
	// or if the returned service graph may show traces from an older version of
	// the group's filter expression.
	ContainsOldGroupVersions *bool `type:"boolean"`

	// The end of the time frame for which the graph was generated.
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// The services that have processed a traced request during the specified time
	// frame.
	Services []Service `type:"list"`

	// The start of the time frame for which the graph was generated.
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s GetServiceGraphOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetServiceGraphOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetServiceGraphOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetServiceGraphOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContainsOldGroupVersions != nil {
		v := *s.ContainsOldGroupVersions

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContainsOldGroupVersions", protocol.BoolValue(v), metadata)
	}
	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Services) > 0 {
		v := s.Services

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Services", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceGraphRequest
type GetTraceGraphInput struct {
	_ struct{} `type:"structure"`

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// Trace IDs of requests for which to generate a service graph.
	//
	// TraceIds is a required field
	TraceIds []string `type:"list" required:"true"`
}

// String returns the string representation
func (s GetTraceGraphInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTraceGraphInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTraceGraphInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTraceGraphInput"}

	if s.TraceIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("TraceIds"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTraceGraphInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TraceIds) > 0 {
		v := s.TraceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TraceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceGraphResult
type GetTraceGraphOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Pagination token. Not used.
	NextToken *string `type:"string"`

	// The services that have processed one of the specified requests.
	Services []Service `type:"list"`
}

// String returns the string representation
func (s GetTraceGraphOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTraceGraphOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTraceGraphOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTraceGraphOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Services) > 0 {
		v := s.Services

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Services", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceSummariesRequest
type GetTraceSummariesInput struct {
	_ struct{} `type:"structure"`

	// The end of the time frame for which to retrieve traces.
	//
	// EndTime is a required field
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Specify a filter expression to retrieve trace summaries for services or requests
	// that meet certain requirements.
	FilterExpression *string `min:"1" type:"string"`

	// Specify the pagination token returned by a previous request to retrieve the
	// next page of results.
	NextToken *string `type:"string"`

	// Set to true to get summaries for only a subset of available traces.
	Sampling *bool `type:"boolean"`

	// The start of the time frame for which to retrieve traces.
	//
	// StartTime is a required field
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`
}

// String returns the string representation
func (s GetTraceSummariesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTraceSummariesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTraceSummariesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTraceSummariesInput"}

	if s.EndTime == nil {
		invalidParams.Add(aws.NewErrParamRequired("EndTime"))
	}
	if s.FilterExpression != nil && len(*s.FilterExpression) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FilterExpression", 1))
	}

	if s.StartTime == nil {
		invalidParams.Add(aws.NewErrParamRequired("StartTime"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTraceSummariesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.FilterExpression != nil {
		v := *s.FilterExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FilterExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Sampling != nil {
		v := *s.Sampling

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Sampling", protocol.BoolValue(v), metadata)
	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GetTraceSummariesResult
type GetTraceSummariesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The start time of this page of results.
	ApproximateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// If the requested time frame contained more than one page of results, you
	// can use this token to retrieve the next page. The first page contains the
	// most most recent results, closest to the end of the time frame.
	NextToken *string `type:"string"`

	// Trace IDs and metadata for traces that were found in the specified time frame.
	TraceSummaries []TraceSummary `type:"list"`

	// The total number of traces processed, including traces that did not match
	// the specified filter expression.
	TracesProcessedCount *int64 `type:"long"`
}

// String returns the string representation
func (s GetTraceSummariesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTraceSummariesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTraceSummariesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTraceSummariesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApproximateTime != nil {
		v := *s.ApproximateTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ApproximateTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TraceSummaries) > 0 {
		v := s.TraceSummaries

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TraceSummaries", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.TracesProcessedCount != nil {
		v := *s.TracesProcessedCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TracesProcessedCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Details and metadata for a group.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Group
type Group struct {
	_ struct{} `type:"structure"`

	// The filter expression defining the parameters to include traces.
	FilterExpression *string `type:"string"`

	// The ARN of the group generated based on the GroupName.
	GroupARN *string `type:"string"`

	// The unique case-sensitive name of the group.
	GroupName *string `type:"string"`
}

// String returns the string representation
func (s Group) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Group) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Group) MarshalFields(e protocol.FieldEncoder) error {
	if s.FilterExpression != nil {
		v := *s.FilterExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FilterExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupARN != nil {
		v := *s.GroupARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupName != nil {
		v := *s.GroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Details for a group without metadata.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/GroupSummary
type GroupSummary struct {
	_ struct{} `type:"structure"`

	// The filter expression defining the parameters to include traces.
	FilterExpression *string `type:"string"`

	// The ARN of the group generated based on the GroupName.
	GroupARN *string `type:"string"`

	// The unique case-sensitive name of the group.
	GroupName *string `type:"string"`
}

// String returns the string representation
func (s GroupSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GroupSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GroupSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.FilterExpression != nil {
		v := *s.FilterExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FilterExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupARN != nil {
		v := *s.GroupARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupName != nil {
		v := *s.GroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// An entry in a histogram for a statistic. A histogram maps the range of observed
// values on the X axis, and the prevalence of each value on the Y axis.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/HistogramEntry
type HistogramEntry struct {
	_ struct{} `type:"structure"`

	// The prevalence of the entry.
	Count *int64 `type:"integer"`

	// The value of the entry.
	Value *float64 `type:"double"`
}

// String returns the string representation
func (s HistogramEntry) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HistogramEntry) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HistogramEntry) MarshalFields(e protocol.FieldEncoder) error {
	if s.Count != nil {
		v := *s.Count

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Count", protocol.Int64Value(v), metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.Float64Value(v), metadata)
	}
	return nil
}

// Information about an HTTP request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Http
type Http struct {
	_ struct{} `type:"structure"`

	// The IP address of the requestor.
	ClientIp *string `type:"string"`

	// The request method.
	HttpMethod *string `type:"string"`

	// The response status.
	HttpStatus *int64 `type:"integer"`

	// The request URL.
	HttpURL *string `type:"string"`

	// The request's user agent string.
	UserAgent *string `type:"string"`
}

// String returns the string representation
func (s Http) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Http) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Http) MarshalFields(e protocol.FieldEncoder) error {
	if s.ClientIp != nil {
		v := *s.ClientIp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ClientIp", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpMethod", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpStatus != nil {
		v := *s.HttpStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpStatus", protocol.Int64Value(v), metadata)
	}
	if s.HttpURL != nil {
		v := *s.HttpURL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpURL", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserAgent != nil {
		v := *s.UserAgent

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UserAgent", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A list of EC2 instance IDs corresponding to the segments in a trace.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/InstanceIdDetail
type InstanceIdDetail struct {
	_ struct{} `type:"structure"`

	// The ID of a corresponding EC2 instance.
	Id *string `type:"string"`
}

// String returns the string representation
func (s InstanceIdDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InstanceIdDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InstanceIdDetail) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutEncryptionConfigRequest
type PutEncryptionConfigInput struct {
	_ struct{} `type:"structure"`

	// An AWS KMS customer master key (CMK) in one of the following formats:
	//
	//    * Alias - The name of the key. For example, alias/MyKey.
	//
	//    * Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456.
	//
	//    * ARN - The full Amazon Resource Name of the key ID or alias. For example,
	//    arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456.
	//    Use this format to specify a key in a different account.
	//
	// Omit this key if you set Type to NONE.
	KeyId *string `min:"1" type:"string"`

	// The type of encryption. Set to KMS to use your own key for encryption. Set
	// to NONE for default encryption.
	//
	// Type is a required field
	Type EncryptionType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s PutEncryptionConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutEncryptionConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutEncryptionConfigInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutEncryptionConfigInput"}
	if s.KeyId != nil && len(*s.KeyId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("KeyId", 1))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutEncryptionConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutEncryptionConfigResult
type PutEncryptionConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The new encryption configuration.
	EncryptionConfig *EncryptionConfig `type:"structure"`
}

// String returns the string representation
func (s PutEncryptionConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutEncryptionConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutEncryptionConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutEncryptionConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.EncryptionConfig != nil {
		v := s.EncryptionConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EncryptionConfig", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTelemetryRecordsRequest
type PutTelemetryRecordsInput struct {
	_ struct{} `type:"structure"`

	EC2InstanceId *string `type:"string"`

	Hostname *string `type:"string"`

	ResourceARN *string `type:"string"`

	// TelemetryRecords is a required field
	TelemetryRecords []TelemetryRecord `type:"list" required:"true"`
}

// String returns the string representation
func (s PutTelemetryRecordsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutTelemetryRecordsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutTelemetryRecordsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutTelemetryRecordsInput"}

	if s.TelemetryRecords == nil {
		invalidParams.Add(aws.NewErrParamRequired("TelemetryRecords"))
	}
	if s.TelemetryRecords != nil {
		for i, v := range s.TelemetryRecords {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TelemetryRecords", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutTelemetryRecordsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.EC2InstanceId != nil {
		v := *s.EC2InstanceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EC2InstanceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Hostname != nil {
		v := *s.Hostname

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Hostname", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceARN != nil {
		v := *s.ResourceARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TelemetryRecords) > 0 {
		v := s.TelemetryRecords

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TelemetryRecords", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTelemetryRecordsResult
type PutTelemetryRecordsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s PutTelemetryRecordsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutTelemetryRecordsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutTelemetryRecordsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutTelemetryRecordsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTraceSegmentsRequest
type PutTraceSegmentsInput struct {
	_ struct{} `type:"structure"`

	// A string containing a JSON document defining one or more segments or subsegments.
	//
	// TraceSegmentDocuments is a required field
	TraceSegmentDocuments []string `type:"list" required:"true"`
}

// String returns the string representation
func (s PutTraceSegmentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutTraceSegmentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutTraceSegmentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutTraceSegmentsInput"}

	if s.TraceSegmentDocuments == nil {
		invalidParams.Add(aws.NewErrParamRequired("TraceSegmentDocuments"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutTraceSegmentsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.TraceSegmentDocuments) > 0 {
		v := s.TraceSegmentDocuments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TraceSegmentDocuments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/PutTraceSegmentsResult
type PutTraceSegmentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Segments that failed processing.
	UnprocessedTraceSegments []UnprocessedTraceSegment `type:"list"`
}

// String returns the string representation
func (s PutTraceSegmentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutTraceSegmentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutTraceSegmentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutTraceSegmentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.UnprocessedTraceSegments) > 0 {
		v := s.UnprocessedTraceSegments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UnprocessedTraceSegments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A list of resources ARNs corresponding to the segments in a trace.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ResourceARNDetail
type ResourceARNDetail struct {
	_ struct{} `type:"structure"`

	// The ARN of a corresponding resource.
	ARN *string `type:"string"`
}

// String returns the string representation
func (s ResourceARNDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourceARNDetail) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourceARNDetail) MarshalFields(e protocol.FieldEncoder) error {
	if s.ARN != nil {
		v := *s.ARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The root cause information for a response time warning.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ResponseTimeRootCause
type ResponseTimeRootCause struct {
	_ struct{} `type:"structure"`

	// A list of corresponding services. A service identifies a segment and contains
	// a name, account ID, type, and inferred flag.
	Services []ResponseTimeRootCauseService `type:"list"`
}

// String returns the string representation
func (s ResponseTimeRootCause) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResponseTimeRootCause) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResponseTimeRootCause) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Services) > 0 {
		v := s.Services

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Services", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A collection of segments and corresponding subsegments associated to a response
// time warning.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ResponseTimeRootCauseEntity
type ResponseTimeRootCauseEntity struct {
	_ struct{} `type:"structure"`

	// The types and messages of the exceptions.
	Coverage *float64 `type:"double"`

	// The name of the entity.
	Name *string `type:"string"`

	// A flag that denotes a remote subsegment.
	Remote *bool `type:"boolean"`
}

// String returns the string representation
func (s ResponseTimeRootCauseEntity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResponseTimeRootCauseEntity) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResponseTimeRootCauseEntity) MarshalFields(e protocol.FieldEncoder) error {
	if s.Coverage != nil {
		v := *s.Coverage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Coverage", protocol.Float64Value(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Remote != nil {
		v := *s.Remote

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Remote", protocol.BoolValue(v), metadata)
	}
	return nil
}

// A collection of fields identifying the service in a response time warning.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ResponseTimeRootCauseService
type ResponseTimeRootCauseService struct {
	_ struct{} `type:"structure"`

	// The account ID associated to the service.
	AccountId *string `type:"string"`

	// The path of root cause entities found on the service.
	EntityPath []ResponseTimeRootCauseEntity `type:"list"`

	// A Boolean value indicating if the service is inferred from the trace.
	Inferred *bool `type:"boolean"`

	// The service name.
	Name *string `type:"string"`

	// A collection of associated service names.
	Names []string `type:"list"`

	// The type associated to the service.
	Type *string `type:"string"`
}

// String returns the string representation
func (s ResponseTimeRootCauseService) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResponseTimeRootCauseService) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResponseTimeRootCauseService) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EntityPath) > 0 {
		v := s.EntityPath

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "EntityPath", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Inferred != nil {
		v := *s.Inferred

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Inferred", protocol.BoolValue(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The exception associated with a root cause.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/RootCauseException
type RootCauseException struct {
	_ struct{} `type:"structure"`

	// The message of the exception.
	Message *string `type:"string"`

	// The name of the exception.
	Name *string `type:"string"`
}

// String returns the string representation
func (s RootCauseException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RootCauseException) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RootCauseException) MarshalFields(e protocol.FieldEncoder) error {
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Message", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A sampling rule that services use to decide whether to instrument a request.
// Rule fields can match properties of the service, or properties of a request.
// The service can ignore rules that don't match its properties.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/SamplingRule
type SamplingRule struct {
	_ struct{} `type:"structure"`

	// Matches attributes derived from the request.
	Attributes map[string]string `type:"map"`

	// The percentage of matching requests to instrument, after the reservoir is
	// exhausted.
	//
	// FixedRate is a required field
	FixedRate *float64 `type:"double" required:"true"`

	// Matches the HTTP method of a request.
	//
	// HTTPMethod is a required field
	HTTPMethod *string `type:"string" required:"true"`

	// Matches the hostname from a request URL.
	//
	// Host is a required field
	Host *string `type:"string" required:"true"`

	// The priority of the sampling rule.
	//
	// Priority is a required field
	Priority *int64 `min:"1" type:"integer" required:"true"`

	// A fixed number of matching requests to instrument per second, prior to applying
	// the fixed rate. The reservoir is not used directly by services, but applies
	// to all services using the rule collectively.
	//
	// ReservoirSize is a required field
	ReservoirSize *int64 `type:"integer" required:"true"`

	// Matches the ARN of the AWS resource on which the service runs.
	//
	// ResourceARN is a required field
	ResourceARN *string `type:"string" required:"true"`

	// The ARN of the sampling rule. Specify a rule by either name or ARN, but not
	// both.
	RuleARN *string `type:"string"`

	// The name of the sampling rule. Specify a rule by either name or ARN, but
	// not both.
	RuleName *string `min:"1" type:"string"`

	// Matches the name that the service uses to identify itself in segments.
	//
	// ServiceName is a required field
	ServiceName *string `type:"string" required:"true"`

	// Matches the origin that the service uses to identify its type in segments.
	//
	// ServiceType is a required field
	ServiceType *string `type:"string" required:"true"`

	// Matches the path from a request URL.
	//
	// URLPath is a required field
	URLPath *string `type:"string" required:"true"`

	// The version of the sampling rule format (1).
	//
	// Version is a required field
	Version *int64 `min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s SamplingRule) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SamplingRule) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SamplingRule) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SamplingRule"}

	if s.FixedRate == nil {
		invalidParams.Add(aws.NewErrParamRequired("FixedRate"))
	}

	if s.HTTPMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HTTPMethod"))
	}

	if s.Host == nil {
		invalidParams.Add(aws.NewErrParamRequired("Host"))
	}

	if s.Priority == nil {
		invalidParams.Add(aws.NewErrParamRequired("Priority"))
	}
	if s.Priority != nil && *s.Priority < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Priority", 1))
	}

	if s.ReservoirSize == nil {
		invalidParams.Add(aws.NewErrParamRequired("ReservoirSize"))
	}

	if s.ResourceARN == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceARN"))
	}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if s.ServiceName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ServiceName"))
	}

	if s.ServiceType == nil {
		invalidParams.Add(aws.NewErrParamRequired("ServiceType"))
	}

	if s.URLPath == nil {
		invalidParams.Add(aws.NewErrParamRequired("URLPath"))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && *s.Version < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SamplingRule) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Attributes", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.FixedRate != nil {
		v := *s.FixedRate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FixedRate", protocol.Float64Value(v), metadata)
	}
	if s.HTTPMethod != nil {
		v := *s.HTTPMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HTTPMethod", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Host != nil {
		v := *s.Host

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Host", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Priority", protocol.Int64Value(v), metadata)
	}
	if s.ReservoirSize != nil {
		v := *s.ReservoirSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservoirSize", protocol.Int64Value(v), metadata)
	}
	if s.ResourceARN != nil {
		v := *s.ResourceARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleARN != nil {
		v := *s.RuleARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ServiceName != nil {
		v := *s.ServiceName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ServiceName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ServiceType != nil {
		v := *s.ServiceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ServiceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.URLPath != nil {
		v := *s.URLPath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "URLPath", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Version", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A SamplingRule and its metadata.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/SamplingRuleRecord
type SamplingRuleRecord struct {
	_ struct{} `type:"structure"`

	// When the rule was created.
	CreatedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// When the rule was last modified.
	ModifiedAt *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The sampling rule.
	SamplingRule *SamplingRule `type:"structure"`
}

// String returns the string representation
func (s SamplingRuleRecord) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SamplingRuleRecord) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SamplingRuleRecord) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedAt != nil {
		v := *s.CreatedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreatedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.ModifiedAt != nil {
		v := *s.ModifiedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ModifiedAt", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.SamplingRule != nil {
		v := s.SamplingRule

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SamplingRule", v, metadata)
	}
	return nil
}

// A document specifying changes to a sampling rule's configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/SamplingRuleUpdate
type SamplingRuleUpdate struct {
	_ struct{} `type:"structure"`

	// Matches attributes derived from the request.
	Attributes map[string]string `type:"map"`

	// The percentage of matching requests to instrument, after the reservoir is
	// exhausted.
	FixedRate *float64 `type:"double"`

	// Matches the HTTP method of a request.
	HTTPMethod *string `type:"string"`

	// Matches the hostname from a request URL.
	Host *string `type:"string"`

	// The priority of the sampling rule.
	Priority *int64 `type:"integer"`

	// A fixed number of matching requests to instrument per second, prior to applying
	// the fixed rate. The reservoir is not used directly by services, but applies
	// to all services using the rule collectively.
	ReservoirSize *int64 `type:"integer"`

	// Matches the ARN of the AWS resource on which the service runs.
	ResourceARN *string `type:"string"`

	// The ARN of the sampling rule. Specify a rule by either name or ARN, but not
	// both.
	RuleARN *string `type:"string"`

	// The name of the sampling rule. Specify a rule by either name or ARN, but
	// not both.
	RuleName *string `min:"1" type:"string"`

	// Matches the name that the service uses to identify itself in segments.
	ServiceName *string `type:"string"`

	// Matches the origin that the service uses to identify its type in segments.
	ServiceType *string `type:"string"`

	// Matches the path from a request URL.
	URLPath *string `type:"string"`
}

// String returns the string representation
func (s SamplingRuleUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SamplingRuleUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SamplingRuleUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SamplingRuleUpdate"}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SamplingRuleUpdate) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Attributes) > 0 {
		v := s.Attributes

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Attributes", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.FixedRate != nil {
		v := *s.FixedRate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FixedRate", protocol.Float64Value(v), metadata)
	}
	if s.HTTPMethod != nil {
		v := *s.HTTPMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HTTPMethod", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Host != nil {
		v := *s.Host

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Host", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Priority", protocol.Int64Value(v), metadata)
	}
	if s.ReservoirSize != nil {
		v := *s.ReservoirSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservoirSize", protocol.Int64Value(v), metadata)
	}
	if s.ResourceARN != nil {
		v := *s.ResourceARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleARN != nil {
		v := *s.RuleARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ServiceName != nil {
		v := *s.ServiceName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ServiceName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ServiceType != nil {
		v := *s.ServiceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ServiceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.URLPath != nil {
		v := *s.URLPath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "URLPath", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Aggregated request sampling data for a sampling rule across all services
// for a 10 second window.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/SamplingStatisticSummary
type SamplingStatisticSummary struct {
	_ struct{} `type:"structure"`

	// The number of requests recorded with borrowed reservoir quota.
	BorrowCount *int64 `type:"integer"`

	// The number of requests that matched the rule.
	RequestCount *int64 `type:"integer"`

	// The name of the sampling rule.
	RuleName *string `type:"string"`

	// The number of requests recorded.
	SampledCount *int64 `type:"integer"`

	// The start time of the reporting window.
	Timestamp *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s SamplingStatisticSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SamplingStatisticSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SamplingStatisticSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.BorrowCount != nil {
		v := *s.BorrowCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BorrowCount", protocol.Int64Value(v), metadata)
	}
	if s.RequestCount != nil {
		v := *s.RequestCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RequestCount", protocol.Int64Value(v), metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SampledCount != nil {
		v := *s.SampledCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SampledCount", protocol.Int64Value(v), metadata)
	}
	if s.Timestamp != nil {
		v := *s.Timestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Timestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Request sampling results for a single rule from a service. Results are for
// the last 10 seconds unless the service has been assigned a longer reporting
// interval after a previous call to GetSamplingTargets.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/SamplingStatisticsDocument
type SamplingStatisticsDocument struct {
	_ struct{} `type:"structure"`

	// The number of requests recorded with borrowed reservoir quota.
	BorrowCount *int64 `type:"integer"`

	// A unique identifier for the service in hexadecimal.
	//
	// ClientID is a required field
	ClientID *string `min:"24" type:"string" required:"true"`

	// The number of requests that matched the rule.
	//
	// RequestCount is a required field
	RequestCount *int64 `type:"integer" required:"true"`

	// The name of the sampling rule.
	//
	// RuleName is a required field
	RuleName *string `min:"1" type:"string" required:"true"`

	// The number of requests recorded.
	//
	// SampledCount is a required field
	SampledCount *int64 `type:"integer" required:"true"`

	// The current time.
	//
	// Timestamp is a required field
	Timestamp *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`
}

// String returns the string representation
func (s SamplingStatisticsDocument) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SamplingStatisticsDocument) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SamplingStatisticsDocument) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "SamplingStatisticsDocument"}

	if s.ClientID == nil {
		invalidParams.Add(aws.NewErrParamRequired("ClientID"))
	}
	if s.ClientID != nil && len(*s.ClientID) < 24 {
		invalidParams.Add(aws.NewErrParamMinLen("ClientID", 24))
	}

	if s.RequestCount == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestCount"))
	}

	if s.RuleName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RuleName"))
	}
	if s.RuleName != nil && len(*s.RuleName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RuleName", 1))
	}

	if s.SampledCount == nil {
		invalidParams.Add(aws.NewErrParamRequired("SampledCount"))
	}

	if s.Timestamp == nil {
		invalidParams.Add(aws.NewErrParamRequired("Timestamp"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SamplingStatisticsDocument) MarshalFields(e protocol.FieldEncoder) error {
	if s.BorrowCount != nil {
		v := *s.BorrowCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BorrowCount", protocol.Int64Value(v), metadata)
	}
	if s.ClientID != nil {
		v := *s.ClientID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ClientID", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RequestCount != nil {
		v := *s.RequestCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RequestCount", protocol.Int64Value(v), metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SampledCount != nil {
		v := *s.SampledCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SampledCount", protocol.Int64Value(v), metadata)
	}
	if s.Timestamp != nil {
		v := *s.Timestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Timestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// Temporary changes to a sampling rule configuration. To meet the global sampling
// target for a rule, X-Ray calculates a new reservoir for each service based
// on the recent sampling results of all services that called GetSamplingTargets.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/SamplingTargetDocument
type SamplingTargetDocument struct {
	_ struct{} `type:"structure"`

	// The percentage of matching requests to instrument, after the reservoir is
	// exhausted.
	FixedRate *float64 `type:"double"`

	// The number of seconds for the service to wait before getting sampling targets
	// again.
	Interval *int64 `type:"integer"`

	// The number of requests per second that X-Ray allocated this service.
	ReservoirQuota *int64 `type:"integer"`

	// When the reservoir quota expires.
	ReservoirQuotaTTL *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The name of the sampling rule.
	RuleName *string `type:"string"`
}

// String returns the string representation
func (s SamplingTargetDocument) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SamplingTargetDocument) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SamplingTargetDocument) MarshalFields(e protocol.FieldEncoder) error {
	if s.FixedRate != nil {
		v := *s.FixedRate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FixedRate", protocol.Float64Value(v), metadata)
	}
	if s.Interval != nil {
		v := *s.Interval

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Interval", protocol.Int64Value(v), metadata)
	}
	if s.ReservoirQuota != nil {
		v := *s.ReservoirQuota

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservoirQuota", protocol.Int64Value(v), metadata)
	}
	if s.ReservoirQuotaTTL != nil {
		v := *s.ReservoirQuotaTTL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservoirQuotaTTL", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A segment from a trace that has been ingested by the X-Ray service. The segment
// can be compiled from documents uploaded with PutTraceSegments, or an inferred
// segment for a downstream service, generated from a subsegment sent by the
// service that called it.
//
// For the full segment document schema, see AWS X-Ray Segment Documents (https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html)
// in the AWS X-Ray Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Segment
type Segment struct {
	_ struct{} `type:"structure"`

	// The segment document.
	Document *string `min:"1" type:"string"`

	// The segment's ID.
	Id *string `type:"string"`
}

// String returns the string representation
func (s Segment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Segment) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Segment) MarshalFields(e protocol.FieldEncoder) error {
	if s.Document != nil {
		v := *s.Document

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Document", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about an application that processed requests, users that made
// requests, or downstream services, resources and applications that an application
// used.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Service
type Service struct {
	_ struct{} `type:"structure"`

	// Identifier of the AWS account in which the service runs.
	AccountId *string `type:"string"`

	// A histogram that maps the spread of service durations.
	DurationHistogram []HistogramEntry `type:"list"`

	// Connections to downstream services.
	Edges []Edge `type:"list"`

	// The end time of the last segment that the service generated.
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The canonical name of the service.
	Name *string `type:"string"`

	// A list of names for the service, including the canonical name.
	Names []string `type:"list"`

	// Identifier for the service. Unique within the service map.
	ReferenceId *int64 `type:"integer"`

	// A histogram that maps the spread of service response times.
	ResponseTimeHistogram []HistogramEntry `type:"list"`

	// Indicates that the service was the first service to process a request.
	Root *bool `type:"boolean"`

	// The start time of the first segment that the service generated.
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The service's state.
	State *string `type:"string"`

	// Aggregated statistics for the service.
	SummaryStatistics *ServiceStatistics `type:"structure"`

	// The type of service.
	//
	//    * AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance
	//    for a application running on Amazon EC2 or AWS::DynamoDB::Table for an
	//    Amazon DynamoDB table that the application used.
	//
	//    * AWS Service - The type of an AWS service. For example, AWS::DynamoDB
	//    for downstream calls to Amazon DynamoDB that didn't target a specific
	//    table.
	//
	//    * client - Represents the clients that sent requests to a root service.
	//
	//    * remote - A downstream service of indeterminate type.
	Type *string `type:"string"`
}

// String returns the string representation
func (s Service) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Service) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Service) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.DurationHistogram) > 0 {
		v := s.DurationHistogram

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "DurationHistogram", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Edges) > 0 {
		v := s.Edges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Edges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.EndTime != nil {
		v := *s.EndTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EndTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ReferenceId != nil {
		v := *s.ReferenceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReferenceId", protocol.Int64Value(v), metadata)
	}
	if len(s.ResponseTimeHistogram) > 0 {
		v := s.ResponseTimeHistogram

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResponseTimeHistogram", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Root != nil {
		v := *s.Root

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Root", protocol.BoolValue(v), metadata)
	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.State != nil {
		v := *s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SummaryStatistics != nil {
		v := s.SummaryStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SummaryStatistics", v, metadata)
	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ServiceId
type ServiceId struct {
	_ struct{} `type:"structure"`

	AccountId *string `type:"string"`

	Name *string `type:"string"`

	Names []string `type:"list"`

	Type *string `type:"string"`
}

// String returns the string representation
func (s ServiceId) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ServiceId) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ServiceId) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccountId != nil {
		v := *s.AccountId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccountId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Names) > 0 {
		v := s.Names

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Names", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Response statistics for a service.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ServiceStatistics
type ServiceStatistics struct {
	_ struct{} `type:"structure"`

	// Information about requests that failed with a 4xx Client Error status code.
	ErrorStatistics *ErrorStatistics `type:"structure"`

	// Information about requests that failed with a 5xx Server Error status code.
	FaultStatistics *FaultStatistics `type:"structure"`

	// The number of requests that completed with a 2xx Success status code.
	OkCount *int64 `type:"long"`

	// The total number of completed requests.
	TotalCount *int64 `type:"long"`

	// The aggregate response time of completed requests.
	TotalResponseTime *float64 `type:"double"`
}

// String returns the string representation
func (s ServiceStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ServiceStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ServiceStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorStatistics != nil {
		v := s.ErrorStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ErrorStatistics", v, metadata)
	}
	if s.FaultStatistics != nil {
		v := s.FaultStatistics

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "FaultStatistics", v, metadata)
	}
	if s.OkCount != nil {
		v := *s.OkCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "OkCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalCount != nil {
		v := *s.TotalCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalCount", protocol.Int64Value(v), metadata)
	}
	if s.TotalResponseTime != nil {
		v := *s.TotalResponseTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalResponseTime", protocol.Float64Value(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/TelemetryRecord
type TelemetryRecord struct {
	_ struct{} `type:"structure"`

	BackendConnectionErrors *BackendConnectionErrors `type:"structure"`

	SegmentsReceivedCount *int64 `type:"integer"`

	SegmentsRejectedCount *int64 `type:"integer"`

	SegmentsSentCount *int64 `type:"integer"`

	SegmentsSpilloverCount *int64 `type:"integer"`

	// Timestamp is a required field
	Timestamp *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`
}

// String returns the string representation
func (s TelemetryRecord) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TelemetryRecord) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TelemetryRecord) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TelemetryRecord"}

	if s.Timestamp == nil {
		invalidParams.Add(aws.NewErrParamRequired("Timestamp"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TelemetryRecord) MarshalFields(e protocol.FieldEncoder) error {
	if s.BackendConnectionErrors != nil {
		v := s.BackendConnectionErrors

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "BackendConnectionErrors", v, metadata)
	}
	if s.SegmentsReceivedCount != nil {
		v := *s.SegmentsReceivedCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SegmentsReceivedCount", protocol.Int64Value(v), metadata)
	}
	if s.SegmentsRejectedCount != nil {
		v := *s.SegmentsRejectedCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SegmentsRejectedCount", protocol.Int64Value(v), metadata)
	}
	if s.SegmentsSentCount != nil {
		v := *s.SegmentsSentCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SegmentsSentCount", protocol.Int64Value(v), metadata)
	}
	if s.SegmentsSpilloverCount != nil {
		v := *s.SegmentsSpilloverCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SegmentsSpilloverCount", protocol.Int64Value(v), metadata)
	}
	if s.Timestamp != nil {
		v := *s.Timestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Timestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	return nil
}

// A collection of segment documents with matching trace IDs.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/Trace
type Trace struct {
	_ struct{} `type:"structure"`

	// The length of time in seconds between the start time of the root segment
	// and the end time of the last segment that completed.
	Duration *float64 `type:"double"`

	// The unique identifier for the request that generated the trace's segments
	// and subsegments.
	Id *string `min:"1" type:"string"`

	// Segment documents for the segments and subsegments that comprise the trace.
	Segments []Segment `type:"list"`
}

// String returns the string representation
func (s Trace) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Trace) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Trace) MarshalFields(e protocol.FieldEncoder) error {
	if s.Duration != nil {
		v := *s.Duration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Duration", protocol.Float64Value(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Segments) > 0 {
		v := s.Segments

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Segments", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Metadata generated from the segment documents in a trace.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/TraceSummary
type TraceSummary struct {
	_ struct{} `type:"structure"`

	// Annotations from the trace's segment documents.
	Annotations map[string][]ValueWithServiceIds `type:"map"`

	// A list of availability zones for any zone corresponding to the trace segments.
	AvailabilityZones []AvailabilityZoneDetail `type:"list"`

	// The length of time in seconds between the start time of the root segment
	// and the end time of the last segment that completed.
	Duration *float64 `type:"double"`

	// The root of a trace.
	EntryPoint *ServiceId `type:"structure"`

	// A collection of ErrorRootCause structures corresponding to the trace segments.
	ErrorRootCauses []ErrorRootCause `type:"list"`

	// A collection of FaultRootCause structures corresponding to the the trace
	// segments.
	FaultRootCauses []FaultRootCause `type:"list"`

	// One or more of the segment documents has a 400 series error.
	HasError *bool `type:"boolean"`

	// One or more of the segment documents has a 500 series error.
	HasFault *bool `type:"boolean"`

	// One or more of the segment documents has a 429 throttling error.
	HasThrottle *bool `type:"boolean"`

	// Information about the HTTP request served by the trace.
	Http *Http `type:"structure"`

	// The unique identifier for the request that generated the trace's segments
	// and subsegments.
	Id *string `min:"1" type:"string"`

	// A list of EC2 instance IDs for any instance corresponding to the trace segments.
	InstanceIds []InstanceIdDetail `type:"list"`

	// One or more of the segment documents is in progress.
	IsPartial *bool `type:"boolean"`

	// A list of resource ARNs for any resource corresponding to the trace segments.
	ResourceARNs []ResourceARNDetail `type:"list"`

	// The length of time in seconds between the start and end times of the root
	// segment. If the service performs work asynchronously, the response time measures
	// the time before the response is sent to the user, while the duration measures
	// the amount of time before the last traced activity completes.
	ResponseTime *float64 `type:"double"`

	// A collection of ResponseTimeRootCause structures corresponding to the trace
	// segments.
	ResponseTimeRootCauses []ResponseTimeRootCause `type:"list"`

	// The revision number of a trace.
	Revision *int64 `type:"integer"`

	// Service IDs from the trace's segment documents.
	ServiceIds []ServiceId `type:"list"`

	// Users from the trace's segment documents.
	Users []TraceUser `type:"list"`
}

// String returns the string representation
func (s TraceSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TraceSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TraceSummary) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Annotations) > 0 {
		v := s.Annotations

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Annotations", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ls1 := ms0.List(k1)
			ls1.Start()
			for _, v2 := range v1 {
				ls1.ListAddFields(v2)
			}
			ls1.End()
		}
		ms0.End()

	}
	if len(s.AvailabilityZones) > 0 {
		v := s.AvailabilityZones

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AvailabilityZones", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Duration != nil {
		v := *s.Duration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Duration", protocol.Float64Value(v), metadata)
	}
	if s.EntryPoint != nil {
		v := s.EntryPoint

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EntryPoint", v, metadata)
	}
	if len(s.ErrorRootCauses) > 0 {
		v := s.ErrorRootCauses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ErrorRootCauses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.FaultRootCauses) > 0 {
		v := s.FaultRootCauses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FaultRootCauses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.HasError != nil {
		v := *s.HasError

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HasError", protocol.BoolValue(v), metadata)
	}
	if s.HasFault != nil {
		v := *s.HasFault

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HasFault", protocol.BoolValue(v), metadata)
	}
	if s.HasThrottle != nil {
		v := *s.HasThrottle

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HasThrottle", protocol.BoolValue(v), metadata)
	}
	if s.Http != nil {
		v := s.Http

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Http", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.InstanceIds) > 0 {
		v := s.InstanceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "InstanceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.IsPartial != nil {
		v := *s.IsPartial

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsPartial", protocol.BoolValue(v), metadata)
	}
	if len(s.ResourceARNs) > 0 {
		v := s.ResourceARNs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResourceARNs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResponseTime != nil {
		v := *s.ResponseTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResponseTime", protocol.Float64Value(v), metadata)
	}
	if len(s.ResponseTimeRootCauses) > 0 {
		v := s.ResponseTimeRootCauses

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ResponseTimeRootCauses", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Revision != nil {
		v := *s.Revision

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Revision", protocol.Int64Value(v), metadata)
	}
	if len(s.ServiceIds) > 0 {
		v := s.ServiceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ServiceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.Users) > 0 {
		v := s.Users

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Users", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Information about a user recorded in segment documents.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/TraceUser
type TraceUser struct {
	_ struct{} `type:"structure"`

	// Services that the user's request hit.
	ServiceIds []ServiceId `type:"list"`

	// The user's name.
	UserName *string `type:"string"`
}

// String returns the string representation
func (s TraceUser) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TraceUser) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TraceUser) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ServiceIds) > 0 {
		v := s.ServiceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ServiceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.UserName != nil {
		v := *s.UserName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UserName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Sampling statistics from a call to GetSamplingTargets that X-Ray could not
// process.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UnprocessedStatistics
type UnprocessedStatistics struct {
	_ struct{} `type:"structure"`

	// The error code.
	ErrorCode *string `type:"string"`

	// The error message.
	Message *string `type:"string"`

	// The name of the sampling rule.
	RuleName *string `type:"string"`
}

// String returns the string representation
func (s UnprocessedStatistics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UnprocessedStatistics) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UnprocessedStatistics) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorCode != nil {
		v := *s.ErrorCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ErrorCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Message", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RuleName != nil {
		v := *s.RuleName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RuleName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Information about a segment that failed processing.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UnprocessedTraceSegment
type UnprocessedTraceSegment struct {
	_ struct{} `type:"structure"`

	// The error that caused processing to fail.
	ErrorCode *string `type:"string"`

	// The segment's ID.
	Id *string `type:"string"`

	// The error message.
	Message *string `type:"string"`
}

// String returns the string representation
func (s UnprocessedTraceSegment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UnprocessedTraceSegment) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UnprocessedTraceSegment) MarshalFields(e protocol.FieldEncoder) error {
	if s.ErrorCode != nil {
		v := *s.ErrorCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ErrorCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Message", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UpdateGroupRequest
type UpdateGroupInput struct {
	_ struct{} `type:"structure"`

	// The updated filter expression defining criteria by which to group traces.
	FilterExpression *string `min:"1" type:"string"`

	// The ARN that was generated upon creation.
	GroupARN *string `min:"1" type:"string"`

	// The case-sensitive name of the group.
	GroupName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s UpdateGroupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGroupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateGroupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateGroupInput"}
	if s.FilterExpression != nil && len(*s.FilterExpression) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FilterExpression", 1))
	}
	if s.GroupARN != nil && len(*s.GroupARN) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupARN", 1))
	}
	if s.GroupName != nil && len(*s.GroupName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GroupName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateGroupInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.FilterExpression != nil {
		v := *s.FilterExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FilterExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupARN != nil {
		v := *s.GroupARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.GroupName != nil {
		v := *s.GroupName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GroupName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UpdateGroupResult
type UpdateGroupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The group that was updated. Contains the name of the group that was updated,
	// the ARN of the group that was updated, and the updated filter expression
	// assigned to the group.
	Group *Group `type:"structure"`
}

// String returns the string representation
func (s UpdateGroupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGroupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateGroupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateGroupOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Group != nil {
		v := s.Group

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Group", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UpdateSamplingRuleRequest
type UpdateSamplingRuleInput struct {
	_ struct{} `type:"structure"`

	// The rule and fields to change.
	//
	// SamplingRuleUpdate is a required field
	SamplingRuleUpdate *SamplingRuleUpdate `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateSamplingRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateSamplingRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateSamplingRuleInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateSamplingRuleInput"}

	if s.SamplingRuleUpdate == nil {
		invalidParams.Add(aws.NewErrParamRequired("SamplingRuleUpdate"))
	}
	if s.SamplingRuleUpdate != nil {
		if err := s.SamplingRuleUpdate.Validate(); err != nil {
			invalidParams.AddNested("SamplingRuleUpdate", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateSamplingRuleInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.SamplingRuleUpdate != nil {
		v := s.SamplingRuleUpdate

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SamplingRuleUpdate", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/UpdateSamplingRuleResult
type UpdateSamplingRuleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The updated rule definition and metadata.
	SamplingRuleRecord *SamplingRuleRecord `type:"structure"`
}

// String returns the string representation
func (s UpdateSamplingRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateSamplingRuleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateSamplingRuleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateSamplingRuleOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.SamplingRuleRecord != nil {
		v := s.SamplingRuleRecord

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SamplingRuleRecord", v, metadata)
	}
	return nil
}

// Information about a segment annotation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/xray-2016-04-12/ValueWithServiceIds
type ValueWithServiceIds struct {
	_ struct{} `type:"structure"`

	// Values of the annotation.
	AnnotationValue *AnnotationValue `type:"structure"`

	// Services to which the annotation applies.
	ServiceIds []ServiceId `type:"list"`
}

// String returns the string representation
func (s ValueWithServiceIds) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ValueWithServiceIds) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ValueWithServiceIds) MarshalFields(e protocol.FieldEncoder) error {
	if s.AnnotationValue != nil {
		v := s.AnnotationValue

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AnnotationValue", v, metadata)
	}
	if len(s.ServiceIds) > 0 {
		v := s.ServiceIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ServiceIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type EncryptionStatus string

// Enum values for EncryptionStatus
const (
	EncryptionStatusUpdating EncryptionStatus = "UPDATING"
	EncryptionStatusActive   EncryptionStatus = "ACTIVE"
)

func (enum EncryptionStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EncryptionStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type EncryptionType string

// Enum values for EncryptionType
const (
	EncryptionTypeNone EncryptionType = "NONE"
	EncryptionTypeKms  EncryptionType = "KMS"
)

func (enum EncryptionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EncryptionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
