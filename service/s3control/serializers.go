// Code generated by smithy-go-codegen DO NOT EDIT.

package s3control

import (
	"bytes"
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/s3control/types"
	smithy "github.com/awslabs/smithy-go"
	"github.com/awslabs/smithy-go/httpbinding"
	"github.com/awslabs/smithy-go/middleware"
	smithytime "github.com/awslabs/smithy-go/time"
	smithyhttp "github.com/awslabs/smithy-go/transport/http"
	smithyxml "github.com/awslabs/smithy-go/xml"
)

type awsRestxml_serializeOpCreateAccessPoint struct {
}

func (*awsRestxml_serializeOpCreateAccessPoint) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpCreateAccessPoint) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateAccessPointInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/accesspoint/{Name}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsCreateAccessPointInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/xml")

	xmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))
	rootAttr := []smithyxml.Attr{}
	root := smithyxml.StartElement{
		Name: smithyxml.Name{
			Local: "CreateAccessPointRequest",
		},
		Attr: rootAttr,
	}
	if err := awsRestxml_serializeOpDocumentCreateAccessPointInput(input, xmlEncoder.RootElement(root)); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	if request, err = request.SetStream(bytes.NewReader(xmlEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsCreateAccessPointInput(v *CreateAccessPointInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.Name != nil {
		if err := encoder.SetURI("Name").String(*v.Name); err != nil {
			return err
		}
	}

	return nil
}

func awsRestxml_serializeOpDocumentCreateAccessPointInput(v *CreateAccessPointInput, value smithyxml.Value) error {
	defer value.Close()
	if v.Bucket != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Bucket",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.Bucket)
	}
	if v.PublicAccessBlockConfiguration != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "PublicAccessBlockConfiguration",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentPublicAccessBlockConfiguration(v.PublicAccessBlockConfiguration, el); err != nil {
			return err
		}
	}
	if v.VpcConfiguration != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "VpcConfiguration",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentVpcConfiguration(v.VpcConfiguration, el); err != nil {
			return err
		}
	}
	return nil
}

type awsRestxml_serializeOpCreateJob struct {
}

func (*awsRestxml_serializeOpCreateJob) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpCreateJob) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*CreateJobInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/jobs")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsCreateJobInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/xml")

	xmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))
	rootAttr := []smithyxml.Attr{}
	root := smithyxml.StartElement{
		Name: smithyxml.Name{
			Local: "CreateJobRequest",
		},
		Attr: rootAttr,
	}
	if err := awsRestxml_serializeOpDocumentCreateJobInput(input, xmlEncoder.RootElement(root)); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	if request, err = request.SetStream(bytes.NewReader(xmlEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsCreateJobInput(v *CreateJobInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	return nil
}

func awsRestxml_serializeOpDocumentCreateJobInput(v *CreateJobInput, value smithyxml.Value) error {
	defer value.Close()
	if v.ClientRequestToken != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ClientRequestToken",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ClientRequestToken)
	}
	if v.ConfirmationRequired != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ConfirmationRequired",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.ConfirmationRequired)
	}
	if v.Description != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Description",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.Description)
	}
	if v.Manifest != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Manifest",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentJobManifest(v.Manifest, el); err != nil {
			return err
		}
	}
	if v.Operation != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Operation",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentJobOperation(v.Operation, el); err != nil {
			return err
		}
	}
	if v.Priority != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Priority",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Integer(*v.Priority)
	}
	if v.Report != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Report",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentJobReport(v.Report, el); err != nil {
			return err
		}
	}
	if v.RoleArn != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "RoleArn",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.RoleArn)
	}
	if v.Tags != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Tags",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3TagSet(v.Tags, el); err != nil {
			return err
		}
	}
	return nil
}

type awsRestxml_serializeOpDeleteAccessPoint struct {
}

func (*awsRestxml_serializeOpDeleteAccessPoint) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpDeleteAccessPoint) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteAccessPointInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/accesspoint/{Name}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsDeleteAccessPointInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsDeleteAccessPointInput(v *DeleteAccessPointInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.Name != nil {
		if err := encoder.SetURI("Name").String(*v.Name); err != nil {
			return err
		}
	}

	return nil
}

type awsRestxml_serializeOpDeleteAccessPointPolicy struct {
}

func (*awsRestxml_serializeOpDeleteAccessPointPolicy) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpDeleteAccessPointPolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteAccessPointPolicyInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/accesspoint/{Name}/policy")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsDeleteAccessPointPolicyInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsDeleteAccessPointPolicyInput(v *DeleteAccessPointPolicyInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.Name != nil {
		if err := encoder.SetURI("Name").String(*v.Name); err != nil {
			return err
		}
	}

	return nil
}

type awsRestxml_serializeOpDeleteJobTagging struct {
}

func (*awsRestxml_serializeOpDeleteJobTagging) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpDeleteJobTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeleteJobTaggingInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/jobs/{JobId}/tagging")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsDeleteJobTaggingInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsDeleteJobTaggingInput(v *DeleteJobTaggingInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.JobId != nil {
		if err := encoder.SetURI("JobId").String(*v.JobId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestxml_serializeOpDeletePublicAccessBlock struct {
}

func (*awsRestxml_serializeOpDeletePublicAccessBlock) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpDeletePublicAccessBlock) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DeletePublicAccessBlockInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/configuration/publicAccessBlock")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "DELETE"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsDeletePublicAccessBlockInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsDeletePublicAccessBlockInput(v *DeletePublicAccessBlockInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	return nil
}

type awsRestxml_serializeOpDescribeJob struct {
}

func (*awsRestxml_serializeOpDescribeJob) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpDescribeJob) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*DescribeJobInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/jobs/{JobId}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsDescribeJobInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsDescribeJobInput(v *DescribeJobInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.JobId != nil {
		if err := encoder.SetURI("JobId").String(*v.JobId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestxml_serializeOpGetAccessPoint struct {
}

func (*awsRestxml_serializeOpGetAccessPoint) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpGetAccessPoint) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetAccessPointInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/accesspoint/{Name}")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsGetAccessPointInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsGetAccessPointInput(v *GetAccessPointInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.Name != nil {
		if err := encoder.SetURI("Name").String(*v.Name); err != nil {
			return err
		}
	}

	return nil
}

type awsRestxml_serializeOpGetAccessPointPolicy struct {
}

func (*awsRestxml_serializeOpGetAccessPointPolicy) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpGetAccessPointPolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetAccessPointPolicyInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/accesspoint/{Name}/policy")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsGetAccessPointPolicyInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsGetAccessPointPolicyInput(v *GetAccessPointPolicyInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.Name != nil {
		if err := encoder.SetURI("Name").String(*v.Name); err != nil {
			return err
		}
	}

	return nil
}

type awsRestxml_serializeOpGetAccessPointPolicyStatus struct {
}

func (*awsRestxml_serializeOpGetAccessPointPolicyStatus) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpGetAccessPointPolicyStatus) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetAccessPointPolicyStatusInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/accesspoint/{Name}/policyStatus")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsGetAccessPointPolicyStatusInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsGetAccessPointPolicyStatusInput(v *GetAccessPointPolicyStatusInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.Name != nil {
		if err := encoder.SetURI("Name").String(*v.Name); err != nil {
			return err
		}
	}

	return nil
}

type awsRestxml_serializeOpGetJobTagging struct {
}

func (*awsRestxml_serializeOpGetJobTagging) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpGetJobTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetJobTaggingInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/jobs/{JobId}/tagging")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsGetJobTaggingInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsGetJobTaggingInput(v *GetJobTaggingInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.JobId != nil {
		if err := encoder.SetURI("JobId").String(*v.JobId); err != nil {
			return err
		}
	}

	return nil
}

type awsRestxml_serializeOpGetPublicAccessBlock struct {
}

func (*awsRestxml_serializeOpGetPublicAccessBlock) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpGetPublicAccessBlock) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*GetPublicAccessBlockInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/configuration/publicAccessBlock")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsGetPublicAccessBlockInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsGetPublicAccessBlockInput(v *GetPublicAccessBlockInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	return nil
}

type awsRestxml_serializeOpListAccessPoints struct {
}

func (*awsRestxml_serializeOpListAccessPoints) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpListAccessPoints) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListAccessPointsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/accesspoint")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsListAccessPointsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsListAccessPointsInput(v *ListAccessPointsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.Bucket != nil {
		encoder.SetQuery("bucket").String(*v.Bucket)
	}

	if v.MaxResults != nil {
		encoder.SetQuery("maxResults").Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		encoder.SetQuery("nextToken").String(*v.NextToken)
	}

	return nil
}

type awsRestxml_serializeOpListJobs struct {
}

func (*awsRestxml_serializeOpListJobs) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpListJobs) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*ListJobsInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/jobs")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "GET"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsListJobsInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsListJobsInput(v *ListJobsInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.JobStatuses != nil {
		for i := range v.JobStatuses {
			encoder.AddQuery("jobStatuses").String(string(v.JobStatuses[i]))
		}
	}

	if v.MaxResults != nil {
		encoder.SetQuery("maxResults").Integer(*v.MaxResults)
	}

	if v.NextToken != nil {
		encoder.SetQuery("nextToken").String(*v.NextToken)
	}

	return nil
}

type awsRestxml_serializeOpPutAccessPointPolicy struct {
}

func (*awsRestxml_serializeOpPutAccessPointPolicy) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpPutAccessPointPolicy) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PutAccessPointPolicyInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/accesspoint/{Name}/policy")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsPutAccessPointPolicyInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/xml")

	xmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))
	rootAttr := []smithyxml.Attr{}
	root := smithyxml.StartElement{
		Name: smithyxml.Name{
			Local: "PutAccessPointPolicyRequest",
		},
		Attr: rootAttr,
	}
	if err := awsRestxml_serializeOpDocumentPutAccessPointPolicyInput(input, xmlEncoder.RootElement(root)); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	if request, err = request.SetStream(bytes.NewReader(xmlEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsPutAccessPointPolicyInput(v *PutAccessPointPolicyInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.Name != nil {
		if err := encoder.SetURI("Name").String(*v.Name); err != nil {
			return err
		}
	}

	return nil
}

func awsRestxml_serializeOpDocumentPutAccessPointPolicyInput(v *PutAccessPointPolicyInput, value smithyxml.Value) error {
	defer value.Close()
	if v.Policy != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Policy",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.Policy)
	}
	return nil
}

type awsRestxml_serializeOpPutJobTagging struct {
}

func (*awsRestxml_serializeOpPutJobTagging) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpPutJobTagging) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PutJobTaggingInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/jobs/{JobId}/tagging")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsPutJobTaggingInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	restEncoder.SetHeader("Content-Type").String("application/xml")

	xmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))
	rootAttr := []smithyxml.Attr{}
	root := smithyxml.StartElement{
		Name: smithyxml.Name{
			Local: "PutJobTaggingRequest",
		},
		Attr: rootAttr,
	}
	if err := awsRestxml_serializeOpDocumentPutJobTaggingInput(input, xmlEncoder.RootElement(root)); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	if request, err = request.SetStream(bytes.NewReader(xmlEncoder.Bytes())); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsPutJobTaggingInput(v *PutJobTaggingInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.JobId != nil {
		if err := encoder.SetURI("JobId").String(*v.JobId); err != nil {
			return err
		}
	}

	return nil
}

func awsRestxml_serializeOpDocumentPutJobTaggingInput(v *PutJobTaggingInput, value smithyxml.Value) error {
	defer value.Close()
	if v.Tags != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Tags",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3TagSet(v.Tags, el); err != nil {
			return err
		}
	}
	return nil
}

type awsRestxml_serializeOpPutPublicAccessBlock struct {
}

func (*awsRestxml_serializeOpPutPublicAccessBlock) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpPutPublicAccessBlock) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*PutPublicAccessBlockInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/configuration/publicAccessBlock")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "PUT"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsPutPublicAccessBlockInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if input.PublicAccessBlockConfiguration != nil {
		if !restEncoder.HasHeader("Content-Type") {
			restEncoder.SetHeader("Content-Type").String("application/xml")
		}

		xmlEncoder := smithyxml.NewEncoder(bytes.NewBuffer(nil))
		payloadRootAttr := []smithyxml.Attr{}
		payloadRoot := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "PublicAccessBlockConfiguration",
			},
			Attr: payloadRootAttr,
		}
		if err := awsRestxml_serializeDocumentPublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, xmlEncoder.RootElement(payloadRoot)); err != nil {
			return out, metadata, &smithy.SerializationError{Err: err}
		}
		payload := bytes.NewReader(xmlEncoder.Bytes())
		if request, err = request.SetStream(payload); err != nil {
			return out, metadata, &smithy.SerializationError{Err: err}
		}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsPutPublicAccessBlockInput(v *PutPublicAccessBlockInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	return nil
}

type awsRestxml_serializeOpUpdateJobPriority struct {
}

func (*awsRestxml_serializeOpUpdateJobPriority) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpUpdateJobPriority) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateJobPriorityInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/jobs/{JobId}/priority")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsUpdateJobPriorityInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsUpdateJobPriorityInput(v *UpdateJobPriorityInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.JobId != nil {
		if err := encoder.SetURI("JobId").String(*v.JobId); err != nil {
			return err
		}
	}

	if v.Priority != nil {
		encoder.SetQuery("priority").Integer(*v.Priority)
	}

	return nil
}

type awsRestxml_serializeOpUpdateJobStatus struct {
}

func (*awsRestxml_serializeOpUpdateJobStatus) ID() string {
	return "OperationSerializer"
}

func (m *awsRestxml_serializeOpUpdateJobStatus) HandleSerialize(ctx context.Context, in middleware.SerializeInput, next middleware.SerializeHandler) (
	out middleware.SerializeOutput, metadata middleware.Metadata, err error,
) {
	request, ok := in.Request.(*smithyhttp.Request)
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown transport type %T", in.Request)}
	}

	input, ok := in.Parameters.(*UpdateJobStatusInput)
	_ = input
	if !ok {
		return out, metadata, &smithy.SerializationError{Err: fmt.Errorf("unknown input parameters type %T", in.Parameters)}
	}

	opPath, opQuery := httpbinding.SplitURI("/v20180820/jobs/{JobId}/status")
	request.URL.Path = opPath
	if len(request.URL.RawQuery) > 0 {
		request.URL.RawQuery = "&" + opQuery
	} else {
		request.URL.RawQuery = opQuery
	}

	request.Method = "POST"
	restEncoder, err := httpbinding.NewEncoder(request.URL.Path, request.URL.RawQuery, request.Header)
	if err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if err := awsRestxml_serializeOpHttpBindingsUpdateJobStatusInput(input, restEncoder); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}

	if request.Request, err = restEncoder.Encode(request.Request); err != nil {
		return out, metadata, &smithy.SerializationError{Err: err}
	}
	in.Request = request

	return next.HandleSerialize(ctx, in)
}
func awsRestxml_serializeOpHttpBindingsUpdateJobStatusInput(v *UpdateJobStatusInput, encoder *httpbinding.Encoder) error {
	if v == nil {
		return fmt.Errorf("unsupported serialization of nil %T", v)
	}

	if v.AccountId != nil {
		locationName := "X-Amz-Account-Id"
		if len(*v.AccountId) > 0 {
			encoder.SetHeader(locationName).String(*v.AccountId)
		}
	}

	if v.JobId != nil {
		if err := encoder.SetURI("JobId").String(*v.JobId); err != nil {
			return err
		}
	}

	if len(v.RequestedJobStatus) > 0 {
		encoder.SetQuery("requestedJobStatus").String(string(v.RequestedJobStatus))
	}

	if v.StatusUpdateReason != nil {
		encoder.SetQuery("statusUpdateReason").String(*v.StatusUpdateReason)
	}

	return nil
}

func awsRestxml_serializeDocumentJobManifest(v *types.JobManifest, value smithyxml.Value) error {
	defer value.Close()
	if v.Location != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Location",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentJobManifestLocation(v.Location, el); err != nil {
			return err
		}
	}
	if v.Spec != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Spec",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentJobManifestSpec(v.Spec, el); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentJobManifestFieldList(v []types.JobManifestFieldName, value smithyxml.Value) error {
	var array *smithyxml.Array
	if !value.IsFlattened() {
		defer value.Close()
	}
	array = value.Array()
	for i := range v {
		am := array.Member()
		am.String(string(v[i]))
	}
	return nil
}

func awsRestxml_serializeDocumentJobManifestLocation(v *types.JobManifestLocation, value smithyxml.Value) error {
	defer value.Close()
	if v.ETag != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ETag",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ETag)
	}
	if v.ObjectArn != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ObjectArn",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ObjectArn)
	}
	if v.ObjectVersionId != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ObjectVersionId",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ObjectVersionId)
	}
	return nil
}

func awsRestxml_serializeDocumentJobManifestSpec(v *types.JobManifestSpec, value smithyxml.Value) error {
	defer value.Close()
	if v.Fields != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Fields",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentJobManifestFieldList(v.Fields, el); err != nil {
			return err
		}
	}
	if len(v.Format) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Format",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.Format))
	}
	return nil
}

func awsRestxml_serializeDocumentJobOperation(v *types.JobOperation, value smithyxml.Value) error {
	defer value.Close()
	if v.LambdaInvoke != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "LambdaInvoke",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentLambdaInvokeOperation(v.LambdaInvoke, el); err != nil {
			return err
		}
	}
	if v.S3InitiateRestoreObject != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "S3InitiateRestoreObject",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3InitiateRestoreObjectOperation(v.S3InitiateRestoreObject, el); err != nil {
			return err
		}
	}
	if v.S3PutObjectAcl != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "S3PutObjectAcl",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3SetObjectAclOperation(v.S3PutObjectAcl, el); err != nil {
			return err
		}
	}
	if v.S3PutObjectCopy != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "S3PutObjectCopy",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3CopyObjectOperation(v.S3PutObjectCopy, el); err != nil {
			return err
		}
	}
	if v.S3PutObjectLegalHold != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "S3PutObjectLegalHold",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3SetObjectLegalHoldOperation(v.S3PutObjectLegalHold, el); err != nil {
			return err
		}
	}
	if v.S3PutObjectRetention != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "S3PutObjectRetention",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3SetObjectRetentionOperation(v.S3PutObjectRetention, el); err != nil {
			return err
		}
	}
	if v.S3PutObjectTagging != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "S3PutObjectTagging",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3SetObjectTaggingOperation(v.S3PutObjectTagging, el); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentJobReport(v *types.JobReport, value smithyxml.Value) error {
	defer value.Close()
	if v.Bucket != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Bucket",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.Bucket)
	}
	if v.Enabled != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Enabled",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.Enabled)
	}
	if len(v.Format) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Format",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.Format))
	}
	if v.Prefix != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Prefix",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.Prefix)
	}
	if len(v.ReportScope) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ReportScope",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.ReportScope))
	}
	return nil
}

func awsRestxml_serializeDocumentLambdaInvokeOperation(v *types.LambdaInvokeOperation, value smithyxml.Value) error {
	defer value.Close()
	if v.FunctionArn != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "FunctionArn",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.FunctionArn)
	}
	return nil
}

func awsRestxml_serializeDocumentPublicAccessBlockConfiguration(v *types.PublicAccessBlockConfiguration, value smithyxml.Value) error {
	defer value.Close()
	if v.BlockPublicAcls != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "BlockPublicAcls",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.BlockPublicAcls)
	}
	if v.BlockPublicPolicy != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "BlockPublicPolicy",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.BlockPublicPolicy)
	}
	if v.IgnorePublicAcls != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "IgnorePublicAcls",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.IgnorePublicAcls)
	}
	if v.RestrictPublicBuckets != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "RestrictPublicBuckets",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.RestrictPublicBuckets)
	}
	return nil
}

func awsRestxml_serializeDocumentS3AccessControlList(v *types.S3AccessControlList, value smithyxml.Value) error {
	defer value.Close()
	if v.Grants != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Grants",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3GrantList(v.Grants, el); err != nil {
			return err
		}
	}
	if v.Owner != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Owner",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3ObjectOwner(v.Owner, el); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentS3AccessControlPolicy(v *types.S3AccessControlPolicy, value smithyxml.Value) error {
	defer value.Close()
	if v.AccessControlList != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "AccessControlList",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3AccessControlList(v.AccessControlList, el); err != nil {
			return err
		}
	}
	if len(v.CannedAccessControlList) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "CannedAccessControlList",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.CannedAccessControlList))
	}
	return nil
}

func awsRestxml_serializeDocumentS3CopyObjectOperation(v *types.S3CopyObjectOperation, value smithyxml.Value) error {
	defer value.Close()
	if v.AccessControlGrants != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "AccessControlGrants",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3GrantList(v.AccessControlGrants, el); err != nil {
			return err
		}
	}
	if len(v.CannedAccessControlList) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "CannedAccessControlList",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.CannedAccessControlList))
	}
	if len(v.MetadataDirective) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "MetadataDirective",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.MetadataDirective))
	}
	if v.ModifiedSinceConstraint != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ModifiedSinceConstraint",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(smithytime.FormatDateTime(*v.ModifiedSinceConstraint))
	}
	if v.NewObjectMetadata != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "NewObjectMetadata",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3ObjectMetadata(v.NewObjectMetadata, el); err != nil {
			return err
		}
	}
	if v.NewObjectTagging != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "NewObjectTagging",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3TagSet(v.NewObjectTagging, el); err != nil {
			return err
		}
	}
	if len(v.ObjectLockLegalHoldStatus) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ObjectLockLegalHoldStatus",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.ObjectLockLegalHoldStatus))
	}
	if len(v.ObjectLockMode) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ObjectLockMode",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.ObjectLockMode))
	}
	if v.ObjectLockRetainUntilDate != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ObjectLockRetainUntilDate",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(smithytime.FormatDateTime(*v.ObjectLockRetainUntilDate))
	}
	if v.RedirectLocation != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "RedirectLocation",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.RedirectLocation)
	}
	if v.RequesterPays != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "RequesterPays",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.RequesterPays)
	}
	if v.SSEAwsKmsKeyId != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "SSEAwsKmsKeyId",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.SSEAwsKmsKeyId)
	}
	if len(v.StorageClass) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "StorageClass",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.StorageClass))
	}
	if v.TargetKeyPrefix != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "TargetKeyPrefix",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.TargetKeyPrefix)
	}
	if v.TargetResource != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "TargetResource",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.TargetResource)
	}
	if v.UnModifiedSinceConstraint != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "UnModifiedSinceConstraint",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(smithytime.FormatDateTime(*v.UnModifiedSinceConstraint))
	}
	return nil
}

func awsRestxml_serializeDocumentS3Grant(v *types.S3Grant, value smithyxml.Value) error {
	defer value.Close()
	if v.Grantee != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Grantee",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3Grantee(v.Grantee, el); err != nil {
			return err
		}
	}
	if len(v.Permission) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Permission",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.Permission))
	}
	return nil
}

func awsRestxml_serializeDocumentS3Grantee(v *types.S3Grantee, value smithyxml.Value) error {
	defer value.Close()
	if v.DisplayName != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "DisplayName",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.DisplayName)
	}
	if v.Identifier != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Identifier",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.Identifier)
	}
	if len(v.TypeIdentifier) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "TypeIdentifier",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.TypeIdentifier))
	}
	return nil
}

func awsRestxml_serializeDocumentS3GrantList(v []*types.S3Grant, value smithyxml.Value) error {
	var array *smithyxml.Array
	if !value.IsFlattened() {
		defer value.Close()
	}
	array = value.Array()
	for i := range v {
		if vv := v[i]; vv == nil {
			am := array.Member()
			am.Close()
			continue
		}
		am := array.Member()
		if err := awsRestxml_serializeDocumentS3Grant(v[i], am); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentS3InitiateRestoreObjectOperation(v *types.S3InitiateRestoreObjectOperation, value smithyxml.Value) error {
	defer value.Close()
	if v.ExpirationInDays != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ExpirationInDays",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Integer(*v.ExpirationInDays)
	}
	if len(v.GlacierJobTier) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "GlacierJobTier",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.GlacierJobTier))
	}
	return nil
}

func awsRestxml_serializeDocumentS3ObjectLockLegalHold(v *types.S3ObjectLockLegalHold, value smithyxml.Value) error {
	defer value.Close()
	if len(v.Status) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Status",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.Status))
	}
	return nil
}

func awsRestxml_serializeDocumentS3ObjectMetadata(v *types.S3ObjectMetadata, value smithyxml.Value) error {
	defer value.Close()
	if v.CacheControl != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "CacheControl",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.CacheControl)
	}
	if v.ContentDisposition != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ContentDisposition",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ContentDisposition)
	}
	if v.ContentEncoding != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ContentEncoding",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ContentEncoding)
	}
	if v.ContentLanguage != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ContentLanguage",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ContentLanguage)
	}
	if v.ContentLength != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ContentLength",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Long(*v.ContentLength)
	}
	if v.ContentMD5 != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ContentMD5",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ContentMD5)
	}
	if v.ContentType != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ContentType",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ContentType)
	}
	if v.HttpExpiresDate != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "HttpExpiresDate",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(smithytime.FormatDateTime(*v.HttpExpiresDate))
	}
	if v.RequesterCharged != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "RequesterCharged",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.RequesterCharged)
	}
	if len(v.SSEAlgorithm) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "SSEAlgorithm",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.SSEAlgorithm))
	}
	if v.UserMetadata != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "UserMetadata",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3UserMetadata(v.UserMetadata, el); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentS3ObjectOwner(v *types.S3ObjectOwner, value smithyxml.Value) error {
	defer value.Close()
	if v.DisplayName != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "DisplayName",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.DisplayName)
	}
	if v.ID != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "ID",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.ID)
	}
	return nil
}

func awsRestxml_serializeDocumentS3Retention(v *types.S3Retention, value smithyxml.Value) error {
	defer value.Close()
	if len(v.Mode) > 0 {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Mode",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(string(v.Mode))
	}
	if v.RetainUntilDate != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "RetainUntilDate",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(smithytime.FormatDateTime(*v.RetainUntilDate))
	}
	return nil
}

func awsRestxml_serializeDocumentS3SetObjectAclOperation(v *types.S3SetObjectAclOperation, value smithyxml.Value) error {
	defer value.Close()
	if v.AccessControlPolicy != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "AccessControlPolicy",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3AccessControlPolicy(v.AccessControlPolicy, el); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentS3SetObjectLegalHoldOperation(v *types.S3SetObjectLegalHoldOperation, value smithyxml.Value) error {
	defer value.Close()
	if v.LegalHold != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "LegalHold",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3ObjectLockLegalHold(v.LegalHold, el); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentS3SetObjectRetentionOperation(v *types.S3SetObjectRetentionOperation, value smithyxml.Value) error {
	defer value.Close()
	if v.BypassGovernanceRetention != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "BypassGovernanceRetention",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.Boolean(*v.BypassGovernanceRetention)
	}
	if v.Retention != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Retention",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3Retention(v.Retention, el); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentS3SetObjectTaggingOperation(v *types.S3SetObjectTaggingOperation, value smithyxml.Value) error {
	defer value.Close()
	if v.TagSet != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "TagSet",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		if err := awsRestxml_serializeDocumentS3TagSet(v.TagSet, el); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentS3Tag(v *types.S3Tag, value smithyxml.Value) error {
	defer value.Close()
	if v.Key != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Key",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.Key)
	}
	if v.Value != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "Value",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.Value)
	}
	return nil
}

func awsRestxml_serializeDocumentS3TagSet(v []*types.S3Tag, value smithyxml.Value) error {
	var array *smithyxml.Array
	if !value.IsFlattened() {
		defer value.Close()
	}
	array = value.Array()
	for i := range v {
		if vv := v[i]; vv == nil {
			am := array.Member()
			am.Close()
			continue
		}
		am := array.Member()
		if err := awsRestxml_serializeDocumentS3Tag(v[i], am); err != nil {
			return err
		}
	}
	return nil
}

func awsRestxml_serializeDocumentS3UserMetadata(v map[string]*string, value smithyxml.Value) error {
	if !value.IsFlattened() {
		defer value.Close()
	}
	m := value.Map()
	for key := range v {
		entry := m.Entry()
		if vv := v[key]; vv == nil {
			entry.Close()
			continue
		}
		keyElementAttr := []smithyxml.Attr{}
		keyElement := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "key",
			},
			Attr: keyElementAttr,
		}
		entry.MemberElement(keyElement).String(*&key)
		valueElementAttr := []smithyxml.Attr{}
		valueElement := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "value",
			},
			Attr: valueElementAttr,
		}
		entry.MemberElement(valueElement).String(*v[key])
		entry.Close()
	}
	return nil
}

func awsRestxml_serializeDocumentVpcConfiguration(v *types.VpcConfiguration, value smithyxml.Value) error {
	defer value.Close()
	if v.VpcId != nil {
		rootAttr := []smithyxml.Attr{}
		root := smithyxml.StartElement{
			Name: smithyxml.Name{
				Local: "VpcId",
			},
			Attr: rootAttr,
		}
		el := value.MemberElement(root)
		el.String(*v.VpcId)
	}
	return nil
}
